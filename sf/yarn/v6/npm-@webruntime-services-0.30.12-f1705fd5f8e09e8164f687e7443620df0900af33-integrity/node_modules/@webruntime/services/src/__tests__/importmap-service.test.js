/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { ImportMapService } from '../importmap-service';

jest.mock('../utils', () => {
    let isCacheEmpty = false;
    let latest = '1234567890';
    const latestMappings = ({}[latest] = {
        'component://mock/lds@en_US': {
            dev: '1111111111',
            prod: '0909090909',
        },
    });

    return {
        getLatestCachedResourceMap: jest.fn(() => {
            return isCacheEmpty ? [] : latestMappings;
        }),
        getLatestVersion: jest.fn(() => {
            return isCacheEmpty ? undefined : latest;
        }),
        initWatchers: jest.fn(),
        closeWatchers: jest.fn(),
        __setCacheEmpty: value => {
            isCacheEmpty = value;
        },
        __updateLatestVersionForTest: value => {
            latest = value;
        },
    };
});

let importMapService;

describe('importmap-service', () => {
    beforeEach(async () => {
        importMapService = new ImportMapService({
            buildDir: 'dist',
            server: { basePath: '/base' },
        });
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('initialize', () => {
        it('should get latest cached resource metadata', async () => {
            const utilsSpy = require('../utils');
            await importMapService.initialize();
            expect(utilsSpy.getLatestCachedResourceMap).toHaveBeenCalledTimes(1);
        });
    });

    describe('request', () => {
        it('should fail if mode option is not provided', async () => {
            const specifier = 'importmap';
            const options = {
                locale: 'en_US',
            };
            const containerContext = {};
            await importMapService.initialize();
            const requestOutput = await importMapService.request(
                specifier,
                options,
                containerContext
            );
            expect(requestOutput.success).toBe(false);
        });

        it('should fail if locale option is not provided', async () => {
            const specifier = 'importmap';
            const options = {
                mode: 'prod',
            };
            const containerContext = {};

            await importMapService.initialize();
            const requestOutput = await importMapService.request(
                specifier,
                options,
                containerContext
            );
            expect(requestOutput.success).toBe(false);
        });

        it('should fail if mode and locale options are not provided', async () => {
            const specifier = 'importmap';
            const options = {};
            const containerContext = {};
            await importMapService.initialize();
            const requestOutput = await importMapService.request(
                specifier,
                options,
                containerContext
            );
            expect(requestOutput.success).toBe(false);
            expect(requestOutput.diagnostics[0].message).toContain(
                'The "mode" and "locale" parameters are both required'
            );
        });

        it('should used cached resource data if resource version is unchanged', async () => {
            const utilsSpy = require('../utils');
            const specifier = 'importmap';
            const options = {
                mode: 'prod',
                locale: 'en_ES',
            };
            const containerContext = {
                metadata: {
                    importMap: {
                        imports: {},
                    },
                },
            };
            await importMapService.initialize();
            expect(utilsSpy.getLatestCachedResourceMap).toHaveBeenCalledTimes(1);
            await importMapService.request(specifier, options, containerContext);
            expect(utilsSpy.getLatestCachedResourceMap).toHaveBeenCalledTimes(1); // should not trigger another call to getLatestCachedResourceMap
        });

        it('should return importmap', async () => {
            const specifier = 'importmap';
            const options = {
                mode: 'dev',
                locale: 'en_US',
            };
            const containerContext = {
                metadata: {
                    importMap: {
                        imports: {
                            importmap: '/webruntime/imports/:mode/:locale/importmap.json',
                            'mock/lds': '/webruntime/component/:uid/:mode/:locale/mock/lds',
                            'mock/component':
                                '/webruntime/component/:uid/:mode/:locale/mock/component',
                            'mock/foo': '/webruntime/component/:uid/:mode/:locale/mock/foo',
                            'mock/bar': '/webruntime/component/:uid/:mode/:locale/mock/bar',
                            'mock/baz': '/webruntime/component/:uid/:mode/:locale/mock/baz',
                            'mock/bat': '/webruntime/component/:uid/:mode/:locale/mock/bat',
                            'lightning/accordion':
                                '/webruntime/component/:uid/:mode/:locale/lightning/accordion',
                            'lightning/badge':
                                '/webruntime/component/:uid/:mode/:locale/lightning/badge',
                            'lightning/button':
                                '/webruntime/component/:uid/:mode/:locale/lightning/button',
                            'lightning/tab':
                                '/webruntime/component/:uid/:mode/:locale/lightning/tab',
                            'lightning/': '/webruntime/component/:uid/:mode/:locale/lightning/',
                            'force/lds': '/webruntime/component/:uid/:mode/:locale/force/lds',
                            'universal_container/navigation':
                                '/webruntime/component/:uid/:mode/:locale/universal_container/navigation',
                            'universal_container/childRouter':
                                '/webruntime/component/:uid/:mode/:locale/universal_container/childRouter',
                            'sfx/app': '/webruntime/component/:uid/:mode/:locale/sfx/app',
                            'not/packageable': '/sample/:mode/:locale/not/packageable.json',
                            'already/mapped': '/sample/something/param/dev/en_ES/already/mapped',
                        },
                    },
                },
            };
            await importMapService.initialize();
            const result = await importMapService.request(specifier, options, containerContext);
            expect(result).toMatchSnapshot();
        });

        it('should do resource packaging based on namespace', async () => {
            const specifier = 'importmap';
            const options = {
                mode: 'dev',
                locale: 'en_US',
            };
            const containerContext = {
                metadata: {
                    importMap: {
                        imports: {
                            'mock/lds': '/webruntime/component/:uid/:mode/:locale/mock/lds',
                            'mock/component':
                                '/webruntime/component/:uid/:mode/:locale/mock/component',
                            'mock/foo': '/webruntime/component/:uid/:mode/:locale/mock/foo',
                            'mock/bar': '/webruntime/component/:uid/:mode/:locale/mock/bar',
                            'mock/baz': '/webruntime/component/:uid/:mode/:locale/mock/baz',
                            'mock/bat': '/webruntime/component/:uid/:mode/:locale/mock/bat',
                        },
                    },
                },
            };
            await importMapService.initialize();
            const result = await importMapService.request(specifier, options, containerContext);
            expect(result.resource.json.imports['mock/']).toEqual(
                '/base/webruntime/component/latest/dev/en_US/mock/'
            );
        });

        it('should throw error when a mapping has no namespace and name', async () => {
            const specifier = 'importmap';
            const options = {
                mode: 'dev',
                locale: 'en_US',
            };
            const containerContext = {
                metadata: {
                    importMap: {
                        imports: {
                            '': '/this/throws',
                        },
                    },
                },
            };
            await importMapService.initialize();
            await expect(
                importMapService.request(specifier, options, containerContext)
            ).rejects.toThrow('Cannot find a name or namespace from');
        });

        it('should throw if a malformed packaged mapping exists', async () => {
            const specifier = 'importmap';
            const options = {
                mode: 'dev',
                locale: 'en_US',
            };
            const containerContext = {
                metadata: {
                    importMap: {
                        imports: {
                            'blah/': '/this/throws',
                        },
                    },
                },
            };
            await importMapService.initialize();
            await expect(
                importMapService.request(specifier, options, containerContext)
            ).rejects.toThrow('No packaged URL found for packaged specifier "blah/"');
        });
    });

    describe('toSpecifier', () => {
        it('should return importmap specifier', () => {
            const specifier = importMapService.toSpecifier();
            expect(specifier).toBe('importmap');
        });
    });

    describe('shutdown', () => {
        it('should close watchers', async () => {
            const utilsSpy = require('../utils');
            await importMapService.initialize();
            await importMapService.shutdown();
            expect(utilsSpy.closeWatchers).toHaveBeenCalledTimes(1);
        });
    });
});
