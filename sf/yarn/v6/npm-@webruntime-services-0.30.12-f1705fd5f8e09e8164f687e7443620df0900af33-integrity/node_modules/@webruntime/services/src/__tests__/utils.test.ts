/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import * as utils from '../utils';

const buildDir = '_buildDir_';
jest.mock('fs', () => {
    let fileExists;
    return {
        existsSync: jest.fn(() => {
            return fileExists;
        }),
        readFileSync: jest.fn(input => {
            if (input === '_buildDir_/metadata.json') {
                return `{"latest": "1234"}`;
            }
            if (input === '_buildDir_/resources.json') {
                return `{
                    "1234": {
                        "component://mock/lds@en_US": {
                            "dev": "1231231231"
                        }
                    }
                }`;
            }
            return '';
        }),
        __setExistsValue: value => {
            fileExists = value;
        },
    };
});
jest.mock('chokidar', () => {
    const closeSpy = jest.fn();
    return {
        watch: jest.fn().mockReturnValue({
            on: jest.fn().mockReturnValue({
                close: closeSpy,
            }),
        }),
        __getCloseSpy: () => {
            return closeSpy;
        },
    };
});

describe('@webruntime/services utils', () => {
    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('getLatestVersion', () => {
        it('should fetch latest version from filesystem when metadata file exists', async () => {
            const fsSpy = require('fs');
            fsSpy.__setExistsValue(true);
            const version = utils.getLatestVersion(buildDir);
            expect(version).toEqual('1234');
        });

        it('should return undefined if metadata file does not exist', async () => {
            const fsSpy = require('fs');
            fsSpy.__setExistsValue(false);
            const version = utils.getLatestVersion(buildDir);
            expect(version).not.toBeDefined();
        });
    });

    describe('getLatestCachedResourceMap', () => {
        it('should get latest cached resource metadata when manifest file exists', async () => {
            const fsSpy = require('fs');
            fsSpy.__setExistsValue(true);
            const map = utils.getLatestCachedResourceMap(buildDir);
            expect(map).toMatchSnapshot();
        });

        it('should return empty array if manifest file does not exist', async () => {
            const fsSpy = require('fs');
            fsSpy.__setExistsValue(false);
            const map = utils.getLatestCachedResourceMap(buildDir);
            expect(map).toEqual([]);
        });
    });

    describe('initWatchers', () => {
        it('should watch metadata file', async () => {
            const watchSpy = require('chokidar').watch;
            utils.initWatchers(buildDir, () => {
                /* noop */
            });
            expect(watchSpy.mock.calls).toEqual(
                expect.arrayContaining([[`${process.cwd()}/${buildDir}/metadata.json`]])
            );
        });

        it('should watch manifest file', async () => {
            const watchSpy = require('chokidar').watch;
            utils.initWatchers(buildDir, () => {
                /* noop */
            });
            expect(watchSpy.mock.calls).toEqual(
                expect.arrayContaining([[`${process.cwd()}/${buildDir}/resources.json`]])
            );
        });
    });

    describe('closeWatchers', () => {
        it('should close both file watchers', async () => {
            const chokidarSpy = require('chokidar');
            utils.initWatchers(buildDir, () => {
                /* noop */
            });
            utils.closeWatchers();
            expect(chokidarSpy.__getCloseSpy()).toHaveBeenCalledTimes(2);
        });
    });
});
