"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("@webruntime/api");
const performance_1 = require("@webruntime/performance");
const messages_1 = require("./messages");
const utils_1 = require("./utils");
const IMPORTMAP_SVC_SPECIFIER = 'importmap';
const URI = `/imports/:mode/:locale/importmap.json`;
const DEFAULT_UID = 'latest';
/**
 * The core Importmap Service is responsible for providing an addressable
 * importmap resource (compliant with WICG import-map specification) in
 * the format expected by the client loader.
 */
class ImportMapService extends api_1.AddressableService {
    /**
     * Create an {@link ImportMapService}
     *
     * @param {object} options Constructor options
     * @param {string} options.buildDir Configured build directory
     * @param {string} options.server.baseDir Configured base path
     */
    constructor({ buildDir, server: { basePath } }) {
        super(URI);
        this.mappings = {
            [IMPORTMAP_SVC_SPECIFIER]: URI,
        };
        this.uidMap = {};
        this.uidMapChanged = false;
        this.importMapCache = {};
        this.updateUIDMap = () => {
            this.uidMap = utils_1.getLatestCachedResourceMap(this.buildDir);
            this.uidMapChanged = true;
        };
        this.buildDir = buildDir;
        this.basePath = basePath;
    }
    /**
     * Initializes the {@link ImportMapService}
     */
    async initialize() {
        utils_1.initWatchers(this.buildDir, this.updateUIDMap);
        this.updateUIDMap();
    }
    /**
     * Ties into container shutdown lifecycle to perform cleanup.
     * Close watchers that were started via initialize().
     */
    shutdown() {
        utils_1.closeWatchers();
    }
    /**
     * Implementation of {@link RequestService} `request` API which enables {@link ImportMapService}
     * to handle requests for supported resources as defined by its service `mappings`.
     *
     * @param {string} specifier Specifier for an importmap resource
     * @param {object} options a {@link RequestParams} object
     * @param {object} context a context object provided by the container
     * @param {object} context.metadata metadata provided by the container that includes the current importmap
     *
     * @returns {Promise<RequestOutput>} a promise which resolves to a RequestOutput object including an importmap resource
     */
    async request(specifier, options, { metadata }) {
        const { mode, locale } = options;
        if (!mode || !locale) {
            return {
                type: api_1.RequestOutputTypes.JSON,
                specifier,
                success: false,
                diagnostics: [messages_1.importMapMessages.MISSING_PARAMS],
            };
        }
        // Create new importMap anytime the uid map changes or the cacheKey changes
        const cacheKey = mode + locale;
        if (this.uidMapChanged || !this.importMapCache[cacheKey]) {
            const mapInstance = {};
            for (const property in metadata.importMap.imports) {
                if ({}.hasOwnProperty.call(metadata.importMap.imports, property)) {
                    // Do not need to create mappings for importmap resources since they are not imported on the client
                    if (property === IMPORTMAP_SVC_SPECIFIER) {
                        continue;
                    }
                    let uid;
                    const descriptor = `component://${property}@${locale}`; //TODO consider other resource types
                    if (property.endsWith('/')) {
                        uid = DEFAULT_UID;
                    }
                    else if (this.uidMap[descriptor]) {
                        uid = this.uidMap[descriptor][mode] || DEFAULT_UID;
                    }
                    else {
                        uid = DEFAULT_UID;
                    }
                    // Each URI entry should be prefixed by the server base path
                    mapInstance[property] = `${this.basePath}${replaceAll(metadata.importMap.imports[property], {
                        mode,
                        locale,
                        uid,
                    })}`;
                }
            }
            const importMap = { imports: packageImportMap(mapInstance) };
            this.importMapCache[cacheKey] = importMap;
            this.uidMapChanged = false;
        }
        return {
            type: api_1.RequestOutputTypes.JSON,
            specifier,
            resource: {
                json: this.importMapCache[cacheKey],
            },
            success: true,
            diagnostics: [],
        };
    }
    /**
     * Implementation of {@link AddressableService} `toSpecifier` API which returns the
     * `specifier` for an importmap resource.
     *
     * @returns {string} importmap specifier
     */
    toSpecifier() {
        return IMPORTMAP_SVC_SPECIFIER;
    }
}
__decorate([
    performance_1.Measure(specifier => `importmap-service:request:${specifier}`)
], ImportMapService.prototype, "request", null);
exports.ImportMapService = ImportMapService;
function replaceAll(str, mapObj) {
    const re = new RegExp(`:${Object.keys(mapObj).join('|:')}`, 'gi');
    return str.replace(re, function (matched) {
        const name = matched.slice(1);
        return mapObj[name.toLowerCase()];
    });
}
/**
 * Optimize the import map by converting entries into import map packages.
 *
 * @example
 * mapInstance = {
 *  'foo/bar': '/js/123/dev/en_us/foo/bar',
 *  'foo/baz': '/js/latest/dev/en_us/foo/bar',
 *  'foo/bat': '/js/latest/dev/en_us/foo/bat',
 *  'test/': '/some/url/alreadyPackaged/test/',
 *  'test/foo': '/some/other/url/test/foo',
 *  '@salesforce/error/labels/': '/js/en_US/labels',
 *  'wire-service': '/js/components/wire-service'
 * }
 *
 * // foo/baz && foo/bat are "packaged"
 * packagedMapInstance = {
 *  'foo/bar': '/js/123/dev/en_us/foo/bar'
 *  'foo/': '/js/latest/dev/en_us/foo/',
 *  'test/': '/some/url/alreadyPackaged/test/',
 *  'test/foo': '/some/other/url/test/foo',
 *  '@salesforce/error/labels/': '/js/en_US/labels',
 *  'wire-service': '/js/components/wire-service'
 * }
 *
 */
function packageImportMap(mapInstance) {
    const packagedMapInstance = {};
    const namespaceMap = {};
    Object.keys(mapInstance).forEach(specifier => {
        // TODO can namespace have multiple '/'? eg @salesforce/error/labels
        const { namespace, name } = parseNameAndNamespace(specifier);
        api_1.invariant(namespace || name, messages_1.importMapMessages.MISSING_NAMES, [specifier]);
        const url = mapInstance[specifier];
        if (!namespace && name) {
            // support non-namespaced like 'wire-service'
            packagedMapInstance[name] = url;
        }
        else if (!name && namespace.endsWith('/')) {
            api_1.invariant(url.endsWith('/'), messages_1.importMapMessages.INVALID_PACKAGE, [specifier]);
            // already a package
            packagedMapInstance[namespace] = url;
        }
        else if (!url.endsWith(specifier)) {
            // If both name && namespace, but URL does not end with specifier, don't try to package
            packagedMapInstance[specifier] = url;
        }
        else if (packagedMapInstance[namespace]) {
            // namespace already taken
            packagedMapInstance[specifier] = url;
        }
        else if (!packagedMapInstance[specifier]) {
            // Count the occurrences of the package URL, grouping them under namespace
            //
            // namespace - 'foo/'
            // packageUrls - '/js/latest/dev/en_us/foo/bar' --> '/js/latest/dev/en_us/foo/'
            const packageUrl = url.slice(0, url.lastIndexOf(name));
            namespaceMap[namespace] = namespaceMap[namespace] || {
                packageUrls: {},
                highCount: { count: 0, packageUrl },
            };
            const currentHighCount = namespaceMap[namespace].highCount.count;
            if (namespaceMap[namespace].packageUrls[packageUrl]) {
                const packageUrlArray = namespaceMap[namespace].packageUrls[packageUrl];
                packageUrlArray.push(name);
                if (packageUrlArray.length > currentHighCount) {
                    namespaceMap[namespace].highCount = {
                        count: packageUrlArray.length,
                        packageUrl,
                    };
                }
            }
            else {
                namespaceMap[namespace].packageUrls[packageUrl] = [name];
                if (currentHighCount === 0) {
                    namespaceMap[namespace].highCount = {
                        count: 1,
                        packageUrl,
                    };
                }
            }
        }
    });
    Object.keys(namespaceMap).forEach(qualifiedNamespace => {
        const urlMap = namespaceMap[qualifiedNamespace];
        let highCountPackaged = false;
        let { packageUrl: highCountUrl } = urlMap.highCount;
        // Only package the entry if more than one
        if (urlMap.highCount.count > 1) {
            const existingPackageUrl = packagedMapInstance[qualifiedNamespace];
            // Package the high count if there isn't an existing package
            if (!existingPackageUrl || highCountUrl === existingPackageUrl) {
                packagedMapInstance[qualifiedNamespace] = highCountUrl;
                highCountPackaged = true;
            }
        }
        else {
            highCountPackaged = true;
            highCountUrl = null;
        }
        // Map the rest with the full specifier + full url
        Object.keys(urlMap.packageUrls).forEach(packageUrl => {
            if (!highCountPackaged || packageUrl !== highCountUrl) {
                const names = urlMap.packageUrls[packageUrl];
                names.forEach(name => {
                    packagedMapInstance[`${qualifiedNamespace}${name}`] = packageUrl + name;
                });
            }
        });
    });
    return packagedMapInstance;
}
function parseNameAndNamespace(specifier) {
    const idx = specifier.lastIndexOf('/');
    return {
        namespace: specifier.slice(0, idx + 1),
        name: specifier.slice(idx + 1),
    };
}
//# sourceMappingURL=importmap-service.js.map