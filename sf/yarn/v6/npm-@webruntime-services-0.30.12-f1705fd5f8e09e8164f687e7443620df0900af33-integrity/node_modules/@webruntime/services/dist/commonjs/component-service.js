"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("@webruntime/api");
const compiler_1 = require("@webruntime/compiler");
const performance_1 = require("@webruntime/performance");
const module_resolver_1 = require("@lwc/module-resolver");
const URI_PREFIX = `/component`;
const uri = [
    `${URI_PREFIX}/:uid/:mode/:locale/:name`,
    `${URI_PREFIX}/:uid/:mode/:locale/:namespace/:name`,
];
class ComponentService extends api_1.AddressableService {
    constructor({ projectDir, moduleDir, compilerConfig: { lwcOptions } }) {
        super(uri);
        this.mappings = {};
        this.modules = {};
        this.projectDir = projectDir;
        this.moduleDir = moduleDir;
        this.customModuleDirs = lwcOptions && lwcOptions.modules ? lwcOptions.modules : [];
    }
    async initialize() {
        this.modules = resolveAllModules(this.projectDir, this.moduleDir, this.customModuleDirs);
        this.mappings = computeMappings(this.modules, this.mappings);
    }
    async request(specifier, pivots, { compilerConfig }) {
        const { namespace, name } = extractNameNamespace(specifier);
        const { result, metadata, success, diagnostics } = await compiler_1.compile({
            ...compilerConfig,
            name,
            namespace,
        });
        return {
            type: api_1.RequestOutputTypes.COMPONENT,
            specifier,
            resource: result,
            metadata,
            success,
            diagnostics,
        };
    }
    toSpecifier(url) {
        const { namespace, name } = this.parseUrl(url);
        return namespace ? `${namespace}/${name}` : name;
    }
}
__decorate([
    performance_1.Measure(specifier => `component-service:request:${specifier}`)
], ComponentService.prototype, "request", null);
exports.ComponentService = ComponentService;
function extractNameNamespace(specifier) {
    let [namespace, name] = specifier.split('/');
    if (!name) {
        // non-namespaced module such as 'wire-service'
        name = namespace;
        namespace = '';
    }
    return {
        name,
        namespace,
    };
}
function computeMappings(modules, mappings) {
    for (const key of Object.keys(modules)) {
        const { name, namespace, specifier } = modules[key];
        if (name && namespace) {
            mappings[`${namespace}/${name}`] = `${URI_PREFIX}/:uid/:mode/:locale/${namespace}/${name}`;
        }
        else if (specifier) {
            mappings[`${specifier}`] = `${URI_PREFIX}/:uid/:mode/:locale/${specifier}`;
        }
    }
    return mappings;
}
function resolveAllModules(projectDir, moduleDir, customModuleDirs) {
    const installedModules = module_resolver_1.resolveModules({
        rootDir: projectDir,
        modules: moduleDir ? [moduleDir, ...customModuleDirs] : customModuleDirs,
    });
    return installedModules.map(item => {
        const { name, namespace } = extractNameNamespace(item.specifier);
        return { ...item, name, namespace };
    });
}
//# sourceMappingURL=component-service.js.map