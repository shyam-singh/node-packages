(function () {
  'use strict';

  /* Custom Lightning Web Runtime SystemJS bundle */
  var self = {};
  var System;
  var define;
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /**
   * This is a patch to override SystemJS globals, which attach themselves to the environment global.
   *
   * SystemJS creates global variables `System`, `define`, which this patch converts to local variables.
   *
   */

  /* NOTE: Our Rollup config will use `output.intro` to inject scoped variables self, System, global here. */
  // Workaround SystemJS sometimes referencing the globals directly,
  // and other times via self/global.System. Need to update the local
  // scoped variables when it does
  // eslint-disable-next-line no-restricted-globals

  Object.defineProperty(self, 'System', {
    get: function () {
      return System;
      /* eslint-disable-line no-undef */
    },
    set: function (value) {
      System = value;
      /* eslint-disable-line no-undef */
    }
  }); // eslint-disable-next-line no-restricted-globals

  Object.defineProperty(self, 'define', {
    get: function () {
      return define;
      /* eslint-disable-line no-undef */
    },
    set: function (value) {
      define = value;
      /* eslint-disable-line no-undef */
    }
  });
  /*
  * SystemJS 6.2.4
  */

  (function () {
    const hasSelf = typeof self !== 'undefined';
    const hasDocument = typeof document !== 'undefined';
    const envGlobal = hasSelf ? self : global;
    let baseUrl;

    if (hasDocument) {
      const baseEl = document.querySelector('base[href]');
      if (baseEl) baseUrl = baseEl.href;
    }

    if (!baseUrl && typeof location !== 'undefined') {
      baseUrl = location.href.split('#')[0].split('?')[0];
      const lastSepIndex = baseUrl.lastIndexOf('/');
      if (lastSepIndex !== -1) baseUrl = baseUrl.slice(0, lastSepIndex + 1);
    }

    const backslashRegEx = /\\/g;

    function resolveIfNotPlainOrUrl(relUrl, parentUrl) {
      if (relUrl.indexOf('\\') !== -1) relUrl = relUrl.replace(backslashRegEx, '/'); // protocol-relative

      if (relUrl[0] === '/' && relUrl[1] === '/') {
        return parentUrl.slice(0, parentUrl.indexOf(':') + 1) + relUrl;
      } // relative-url
      else if (relUrl[0] === '.' && (relUrl[1] === '/' || relUrl[1] === '.' && (relUrl[2] === '/' || relUrl.length === 2 && (relUrl += '/')) || relUrl.length === 1 && (relUrl += '/')) || relUrl[0] === '/') {
          const parentProtocol = parentUrl.slice(0, parentUrl.indexOf(':') + 1); // Disabled, but these cases will give inconsistent results for deep backtracking
          //if (parentUrl[parentProtocol.length] !== '/')
          //  throw Error('Cannot resolve');
          // read pathname from parent URL
          // pathname taken to be part after leading "/"

          let pathname;

          if (parentUrl[parentProtocol.length + 1] === '/') {
            // resolving to a :// so we need to read out the auth and host
            if (parentProtocol !== 'file:') {
              pathname = parentUrl.slice(parentProtocol.length + 2);
              pathname = pathname.slice(pathname.indexOf('/') + 1);
            } else {
              pathname = parentUrl.slice(8);
            }
          } else {
            // resolving to :/ so pathname is the /... part
            pathname = parentUrl.slice(parentProtocol.length + (parentUrl[parentProtocol.length] === '/'));
          }

          if (relUrl[0] === '/') return parentUrl.slice(0, parentUrl.length - pathname.length - 1) + relUrl; // join together and split for removal of .. and . segments
          // looping the string instead of anything fancy for perf reasons
          // '../../../../../z' resolved to 'x/y' is just 'z'

          const segmented = pathname.slice(0, pathname.lastIndexOf('/') + 1) + relUrl;
          const output = [];
          let segmentIndex = -1;

          for (let i = 0; i < segmented.length; i++) {
            // busy reading a segment - only terminate on '/'
            if (segmentIndex !== -1) {
              if (segmented[i] === '/') {
                output.push(segmented.slice(segmentIndex, i + 1));
                segmentIndex = -1;
              }
            } // new segment - check if it is relative
            else if (segmented[i] === '.') {
                // ../ segment
                if (segmented[i + 1] === '.' && (segmented[i + 2] === '/' || i + 2 === segmented.length)) {
                  output.pop();
                  i += 2;
                } // ./ segment
                else if (segmented[i + 1] === '/' || i + 1 === segmented.length) {
                    i += 1;
                  } else {
                    // the start of a new segment as below
                    segmentIndex = i;
                  }
              } // it is the start of a new segment
              else {
                  segmentIndex = i;
                }
          } // finish reading out the last segment


          if (segmentIndex !== -1) output.push(segmented.slice(segmentIndex));
          return parentUrl.slice(0, parentUrl.length - pathname.length) + output.join('');
        }
    }
    /*
     * Import maps implementation
     *
     * To make lookups fast we pre-resolve the entire import map
     * and then match based on backtracked hash lookups
     *
     */


    function resolveUrl(relUrl, parentUrl) {
      return resolveIfNotPlainOrUrl(relUrl, parentUrl) || (relUrl.indexOf(':') !== -1 ? relUrl : resolveIfNotPlainOrUrl('./' + relUrl, parentUrl));
    }

    function objectAssign(to, from) {
      for (let p in from) to[p] = from[p];

      return to;
    }

    function resolveAndComposePackages(packages, outPackages, baseUrl, parentMap, parentUrl) {
      for (let p in packages) {
        const resolvedLhs = resolveIfNotPlainOrUrl(p, baseUrl) || p;
        const rhs = packages[p]; // package fallbacks not currently supported

        if (typeof rhs !== 'string') continue;
        const mapped = resolveImportMap(parentMap, resolveIfNotPlainOrUrl(rhs, baseUrl) || rhs, parentUrl);
        if (!mapped) targetWarning(p, rhs, 'bare specifier did not resolve');else outPackages[resolvedLhs] = mapped;
      }
    }

    function resolveAndComposeImportMap(json, baseUrl, parentMap) {
      const outMap = {
        imports: objectAssign({}, parentMap.imports),
        scopes: objectAssign({}, parentMap.scopes)
      };
      if (json.imports) resolveAndComposePackages(json.imports, outMap.imports, baseUrl, parentMap, null);
      if (json.scopes) for (let s in json.scopes) {
        const resolvedScope = resolveUrl(s, baseUrl);
        resolveAndComposePackages(json.scopes[s], outMap.scopes[resolvedScope] || (outMap.scopes[resolvedScope] = {}), baseUrl, parentMap, resolvedScope);
      }
      return outMap;
    }

    function getMatch(path, matchObj) {
      if (matchObj[path]) return path;
      let sepIndex = path.length;

      do {
        const segment = path.slice(0, sepIndex + 1);
        if (segment in matchObj) return segment;
      } while ((sepIndex = path.lastIndexOf('/', sepIndex - 1)) !== -1);
    }

    function applyPackages(id, packages) {
      const pkgName = getMatch(id, packages);

      if (pkgName) {
        const pkg = packages[pkgName];
        if (pkg === null) return;
        if (id.length > pkgName.length && pkg[pkg.length - 1] !== '/') targetWarning(pkgName, pkg, "should have a trailing '/'");else return pkg + id.slice(pkgName.length);
      }
    }

    function targetWarning(match, target, msg) {
      console.warn("Package target " + msg + ", resolving target '" + target + "' for " + match);
    }

    function resolveImportMap(importMap, resolvedOrPlain, parentUrl) {
      let scopeUrl = parentUrl && getMatch(parentUrl, importMap.scopes);

      while (scopeUrl) {
        const packageResolution = applyPackages(resolvedOrPlain, importMap.scopes[scopeUrl]);
        if (packageResolution) return packageResolution;
        scopeUrl = getMatch(scopeUrl.slice(0, scopeUrl.lastIndexOf('/')), importMap.scopes);
      }

      return applyPackages(resolvedOrPlain, importMap.imports) || resolvedOrPlain.indexOf(':') !== -1 && resolvedOrPlain;
    }
    /*
     * SystemJS Core
     * 
     * Provides
     * - System.import
     * - System.register support for
     *     live bindings, function hoisting through circular references,
     *     reexports, dynamic import, import.meta.url, top-level await
     * - System.getRegister to get the registration
     * - Symbol.toStringTag support in Module objects
     * - Hookable System.createContext to customize import.meta
     * - System.onload(err, id, deps) handler for tracing / hot-reloading
     * 
     * Core comes with no System.prototype.resolve or
     * System.prototype.instantiate implementations
     */


    const hasSymbol = typeof Symbol !== 'undefined';
    const toStringTag = hasSymbol && Symbol.toStringTag;
    const REGISTRY = hasSymbol ? Symbol() : '@';

    function SystemJS() {
      this[REGISTRY] = {};
    }

    const systemJSPrototype = SystemJS.prototype;

    systemJSPrototype.prepareImport = function () {};

    systemJSPrototype.import = function (id, parentUrl) {
      const loader = this;
      return Promise.resolve(loader.prepareImport()).then(function () {
        return loader.resolve(id, parentUrl);
      }).then(function (id) {
        const load = getOrCreateLoad(loader, id);
        return load.C || topLevelLoad(loader, load);
      });
    }; // Hookable createContext function -> allowing eg custom import meta


    systemJSPrototype.createContext = function (parentId) {
      return {
        url: parentId
      };
    }; // onLoad(err, id, deps) provided for tracing / hot-reloading


    systemJSPrototype.onload = function () {};

    function loadToId(load) {
      return load.id;
    }

    function triggerOnload(loader, load, err) {
      loader.onload(err, load.id, load.d && load.d.map(loadToId));
      if (err) throw err;
    }

    let lastRegister;

    systemJSPrototype.register = function (deps, declare) {
      lastRegister = [deps, declare];
    };
    /*
     * getRegister provides the last anonymous System.register call
     */


    systemJSPrototype.getRegister = function () {
      const _lastRegister = lastRegister;
      lastRegister = undefined;
      return _lastRegister;
    };

    function getOrCreateLoad(loader, id, firstParentUrl) {
      let load = loader[REGISTRY][id];
      if (load) return load;
      const importerSetters = [];
      const ns = Object.create(null);
      if (toStringTag) Object.defineProperty(ns, toStringTag, {
        value: 'Module'
      });
      let instantiatePromise = Promise.resolve().then(function () {
        return loader.instantiate(id, firstParentUrl);
      }).then(function (registration) {
        if (!registration) throw Error('Module ' + id + ' did not instantiate');

        function _export(name, value) {
          // note if we have hoisted exports (including reexports)
          load.h = true;
          let changed = false;

          if (typeof name !== 'object') {
            if (!(name in ns) || ns[name] !== value) {
              ns[name] = value;
              changed = true;
            }
          } else {
            for (let p in name) {
              let value = name[p];

              if (!(p in ns) || ns[p] !== value) {
                ns[p] = value;
                changed = true;
              }
            }

            if (name.__esModule) {
              ns.__esModule = name.__esModule;
            }
          }

          if (changed) for (let i = 0; i < importerSetters.length; i++) importerSetters[i](ns);
          return value;
        }

        const declared = registration[1](_export, registration[1].length === 2 ? {
          import: function (importId) {
            return loader.import(importId, id);
          },
          meta: loader.createContext(id)
        } : undefined);

        load.e = declared.execute || function () {};

        return [registration[0], declared.setters || []];
      });
      instantiatePromise = instantiatePromise.catch(function (err) {
        triggerOnload(loader, load, err);
      });
      const linkPromise = instantiatePromise.then(function (instantiation) {
        return Promise.all(instantiation[0].map(function (dep, i) {
          const setter = instantiation[1][i];
          return Promise.resolve(loader.resolve(dep, id)).then(function (depId) {
            const depLoad = getOrCreateLoad(loader, depId, id); // depLoad.I may be undefined for already-evaluated

            return Promise.resolve(depLoad.I).then(function () {
              if (setter) {
                depLoad.i.push(setter); // only run early setters when there are hoisted exports of that module
                // the timing works here as pending hoisted export calls will trigger through importerSetters

                if (depLoad.h || !depLoad.I) setter(depLoad.n);
              }

              return depLoad;
            });
          });
        })).then(function (depLoads) {
          load.d = depLoads;
        });
      });
      linkPromise.catch(function (err) {
        load.e = null;
        load.er = err;
      }); // Capital letter = a promise function

      return load = loader[REGISTRY][id] = {
        id: id,
        // importerSetters, the setters functions registered to this dependency
        // we retain this to add more later
        i: importerSetters,
        // module namespace object
        n: ns,
        // instantiate
        I: instantiatePromise,
        // link
        L: linkPromise,
        // whether it has hoisted exports
        h: false,
        // On instantiate completion we have populated:
        // dependency load records
        d: undefined,
        // execution function
        // set to NULL immediately after execution (or on any failure) to indicate execution has happened
        // in such a case, C should be used, and E, I, L will be emptied
        e: undefined,
        // On execution we have populated:
        // the execution error if any
        er: undefined,
        // in the case of TLA, the execution promise
        E: undefined,
        // On execution, L, I, E cleared
        // Promise for top-level completion
        C: undefined
      };
    }

    function instantiateAll(loader, load, loaded) {
      if (!loaded[load.id]) {
        loaded[load.id] = true; // load.L may be undefined for already-instantiated

        return Promise.resolve(load.L).then(function () {
          return Promise.all(load.d.map(function (dep) {
            return instantiateAll(loader, dep, loaded);
          }));
        });
      }
    }

    function topLevelLoad(loader, load) {
      return load.C = instantiateAll(loader, load, {}).then(function () {
        return postOrderExec(loader, load, {});
      }).then(function () {
        return load.n;
      });
    } // the closest we can get to call(undefined)


    const nullContext = Object.freeze(Object.create(null)); // returns a promise if and only if a top-level await subgraph
    // throws on sync errors

    function postOrderExec(loader, load, seen) {
      if (seen[load.id]) return;
      seen[load.id] = true;

      if (!load.e) {
        if (load.er) throw load.er;
        if (load.E) return load.E;
        return;
      } // deps execute first, unless circular


      let depLoadPromises;
      load.d.forEach(function (depLoad) {
        {
          try {
            const depLoadPromise = postOrderExec(loader, depLoad, seen);

            if (depLoadPromise) {
              depLoadPromise.catch(function (err) {
                triggerOnload(loader, load, err);
              });
              (depLoadPromises = depLoadPromises || []).push(depLoadPromise);
            }
          } catch (err) {
            triggerOnload(loader, load, err);
          }
        }
      });
      if (depLoadPromises) return Promise.all(depLoadPromises).then(doExec);
      return doExec();

      function doExec() {
        try {
          let execPromise = load.e.call(nullContext);

          if (execPromise) {
            execPromise = execPromise.then(function () {
              load.C = load.n;
              load.E = null; // indicates completion

              triggerOnload(loader, load, null);
            }, function (err) {
              triggerOnload(loader, load, err);
            });
            return load.E = load.E || execPromise;
          } // (should be a promise, but a minify optimization to leave out Promise.resolve)


          load.C = load.n;
          triggerOnload(loader, load, null);
        } catch (err) {
          triggerOnload(loader, load, err);
          load.er = err;
          throw err;
        } finally {
          load.L = load.I = undefined;
          load.e = null;
        }
      }
    }

    envGlobal.System = new SystemJS();
    /*
     * Import map support for SystemJS
     * 
     * <script type="webruntime-importmap">{}</script>
     * OR
     * <script type="webruntime-importmap" src=package.json></script>
     * 
     * Only those import maps available at the time of SystemJS initialization will be loaded
     * and they will be loaded in DOM order.
     * 
     * There is no support for dynamic import maps injection currently.
     */

    let importMap = {
      imports: {},
      scopes: {}
    },
        importMapPromise;

    if (hasDocument) {
      Array.prototype.forEach.call(document.querySelectorAll('script[type="webruntime-importmap"][src]'), function (script) {
        script._j = fetch(script.src).then(function (res) {
          return res.json();
        });
      });
    }

    systemJSPrototype.prepareImport = function () {
      if (!importMapPromise) {
        importMapPromise = Promise.resolve();
        if (hasDocument) Array.prototype.forEach.call(document.querySelectorAll('script[type="webruntime-importmap"]'), function (script) {
          importMapPromise = importMapPromise.then(function () {
            return (script._j || script.src && fetch(script.src).then(function (resp) {
              return resp.json();
            }) || Promise.resolve(JSON.parse(script.innerHTML))).then(function (json) {
              importMap = resolveAndComposeImportMap(json, script.src || baseUrl, importMap);
            });
          });
        });
      }

      return importMapPromise;
    };

    systemJSPrototype.resolve = function (id, parentUrl) {
      parentUrl = parentUrl || baseUrl;
      return resolveImportMap(importMap, resolveIfNotPlainOrUrl(id, parentUrl) || id, parentUrl) || throwUnresolved(id, parentUrl);
    };

    function throwUnresolved(id, parentUrl) {
      throw Error("Unable to resolve specifier '" + id + (parentUrl ? "' from " + parentUrl : "'"));
    }
    /*
     * Supports loading System.register via script tag injection
     */


    const systemRegister = systemJSPrototype.register;

    systemJSPrototype.register = function (deps, declare) {
      systemRegister.call(this, deps, declare);
    };

    systemJSPrototype.createScript = function (url) {
      const script = document.createElement('script');
      script.charset = 'utf-8';
      script.async = true;
      script.crossOrigin = 'anonymous';
      script.src = url;
      return script;
    };

    let lastWindowErrorUrl, lastWindowError;
    if (hasDocument) window.addEventListener('error', function (evt) {
      lastWindowErrorUrl = evt.filename;
      lastWindowError = evt.error;
    });

    systemJSPrototype.instantiate = function (url, firstParentUrl) {
      const loader = this;
      return new Promise(function (resolve, reject) {
        const script = systemJSPrototype.createScript(url);
        script.addEventListener('error', function () {
          reject(Error('Error loading ' + url + (firstParentUrl ? ' from ' + firstParentUrl : '')));
        });
        script.addEventListener('load', function () {
          document.head.removeChild(script); // Note that if an error occurs that isn't caught by this if statement,
          // that getRegister will return null and a "did not instantiate" error will be thrown.

          if (lastWindowErrorUrl === url) {
            reject(lastWindowError);
          } else {
            resolve(loader.getRegister());
          }
        });
        document.head.appendChild(script);
      });
    };

    if (hasDocument) {
      window.addEventListener('DOMContentLoaded', loadScriptModules);
      loadScriptModules();
    }

    function loadScriptModules() {
      Array.prototype.forEach.call(document.querySelectorAll('script[type="text/javascript"]:not([src])'), function (script) {
        if (script.src) {
          System.import(script.src.slice(0, 7) === 'import:' ? script.src.slice(7) : resolveUrl(script.src, baseUrl));
        }
      });
    }
    /*
     * Supports loading System.register in workers
     */


    if (hasSelf && typeof importScripts === 'function') systemJSPrototype.instantiate = function (url) {
      const loader = this;
      return new Promise(function (resolve, reject) {
        try {
          importScripts(url);
        } catch (e) {
          reject(e);
        }

        resolve(loader.getRegister());
      });
    };
    /*
     * SystemJS global script loading support
     * Extra for the s.js build only
     * (Included by default in system.js build)
     */

    (function (global) {
      const systemJSPrototype = global.System.constructor.prototype;
      const isIE = navigator.userAgent.indexOf('Trident') !== -1; // safari unpredictably lists some new globals first or second in object order

      let firstGlobalProp, secondGlobalProp, lastGlobalProp;

      function getGlobalProp() {
        let cnt = 0;
        let lastProp;

        for (let p in global) {
          // do not check frames cause it could be removed during import
          if (!global.hasOwnProperty(p) || !isNaN(p) && p < global.length || isIE && global[p] && global[p].parent === window) continue;
          if (cnt === 0 && p !== firstGlobalProp || cnt === 1 && p !== secondGlobalProp) return p;
          cnt++;
          lastProp = p;
        }

        if (lastProp !== lastGlobalProp) return lastProp;
      }

      function noteGlobalProps() {
        // alternatively Object.keys(global).pop()
        // but this may be faster (pending benchmarks)
        firstGlobalProp = secondGlobalProp = undefined;

        for (let p in global) {
          // do not check frames cause it could be removed during import
          if (!global.hasOwnProperty(p) || !isNaN(p) && p < global.length || isIE && global[p] && global[p].parent === window) continue;
          if (!firstGlobalProp) firstGlobalProp = p;else if (!secondGlobalProp) secondGlobalProp = p;
          lastGlobalProp = p;
        }

        return lastGlobalProp;
      }

      const impt = systemJSPrototype.import;

      systemJSPrototype.import = function (id, parentUrl) {
        noteGlobalProps();
        return impt.call(this, id, parentUrl);
      };

      const emptyInstantiation = [[], function () {
        return {};
      }];
      const getRegister = systemJSPrototype.getRegister;

      systemJSPrototype.getRegister = function () {
        const lastRegister = getRegister.call(this);
        if (lastRegister) return lastRegister; // no registration -> attempt a global detection as difference from snapshot
        // when multiple globals, we take the global value to be the last defined new global object property
        // for performance, this will not support multi-version / global collisions as previous SystemJS versions did
        // note in Edge, deleting and re-adding a global does not change its ordering

        const globalProp = getGlobalProp();
        if (!globalProp) return emptyInstantiation;
        let globalExport;

        try {
          globalExport = global[globalProp];
        } catch (e) {
          return emptyInstantiation;
        }

        return [[], function (_export) {
          return {
            execute: function () {
              _export({
                default: globalExport,
                __useDefault: true
              });
            }
          };
        }];
      };
    })(typeof self !== 'undefined' ? self : global);
    /*
     * Loads JSON, CSS, Wasm module types based on file extensions
     * Supports application/javascript falling back to JS eval
     */


    (function (global) {
      const systemJSPrototype = global.System.constructor.prototype;
      const instantiate = systemJSPrototype.instantiate;
      const moduleTypesRegEx = /\.(css|html|json|wasm)$/;

      systemJSPrototype.shouldFetch = function (url) {
        const path = url.split('?')[0].split('#')[0];
        const ext = path.slice(path.lastIndexOf('.'));
        return ext.match(moduleTypesRegEx);
      };

      systemJSPrototype.fetch = function (url) {
        return fetch(url);
      };

      systemJSPrototype.instantiate = function (url, parent) {
        const loader = this;

        if (this.shouldFetch(url)) {
          return this.fetch(url).then(function (res) {
            if (!res.ok) throw Error(res.status + ' ' + res.statusText + ', loading ' + url + (parent ? ' from ' + parent : ''));
            const contentType = res.headers.get('content-type');

            if (contentType.match(/^(text|application)\/(x-)?javascript(;|$)/)) {
              return res.text().then(function (source) {
                (0, eval)(source);
                return loader.getRegister();
              });
            } else if (contentType.match(/^application\/json(;|$)/)) {
              return res.text().then(function (source) {
                return [[], function (_export) {
                  return {
                    execute: function () {
                      _export('default', JSON.parse(source));
                    }
                  };
                }];
              });
            } else if (contentType.match(/^text\/css(;|$)/)) {
              return res.text().then(function (source) {
                return [[], function (_export) {
                  return {
                    execute: function () {
                      // Relies on a Constructable Stylesheet polyfill
                      const stylesheet = new CSSStyleSheet();
                      stylesheet.replaceSync(source);

                      _export('default', stylesheet);
                    }
                  };
                }];
              });
            } else if (contentType.match(/^application\/wasm(;|$)/)) {
              return (WebAssembly.compileStreaming ? WebAssembly.compileStreaming(res) : res.arrayBuffer().then(WebAssembly.compile)).then(function (module) {
                const deps = [];
                const setters = [];
                const importObj = {}; // we can only set imports if supported (eg early Safari doesnt support)

                if (WebAssembly.Module.imports) WebAssembly.Module.imports(module).forEach(function (impt) {
                  const key = impt.module;

                  if (deps.indexOf(key) === -1) {
                    deps.push(key);
                    setters.push(function (m) {
                      importObj[key] = m;
                    });
                  }
                });
                return [deps, function (_export) {
                  return {
                    setters: setters,
                    execute: function () {
                      return WebAssembly.instantiate(module, importObj).then(function (instance) {
                        _export(instance.exports);
                      });
                    }
                  };
                }];
              });
            } else {
              throw new Error('Unknown module type "' + contentType + '"');
            }
          });
        }

        return instantiate.apply(this, arguments);
      };
    })(typeof self !== 'undefined' ? self : global);

    const toStringTag$1 = typeof Symbol !== 'undefined' && Symbol.toStringTag;

    systemJSPrototype.get = function (id) {
      const load = this[REGISTRY][id];

      if (load && load.e === null && !load.E) {
        if (load.er) return null;
        return load.n;
      }
    };

    systemJSPrototype.set = function (id, module) {
      let ns;

      if (toStringTag$1 && module[toStringTag$1] === 'Module') {
        ns = module;
      } else {
        ns = Object.assign(Object.create(null), module);
        if (toStringTag$1) Object.defineProperty(ns, toStringTag$1, {
          value: 'Module'
        });
      }

      const done = Promise.resolve(ns);
      const load = this[REGISTRY][id] || (this[REGISTRY][id] = {
        id: id,
        i: [],
        h: false,
        d: [],
        e: null,
        er: undefined,
        E: undefined
      });
      if (load.e || load.E) return false;
      Object.assign(load, {
        n: ns,
        I: undefined,
        L: undefined,
        C: done
      });
      return ns;
    };

    systemJSPrototype.has = function (id) {
      const load = this[REGISTRY][id];
      return !!load;
    }; // Delete function provided for hot-reloading use cases


    systemJSPrototype.delete = function (id) {
      const registry = this[REGISTRY];
      const load = registry[id]; // in future we can support load.E case by failing load first
      // but that will require TLA callbacks to be implemented

      if (!load || load.e !== null || load.E) return false;
      let importerSetters = load.i; // remove from importerSetters
      // (release for gc)

      if (load.d) load.d.forEach(function (depLoad) {
        const importerIndex = depLoad.i.indexOf(load);
        if (importerIndex !== -1) depLoad.i.splice(importerIndex, 1);
      });
      delete registry[id];
      return function () {
        const load = registry[id];
        if (!load || !importerSetters || load.e !== null || load.E) return false; // add back the old setters

        importerSetters.forEach(function (setter) {
          load.i.push(setter);
          setter(load.n);
        });
        importerSetters = null;
      };
    };

    const iterator = typeof Symbol !== 'undefined' && Symbol.iterator;

    systemJSPrototype.entries = function () {
      const loader = this,
            keys = Object.keys(loader[REGISTRY]);
      let index = 0,
          ns,
          key;
      const result = {
        next: function () {
          while ((key = keys[index++]) !== undefined && (ns = loader.get(key)) === undefined);

          return {
            done: key === undefined,
            value: key !== undefined && [key, ns]
          };
        }
      };

      result[iterator] = function () {
        return this;
      };

      return result;
    };
  })();
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * This replaces the 'DOMContentLoaded'/loadScriptModules() event from systemjs.
   * The original event was made into a no-op in '../scripts/rollup.config.system.js'
   * This logic ensures the webruntime-modules are executed IN ORDER, instead of in parallel.
   */

  /* eslint-disable */


  (function () {
    if (typeof document !== 'undefined') {
      window.addEventListener('DOMContentLoaded', loadScriptModules);
      loadScriptModules();
    }

    function loadScriptModules() {
      let scriptLoadPromise = Promise.resolve();
      Array.prototype.forEach.call(document.querySelectorAll('script[type=webruntime-module]'), function (script) {
        if (script.src) {
          // Original logic:
          // System.import(script.src.slice(0, 7) === 'import:' ? script.src.slice(7) : resolveUrl(script.src, baseUrl));
          // Create a Promise change for the modules so they execute in order, rather than in parallel.
          scriptLoadPromise = scriptLoadPromise.then(() => System.import(script.src.slice(0, 7) === 'import:' ? script.src.slice(7) : System.resolve(script.src)));
        }
      });
    }
  })();
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * Lightning Web Runtime: Override the systemjs createScript which sets crossOrigin="anonymous" by default.
   * The attribute is broken for Safari, we can remove this hook when it is fixed: https://bugs.webkit.org/show_bug.cgi?id=171566.
   *
   */

  /* eslint-disable */


  (function (global) {
    const systemPrototype = global.System.constructor.prototype;

    systemPrototype.createScript = function (url) {
      const script = document.createElement('script');
      script.charset = 'utf-8';
      script.async = true;
      script.src = url;
      const a = document.createElement('a');
      a.href = url;

      if (a.hostname !== window.location.hostname) {
        script.crossOrigin = 'anonymous';
      }

      return script;
    };
  })(typeof self !== 'undefined' ? self : global);
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * Lightning Web Runtime: This is a modified version of the AMD extra from https://github.com/systemjs/systemjs/blob/master/src/extras/amd.js.
   * The changes here contain a temporary patch to support circular dependencies, and multiple defines in one file aka "bundled AMD modules".
   *
   * This modified file is a copy of version 6.1.4
   */

  /* eslint-disable */


  (function (global) {
    const systemPrototype = global.System.constructor.prototype;
    const emptyInstantiation = [[], function () {
      return {};
    }];

    function unsupportedRequire() {
      throw Error('AMD require not supported.');
    } // LWR change: not used due to bundling changes, see comment in `addToRegisterRegistry`


    let tmpRegister; //, firstNamedDefine;

    function emptyFn() {}

    const requireExportsModule = ['require', 'exports', 'module'];

    function createAMDRegister(amdDefineDeps, amdDefineExec) {
      const exports = {};
      const module = {
        exports: exports
      };
      const depModules = [];
      const setters = [];
      let splice = 0;

      for (let i = 0; i < amdDefineDeps.length; i++) {
        const id = amdDefineDeps[i];
        const index = setters.length;

        if (id === 'require') {
          depModules[i] = unsupportedRequire;
          splice++;
        } else if (id === 'module') {
          depModules[i] = module;
          splice++;
        } else if (id === 'exports') {
          depModules[i] = exports;
          splice++;
        } else {
          // needed for ie11 lack of iteration scope
          const idx = i;
          setters.push(function (ns) {
            depModules[idx] = ns.__useDefault ? ns.default : ns;
          });
        }

        if (splice) amdDefineDeps[index] = id;
      }

      if (splice) amdDefineDeps.length -= splice;
      const amdExec = amdDefineExec;
      return [amdDefineDeps, function (_export) {
        _export({
          default: exports,
          __useDefault: true
        });

        return {
          setters: setters,
          execute: function (deps) {
            // Workaround to handle circular/recursive dependencies.
            // This workaround is required until https://github.com/rollup/rollup/issues/3384 is resolved
            for (var i = 0; i < deps.length; i++) {
              const dep = deps[i];

              if (dep !== 'exports' && dep !== 'module' && dep !== 'require' && !dep.startsWith('./') && !System.get(System.resolve(dep))) {
                let tmp = function () {
                  const module = System.get(System.resolve(dep));
                  return module.__useDefault ? module.default : module;
                }; // __circular__ expected by LWC engine workaround


                tmp.__circular__ = true;
                depModules[i] = tmp;
              }
            } // START: Fix to ensure falsy modules (eg: empty strings, false, etc) are returned.
            // module.exports = amdExec.apply(exports, depModules) || module.exports;


            const amdResult = amdExec.apply(exports, depModules);
            if (amdResult !== null && amdResult !== undefined) module.exports = amdResult; // END: falsy module fix

            if (exports !== module.exports) _export('default', module.exports);
          }.bind(null, amdDefineDeps)
        };
      }];
    } // hook System.register to know the last declaration binding


    let lastRegisterDeclare;
    const systemRegister = systemPrototype.register;

    systemPrototype.register = function (name, deps, declare) {
      lastRegisterDeclare = typeof name === 'string' ? declare : deps;
      systemRegister.apply(this, arguments);
    };

    const instantiate = systemPrototype.instantiate;

    systemPrototype.instantiate = function () {
      // Reset "currently executing script"
      amdDefineDeps = null;
      bundleDefineQueue = [];
      return instantiate.apply(this, arguments);
    };

    const getRegister = systemPrototype.getRegister;

    systemPrototype.getRegister = function () {
      if (tmpRegister) return tmpRegister; // const _firstNamedDefine = firstNamedDefine;
      // firstNamedDefine = null;

      const register = getRegister.call(this); // if its an actual System.register leave it

      if (register && register[1] === lastRegisterDeclare) return register; // const _amdDefineDeps = amdDefineDeps;

      const {
        amdDefineDeps: _amdDefineDeps,
        amdDefineExec: _amdDefineExec
      } = bundleDefineQueue.length && bundleDefineQueue.pop();
      amdDefineDeps = null; // If the script registered a named module, return that module instead of re-instantiating it.
      // if (_firstNamedDefine) return _firstNamedDefine;
      // otherwise AMD takes priority
      // no registration -> attempt AMD detection

      if (!_amdDefineDeps) return register || emptyInstantiation;
      return createAMDRegister(_amdDefineDeps, _amdDefineExec);
    };
    /**
     * WebRuntime change:
     * Add queue of define dependencies to support
     * bundling for NAMED modules only (it doesn't make sense to bundle unamed).
     * The unmodified AMD extra only expects a single define when
     * a file is loaded.  It updates the scope global `amdDefineDeps`
     * with the `deps` of the `define`.  When there are multiple defines
     * in a file, `amdDefineDeps` is set to the `deps` of the last `define` call.
     * By the time `getRegister` is called, the expected deps doesn't match what it thinks
     * should be the deps from the first (and what it thinks is the only) `define`.
     *
     * The solution is to maintain a queue of the `deps` of each define call.  This will
     * match each `define` call to the expecting `getRegister` call.  Note that this also means
     * when requesting a specific component from a bundle, that component MUST be included *last*
     * in the bundle, or the component returned from the System.import() will not match.
     *
     * Eg System.import('myapp') // myapp --> /bundle.js through import-map
     *
     * // bundle.js - myapp must be last.
     * define('dep1',[],function(){});
     * define('myapp',['dep'], function(){})
     */


    let amdDefineDeps; // , amdDefineExec;

    let bundleDefineQueue = [];

    global.define = function (name, deps, execute) {
      // define('', [], function () {})
      if (typeof name === 'string') {
        const depsAndExec = getDepsAndExec(deps, execute);

        if (amdDefineDeps) {
          if (!System.registerRegistry) throw Error('Include the named register extension for SystemJS named AMD support.');
          addToRegisterRegistry(name, createAMDRegister(depsAndExec[0], depsAndExec[1]));
          amdDefineDeps = [];
          amdDefineExec = emptyFn;
          return;
        } else {
          if (System.registerRegistry) addToRegisterRegistry(name, createAMDRegister([].concat(depsAndExec[0]), depsAndExec[1]));
          name = deps;
          deps = execute;
        }
      }

      const depsAndExec = getDepsAndExec(name, deps);
      bundleDefineQueue.push({
        amdDefineDeps: depsAndExec[0],
        amdDefineExec: depsAndExec[1]
      });
    };

    global.define.amd = {};

    function getDepsAndExec(arg1, arg2) {
      // define([], function () {})
      if (arg1 instanceof Array) {
        return [arg1, arg2];
      } // define({})
      else if (typeof arg1 === 'object') {
          return [[], function () {
            return arg1;
          }];
        } // define(function () {})
        else if (typeof arg1 === 'function') {
            return [requireExportsModule, arg1];
          }
    }

    function addToRegisterRegistry(name, define) {
      // LWR change: This was added to fix a race condition in https://github.com/systemjs/systemjs/pull/2121
      // however, with our custom bundling changes, it is not required.

      /*if (!firstNamedDefine) {
          firstNamedDefine = define;
          setTimeout(function() {
              firstNamedDefine = null;
          });
      }*/
      // We must call System.getRegister() here to give other extras, such as the named-exports extra,
      // a chance to modify the define before it's put into the registerRegistry.
      // See https://github.com/systemjs/systemjs/issues/2073
      tmpRegister = define;
      System.registerRegistry[name] = System.getRegister();
      tmpRegister = null;
    }
  })(typeof self !== 'undefined' ? self : global);
  /*
   * Named exports support for legacy module formats in SystemJS 2.0
   */


  (function (global) {
    const systemJSPrototype = global.System.constructor.prototype; // hook System.register to know the last declaration binding

    let lastRegisterDeclare;
    const systemRegister = systemJSPrototype.register;

    systemJSPrototype.register = function (name, deps, declare) {
      lastRegisterDeclare = typeof name === 'string' ? declare : deps;
      systemRegister.apply(this, arguments);
    };

    const getRegister = systemJSPrototype.getRegister;

    systemJSPrototype.getRegister = function () {
      const register = getRegister.call(this); // if it is an actual System.register call, then its ESM
      // -> dont add named exports

      if (!register || register[1] === lastRegisterDeclare || register[1].length === 0) return register; // otherwise it was provided by a custom instantiator
      // -> extend the registration with named exports support

      const registerDeclare = register[1];

      register[1] = function (_export, _context) {
        // hook the _export function to note the default export
        let defaultExport,
            hasDefaultExport = false;
        const declaration = registerDeclare.call(this, function (name, value) {
          if (typeof name === 'object' && name.__useDefault) defaultExport = name.default, hasDefaultExport = true;else if (name === 'default') defaultExport = value;else if (name === '__useDefault') hasDefaultExport = true;

          _export(name, value);
        }, _context); // hook the execute function

        const execute = declaration.execute;
        if (execute) declaration.execute = function () {
          execute.call(this); // do a bulk export of the default export object
          // to export all its names as named exports

          if (hasDefaultExport && typeof defaultExport === 'object') for (let name in defaultExport) {
            // default is not a named export
            if (name !== 'default') {
              _export(name, defaultExport[name]);
            }
          }
        };
        return declaration;
      };

      return register;
    };
  })(typeof self !== 'undefined' ? self : global);
  /*
   * SystemJS named register extension
   * Supports System.register('name', [..deps..], function (_export, _context) { ... })
   * 
   * Names are written to the registry as-is
   * System.register('x', ...) can be imported as System.import('x')
   */


  (function (global) {
    const System = global.System;
    setRegisterRegistry(System);
    const systemJSPrototype = System.constructor.prototype;
    const constructor = System.constructor;

    const SystemJS = function () {
      constructor.call(this);
      setRegisterRegistry(this);
    };

    SystemJS.prototype = systemJSPrototype;
    System.constructor = SystemJS;
    let firstNamedDefine;

    function setRegisterRegistry(systemInstance) {
      systemInstance.registerRegistry = Object.create(null);
    }

    const register = systemJSPrototype.register;

    systemJSPrototype.register = function (name, deps, declare) {
      if (typeof name !== 'string') return register.apply(this, arguments);
      const define = [deps, declare];
      this.registerRegistry[name] = define;

      if (!firstNamedDefine) {
        firstNamedDefine = define;
        setTimeout(function () {
          firstNamedDefine = null;
        });
      }

      return register.apply(this, arguments);
    };

    const resolve = systemJSPrototype.resolve;

    systemJSPrototype.resolve = function (id, parentURL) {
      try {
        // Prefer import map (or other existing) resolution over the registerRegistry
        return resolve.call(this, id, parentURL);
      } catch (err) {
        if (id in this.registerRegistry) {
          return id;
        }

        throw err;
      }
    };

    const instantiate = systemJSPrototype.instantiate;

    systemJSPrototype.instantiate = function (url, firstParentUrl) {
      const result = this.registerRegistry[url];

      if (result) {
        this.registerRegistry[url] = null;
        return result;
      } else {
        return instantiate.call(this, url, firstParentUrl);
      }
    };

    const getRegister = systemJSPrototype.getRegister;

    systemJSPrototype.getRegister = function () {
      // Calling getRegister() because other extras need to know it was called so they can perform side effects
      const register = getRegister.call(this);
      const result = firstNamedDefine || register;
      firstNamedDefine = null;
      return result;
    };
  })(typeof self !== 'undefined' ? self : global);
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * Lightning Web Runtime: this patches the named-register plugin when resolving
   * named modules, see https://github.com/systemjs/systemjs/issues/2030
   */

  /* eslint-disable */


  (function (global) {
    const System = global.System;
    const systemJSPrototype = System.constructor.prototype;
    /**
     * WebRuntime change: instead of resolving the ID for named modules,
     * we need to check if it is in the module registry as the URL.
     *
     * Works around module resolution issue with named modules:
     * https://github.com/systemjs/systemjs/issues/2030
     */

    const resolve = systemJSPrototype.resolve;

    systemJSPrototype.resolve = function (id, parentURL) {
      if (id in this.registerRegistry) {
        // Get the import map URL value
        try {
          const importMapValue = resolve.call(this, id, parentURL);

          if (this.has(importMapValue)) {
            return importMapValue;
          }
        } catch (ignore) {
          /*ignore*/
        }

        return id;
      }

      return resolve.call(this, id, parentURL);
    };
  })(typeof self !== 'undefined' ? self : global);
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */


  const localSystem = System;
  /* eslint-disable-line no-undef */

  const localDefine = define;
  /* eslint-disable-line no-undef */

  /** @hidden */

  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  function invariant(condition, errorInfo) {
    if (!condition) {
      throw new Error(`LWR${errorInfo.code}: ${errorInfo.message}`);
    }
  }

  const messages = {
    MISSING_NAME: {
      code: 3000,
      message: 'A module name is required.',
      level: 0,
      url: ''
    },
    INVALID_DEPS: {
      code: 3001,
      message: 'Unexpected value received for dependencies argument; expected an array.',
      level: 0,
      url: ''
    }
  };
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /**
   * A module loader supporting import maps for module resolution.
   */

  const loader = {
    /**
     * "Declares" a single module, caching the metadata: name (if given), dependencies, and the function.
     * Once a module is executed (eg requested via a loader.load), or as a dependency of another executed module,
     * its dependencies are asynchronously resolved and the module function is called.
     *
     * @param {string} name - The name of the module to add
     * @param {string[]} dependencies - An array literal of the module ids that are dependencies required by the module that is being defined
     * @param {Function} execute - A function that should be executed to instantiate the module or an object
     */
    define(name, dependencies, execute) {
      invariant(typeof name === 'string', messages.MISSING_NAME);
      let ctor = execute;
      let deps = dependencies; // Convert no dependencies form `define('name', function(){});`
      // to: `define('name', [], function(){})`

      if (typeof deps === 'function') {
        ctor = dependencies;
        deps = [];
      }

      invariant(Array.isArray(deps), messages.INVALID_DEPS); // ignore if module is already registered

      if (!localSystem.registerRegistry[name]) {
        localDefine(name, deps, ctor);
      }
    },

    /**
     * Polyfill for dynamic import(). Loads a module by name or URL
     *
     * @param {string} id - The name or URL of the module to load
     */
    async load(id) {
      return localSystem.import(id);
    },

    /**
     * Check if registrry contains module
     *
     * @param {string} id - The name or URL of the module to check
     */
    has(id) {
      return !!localSystem.has(id);
    },

    /**
     * Get the module from the module registry
     *
     * @param {string} id - The name or URL of the module to get
     * @param {boolean} [resolve = false] - Resolve the module ID
     */
    get(id) {
      return localSystem.get(id);
    },

    /**
     * Resolve the resolved URL for a module id
     *
     * @param {string} id - The name or URL of the module to get
     */
    resolve(id) {
      return localSystem.resolve(id);
    },

    /**
     * "Declares" multiple modules to the registry by name.
     *
     * @param {object.<string, module>} modulesByName - An object where key is the name of
     *                                  the module to register, and the value is module
     */
    defineModules(modulesByName) {
      if (modulesByName) {
        Object.entries(modulesByName).forEach(([name, module]) => {
          // ignore if module is already registered
          if (!localSystem.registerRegistry[name]) {
            localDefine(name, [], function () {
              return module;
            });
          }
        });
      }
    },

    delete(specifier) {
      if (localSystem.registerRegistry[specifier]) {
        delete localSystem.registerRegistry[specifier];
      }

      const result = localSystem.delete(specifier);

      try {
        const url = localSystem.resolve(specifier);
        return localSystem.delete(url);
      } catch (exception) {
        // resolve might fail with url if import was with specifier
        return result;
      }
    }

  };

  /* proxy-compat-disable */
  function invariant$1(value, msg) {
    if (!value) {
      throw new Error(`Invariant Violation: ${msg}`);
    }
  }

  function isTrue(value, msg) {
    if (!value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }

  function isFalse(value, msg) {
    if (value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }

  function fail(msg) {
    throw new Error(msg);
  }

  var assert = Object.freeze({
    __proto__: null,
    invariant: invariant$1,
    isTrue: isTrue,
    isFalse: isFalse,
    fail: fail
  });
  const {
    assign,
    create,
    defineProperties,
    defineProperty,
    freeze,
    getOwnPropertyDescriptor,
    getOwnPropertyNames,
    getPrototypeOf,
    hasOwnProperty,
    keys,
    seal,
    setPrototypeOf
  } = Object;
  const {
    isArray
  } = Array;
  const {
    filter: ArrayFilter,
    find: ArrayFind,
    forEach,
    indexOf: ArrayIndexOf,
    join: ArrayJoin,
    map: ArrayMap,
    push: ArrayPush,
    reduce: ArrayReduce,
    reverse: ArrayReverse,
    slice: ArraySlice,
    splice: ArraySplice,
    unshift: ArrayUnshift
  } = Array.prototype;
  const {
    charCodeAt: StringCharCodeAt,
    replace: StringReplace,
    slice: StringSlice,
    toLowerCase: StringToLowerCase
  } = String.prototype;

  function isUndefined(obj) {
    return obj === undefined;
  }

  function isNull(obj) {
    return obj === null;
  }

  function isTrue$1(obj) {
    return obj === true;
  }

  function isFalse$1(obj) {
    return obj === false;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function isObject(obj) {
    return typeof obj === 'object';
  }

  const OtS = {}.toString;

  function toString(obj) {
    if (obj && obj.toString) {
      if (isArray(obj)) {
        return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
      }

      return obj.toString();
    } else if (typeof obj === 'object') {
      return OtS.call(obj);
    } else {
      return obj + emptyString;
    }
  }

  function getPropertyDescriptor(o, p) {
    do {
      const d = getOwnPropertyDescriptor(o, p);

      if (!isUndefined(d)) {
        return d;
      }

      o = getPrototypeOf(o);
    } while (o !== null);
  }

  const emptyString = '';
  const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';

  function createHiddenField(key, namespace) {
    return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`;
  }

  const hiddenFieldsMap = new WeakMap();

  function setHiddenField(o, field, value) {
    let valuesByField = hiddenFieldsMap.get(o);

    if (isUndefined(valuesByField)) {
      valuesByField = create(null);
      hiddenFieldsMap.set(o, valuesByField);
    }

    valuesByField[field] = value;
  }

  function getHiddenField(o, field) {
    const valuesByField = hiddenFieldsMap.get(o);

    if (!isUndefined(valuesByField)) {
      return valuesByField[field];
    }
  }

  const {
    DOCUMENT_POSITION_CONTAINED_BY,
    DOCUMENT_POSITION_CONTAINS,
    DOCUMENT_POSITION_PRECEDING,
    DOCUMENT_POSITION_FOLLOWING,
    ELEMENT_NODE,
    TEXT_NODE,
    CDATA_SECTION_NODE,
    PROCESSING_INSTRUCTION_NODE,
    COMMENT_NODE,
    DOCUMENT_FRAGMENT_NODE
  } = Node;
  const {
    appendChild,
    cloneNode,
    compareDocumentPosition,
    insertBefore,
    removeChild,
    replaceChild,
    hasChildNodes
  } = Node.prototype;
  const {
    contains
  } = HTMLElement.prototype;
  const firstChildGetter = getOwnPropertyDescriptor(Node.prototype, 'firstChild').get;
  const lastChildGetter = getOwnPropertyDescriptor(Node.prototype, 'lastChild').get;
  const textContentGetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
  const parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
  const ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
  const parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement') ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
  const textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
  const childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes') ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
  const isConnected = hasOwnProperty.call(Node.prototype, 'isConnected') ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get : function () {
    const doc = ownerDocumentGetter.call(this);
    return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  };
  const {
    addEventListener,
    getAttribute,
    getBoundingClientRect,
    getElementsByTagName,
    getElementsByTagNameNS,
    hasAttribute,
    querySelectorAll,
    removeAttribute,
    removeEventListener,
    setAttribute
  } = Element.prototype;
  const attachShadow = hasOwnProperty.call(Element.prototype, 'attachShadow') ? Element.prototype.attachShadow : () => {
    throw new TypeError('attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components');
  };
  const childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;
  const firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
  const lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;
  const innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'innerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');
  const innerHTMLGetter = innerHTMLDescriptor.get;
  const innerHTMLSetter = innerHTMLDescriptor.set;
  const outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'outerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML');
  const outerHTMLGetter = outerHTMLDescriptor.get;
  const outerHTMLSetter = outerHTMLDescriptor.set;
  const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
  const tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');
  const tabIndexGetter = tabIndexDescriptor.get;
  const tabIndexSetter = tabIndexDescriptor.set;
  const matches = hasOwnProperty.call(Element.prototype, 'matches') ? Element.prototype.matches : Element.prototype.msMatchesSelector;
  const childrenGetter = hasOwnProperty.call(Element.prototype, 'children') ? getOwnPropertyDescriptor(Element.prototype, 'children').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
  const {
    getElementsByClassName
  } = HTMLElement.prototype;
  const shadowRootGetter = hasOwnProperty.call(Element.prototype, 'shadowRoot') ? getOwnPropertyDescriptor(Element.prototype, 'shadowRoot').get : () => null;
  let assignedNodes, assignedElements;

  if (typeof HTMLSlotElement !== 'undefined') {
    assignedNodes = HTMLSlotElement.prototype.assignedNodes;
    assignedElements = HTMLSlotElement.prototype.assignedElements;
  } else {
    assignedNodes = () => {
      throw new TypeError("assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };

    assignedElements = () => {
      throw new TypeError("assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
  }

  const dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
  const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
  const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
  const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;
  const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
  const elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint') ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
  const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
  const {
    createComment,
    querySelectorAll: querySelectorAll$1,
    getElementById,
    getElementsByClassName: getElementsByClassName$1,
    getElementsByTagName: getElementsByTagName$1,
    getElementsByTagNameNS: getElementsByTagNameNS$1
  } = Document.prototype;
  const {
    getElementsByName
  } = HTMLDocument.prototype;
  const {
    addEventListener: windowAddEventListener,
    removeEventListener: windowRemoveEventListener
  } = window;
  const MO = MutationObserver;
  const MutationObserverObserve = MO.prototype.observe;

  function detect() {
    return typeof HTMLSlotElement === 'undefined';
  }

  const {
    createElement
  } = Document.prototype;
  const CHAR_S = 115;
  const CHAR_L = 108;
  const CHAR_O = 111;
  const CHAR_T = 116;

  function apply() {
    class HTMLSlotElement {}

    setPrototypeOf(HTMLSlotElement, HTMLElement.constructor);
    setPrototypeOf(HTMLSlotElement.prototype, HTMLElement.prototype);
    Window.prototype.HTMLSlotElement = HTMLSlotElement;
    defineProperty(Document.prototype, 'createElement', {
      value: function (tagName, _options) {
        const elm = createElement.apply(this, ArraySlice.call(arguments));

        if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
          setPrototypeOf(elm, HTMLSlotElement.prototype);
        }

        return elm;
      }
    });
  }

  if (detect()) {
    apply();
  }

  const {
    assign: assign$1,
    create: create$1,
    defineProperties: defineProperties$1,
    defineProperty: defineProperty$1,
    freeze: freeze$1,
    getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,
    getOwnPropertyNames: getOwnPropertyNames$1,
    getPrototypeOf: getPrototypeOf$1,
    hasOwnProperty: hasOwnProperty$1,
    keys: keys$1,
    seal: seal$1,
    setPrototypeOf: setPrototypeOf$1
  } = Object;
  const hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';

  let _globalThis;

  if (typeof globalThis === 'object') {
    _globalThis = globalThis;
  }

  function getGlobalThis() {
    if (typeof _globalThis === 'object') {
      return _globalThis;
    }

    try {
      Object.defineProperty(Object.prototype, '__magic__', {
        get: function () {
          return this;
        },
        configurable: true
      });
      _globalThis = __magic__;
      delete Object.prototype.__magic__;
    } catch (ex) {} finally {
      if (typeof _globalThis === 'undefined') {
        _globalThis = window;
      }
    }

    return _globalThis;
  }

  const _globalThis$1 = getGlobalThis();

  if (!_globalThis$1.lwcRuntimeFlags) {
    Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {
      value: create$1(null)
    });
  }

  const runtimeFlags = _globalThis$1.lwcRuntimeFlags;

  function getOwnerDocument(node) {
    const doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
  }

  function getOwnerWindow(node) {
    const doc = getOwnerDocument(node);
    const win = defaultViewGetter.call(doc);

    if (win === null) {
      throw new TypeError();
    }

    return win;
  }

  let skipGlobalPatching;

  function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
      const ownerDocument = getOwnerDocument(node);
      skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') === 'temporary-bypass';
    }

    return isTrue$1(skipGlobalPatching);
  }

  function arrayFromCollection(collection) {
    const size = collection.length;
    const cloned = [];

    if (size > 0) {
      for (let i = 0; i < size; i++) {
        cloned[i] = collection[i];
      }
    }

    return cloned;
  }

  function pathComposer(startNode, composed) {
    const composedPath = [];
    let current = startNode;
    const startRoot = startNode instanceof Window ? startNode : startNode.getRootNode();

    while (!isNull(current)) {
      composedPath.push(current);
      let assignedSlot = null;

      if (current instanceof Element) {
        assignedSlot = current.assignedSlot;
      }

      if (!isNull(assignedSlot)) {
        current = assignedSlot;
      } else if (current instanceof ShadowRoot && (composed || current !== startRoot)) {
        current = current.host;
      } else {
        current = current.parentNode;
      }
    }

    let doc;

    if (startNode instanceof Window) {
      doc = startNode.document;
    } else {
      doc = getOwnerDocument(startNode);
    }

    if (composedPath[composedPath.length - 1] === doc) {
      composedPath.push(window);
    }

    return composedPath;
  }

  function retarget(refNode, path) {
    if (isNull(refNode)) {
      return null;
    }

    const refNodePath = pathComposer(refNode, true);
    const p$ = path;

    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
      ancestor = p$[i];
      root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();

      if (root !== lastRoot) {
        rootIdx = refNodePath.indexOf(root);
        lastRoot = root;
      }

      if (!(root instanceof SyntheticShadowRoot) || !isUndefined(rootIdx) && rootIdx > -1) {
        return ancestor;
      }
    }

    return null;
  }

  var EventListenerContext;

  (function (EventListenerContext) {
    EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
    EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
  })(EventListenerContext || (EventListenerContext = {}));

  const eventToContextMap = new WeakMap();

  function isChildNode(root, node) {
    return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
  }

  const GET_ROOT_NODE_CONFIG_FALSE = {
    composed: false
  };

  function getRootNodeHost(node, options) {
    let rootNode = node.getRootNode(options);

    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
      rootNode = getHost(rootNode);
    }

    return rootNode;
  }

  function targetGetter() {
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    const originalTarget = eventTargetGetter.call(this);
    const composedPath = pathComposer(originalTarget, this.composed);
    const doc = getOwnerDocument(originalTarget);

    if (!(originalCurrentTarget instanceof Node)) {
      if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    } else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
      if (isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    }

    const eventContext = eventToContextMap.get(this);
    const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
    return retarget(currentTarget, composedPath);
  }

  function composedPathValue() {
    const originalTarget = eventTargetGetter.call(this);
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    return isNull(originalCurrentTarget) ? [] : pathComposer(originalTarget, this.composed);
  }

  function patchEvent(event) {
    if (eventToContextMap.has(event)) {
      return;
    }

    defineProperties(event, {
      target: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      composedPath: {
        value: composedPathValue,
        writable: true,
        enumerable: true,
        configurable: true
      },
      srcElement: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      path: {
        get: composedPathValue,
        enumerable: true,
        configurable: true
      }
    });
    const originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');

    if (!isUndefined(originalRelatedTargetDescriptor)) {
      const relatedTargetGetter = originalRelatedTargetDescriptor.get;
      defineProperty(event, 'relatedTarget', {
        get() {
          const eventContext = eventToContextMap.get(this);
          const originalCurrentTarget = eventCurrentTargetGetter.call(this);
          const relatedTarget = relatedTargetGetter.call(this);

          if (isNull(relatedTarget)) {
            return null;
          }

          const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
          return retarget(currentTarget, pathComposer(relatedTarget, true));
        },

        enumerable: true,
        configurable: true
      });
    }

    eventToContextMap.set(event, 0);
  }

  const customElementToWrappedListeners = new WeakMap();

  function getEventMap(elm) {
    let listenerInfo = customElementToWrappedListeners.get(elm);

    if (isUndefined(listenerInfo)) {
      listenerInfo = create(null);
      customElementToWrappedListeners.set(elm, listenerInfo);
    }

    return listenerInfo;
  }

  const shadowRootEventListenerMap = new WeakMap();

  function getWrappedShadowRootListener(sr, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);

    if (isUndefined(shadowRootWrappedListener)) {
      shadowRootWrappedListener = function (event) {
        const {
          composed
        } = event;
        const target = eventTargetGetter.call(event);
        const currentTarget = eventCurrentTargetGetter.call(event);

        if (target !== currentTarget) {
          const rootNode = getRootNodeHost(target, {
            composed
          });

          if (isChildNode(rootNode, currentTarget) || composed === false && rootNode === currentTarget) {
            listener.call(sr, event);
          }
        }
      };

      shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;

      {
        shadowRootWrappedListener.original = listener;
      }

      shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }

    return shadowRootWrappedListener;
  }

  const customElementEventListenerMap = new WeakMap();

  function getWrappedCustomElementListener(elm, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    let customElementWrappedListener = customElementEventListenerMap.get(listener);

    if (isUndefined(customElementWrappedListener)) {
      customElementWrappedListener = function (event) {
        if (isValidEventForCustomElement(event)) {
          listener.call(elm, event);
        }
      };

      customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;

      {
        customElementWrappedListener.original = listener;
      }

      customElementEventListenerMap.set(listener, customElementWrappedListener);
    }

    return customElementWrappedListener;
  }

  function domListener(evt) {
    patchEvent(evt);
    let immediatePropagationStopped = false;
    let propagationStopped = false;
    const {
      type,
      stopImmediatePropagation,
      stopPropagation
    } = evt;
    const currentTarget = eventCurrentTargetGetter.call(evt);
    const listenerMap = getEventMap(currentTarget);
    const listeners = listenerMap[type];
    defineProperty(evt, 'stopImmediatePropagation', {
      value() {
        immediatePropagationStopped = true;
        stopImmediatePropagation.call(evt);
      },

      writable: true,
      enumerable: true,
      configurable: true
    });
    defineProperty(evt, 'stopPropagation', {
      value() {
        propagationStopped = true;
        stopPropagation.call(evt);
      },

      writable: true,
      enumerable: true,
      configurable: true
    });
    const bookkeeping = ArraySlice.call(listeners);

    function invokeListenersByPlacement(placement) {
      forEach.call(bookkeeping, listener => {
        if (isFalse$1(immediatePropagationStopped) && listener.placement === placement) {
          if (ArrayIndexOf.call(listeners, listener) !== -1) {
            listener.call(undefined, evt);
          }
        }
      });
    }

    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);

    if (isFalse$1(immediatePropagationStopped) && isFalse$1(propagationStopped)) {
      eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
      invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    }

    eventToContextMap.set(evt, 0);
  }

  function attachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let cmpEventHandlers = listenerMap[type];

    if (isUndefined(cmpEventHandlers)) {
      cmpEventHandlers = listenerMap[type] = [];
    }

    if (cmpEventHandlers.length === 0) {
      addEventListener.call(elm, type, domListener);
    }

    ArrayPush.call(cmpEventHandlers, wrappedListener);
  }

  function detachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let p;
    let listeners;

    if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
      ArraySplice.call(listeners, p, 1);

      if (listeners.length === 0) {
        removeEventListener.call(elm, type, domListener);
      }
    }
  }

  function isValidEventForCustomElement(event) {
    const target = eventTargetGetter.call(event);
    const currentTarget = eventCurrentTargetGetter.call(event);
    const {
      composed
    } = event;
    return composed === true || target === currentTarget || isChildNode(getRootNodeHost(target, GET_ROOT_NODE_CONFIG_FALSE), currentTarget);
  }

  function addCustomElementEventListener(elm, type, listener, _options) {
    {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for Element.addEventListener() in ${toString(elm)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }

    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    attachDOMListener(elm, type, wrappedListener);
  }

  function removeCustomElementEventListener(elm, type, listener, _options) {
    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    detachDOMListener(elm, type, wrappedListener);
  }

  function addShadowRootEventListener(sr, type, listener, _options) {
    {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for ShadowRoot.addEventListener() in ${toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }

    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    attachDOMListener(elm, type, wrappedListener);
  }

  function removeShadowRootEventListener(sr, type, listener, _options) {
    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    detachDOMListener(elm, type, wrappedListener);
  }

  function getTextContent(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          const childNodes = getFilteredChildNodes(node);
          let content = '';

          for (let i = 0, len = childNodes.length; i < len; i += 1) {
            const currentNode = childNodes[i];

            if (currentNode.nodeType !== COMMENT_NODE) {
              content += getTextContent(currentNode);
            }
          }

          return content;
        }

      default:
        return node.nodeValue;
    }
  }

  const Items = createHiddenField('StaticNodeListItems', 'synthetic-shadow');

  function StaticNodeList() {
    throw new TypeError('Illegal constructor');
  }

  StaticNodeList.prototype = create(NodeList.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticNodeList
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(index) {
        return this[index];
      }

    },
    length: {
      enumerable: true,
      configurable: true,

      get() {
        return getHiddenField(this, Items).length;
      }

    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items), cb, thisArg);
      }

    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items), (v, i) => [i, v]);
      }

    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items), (_v, i) => i);
      }

    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return getHiddenField(this, Items);
      }

    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,

      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = getHiddenField(this, Items);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }

    },
    [Symbol.toStringTag]: {
      configurable: true,

      get() {
        return 'NodeList';
      }

    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return '[object NodeList]';
      }

    }
  });
  setPrototypeOf(StaticNodeList, NodeList);

  function createStaticNodeList(items) {
    const nodeList = create(StaticNodeList.prototype);
    setHiddenField(nodeList, Items, items);
    forEach.call(items, (item, index) => {
      defineProperty(nodeList, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return nodeList;
  }

  const Items$1 = createHiddenField('StaticHTMLCollectionItems', 'synthetic-shadow');

  function StaticHTMLCollection() {
    throw new TypeError('Illegal constructor');
  }

  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticHTMLCollection
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(index) {
        return this[index];
      }

    },
    length: {
      enumerable: true,
      configurable: true,

      get() {
        return getHiddenField(this, Items$1).length;
      }

    },
    namedItem: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(name) {
        if (name === '') {
          return null;
        }

        const items = getHiddenField(this, Items$1);

        for (let i = 0, len = items.length; i < len; i++) {
          const item = items[len];

          if (name === getAttribute.call(item, 'id') || name === getAttribute.call(item, 'name')) {
            return item;
          }
        }

        return null;
      }

    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items$1), cb, thisArg);
      }

    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items$1), (v, i) => [i, v]);
      }

    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items$1), (v, i) => i);
      }

    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return getHiddenField(this, Items$1);
      }

    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,

      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = getHiddenField(this, Items$1);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }

    },
    [Symbol.toStringTag]: {
      configurable: true,

      get() {
        return 'HTMLCollection';
      }

    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return '[object HTMLCollection]';
      }

    }
  });
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);

  function createStaticHTMLCollection(items) {
    const collection = create(StaticHTMLCollection.prototype);
    setHiddenField(collection, Items$1, items);
    forEach.call(items, (item, index) => {
      defineProperty(collection, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return collection;
  }

  function getInnerHTML(node) {
    let s = '';
    const childNodes = getFilteredChildNodes(node);

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      s += getOuterHTML(childNodes[i]);
    }

    return s;
  }

  const escapeAttrRegExp = /[&\u00A0"]/g;
  const escapeDataRegExp = /[&\u00A0<>]/g;
  const {
    replace,
    toLowerCase
  } = String.prototype;

  function escapeReplace(c) {
    switch (c) {
      case '&':
        return '&amp;';

      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '"':
        return '&quot;';

      case '\u00A0':
        return '&nbsp;';

      default:
        return '';
    }
  }

  function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
  }

  function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
  }

  const voidElements = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);
  const plaintextParents = new Set(['STYLE', 'SCRIPT', 'XMP', 'IFRAME', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT', 'NOSCRIPT']);

  function getOuterHTML(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          const {
            attributes: attrs
          } = node;
          const tagName = tagNameGetter.call(node);
          let s = '<' + toLowerCase.call(tagName);

          for (let i = 0, attr; attr = attrs[i]; i++) {
            s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
          }

          s += '>';

          if (voidElements.has(tagName)) {
            return s;
          }

          return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
        }

      case TEXT_NODE:
        {
          const {
            data,
            parentNode
          } = node;

          if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {
            return data;
          }

          return escapeData(data);
        }

      case CDATA_SECTION_NODE:
        {
          return `<!CDATA[[${node.data}]]>`;
        }

      case PROCESSING_INSTRUCTION_NODE:
        {
          return `<?${node.target} ${node.data}?>`;
        }

      case COMMENT_NODE:
        {
          return `<!--${node.data}-->`;
        }

      default:
        {
          return '';
        }
    }
  }

  const InternalSlot = createHiddenField('shadowRecord', 'synthetic-shadow');
  const {
    createDocumentFragment
  } = document;

  function getInternalSlot(root) {
    const record = getHiddenField(root, InternalSlot);

    if (isUndefined(record)) {
      throw new TypeError();
    }

    return record;
  }

  const ShadowRootResolverKey = '$shadowResolver$';
  const ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
  defineProperty(Node.prototype, ShadowRootResolverKey, {
    set(fn) {
      this[ShadowResolverPrivateKey] = fn;
      setNodeOwnerKey(this, fn.nodeKey);
    },

    get() {
      return this[ShadowResolverPrivateKey];
    },

    configurable: true,
    enumerable: true
  });

  function getShadowRootResolver(node) {
    return node[ShadowRootResolverKey];
  }

  function setShadowRootResolver(node, fn) {
    node[ShadowRootResolverKey] = fn;
  }

  function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
  }

  function getHost(root) {
    return getInternalSlot(root).host;
  }

  function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
  }

  function isHostElement(elm) {
    return !isUndefined(getHiddenField(elm, InternalSlot));
  }

  let uid = 0;

  function attachShadow$1(elm, options) {
    if (!isUndefined(getHiddenField(elm, InternalSlot))) {
      throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }

    const {
      mode,
      delegatesFocus
    } = options;
    const doc = getOwnerDocument(elm);
    const sr = createDocumentFragment.call(doc);
    const record = {
      mode,
      delegatesFocus: !!delegatesFocus,
      host: elm,
      shadowRoot: sr
    };
    setHiddenField(sr, InternalSlot, record);
    setHiddenField(elm, InternalSlot, record);

    const shadowResolver = () => sr;

    const x = shadowResolver.nodeKey = uid++;
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
  }

  const SyntheticShadowRootDescriptors = {
    constructor: {
      writable: true,
      configurable: true,
      value: SyntheticShadowRoot
    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return `[object ShadowRoot]`;
      }

    }
  };
  const ShadowRootDescriptors = {
    activeElement: {
      enumerable: true,
      configurable: true,

      get() {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const activeElement = DocumentPrototypeActiveElement.call(doc);

        if (isNull(activeElement)) {
          return activeElement;
        }

        if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
          return null;
        }

        let node = activeElement;

        while (!isNodeOwnedBy(host, node)) {
          node = parentElementGetter.call(node);
        }

        if (isSlotElement(node)) {
          return null;
        }

        return node;
      }

    },
    delegatesFocus: {
      configurable: true,

      get() {
        return getInternalSlot(this).delegatesFocus;
      }

    },
    elementFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(left, top) {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const element = elementFromPoint.call(doc, left, top);

        if (isNull(element)) {
          return element;
        }

        return retarget(this, pathComposer(element, true));
      }

    },
    elementsFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(_left, _top) {
        throw new Error();
      }

    },
    getSelection: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        throw new Error();
      }

    },
    host: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this);
      }

    },
    mode: {
      configurable: true,

      get() {
        return getInternalSlot(this).mode;
      }

    },
    styleSheets: {
      enumerable: true,
      configurable: true,

      get() {
        throw new Error();
      }

    }
  };
  const NodePatchDescriptors = {
    insertBefore: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild, refChild) {
        insertBefore.call(getHost(this), newChild, refChild);
        return newChild;
      }

    },
    removeChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(oldChild) {
        removeChild.call(getHost(this), oldChild);
        return oldChild;
      }

    },
    appendChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild) {
        appendChild.call(getHost(this), newChild);
        return newChild;
      }

    },
    replaceChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild, oldChild) {
        replaceChild.call(getHost(this), newChild, oldChild);
        return oldChild;
      }

    },
    addEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(type, listener, options) {
        addShadowRootEventListener(this, type, listener);
      }

    },
    removeEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(type, listener, options) {
        removeShadowRootEventListener(this, type, listener);
      }

    },
    baseURI: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this).baseURI;
      }

    },
    childNodes: {
      enumerable: true,
      configurable: true,

      get() {
        return createStaticNodeList(shadowRootChildNodes(this));
      }

    },
    compareDocumentPosition: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(otherNode) {
        const host = getHost(this);

        if (this === otherNode) {
          return 0;
        } else if (this.contains(otherNode)) {
          return 20;
        } else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
          return 37;
        } else {
          return 35;
        }
      }

    },
    contains: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(otherNode) {
        if (this === otherNode) {
          return true;
        }

        const host = getHost(this);
        return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
      }

    },
    firstChild: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[0] || null;
      }

    },
    lastChild: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[childNodes.length - 1] || null;
      }

    },
    hasChildNodes: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        const childNodes = getInternalChildNodes(this);
        return childNodes.length > 0;
      }

    },
    isConnected: {
      enumerable: true,
      configurable: true,

      get() {
        return isConnected.call(getHost(this));
      }

    },
    nextSibling: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    previousSibling: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    nodeName: {
      enumerable: true,
      configurable: true,

      get() {
        return '#document-fragment';
      }

    },
    nodeType: {
      enumerable: true,
      configurable: true,

      get() {
        return 11;
      }

    },
    nodeValue: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    ownerDocument: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this).ownerDocument;
      }

    },
    parentElement: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    parentNode: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    textContent: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        let textContent = '';

        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];

          if (currentNode.nodeType !== COMMENT_NODE) {
            textContent += getTextContent(currentNode);
          }
        }

        return textContent;
      },

      set(v) {
        const host = getHost(this);
        textContextSetter.call(host, v);
      }

    },
    getRootNode: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(options) {
        return !isUndefined(options) && isTrue$1(options.composed) ? getHost(this).getRootNode(options) : this;
      }

    }
  };
  const ElementPatchDescriptors = {
    innerHTML: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        let innerHTML = '';

        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
        }

        return innerHTML;
      },

      set(v) {
        const host = getHost(this);
        innerHTMLSetter.call(host, v);
      }

    }
  };
  const ParentNodePatchDescriptors = {
    childElementCount: {
      enumerable: true,
      configurable: true,

      get() {
        return this.children.length;
      }

    },
    children: {
      enumerable: true,
      configurable: true,

      get() {
        return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), elm => elm instanceof Element));
      }

    },
    firstElementChild: {
      enumerable: true,
      configurable: true,

      get() {
        return this.children[0] || null;
      }

    },
    lastElementChild: {
      enumerable: true,
      configurable: true,

      get() {
        const {
          children
        } = this;
        return children.item(children.length - 1) || null;
      }

    },
    querySelector: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(selectors) {
        return shadowRootQuerySelector(this, selectors);
      }

    },
    querySelectorAll: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(selectors) {
        return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
      }

    }
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);

  function SyntheticShadowRoot() {
    throw new TypeError('Illegal constructor');
  }

  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);

  function getIE11FakeShadowRootPlaceholder(host) {
    const shadowRoot = getShadowRoot(host);
    let c = shadowRoot.$$placeholder$$;

    if (!isUndefined(c)) {
      return c;
    }

    const doc = getOwnerDocument(host);
    c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
    defineProperties(c, {
      childNodes: {
        get() {
          return shadowRoot.childNodes;
        },

        enumerable: true,
        configurable: true
      },
      tagName: {
        get() {
          return `#shadow-root (${shadowRoot.mode})`;
        },

        enumerable: true,
        configurable: true
      }
    });
    return c;
  }

  function foldSlotElement(slot) {
    let parent = parentElementGetter.call(slot);

    while (!isNull(parent) && isSlotElement(parent)) {
      slot = parent;
      parent = parentElementGetter.call(slot);
    }

    return slot;
  }

  function isNodeSlotted(host, node) {
    {
      assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
      assert.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
    }

    const hostKey = getNodeKey(host);
    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);

    while (!isNull(currentElement) && currentElement !== host) {
      const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
      const parent = parentElementGetter.call(currentElement);

      if (elmOwnerKey === hostKey) {
        return isSlotElement(currentElement);
      } else if (parent === host) {
        return false;
      } else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
        if (isSlotElement(parent)) {
          currentElement = getNodeOwner(foldSlotElement(parent));

          if (!isNull(currentElement)) {
            if (currentElement === host) {
              return true;
            } else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        currentElement = parent;
      }
    }

    return false;
  }

  function getNodeOwner(node) {
    if (!(node instanceof Node)) {
      return null;
    }

    const ownerKey = getNodeNearestOwnerKey(node);

    if (isUndefined(ownerKey)) {
      return null;
    }

    let nodeOwner = node;

    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
      nodeOwner = parentNodeGetter.call(nodeOwner);
    }

    if (isNull(nodeOwner)) {
      return null;
    }

    return nodeOwner;
  }

  function isSlotElement(node) {
    return node instanceof HTMLSlotElement;
  }

  function isNodeOwnedBy(owner, node) {
    {
      assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
      assert.invariant(node instanceof Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
    }

    const ownerKey = getNodeNearestOwnerKey(node);
    return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
  }

  function shadowRootChildNodes(root) {
    const elm = getHost(root);
    return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }

  function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];

    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }

  function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        return node;
      }
    }

    return null;
  }

  function getAllMatches(owner, nodeList) {
    const filteredAndPatched = [];

    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      const isOwned = isNodeOwnedBy(owner, node);

      if (isOwned) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }

  function getFirstMatch(owner, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      if (isNodeOwnedBy(owner, nodeList[i])) {
        return nodeList[i];
      }
    }

    return null;
  }

  function shadowRootQuerySelector(root, selector) {
    const elm = getHost(root);
    const nodeList = arrayFromCollection(querySelectorAll.call(elm, selector));
    return getFirstMatch(elm, nodeList);
  }

  function shadowRootQuerySelectorAll(root, selector) {
    const elm = getHost(root);
    const nodeList = querySelectorAll.call(elm, selector);
    return getAllMatches(elm, arrayFromCollection(nodeList));
  }

  function getFilteredChildNodes(node) {
    let children;

    if (!isHostElement(node) && !isSlotElement(node)) {
      children = childNodesGetter.call(node);
      return arrayFromCollection(children);
    }

    if (isHostElement(node)) {
      const slots = arrayFromCollection(querySelectorAll.call(node, 'slot'));
      const resolver = getShadowRootResolver(getShadowRoot(node));
      return ArrayReduce.call(slots, (seed, slot) => {
        if (resolver === getShadowRootResolver(slot)) {
          ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
        }

        return seed;
      }, []);
    } else {
      children = arrayFromCollection(childNodesGetter.call(node));
      const resolver = getShadowRootResolver(node);
      return ArrayReduce.call(children, (seed, child) => {
        if (resolver === getShadowRootResolver(child)) {
          ArrayPush.call(seed, child);
        }

        return seed;
      }, []);
    }
  }

  function getFilteredSlotAssignedNodes(slot) {
    const owner = getNodeOwner(slot);

    if (isNull(owner)) {
      return [];
    }

    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (!isNodeOwnedBy(owner, child)) {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  const OwnKey = '$$OwnKey$$';
  const OwnerKey = '$$OwnerKey$$';
  const hasNativeSymbolsSupport$2 = Symbol('x').toString() === 'Symbol(x)';

  function getNodeOwnerKey(node) {
    return node[OwnerKey];
  }

  function setNodeOwnerKey(node, value) {
    {
      defineProperty(node, OwnerKey, {
        value,
        configurable: true
      });
    }
  }

  function getNodeKey(node) {
    return node[OwnKey];
  }

  function setNodeKey(node, value) {
    {
      defineProperty(node, OwnKey, {
        value
      });
    }
  }

  function getNodeNearestOwnerKey(node) {
    let ownerNode = node;
    let ownerKey;

    while (!isNull(ownerNode)) {
      ownerKey = getNodeOwnerKey(ownerNode);

      if (!isUndefined(ownerKey)) {
        return ownerKey;
      }

      ownerNode = parentNodeGetter.call(ownerNode);
    }
  }

  function isNodeShadowed(node) {
    return !isUndefined(getNodeOwnerKey(node));
  }

  function isNodeDeepShadowed(node) {
    return !isUndefined(getNodeNearestOwnerKey(node));
  }

  function hasMountedChildren(node) {
    return isSlotElement(node) || isHostElement(node);
  }

  function getShadowParent(node, value) {
    const owner = getNodeOwner(node);

    if (value === owner) {
      return getShadowRoot(owner);
    } else if (value instanceof Element) {
      if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
        return value;
      } else if (!isNull(owner) && isSlotElement(value)) {
        const slotOwner = getNodeOwner(value);

        if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
          return slotOwner;
        }
      }
    }

    return null;
  }

  function hasChildNodesPatched() {
    return getInternalChildNodes(this).length > 0;
  }

  function firstChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[0] || null;
  }

  function lastChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[childNodes.length - 1] || null;
  }

  function textContentGetterPatched() {
    return getTextContent(this);
  }

  function textContentSetterPatched(value) {
    textContextSetter.call(this, value);
  }

  function parentNodeGetterPatched() {
    const value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return value;
    }

    return getShadowParent(this, value);
  }

  function parentElementGetterPatched() {
    const value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return null;
    }

    const parentNode = getShadowParent(this, value);
    return parentNode instanceof Element ? parentNode : null;
  }

  function compareDocumentPositionPatched(otherNode) {
    if (this.getRootNode() === otherNode) {
      return 10;
    } else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return 35;
    }

    return compareDocumentPosition.call(this, otherNode);
  }

  function containsPatched(otherNode) {
    if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return false;
    }

    return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }

  function cloneNodePatched(deep) {
    const clone = cloneNode.call(this, false);

    if (!deep) {
      return clone;
    }

    const childNodes = getInternalChildNodes(this);

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      clone.appendChild(childNodes[i].cloneNode(true));
    }

    return clone;
  }

  function childNodesGetterPatched() {
    if (this instanceof Element && isHostElement(this)) {
      const owner = getNodeOwner(this);
      const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));

      if ( isFalse$1(hasNativeSymbolsSupport$2) && isExternalChildNodeAccessorFlagOn()) {
        ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
      }

      return createStaticNodeList(childNodes);
    }

    return childNodesGetter.call(this);
  }

  const nativeGetRootNode = Node.prototype.getRootNode;
  const getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function () {
    let node = this;
    let nodeParent;

    while (!isNull(nodeParent = parentNodeGetter.call(node))) {
      node = nodeParent;
    }

    return node;
  };

  function getNearestRoot(node) {
    const ownerNode = getNodeOwner(node);

    if (isNull(ownerNode)) {
      return getDocumentOrRootNode.call(node);
    }

    return getShadowRoot(ownerNode);
  }

  function getRootNodePatched(options) {
    const composed = isUndefined(options) ? false : !!options.composed;
    return isTrue$1(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }

  defineProperties(Node.prototype, {
    firstChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstChildGetterPatched.call(this);
        }

        return firstChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    lastChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastChildGetterPatched.call(this);
        }

        return lastChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    textContent: {
      get() {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return textContentGetterPatched.call(this);
          }

          return textContentGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return textContentGetter.call(this);
        }

        return textContentGetterPatched.call(this);
      },

      set: textContentSetterPatched,
      enumerable: true,
      configurable: true
    },
    parentNode: {
      get() {
        if (isNodeShadowed(this)) {
          return parentNodeGetterPatched.call(this);
        }

        return parentNodeGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    parentElement: {
      get() {
        if (isNodeShadowed(this)) {
          return parentElementGetterPatched.call(this);
        }

        return parentElementGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (hasMountedChildren(this)) {
          return childNodesGetterPatched.call(this);
        }

        return childNodesGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    hasChildNodes: {
      value() {
        if (hasMountedChildren(this)) {
          return hasChildNodesPatched.call(this);
        }

        return hasChildNodes.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    compareDocumentPosition: {
      value(otherNode) {
        if (isGlobalPatchingSkipped(this)) {
          return compareDocumentPosition.call(this, otherNode);
        }

        return compareDocumentPositionPatched.call(this, otherNode);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    contains: {
      value(otherNode) {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (otherNode == null) {
            return false;
          }

          if (isNodeShadowed(this) || isHostElement(this)) {
            return containsPatched.call(this, otherNode);
          }

          return contains.call(this, otherNode);
        }

        if (isGlobalPatchingSkipped(this)) {
          return contains.call(this, otherNode);
        }

        return containsPatched.call(this, otherNode);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    cloneNode: {
      value(deep) {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return cloneNodePatched.call(this, deep);
          }

          return cloneNode.call(this, deep);
        }

        if (isTrue$1(deep)) {
          if (isGlobalPatchingSkipped(this)) {
            return cloneNode.call(this, deep);
          }

          return cloneNodePatched.call(this, deep);
        }

        return cloneNode.call(this, deep);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    getRootNode: {
      value: getRootNodePatched,
      enumerable: true,
      configurable: true,
      writable: true
    },
    isConnected: {
      enumerable: true,
      configurable: true,

      get() {
        return isConnected.call(this);
      }

    }
  });
  let internalChildNodeAccessorFlag = false;

  function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
  }

  const getInternalChildNodes =  isFalse$1(hasNativeSymbolsSupport$2) ? function (node) {
    internalChildNodeAccessorFlag = true;
    let childNodes;
    let error = null;

    try {
      childNodes = node.childNodes;
    } catch (e) {
      error = e;
    } finally {
      internalChildNodeAccessorFlag = false;

      if (!isNull(error)) {
        throw error;
      }
    }

    return childNodes;
  } : function (node) {
    return node.childNodes;
  };

  if (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {
    defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(Node.prototype, 'contains'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {
    defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(Node.prototype, 'parentElement'));
  }

  function elemFromPoint(left, top) {
    const element = elementFromPoint.call(this, left, top);

    if (isNull(element)) {
      return element;
    }

    return retarget(this, pathComposer(element, true));
  }

  Document.prototype.elementFromPoint = elemFromPoint;
  defineProperty(Document.prototype, 'activeElement', {
    get() {
      let node = DocumentPrototypeActiveElement.call(this);

      if (isNull(node)) {
        return node;
      }

      while (!isUndefined(getNodeOwnerKey(node))) {
        node = parentElementGetter.call(node);

        if (isNull(node)) {
          return null;
        }
      }

      if (node.tagName === 'HTML') {
        node = this.body;
      }

      return node;
    },

    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementById', {
    value() {
      const elm = getElementById.apply(this, ArraySlice.call(arguments));

      if (isNull(elm)) {
        return null;
      }

      return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelector', {
    value() {
      const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFind.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return !isUndefined(filtered) ? filtered : null;
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelectorAll', {
    value() {
      const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByClassName', {
    value() {
      const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagName', {
    value() {
      const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagNameNS', {
    value() {
      const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName') ? HTMLDocument.prototype : Document.prototype, 'getElementsByName', {
    value() {
      const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(window, 'ShadowRoot', {
    value: SyntheticShadowRoot,
    configurable: true,
    writable: true
  });

  function doesEventNeedsPatch(e) {
    const originalTarget = eventTargetGetter.call(e);
    return originalTarget instanceof Node && isNodeDeepShadowed(originalTarget);
  }

  function isValidEventListener(listener) {
    return isFunction(listener) || !isNull(listener) && isObject(listener) && isFunction(listener.handleEvent);
  }

  function getEventListenerWrapper(listener) {
    if ('$$lwcEventWrapper$$' in listener) {
      return listener.$$lwcEventWrapper$$;
    }

    const isHandlerFunction = isFunction(listener);

    const wrapperFn = listener.$$lwcEventWrapper$$ = function (e) {
      if (doesEventNeedsPatch(e)) {
        patchEvent(e);
      }

      return isHandlerFunction ? listener.call(this, e) : listener.handleEvent && listener.handleEvent(e);
    };

    return wrapperFn;
  }

  function windowAddEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function windowRemoveEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    windowRemoveEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  function addEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    addEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function removeEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    removeEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  window.addEventListener = windowAddEventListener$1;
  window.removeEventListener = windowRemoveEventListener$1;
  const protoToBePatched = typeof EventTarget !== 'undefined' ? EventTarget.prototype : Node.prototype;
  defineProperties(protoToBePatched, {
    addEventListener: {
      value: addEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: removeEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');

  function detect$1() {
    if (!composedDescriptor) {
      return false;
    }

    let clickEvent = new Event('click');
    const button = document.createElement('button');
    button.addEventListener('click', event => clickEvent = event);
    button.click();
    return !composedDescriptor.get.call(clickEvent);
  }

  const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');

  function handleClick(event) {
    Object.defineProperty(event, 'composed', {
      configurable: true,
      enumerable: true,

      get() {
        return true;
      }

    });
  }

  function apply$1() {
    HTMLElement.prototype.click = function () {
      addEventListener.call(this, 'click', handleClick);

      try {
        originalClickDescriptor.value.call(this);
      } finally {
        removeEventListener.call(this, 'click', handleClick);
      }
    };
  }

  if (detect$1()) {
    apply$1();
  }

  function detect$2() {
    return new Event('test', {
      composed: true
    }).composed !== true;
  }

  function apply$2() {
    const composedEvents = assign(create(null), {
      blur: 1,
      focus: 1,
      focusin: 1,
      focusout: 1,
      click: 1,
      dblclick: 1,
      mousedown: 1,
      mouseenter: 1,
      mouseleave: 1,
      mousemove: 1,
      mouseout: 1,
      mouseover: 1,
      mouseup: 1,
      wheel: 1,
      beforeinput: 1,
      input: 1,
      keydown: 1,
      keyup: 1,
      compositionstart: 1,
      compositionupdate: 1,
      compositionend: 1,
      touchstart: 1,
      touchend: 1,
      touchmove: 1,
      touchcancel: 1,
      pointerover: 1,
      pointerenter: 1,
      pointerdown: 1,
      pointermove: 1,
      pointerup: 1,
      pointercancel: 1,
      pointerout: 1,
      pointerleave: 1,
      gotpointercapture: 1,
      lostpointercapture: 1,
      dragstart: 1,
      drag: 1,
      dragenter: 1,
      dragleave: 1,
      dragover: 1,
      drop: 1,
      dragend: 1,
      DOMActivate: 1,
      DOMFocusIn: 1,
      DOMFocusOut: 1,
      keypress: 1
    });
    const EventConstructor = Event;

    function PatchedEvent(type, eventInitDict) {
      const event = new EventConstructor(type, eventInitDict);
      const isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
        composed: {
          get() {
            return isComposed;
          },

          configurable: true,
          enumerable: true
        }
      });
      return event;
    }

    PatchedEvent.prototype = EventConstructor.prototype;
    PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;
    PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;
    PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;
    PatchedEvent.NONE = EventConstructor.NONE;
    window.Event = PatchedEvent;
    Object.defineProperties(Event.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return composedEvents[type] === 1;
        },

        configurable: true,
        enumerable: true
      }
    });
  }

  if (detect$2()) {
    apply$2();
  }

  const CustomEventConstructor = CustomEvent;

  function PatchedCustomEvent(type, eventInitDict) {
    const event = new CustomEventConstructor(type, eventInitDict);
    const isComposed = !!(eventInitDict && eventInitDict.composed);
    Object.defineProperties(event, {
      composed: {
        get() {
          return isComposed;
        },

        configurable: true,
        enumerable: true
      }
    });
    return event;
  }

  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;
  const originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed').get;
  Object.defineProperties(FocusEvent.prototype, {
    composed: {
      get() {
        const {
          isTrusted
        } = this;
        const composed = originalComposedGetter.call(this);

        if (isTrusted && composed === false) {
          return true;
        }

        return composed;
      },

      enumerable: true,
      configurable: true
    }
  });

  function detect$3() {
    return typeof HTMLIFrameElement !== 'undefined';
  }

  function apply$3() {
    const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
    const {
      get: originalGetter
    } = desc;

    desc.get = function () {
      const original = originalGetter.call(this);

      if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
        return original;
      }

      return wrapIframeWindow(original);
    };

    defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
  }

  function wrapIframeWindow(win) {
    return {
      addEventListener() {
        return win.addEventListener.apply(win, arguments);
      },

      blur() {
        return win.blur.apply(win, arguments);
      },

      close() {
        return win.close.apply(win, arguments);
      },

      focus() {
        return win.focus.apply(win, arguments);
      },

      postMessage() {
        return win.postMessage.apply(win, arguments);
      },

      removeEventListener() {
        return win.removeEventListener.apply(win, arguments);
      },

      get closed() {
        return win.closed;
      },

      get frames() {
        return win.frames;
      },

      get length() {
        return win.length;
      },

      get location() {
        return win.location;
      },

      set location(value) {
        win.location = value;
      },

      get opener() {
        return win.opener;
      },

      get parent() {
        return win.parent;
      },

      get self() {
        return win.self;
      },

      get top() {
        return win.top;
      },

      get window() {
        return win.window;
      }

    };
  }

  if (detect$3()) {
    apply$3();
  }

  const OriginalMutationObserver = MutationObserver;
  const {
    disconnect: originalDisconnect,
    observe: originalObserve,
    takeRecords: originalTakeRecords
  } = OriginalMutationObserver.prototype;
  const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
  const observerLookupField = '$$lwcNodeObservers$$';
  const observerToNodesMap = new WeakMap();

  function getNodeObservers(node) {
    return node[observerLookupField];
  }

  function setNodeObservers(node, observers) {
    node[observerLookupField] = observers;
  }

  function retargetMutationRecord(originalRecord) {
    const {
      addedNodes,
      removedNodes,
      target,
      type
    } = originalRecord;
    const retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
      addedNodes: {
        get() {
          return addedNodes;
        },

        enumerable: true,
        configurable: true
      },
      removedNodes: {
        get() {
          return removedNodes;
        },

        enumerable: true,
        configurable: true
      },
      type: {
        get() {
          return type;
        },

        enumerable: true,
        configurable: true
      },
      target: {
        get() {
          return target.shadowRoot;
        },

        enumerable: true,
        configurable: true
      }
    });
    return retargetedRecord;
  }

  function isQualifiedObserver(observer, target) {
    let parentNode = target;

    while (!isNull(parentNode)) {
      const parentNodeObservers = getNodeObservers(parentNode);

      if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer || ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
        return true;
      }

      parentNode = parentNode.parentNode;
    }

    return false;
  }

  function filterMutationRecords(mutations, observer) {
    return ArrayReduce.call(mutations, (filteredSet, record) => {
      const {
        target,
        addedNodes,
        removedNodes,
        type
      } = record;

      if (type === 'childList' && !isUndefined(getNodeKey(target))) {
        if (addedNodes.length > 0) {
          const sampleNode = addedNodes[0];

          if (isQualifiedObserver(observer, sampleNode)) {
            const nodeObservers = getNodeObservers(target);

            if (nodeObservers && (nodeObservers[0] === observer || ArrayIndexOf.call(nodeObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, record);
            } else {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        } else {
          const shadowRoot = target.shadowRoot;
          const sampleNode = removedNodes[0];

          if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && isQualifiedObserver(observer, target)) {
            ArrayPush.call(filteredSet, record);
          } else if (shadowRoot) {
            const shadowRootObservers = getNodeObservers(shadowRoot);

            if (shadowRootObservers && (shadowRootObservers[0] === observer || ArrayIndexOf.call(shadowRootObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        }
      } else {
        if (isQualifiedObserver(observer, target)) {
          ArrayPush.call(filteredSet, record);
        }
      }

      return filteredSet;
    }, []);
  }

  function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];

    if (isUndefined(wrappedCallback)) {
      wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
        const filteredRecords = filterMutationRecords(mutations, observer);

        if (filteredRecords.length === 0) {
          return;
        }

        callback.call(observer, filteredRecords, observer);
      };
    }

    return wrappedCallback;
  }

  function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer = new OriginalMutationObserver(wrappedCallback);
    return observer;
  }

  function patchedDisconnect() {
    originalDisconnect.call(this);
    const observedNodes = observerToNodesMap.get(this);

    if (!isUndefined(observedNodes)) {
      forEach.call(observedNodes, observedNode => {
        const observers = observedNode[observerLookupField];

        if (!isUndefined(observers)) {
          const index = ArrayIndexOf.call(observers, this);

          if (index !== -1) {
            ArraySplice.call(observers, index, 1);
          }
        }
      });
      observedNodes.length = 0;
    }
  }

  function patchedObserve(target, options) {
    let targetObservers = getNodeObservers(target);

    if (isUndefined(targetObservers)) {
      targetObservers = [];
      setNodeObservers(target, targetObservers);
    }

    if (ArrayIndexOf.call(targetObservers, this) === -1) {
      ArrayPush.call(targetObservers, this);
    }

    if (target instanceof SyntheticShadowRoot) {
      target = target.host;
    }

    if (observerToNodesMap.has(this)) {
      const observedNodes = observerToNodesMap.get(this);

      if (ArrayIndexOf.call(observedNodes, target) === -1) {
        ArrayPush.call(observedNodes, target);
      }
    } else {
      observerToNodesMap.set(this, [target]);
    }

    return originalObserve.call(this, target, options);
  }

  function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
  }

  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, 'MutationObserver', {
    value: PatchedMutationObserver,
    configurable: true,
    writable: true
  });
  let observer;
  const observerConfig = {
    childList: true
  };
  const SlotChangeKey = createHiddenField('slotchange', 'synthetic-shadow');

  function initSlotObserver() {
    return new MO(mutations => {
      const slots = [];
      forEach.call(mutations, mutation => {
        {
          assert.invariant(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
        }

        const {
          target: slot
        } = mutation;

        if (ArrayIndexOf.call(slots, slot) === -1) {
          ArrayPush.call(slots, slot);
          dispatchEvent.call(slot, new CustomEvent('slotchange'));
        }
      });
    });
  }

  function getFilteredSlotFlattenNodes(slot) {
    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (child instanceof Element && isSlotElement(child)) {
        ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
      } else {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  function assignedSlotGetterPatched() {
    const parentNode = parentNodeGetter.call(this);

    if (isNull(parentNode) || !isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
      return null;
    }

    return parentNode;
  }

  defineProperties(HTMLSlotElement.prototype, {
    addEventListener: {
      value(type, listener, options) {
        HTMLElement.prototype.addEventListener.call(this, type, listener, options);

        if (type === 'slotchange' && !getHiddenField(this, SlotChangeKey)) {
          setHiddenField(this, SlotChangeKey, true);

          if (!observer) {
            observer = initSlotObserver();
          }

          MutationObserverObserve.call(observer, this, observerConfig);
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedElements: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue$1(options.flatten);
          const nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
          return ArrayFilter.call(nodes, node => node instanceof Element);
        } else {
          return assignedElements.apply(this, ArraySlice.call(arguments));
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedNodes: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue$1(options.flatten);
          return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        } else {
          return assignedNodes.apply(this, ArraySlice.call(arguments));
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    name: {
      get() {
        const name = getAttribute.call(this, 'name');
        return isNull(name) ? '' : name;
      },

      set(value) {
        setAttribute.call(this, 'name', value);
      },

      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (isNodeShadowed(this)) {
          const owner = getNodeOwner(this);
          const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
          return createStaticNodeList(childNodes);
        }

        return childNodesGetter.call(this);
      },

      enumerable: true,
      configurable: true
    }
  });
  defineProperties(Text.prototype, {
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
    let filtered;
    const ownerKey = getNodeOwnerKey(context);

    if (!isUndefined(ownerKey)) {
      if (isHostElement(context)) {
        const owner = getNodeOwner(context);

        if (isNull(owner)) {
          filtered = [];
        } else if (getNodeKey(context)) {
          filtered = getAllSlottedMatches(context, unfilteredNodes);
        } else {
          filtered = getAllMatches(owner, unfilteredNodes);
        }
      } else {
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
      }
    } else if (context instanceof HTMLBodyElement) {
      filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }

    return filtered;
  }

  var ShadowDomSemantic;

  (function (ShadowDomSemantic) {
    ShadowDomSemantic[ShadowDomSemantic["Disabled"] = 0] = "Disabled";
    ShadowDomSemantic[ShadowDomSemantic["Enabled"] = 1] = "Enabled";
  })(ShadowDomSemantic || (ShadowDomSemantic = {}));

  function innerHTMLGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    let innerHTML = '';

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      innerHTML += getOuterHTML(childNodes[i]);
    }

    return innerHTML;
  }

  function outerHTMLGetterPatched() {
    return getOuterHTML(this);
  }

  function attachShadowPatched(options) {
    if (isTrue$1(options['$$lwc-synthetic-mode$$'])) {
      return attachShadow$1(this, options);
    } else {
      return attachShadow.call(this, options);
    }
  }

  function shadowRootGetterPatched() {
    if (isHostElement(this)) {
      const shadow = getShadowRoot(this);

      if (shadow.mode === 'open') {
        return shadow;
      }
    }

    return shadowRootGetter.call(this);
  }

  function childrenGetterPatched() {
    const owner = getNodeOwner(this);
    const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
    return createStaticHTMLCollection(ArrayFilter.call(childNodes, node => node instanceof Element));
  }

  function childElementCountGetterPatched() {
    return this.children.length;
  }

  function firstElementChildGetterPatched() {
    return this.children[0] || null;
  }

  function lastElementChildGetterPatched() {
    const {
      children
    } = this;
    return children.item(children.length - 1) || null;
  }

  defineProperties(Element.prototype, {
    innerHTML: {
      get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return innerHTMLGetterPatched.call(this);
          }

          return innerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return innerHTMLGetter.call(this);
        }

        return innerHTMLGetterPatched.call(this);
      },

      set(v) {
        innerHTMLSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    outerHTML: {
      get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return outerHTMLGetterPatched.call(this);
          }

          return outerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return outerHTMLGetter.call(this);
        }

        return outerHTMLGetterPatched.call(this);
      },

      set(v) {
        outerHTMLSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    attachShadow: {
      value: attachShadowPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    shadowRoot: {
      get: shadowRootGetterPatched,
      enumerable: true,
      configurable: true
    },
    children: {
      get() {
        if (hasMountedChildren(this)) {
          return childrenGetterPatched.call(this);
        }

        return childrenGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    childElementCount: {
      get() {
        if (hasMountedChildren(this)) {
          return childElementCountGetterPatched.call(this);
        }

        return childElementCountGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    firstElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstElementChildGetterPatched.call(this);
        }

        return firstElementChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    lastElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastElementChildGetterPatched.call(this);
        }

        return lastElementChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  if (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {
    defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {
    defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'children')) {
    defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));
  }

  function querySelectorPatched() {
    const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

    if (isHostElement(this)) {
      const owner = getNodeOwner(this);

      if (isNull(owner)) {
        return null;
      } else if (getNodeKey(this)) {
        return getFirstSlottedMatch(this, nodeList);
      } else {
        return getFirstMatch(owner, nodeList);
      }
    } else if (isNodeShadowed(this)) {
      const ownerKey = getNodeOwnerKey(this);

      if (!isUndefined(ownerKey)) {
        const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === ownerKey);
        return isUndefined(elm) ? null : elm;
      } else {
        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          return nodeList.length === 0 ? null : nodeList[0];
        }

        const contextNearestOwnerKey = getNodeNearestOwnerKey(this);
        const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
        return isUndefined(elm) ? null : elm;
      }
    } else {
      if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
        if (!(this instanceof HTMLBodyElement)) {
          const elm = nodeList[0];
          return isUndefined(elm) ? null : elm;
        }
      }

      const elm = ArrayFind.call(nodeList, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(this));
      return isUndefined(elm) ? null : elm;
    }
  }

  function getFilteredArrayOfNodes(context, unfilteredNodes, shadowDomSemantic) {
    let filtered;

    if (isHostElement(context)) {
      const owner = getNodeOwner(context);

      if (isNull(owner)) {
        filtered = [];
      } else if (getNodeKey(context)) {
        filtered = getAllSlottedMatches(context, unfilteredNodes);
      } else {
        filtered = getAllMatches(owner, unfilteredNodes);
      }
    } else if (isNodeShadowed(context)) {
      const ownerKey = getNodeOwnerKey(context);

      if (!isUndefined(ownerKey)) {
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
      } else if (shadowDomSemantic === ShadowDomSemantic.Enabled) {
        const contextNearestOwnerKey = getNodeNearestOwnerKey(context);
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    } else {
      if (context instanceof HTMLBodyElement || shadowDomSemantic === ShadowDomSemantic.Enabled) {
        filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    }

    return filtered;
  }

  defineProperties(Element.prototype, {
    querySelector: {
      value: querySelectorPatched,
      writable: true,
      enumerable: true,
      configurable: true
    },
    querySelectorAll: {
      value() {
        const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          const filteredResults = getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Disabled);
          return createStaticNodeList(filteredResults);
        }

        return createStaticNodeList(getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Enabled));
      },

      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  {
    defineProperties(Element.prototype, {
      getElementsByClassName: {
        value() {
          const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagName: {
        value() {
          const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagNameNS: {
        value() {
          const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      }
    });
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {
    defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));
  }

  const TabbableElementsQuery = `
    button:not([tabindex="-1"]):not([disabled]),
    [contenteditable]:not([tabindex="-1"]),
    video[controls]:not([tabindex="-1"]),
    audio[controls]:not([tabindex="-1"]),
    [href]:not([tabindex="-1"]),
    input:not([tabindex="-1"]):not([disabled]),
    select:not([tabindex="-1"]):not([disabled]),
    textarea:not([tabindex="-1"]):not([disabled]),
    [tabindex="0"]
`;
  const DidAddMouseDownListener = createHiddenField('DidAddMouseDownListener', 'synthetic-shadow');

  function isVisible(element) {
    const {
      width,
      height
    } = getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
  }

  function isTabbable(element) {
    return matches.call(element, TabbableElementsQuery) && isVisible(element);
  }

  function getTabbableSegments(host) {
    const doc = getOwnerDocument(host);
    const all = arrayFromCollection(querySelectorAll$1.call(doc, TabbableElementsQuery));
    const inner = arrayFromCollection(querySelectorAll.call(host, TabbableElementsQuery));

    {
      assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
    }

    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = ArrayIndexOf.call(all, host);
    const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
    const prev = ArraySlice.call(all, 0, firstChildIndex);
    const next = ArraySlice.call(all, lastChildIndex);
    return {
      prev,
      inner,
      next
    };
  }

  function getActiveElement(host) {
    const doc = getOwnerDocument(host);
    const activeElement = DocumentPrototypeActiveElement.call(doc);

    if (isNull(activeElement)) {
      return activeElement;
    }

    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
  }

  function relatedTargetPosition(host, relatedTarget) {
    const pos = compareDocumentPosition.call(host, relatedTarget);

    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
      return 0;
    } else if (pos & DOCUMENT_POSITION_PRECEDING) {
      return 1;
    } else if (pos & DOCUMENT_POSITION_FOLLOWING) {
      return 2;
    }

    return -1;
  }

  function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, 'focusin', muteEvent, true);
    windowAddEventListener.call(win, 'focusout', muteEvent, true);
    func();
    windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
    windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
  }

  function focusOnNextOrBlur(segment, target, relatedTarget) {
    const win = getOwnerWindow(relatedTarget);
    const next = getNextTabbable(segment, relatedTarget);

    if (isNull(next)) {
      muteFocusEventsDuringExecution(win, () => {
        target.blur();
      });
    } else {
      muteFocusEventsDuringExecution(win, () => {
        next.focus();
      });
    }
  }

  let letBrowserHandleFocus = false;

  function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
  }

  function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
  }

  function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    const host = eventCurrentTargetGetter.call(event);
    const target = eventTargetGetter.call(event);

    if (host !== target) {
      return;
    }

    const relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
      const first = ArrayFind.call(segments.inner, findTabbableElms);

      if (!isUndefined(first)) {
        const win = getOwnerWindow(first);
        muteFocusEventsDuringExecution(win, () => {
          first.focus();
        });
      } else {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
    } else if (host === target) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    const relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    const host = eventCurrentTargetGetter.call(event);
    const segments = getTabbableSegments(host);

    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
      return;
    }

    const target = eventTargetGetter.call(event);
    const position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      focusOnNextOrBlur(segments.next, target, relatedTarget);
    }

    if (position === 2) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
      return false;
    }

    const ownerDocument = getOwnerDocument(toElm);
    let root = toElm.getRootNode();

    while (root !== ownerDocument && root !== fromRoot) {
      const sr = root;
      const host = sr.host;

      if (getAttribute.call(host, 'tabindex') === '-1') {
        return false;
      }

      root = host && host.getRootNode();
    }

    return true;
  }

  function getNextTabbable(tabbables, relatedTarget) {
    const len = tabbables.length;

    if (len > 0) {
      for (let i = 0; i < len; i += 1) {
        const next = tabbables[i];

        if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
          return next;
        }
      }
    }

    return null;
  }

  function handleFocus(elm) {
    {
      assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
    }

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener.call(elm, 'focusin', skipHostHandler, true);
  }

  function ignoreFocus(elm) {
    removeEventListener.call(elm, 'focusin', skipHostHandler, true);
  }

  function bindDocumentMousedownMouseupHandlers(elm) {
    const ownerDocument = getOwnerDocument(elm);

    if (!getHiddenField(ownerDocument, DidAddMouseDownListener)) {
      setHiddenField(ownerDocument, DidAddMouseDownListener, true);
      addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
      addEventListener.call(ownerDocument, 'mouseup', () => {
        setTimeout(enableKeyboardFocusNavigationRoutines);
      }, true);
    }
  }

  function handleFocusIn(elm) {
    {
      assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
    }

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  function ignoreFocusIn(elm) {
    removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  const {
    blur,
    focus
  } = HTMLElement.prototype;

  function tabIndexGetterPatched() {
    if (isDelegatingFocus(this) && isFalse$1(hasAttribute.call(this, 'tabindex'))) {
      return 0;
    }

    return tabIndexGetter.call(this);
  }

  function tabIndexSetterPatched(value) {
    const delegatesFocus = isDelegatingFocus(this);
    const prevValue = tabIndexGetter.call(this);
    const prevHasAttr = hasAttribute.call(this, 'tabindex');
    tabIndexSetter.call(this, value);
    const currValue = tabIndexGetter.call(this);
    const currHasAttr = hasAttribute.call(this, 'tabindex');
    const didValueChange = prevValue !== currValue;

    if (prevHasAttr && (didValueChange || isFalse$1(currHasAttr))) {
      if (prevValue === -1) {
        ignoreFocusIn(this);
      }

      if (prevValue === 0 && delegatesFocus) {
        ignoreFocus(this);
      }
    }

    if (isFalse$1(currHasAttr)) {
      return;
    }

    if (prevHasAttr && currHasAttr && isFalse$1(didValueChange)) {
      return;
    }

    if (currValue === -1) {
      handleFocusIn(this);
    }

    if (currValue === 0 && delegatesFocus) {
      handleFocus(this);
    }
  }

  function blurPatched() {
    if (isDelegatingFocus(this)) {
      const currentActiveElement = getActiveElement(this);

      if (!isNull(currentActiveElement)) {
        currentActiveElement.blur();
        return;
      }
    }

    return blur.call(this);
  }

  function focusPatched() {
    disableKeyboardFocusNavigationRoutines();
    focus.call(this);
    enableKeyboardFocusNavigationRoutines();
  }

  defineProperties(HTMLElement.prototype, {
    tabIndex: {
      get() {
        if (isHostElement(this)) {
          return tabIndexGetterPatched.call(this);
        }

        return tabIndexGetter.call(this);
      },

      set(v) {
        if (isHostElement(this)) {
          return tabIndexSetterPatched.call(this, v);
        }

        return tabIndexSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    blur: {
      value() {
        if (isHostElement(this)) {
          return blurPatched.call(this);
        }

        blur.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    focus: {
      value() {
        focusPatched.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  const {
    addEventListener: superAddEventListener,
    removeEventListener: superRemoveEventListener
  } = Node.prototype;

  function addEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      addCustomElementEventListener(this, type, listener);
    } else {
      superAddEventListener.call(this, type, listener, options);
    }
  }

  function removeEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      removeCustomElementEventListener(this, type, listener);
    } else {
      superRemoveEventListener.call(this, type, listener, options);
    }
  }

  if (typeof EventTarget !== 'undefined') {
    defineProperties(EventTarget.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  } else {
    defineProperties(Node.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  }

  const ShadowTokenKey = '$shadowToken$';
  const ShadowTokenPrivateKey = '$$ShadowTokenKey$$';

  function getShadowToken(node) {
    return node[ShadowTokenKey];
  }

  function setShadowToken(node, shadowToken) {
    node[ShadowTokenKey] = shadowToken;
  }

  defineProperty(Element.prototype, '$shadowToken$', {
    set(shadowToken) {
      const oldShadowToken = this[ShadowTokenPrivateKey];

      if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
        removeAttribute.call(this, oldShadowToken);
      }

      if (!isUndefined(shadowToken)) {
        setAttribute.call(this, shadowToken, '');
      }

      this[ShadowTokenPrivateKey] = shadowToken;
    },

    get() {
      return this[ShadowTokenPrivateKey];
    },

    configurable: true
  });
  const DomManualPrivateKey = '$$DomManualKey$$';

  const DocumentResolverFn = function () {};

  let portalObserver;
  const portalObserverConfig = {
    childList: true
  };

  function adoptChildNode(node, fn, shadowToken) {
    const previousNodeShadowResolver = getShadowRootResolver(node);

    if (previousNodeShadowResolver === fn) {
      return;
    }

    setShadowRootResolver(node, fn);

    if (node instanceof Element) {
      setShadowToken(node, shadowToken);

      if (isHostElement(node)) {
        return;
      }

      if (isUndefined(previousNodeShadowResolver)) {
        MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
      }

      const childNodes = childNodesGetter.call(node);

      for (let i = 0, len = childNodes.length; i < len; i += 1) {
        adoptChildNode(childNodes[i], fn, shadowToken);
      }
    }
  }

  function initPortalObserver() {
    return new MO(mutations => {
      forEach.call(mutations, mutation => {
        const {
          target: elm,
          addedNodes,
          removedNodes
        } = mutation;
        const fn = getShadowRootResolver(elm);
        const shadowToken = getShadowToken(elm);

        for (let i = 0, len = removedNodes.length; i < len; i += 1) {
          const node = removedNodes[i];

          if (!(compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            adoptChildNode(node, DocumentResolverFn, undefined);
          }
        }

        for (let i = 0, len = addedNodes.length; i < len; i += 1) {
          const node = addedNodes[i];

          if (compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            adoptChildNode(node, fn, shadowToken);
          }
        }
      });
    });
  }

  function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
      portalObserver = initPortalObserver();
    }

    if (isUndefined(getShadowRootResolver(elm))) {
      throw new Error(`Invalid Element`);
    }

    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
  }

  defineProperty(Element.prototype, '$domManual$', {
    set(v) {
      this[DomManualPrivateKey] = v;

      if (isTrue$1(v)) {
        markElementAsPortal(this);
      }
    },

    get() {
      return this[DomManualPrivateKey];
    },

    configurable: true
  });
  /** version: 1.1.13-224.5 */

  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */


  loader.defineModules({
    'webruntime_loader/loader': loader
  });
  window.Webruntime = Object.freeze({
    define: loader.define
  });

}());
