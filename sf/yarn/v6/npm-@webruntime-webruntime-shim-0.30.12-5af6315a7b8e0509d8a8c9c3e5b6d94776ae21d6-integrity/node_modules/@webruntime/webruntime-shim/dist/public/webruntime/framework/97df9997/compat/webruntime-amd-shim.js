/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * This shim allows elements written in, or compiled to, ES5 to work on native
 * implementations of Custom Elements v1. It sets new.target to the value of
 * this.constructor so that the native HTMLElement constructor can access the
 * current under-construction element's definition.
 */
(function() {
  if (
    // No Reflect, no classes, no need for shim because native custom elements
    // require ES2015 classes or Reflect.
    window.Reflect === undefined ||
    window.customElements === undefined ||
    // The webcomponentsjs custom elements polyfill doesn't require
    // ES2015-compatible construction (`super()` or `Reflect.construct`).
    window.customElements.polyfillWrapFlushCallback
  ) {
    return;
  }
  const BuiltInHTMLElement = HTMLElement;
  /**
   * With jscompiler's RECOMMENDED_FLAGS the function name will be optimized away.
   * However, if we declare the function as a property on an object literal, and
   * use quotes for the property name, then closure will leave that much intact,
   * which is enough for the JS VM to correctly set Function.prototype.name.
   */
  const wrapperForTheName = {
    'HTMLElement': /** @this {!Object} */ function HTMLElement() {
      return Reflect.construct(
          BuiltInHTMLElement, [], /** @type {!Function} */ (this.constructor));
    }
  };
  window.HTMLElement = wrapperForTheName['HTMLElement'];
  HTMLElement.prototype = BuiltInHTMLElement.prototype;
  HTMLElement.prototype.constructor = HTMLElement;
  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
})();
(function(){
/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
'use strict';var n=window.Document.prototype.createElement,p=window.Document.prototype.createElementNS,aa=window.Document.prototype.importNode,ba=window.Document.prototype.prepend,ca=window.Document.prototype.append,da=window.DocumentFragment.prototype.prepend,ea=window.DocumentFragment.prototype.append,q=window.Node.prototype.cloneNode,r=window.Node.prototype.appendChild,t=window.Node.prototype.insertBefore,u=window.Node.prototype.removeChild,v=window.Node.prototype.replaceChild,x=Object.getOwnPropertyDescriptor(window.Node.prototype,
"textContent"),y=window.Element.prototype.attachShadow,z=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),A=window.Element.prototype.getAttribute,B=window.Element.prototype.setAttribute,C=window.Element.prototype.removeAttribute,D=window.Element.prototype.getAttributeNS,E=window.Element.prototype.setAttributeNS,F=window.Element.prototype.removeAttributeNS,G=window.Element.prototype.insertAdjacentElement,fa=window.Element.prototype.insertAdjacentHTML,ha=window.Element.prototype.prepend,
ia=window.Element.prototype.append,ja=window.Element.prototype.before,ka=window.Element.prototype.after,la=window.Element.prototype.replaceWith,ma=window.Element.prototype.remove,na=window.HTMLElement,H=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),oa=window.HTMLElement.prototype.insertAdjacentElement,pa=window.HTMLElement.prototype.insertAdjacentHTML;var qa=new Set;"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" ").forEach(function(a){return qa.add(a)});function ra(a){var b=qa.has(a);a=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a);return!b&&a}var sa=document.contains?document.contains.bind(document):document.documentElement.contains.bind(document.documentElement);
function I(a){var b=a.isConnected;if(void 0!==b)return b;if(sa(a))return!0;for(;a&&!(a.__CE_isImportDocument||a instanceof Document);)a=a.parentNode||(window.ShadowRoot&&a instanceof ShadowRoot?a.host:void 0);return!(!a||!(a.__CE_isImportDocument||a instanceof Document))}function J(a){var b=a.children;if(b)return Array.prototype.slice.call(b);b=[];for(a=a.firstChild;a;a=a.nextSibling)a.nodeType===Node.ELEMENT_NODE&&b.push(a);return b}
function K(a,b){for(;b&&b!==a&&!b.nextSibling;)b=b.parentNode;return b&&b!==a?b.nextSibling:null}
function L(a,b,c){for(var f=a;f;){if(f.nodeType===Node.ELEMENT_NODE){var d=f;b(d);var e=d.localName;if("link"===e&&"import"===d.getAttribute("rel")){f=d.import;void 0===c&&(c=new Set);if(f instanceof Node&&!c.has(f))for(c.add(f),f=f.firstChild;f;f=f.nextSibling)L(f,b,c);f=K(a,d);continue}else if("template"===e){f=K(a,d);continue}if(d=d.__CE_shadowRoot)for(d=d.firstChild;d;d=d.nextSibling)L(d,b,c)}f=f.firstChild?f.firstChild:K(a,f)}}function M(a,b,c){a[b]=c};function ta(a){var b=document;this.c=a;this.a=b;this.b=void 0;N(this.c,this.a);"loading"===this.a.readyState&&(this.b=new MutationObserver(this.f.bind(this)),this.b.observe(this.a,{childList:!0,subtree:!0}))}function ua(a){a.b&&a.b.disconnect()}ta.prototype.f=function(a){var b=this.a.readyState;"interactive"!==b&&"complete"!==b||ua(this);for(b=0;b<a.length;b++)for(var c=a[b].addedNodes,f=0;f<c.length;f++)N(this.c,c[f])};function va(){var a=this;this.b=this.a=void 0;this.c=new Promise(function(b){a.b=b;a.a&&b(a.a)})}function wa(a){if(a.a)throw Error("Already resolved.");a.a=void 0;a.b&&a.b(void 0)};function O(a){this.f=new Map;this.g=new Map;this.l=new Map;this.i=!1;this.b=a;this.j=new Map;this.c=function(b){return b()};this.a=!1;this.h=[];this.m=a.f?new ta(a):void 0}O.prototype.o=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructor getters must be functions.");xa(this,a);this.f.set(a,b);this.h.push(a);this.a||(this.a=!0,this.c(function(){return ya(c)}))};
O.prototype.define=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructors must be functions.");xa(this,a);za(this,a,b);this.h.push(a);this.a||(this.a=!0,this.c(function(){return ya(c)}))};function xa(a,b){if(!ra(b))throw new SyntaxError("The element name '"+b+"' is not valid.");if(P(a,b))throw Error("A custom element with name '"+b+"' has already been defined.");if(a.i)throw Error("A custom element is already being defined.");}
function za(a,b,c){a.i=!0;var f;try{var d=function(m){var w=e[m];if(void 0!==w&&!(w instanceof Function))throw Error("The '"+m+"' callback must be a function.");return w},e=c.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var g=d("connectedCallback");var h=d("disconnectedCallback");var k=d("adoptedCallback");var l=(f=d("attributeChangedCallback"))&&c.observedAttributes||[]}catch(m){throw m;}finally{a.i=!1}c={localName:b,constructorFunction:c,
connectedCallback:g,disconnectedCallback:h,adoptedCallback:k,attributeChangedCallback:f,observedAttributes:l,constructionStack:[]};a.g.set(b,c);a.l.set(c.constructorFunction,c);return c}O.prototype.upgrade=function(a){N(this.b,a)};
function ya(a){if(!1!==a.a){a.a=!1;for(var b=[],c=a.h,f=new Map,d=0;d<c.length;d++)f.set(c[d],[]);N(a.b,document,{upgrade:function(k){if(void 0===k.__CE_state){var l=k.localName,m=f.get(l);m?m.push(k):a.g.has(l)&&b.push(k)}}});for(d=0;d<b.length;d++)Q(a.b,b[d]);for(d=0;d<c.length;d++){for(var e=c[d],g=f.get(e),h=0;h<g.length;h++)Q(a.b,g[h]);(e=a.j.get(e))&&wa(e)}c.length=0}}O.prototype.get=function(a){if(a=P(this,a))return a.constructorFunction};
O.prototype.whenDefined=function(a){if(!ra(a))return Promise.reject(new SyntaxError("'"+a+"' is not a valid custom element name."));var b=this.j.get(a);if(b)return b.c;b=new va;this.j.set(a,b);var c=this.g.has(a)||this.f.has(a);a=-1===this.h.indexOf(a);c&&a&&wa(b);return b.c};O.prototype.polyfillWrapFlushCallback=function(a){this.m&&ua(this.m);var b=this.c;this.c=function(c){return a(function(){return b(c)})}};
function P(a,b){var c=a.g.get(b);if(c)return c;if(c=a.f.get(b)){a.f.delete(b);try{return za(a,b,c())}catch(f){R(f)}}}window.CustomElementRegistry=O;O.prototype.define=O.prototype.define;O.prototype.upgrade=O.prototype.upgrade;O.prototype.get=O.prototype.get;O.prototype.whenDefined=O.prototype.whenDefined;O.prototype.polyfillDefineLazy=O.prototype.o;O.prototype.polyfillWrapFlushCallback=O.prototype.polyfillWrapFlushCallback;function S(){var a=T&&T.noDocumentConstructionObserver,b=T&&T.shadyDomFastWalk;this.b=[];this.c=[];this.a=!1;this.shadyDomFastWalk=b;this.f=!a}function U(a,b,c,f){var d=window.ShadyDOM;if(a.shadyDomFastWalk&&d&&d.inUse){if(b.nodeType===Node.ELEMENT_NODE&&c(b),b.querySelectorAll)for(a=d.nativeMethods.querySelectorAll.call(b,"*"),b=0;b<a.length;b++)c(a[b])}else L(b,c,f)}function Aa(a,b){a.a=!0;a.b.push(b)}function Ba(a,b){a.a=!0;a.c.push(b)}function V(a,b){a.a&&U(a,b,function(c){return W(a,c)})}
function W(a,b){if(a.a&&!b.__CE_patched){b.__CE_patched=!0;for(var c=0;c<a.b.length;c++)a.b[c](b);for(c=0;c<a.c.length;c++)a.c[c](b)}}function X(a,b){var c=[];U(a,b,function(d){return c.push(d)});for(b=0;b<c.length;b++){var f=c[b];1===f.__CE_state?a.connectedCallback(f):Q(a,f)}}function Y(a,b){var c=[];U(a,b,function(d){return c.push(d)});for(b=0;b<c.length;b++){var f=c[b];1===f.__CE_state&&a.disconnectedCallback(f)}}
function N(a,b,c){c=void 0===c?{}:c;var f=c.s,d=c.upgrade||function(g){return Q(a,g)},e=[];U(a,b,function(g){a.a&&W(a,g);if("link"===g.localName&&"import"===g.getAttribute("rel")){var h=g.import;h instanceof Node&&(h.__CE_isImportDocument=!0,h.__CE_registry=document.__CE_registry);h&&"complete"===h.readyState?h.__CE_documentLoadHandled=!0:g.addEventListener("load",function(){var k=g.import;if(!k.__CE_documentLoadHandled){k.__CE_documentLoadHandled=!0;var l=new Set;f&&(f.forEach(function(m){return l.add(m)}),
l.delete(k));N(a,k,{s:l,upgrade:d})}})}else e.push(g)},f);for(b=0;b<e.length;b++)d(e[b])}
function Q(a,b){try{var c=b.ownerDocument,f=c.__CE_registry;var d=f&&(c.defaultView||c.__CE_isImportDocument)?P(f,b.localName):void 0;if(d&&void 0===b.__CE_state){d.constructionStack.push(b);try{try{if(new d.constructorFunction!==b)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{d.constructionStack.pop()}}catch(k){throw b.__CE_state=2,k;}b.__CE_state=1;b.__CE_definition=d;if(d.attributeChangedCallback&&b.hasAttributes()){var e=d.observedAttributes;
for(d=0;d<e.length;d++){var g=e[d],h=b.getAttribute(g);null!==h&&a.attributeChangedCallback(b,g,null,h,null)}}I(b)&&a.connectedCallback(b)}}catch(k){R(k)}}S.prototype.connectedCallback=function(a){var b=a.__CE_definition;if(b.connectedCallback)try{b.connectedCallback.call(a)}catch(c){R(c)}};S.prototype.disconnectedCallback=function(a){var b=a.__CE_definition;if(b.disconnectedCallback)try{b.disconnectedCallback.call(a)}catch(c){R(c)}};
S.prototype.attributeChangedCallback=function(a,b,c,f,d){var e=a.__CE_definition;if(e.attributeChangedCallback&&-1<e.observedAttributes.indexOf(b))try{e.attributeChangedCallback.call(a,b,c,f,d)}catch(g){R(g)}};
function Ca(a,b,c,f){var d=b.__CE_registry;if(d&&(null===f||"http://www.w3.org/1999/xhtml"===f)&&(d=P(d,c)))try{var e=new d.constructorFunction;if(void 0===e.__CE_state||void 0===e.__CE_definition)throw Error("Failed to construct '"+c+"': The returned value was not constructed with the HTMLElement constructor.");if("http://www.w3.org/1999/xhtml"!==e.namespaceURI)throw Error("Failed to construct '"+c+"': The constructed element's namespace must be the HTML namespace.");if(e.hasAttributes())throw Error("Failed to construct '"+
c+"': The constructed element must not have any attributes.");if(null!==e.firstChild)throw Error("Failed to construct '"+c+"': The constructed element must not have any children.");if(null!==e.parentNode)throw Error("Failed to construct '"+c+"': The constructed element must not have a parent node.");if(e.ownerDocument!==b)throw Error("Failed to construct '"+c+"': The constructed element's owner document is incorrect.");if(e.localName!==c)throw Error("Failed to construct '"+c+"': The constructed element's local name is incorrect.");
return e}catch(g){return R(g),b=null===f?n.call(b,c):p.call(b,f,c),Object.setPrototypeOf(b,HTMLUnknownElement.prototype),b.__CE_state=2,b.__CE_definition=void 0,W(a,b),b}b=null===f?n.call(b,c):p.call(b,f,c);W(a,b);return b}
function R(a){var b=a.message,c=a.sourceURL||a.fileName||"",f=a.line||a.lineNumber||0,d=a.column||a.columnNumber||0,e=void 0;void 0===ErrorEvent.prototype.initErrorEvent?e=new ErrorEvent("error",{cancelable:!0,message:b,filename:c,lineno:f,colno:d,error:a}):(e=document.createEvent("ErrorEvent"),e.initErrorEvent("error",!1,!0,b,c,f),e.preventDefault=function(){Object.defineProperty(this,"defaultPrevented",{configurable:!0,get:function(){return!0}})});void 0===e.error&&Object.defineProperty(e,"error",
{configurable:!0,enumerable:!0,get:function(){return a}});window.dispatchEvent(e);e.defaultPrevented||console.error(a)};var Da=new function(){};function Ea(a){window.HTMLElement=function(){function b(){var c=this.constructor;var f=document.__CE_registry.l.get(c);if(!f)throw Error("Failed to construct a custom element: The constructor was not registered with `customElements`.");var d=f.constructionStack;if(0===d.length)return d=n.call(document,f.localName),Object.setPrototypeOf(d,c.prototype),d.__CE_state=1,d.__CE_definition=f,W(a,d),d;var e=d.length-1,g=d[e];if(g===Da)throw Error("Failed to construct '"+f.localName+"': This element was already constructed.");
d[e]=Da;Object.setPrototypeOf(g,c.prototype);W(a,g);return g}b.prototype=na.prototype;Object.defineProperty(b.prototype,"constructor",{writable:!0,configurable:!0,enumerable:!1,value:b});return b}()};function Z(a,b,c){function f(d){return function(e){for(var g=[],h=0;h<arguments.length;++h)g[h]=arguments[h];h=[];for(var k=[],l=0;l<g.length;l++){var m=g[l];m instanceof Element&&I(m)&&k.push(m);if(m instanceof DocumentFragment)for(m=m.firstChild;m;m=m.nextSibling)h.push(m);else h.push(m)}d.apply(this,g);for(g=0;g<k.length;g++)Y(a,k[g]);if(I(this))for(g=0;g<h.length;g++)k=h[g],k instanceof Element&&X(a,k)}}void 0!==c.prepend&&M(b,"prepend",f(c.prepend));void 0!==c.append&&M(b,"append",f(c.append))}
;function Fa(a){M(Document.prototype,"createElement",function(b){return Ca(a,this,b,null)});M(Document.prototype,"importNode",function(b,c){b=aa.call(this,b,!!c);this.__CE_registry?N(a,b):V(a,b);return b});M(Document.prototype,"createElementNS",function(b,c){return Ca(a,this,c,b)});Z(a,Document.prototype,{prepend:ba,append:ca})};function Ga(a){function b(c,f){Object.defineProperty(c,"textContent",{enumerable:f.enumerable,configurable:!0,get:f.get,set:function(d){if(this.nodeType===Node.TEXT_NODE)f.set.call(this,d);else{var e=void 0;if(this.firstChild){var g=this.childNodes,h=g.length;if(0<h&&I(this)){e=Array(h);for(var k=0;k<h;k++)e[k]=g[k]}}f.set.call(this,d);if(e)for(d=0;d<e.length;d++)Y(a,e[d])}}})}M(Node.prototype,"insertBefore",function(c,f){if(c instanceof DocumentFragment){var d=J(c);c=t.call(this,c,f);if(I(this))for(f=
0;f<d.length;f++)X(a,d[f]);return c}d=c instanceof Element&&I(c);f=t.call(this,c,f);d&&Y(a,c);I(this)&&X(a,c);return f});M(Node.prototype,"appendChild",function(c){if(c instanceof DocumentFragment){var f=J(c);c=r.call(this,c);if(I(this))for(var d=0;d<f.length;d++)X(a,f[d]);return c}f=c instanceof Element&&I(c);d=r.call(this,c);f&&Y(a,c);I(this)&&X(a,c);return d});M(Node.prototype,"cloneNode",function(c){c=q.call(this,!!c);this.ownerDocument.__CE_registry?N(a,c):V(a,c);return c});M(Node.prototype,
"removeChild",function(c){var f=c instanceof Element&&I(c),d=u.call(this,c);f&&Y(a,c);return d});M(Node.prototype,"replaceChild",function(c,f){if(c instanceof DocumentFragment){var d=J(c);c=v.call(this,c,f);if(I(this))for(Y(a,f),f=0;f<d.length;f++)X(a,d[f]);return c}d=c instanceof Element&&I(c);var e=v.call(this,c,f),g=I(this);g&&Y(a,f);d&&Y(a,c);g&&X(a,c);return e});x&&x.get?b(Node.prototype,x):Aa(a,function(c){b(c,{enumerable:!0,configurable:!0,get:function(){for(var f=[],d=this.firstChild;d;d=
d.nextSibling)d.nodeType!==Node.COMMENT_NODE&&f.push(d.textContent);return f.join("")},set:function(f){for(;this.firstChild;)u.call(this,this.firstChild);null!=f&&""!==f&&r.call(this,document.createTextNode(f))}})})};function Ha(a){function b(f){return function(d){for(var e=[],g=0;g<arguments.length;++g)e[g]=arguments[g];g=[];for(var h=[],k=0;k<e.length;k++){var l=e[k];l instanceof Element&&I(l)&&h.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)g.push(l);else g.push(l)}f.apply(this,e);for(e=0;e<h.length;e++)Y(a,h[e]);if(I(this))for(e=0;e<g.length;e++)h=g[e],h instanceof Element&&X(a,h)}}var c=Element.prototype;void 0!==ja&&M(c,"before",b(ja));void 0!==ka&&M(c,"after",b(ka));void 0!==
la&&M(c,"replaceWith",function(f){for(var d=[],e=0;e<arguments.length;++e)d[e]=arguments[e];e=[];for(var g=[],h=0;h<d.length;h++){var k=d[h];k instanceof Element&&I(k)&&g.push(k);if(k instanceof DocumentFragment)for(k=k.firstChild;k;k=k.nextSibling)e.push(k);else e.push(k)}h=I(this);la.apply(this,d);for(d=0;d<g.length;d++)Y(a,g[d]);if(h)for(Y(a,this),d=0;d<e.length;d++)g=e[d],g instanceof Element&&X(a,g)});void 0!==ma&&M(c,"remove",function(){var f=I(this);ma.call(this);f&&Y(a,this)})};function Ia(a){function b(d,e){Object.defineProperty(d,"innerHTML",{enumerable:e.enumerable,configurable:!0,get:e.get,set:function(g){var h=this,k=void 0;I(this)&&(k=[],U(a,this,function(w){w!==h&&k.push(w)}));e.set.call(this,g);if(k)for(var l=0;l<k.length;l++){var m=k[l];1===m.__CE_state&&a.disconnectedCallback(m)}this.ownerDocument.__CE_registry?N(a,this):V(a,this);return g}})}function c(d,e){M(d,"insertAdjacentElement",function(g,h){var k=I(h);g=e.call(this,g,h);k&&Y(a,h);I(g)&&X(a,h);return g})}
function f(d,e){function g(h,k){for(var l=[];h!==k;h=h.nextSibling)l.push(h);for(k=0;k<l.length;k++)N(a,l[k])}M(d,"insertAdjacentHTML",function(h,k){h=h.toLowerCase();if("beforebegin"===h){var l=this.previousSibling;e.call(this,h,k);g(l||this.parentNode.firstChild,this)}else if("afterbegin"===h)l=this.firstChild,e.call(this,h,k),g(this.firstChild,l);else if("beforeend"===h)l=this.lastChild,e.call(this,h,k),g(l||this.firstChild,null);else if("afterend"===h)l=this.nextSibling,e.call(this,h,k),g(this.nextSibling,
l);else throw new SyntaxError("The value provided ("+String(h)+") is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");})}y&&M(Element.prototype,"attachShadow",function(d){d=y.call(this,d);if(a.a&&!d.__CE_patched){d.__CE_patched=!0;for(var e=0;e<a.b.length;e++)a.b[e](d)}return this.__CE_shadowRoot=d});z&&z.get?b(Element.prototype,z):H&&H.get?b(HTMLElement.prototype,H):Ba(a,function(d){b(d,{enumerable:!0,configurable:!0,get:function(){return q.call(this,!0).innerHTML},set:function(e){var g=
"template"===this.localName,h=g?this.content:this,k=p.call(document,this.namespaceURI,this.localName);for(k.innerHTML=e;0<h.childNodes.length;)u.call(h,h.childNodes[0]);for(e=g?k.content:k;0<e.childNodes.length;)r.call(h,e.childNodes[0])}})});M(Element.prototype,"setAttribute",function(d,e){if(1!==this.__CE_state)return B.call(this,d,e);var g=A.call(this,d);B.call(this,d,e);e=A.call(this,d);a.attributeChangedCallback(this,d,g,e,null)});M(Element.prototype,"setAttributeNS",function(d,e,g){if(1!==this.__CE_state)return E.call(this,
d,e,g);var h=D.call(this,d,e);E.call(this,d,e,g);g=D.call(this,d,e);a.attributeChangedCallback(this,e,h,g,d)});M(Element.prototype,"removeAttribute",function(d){if(1!==this.__CE_state)return C.call(this,d);var e=A.call(this,d);C.call(this,d);null!==e&&a.attributeChangedCallback(this,d,e,null,null)});M(Element.prototype,"removeAttributeNS",function(d,e){if(1!==this.__CE_state)return F.call(this,d,e);var g=D.call(this,d,e);F.call(this,d,e);var h=D.call(this,d,e);g!==h&&a.attributeChangedCallback(this,
e,g,h,d)});oa?c(HTMLElement.prototype,oa):G&&c(Element.prototype,G);pa?f(HTMLElement.prototype,pa):fa&&f(Element.prototype,fa);Z(a,Element.prototype,{prepend:ha,append:ia});Ha(a)};var T=window.customElements;function Ja(){var a=new S;Ea(a);Fa(a);Z(a,DocumentFragment.prototype,{prepend:da,append:ea});Ga(a);Ia(a);a=new O(a);document.__CE_registry=a;Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:a})}T&&!T.forcePolyfill&&"function"==typeof T.define&&"function"==typeof T.get||Ja();window.__CE_installPolyfill=Ja;
}).call(self);

//# sourceMappingURL=custom-elements.min.js.map
/* proxy-compat-disable */

Object.setPrototypeOf = Object.setPrototypeOf || function(o, p) { o.__proto__ = p; return o; }
Object.definePropertyNative = Object.defineProperty;
Object.definePropertiesNative = Object.defineProperties;
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// THIS POLYFILL HAS BEEN MODIFIED FROM THE SOURCE
// https://github.com/eligrey/classList.js

if ("document" in self) {

    // Full polyfill for browsers with no classList support
    // Including IE < Edge missing SVGElement.classList
    if (
           !("classList" in document.createElement("_"))
        || document.createElementNS
        && !("classList" in document.createElementNS("http://www.w3.org/2000/svg","g"))
    ) {

    (function (view) {

    "use strict";

    if (!('Element' in view)) return;

    var
          classListProp = "classList"
        , protoProp = "prototype"
        , elemCtrProto = view.Element[protoProp]
        , objCtr = Object
        , strTrim = String[protoProp].trim || function () {
            return this.replace(/^\s+|\s+$/g, "");
        }
        , arrIndexOf = Array[protoProp].indexOf || function (item) {
            var
                  i = 0
                , len = this.length
            ;
            for (; i < len; i++) {
                if (i in this && this[i] === item) {
                    return i;
                }
            }
            return -1;
        }
        // Vendors: please allow content code to instantiate DOMExceptions
        , DOMEx = function (type, message) {
            this.name = type;
            this.code = DOMException[type];
            this.message = message;
        }
        , checkTokenAndGetIndex = function (classList, token) {
            if (token === "") {
                throw new DOMEx(
                      "SYNTAX_ERR"
                    , "The token must not be empty."
                );
            }
            if (/\s/.test(token)) {
                throw new DOMEx(
                      "INVALID_CHARACTER_ERR"
                    , "The token must not contain space characters."
                );
            }
            return arrIndexOf.call(classList, token);
        }
        , ClassList = function (elem) {
            var
                  trimmedClasses = strTrim.call(elem.getAttribute("class") || "")
                , classes = trimmedClasses ? trimmedClasses.split(/\s+/) : []
                , i = 0
                , len = classes.length
            ;
            for (; i < len; i++) {
                this.push(classes[i]);
            }
            this._updateClassName = function () {
                elem.setAttribute("class", this.toString());
            };
        }
        , classListProto = ClassList[protoProp] = []
        , classListGetter = function () {
            return new ClassList(this);
        }
    ;
    // Most DOMException implementations don't allow calling DOMException's toString()
    // on non-DOMExceptions. Error's toString() is sufficient here.
    DOMEx[protoProp] = Error[protoProp];
    classListProto.item = function (i) {
        return this[i] || null;
    };
    classListProto.contains = function (token) {
        return checkTokenAndGetIndex(this, token + "") !== -1;
    };
    classListProto.add = function () {
        var
              tokens = arguments
            , i = 0
            , l = tokens.length
            , token
            , updated = false
        ;
        do {
            token = tokens[i] + "";
            if (checkTokenAndGetIndex(this, token) === -1) {
                this.push(token);
                updated = true;
            }
        }
        while (++i < l);

        if (updated) {
            this._updateClassName();
        }
    };
    classListProto.remove = function () {
        var
              tokens = arguments
            , i = 0
            , l = tokens.length
            , token
            , updated = false
            , index
        ;
        do {
            token = tokens[i] + "";
            index = checkTokenAndGetIndex(this, token);
            while (index !== -1) {
                this.splice(index, 1);
                updated = true;
                index = checkTokenAndGetIndex(this, token);
            }
        }
        while (++i < l);

        if (updated) {
            this._updateClassName();
        }
    };
    classListProto.toggle = function (token, force) {
        var
              result = this.contains(token)
            , method = result ?
                force !== true && "remove"
            :
                force !== false && "add"
        ;

        if (method) {
            this[method](token);
        }

        if (force === true || force === false) {
            return force;
        } else {
            return !result;
        }
    };
    classListProto.replace = function (token, replacement_token) {
        var index = checkTokenAndGetIndex(token + "");
        if (index !== -1) {
            this.splice(index, 1, replacement_token);
            this._updateClassName();
        }
    }
    classListProto.toString = function () {
        return this.join(" ");
    };

    if (objCtr.defineProperty) {
        var classListPropDesc = {
              get: classListGetter
            , enumerable: true
            , configurable: true
        };
        try {
            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
        } catch (ex) { // IE 8 doesn't support enumerable:true
            // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36
            // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected
            if (ex.number === undefined || ex.number === -0x7FF5EC54) {
                classListPropDesc.enumerable = false;
                objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
            }
        }
    } else if (objCtr[protoProp].__defineGetter__) {
        elemCtrProto.__defineGetter__(classListProp, classListGetter);
    }

    }(self));

    }

    // There is full or partial native classList support, so just check if we need
    // to normalize the add/remove and toggle APIs.

    (function () {
        "use strict";

        var testElement = document.createElement("_");

        testElement.classList.add("c1", "c2");

        // Polyfill for IE 10/11 and Firefox <26, where classList.add and
        // classList.remove exist but support only one argument at a time.
        if (!testElement.classList.contains("c2")) {
            var createMethod = function(method) {
                var original = DOMTokenList.prototype[method];

                DOMTokenList.prototype[method] = function(token) {
                    var i, len = arguments.length;

                    for (i = 0; i < len; i++) {
                        token = arguments[i];
                        original.call(this, token);
                    }
                };
            };
            createMethod('add');
            createMethod('remove');
        }

        testElement.classList.toggle("c3", false);

        // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
        // support the second argument.
        if (testElement.classList.contains("c3")) {
            var _toggle = DOMTokenList.prototype.toggle;

            DOMTokenList.prototype.toggle = function(token, force) {
                if (1 in arguments && !this.contains(token) === !force) {
                    return force;
                } else {
                    return _toggle.call(this, token);
                }
            };

        }

        // replace() polyfill
        if (!("replace" in document.createElement("_").classList)) {
            DOMTokenList.prototype.replace = function (token, replacement_token) {
                var
                      tokens = this.toString().split(" ")
                    , index = tokens.indexOf(token + "")
                ;
                if (index !== -1) {
                    tokens = tokens.slice(index);
                    this.remove.apply(this, tokens);
                    this.add(replacement_token);
                    this.add.apply(this, tokens.slice(1));
                }
            }
        }

        testElement = null;
    }());

    }
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
(function() {
    "use strict";

    var create = Object.create;
    var defineProperty = Object.defineProperty;

    var defaultPreventedDescriptor = {
        get: function () { return true; }
    };

    var preventDefault = function () {
        if (this.defaultPrevented === true || this.cancelable !== true) {
            return;
        }

        defineProperty(this, "defaultPrevented", defaultPreventedDescriptor);
    }

    if (typeof CustomEvent !== 'function') {
        window.CustomEvent = function CustomEvent(type, eventInitDict) {
            if (!type) {
                throw Error('TypeError: Failed to construct "CustomEvent": An event name must be provided.');
            }

            var event;
            eventInitDict = eventInitDict || { bubbles: false, cancelable: false, detail: null };

            if ('createEvent' in document) {
                try {
                    event = document.createEvent('CustomEvent');
                    event.initCustomEvent(type, eventInitDict.bubbles, eventInitDict.cancelable, eventInitDict.detail);
                } catch (error) {
                    // for browsers which don't support CustomEvent at all, we use a regular event instead
                    event = document.createEvent('Event');
                    event.initEvent(type, eventInitDict.bubbles, eventInitDict.cancelable);
                    event.detail = eventInitDict.detail;
                }
            } else {

                // IE8
                event = new Event(type, eventInitDict);
                event.detail = eventInitDict && eventInitDict.detail || null;
            }

            // We attach the preventDefault to the instance instead of the prototype:
            //  - We don't want to mutate the Event.prototype.
            //  - Adding an indirection (adding a new level of inheritance) would slow down all the access to the Event properties.
            event.preventDefault = preventDefault;

            // Warning we can't add anything to the CustomEvent prototype because we are returning an event, instead of the this object.
            return event;
        };

        // We also assign Event.prototype to CustomEvent.prototype to ensure that consumer can use the following form
        // CustomEvent.prototype.[method]
        CustomEvent.prototype = Event.prototype;
    }
}());
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
(function () {
	var unlistenableWindowEvents = {
		click: 1,
		dblclick: 1,
		keyup: 1,
		keypress: 1,
		keydown: 1,
		mousedown: 1,
		mouseup: 1,
		mousemove: 1,
		mouseover: 1,
		mouseenter: 1,
		mouseleave: 1,
		mouseout: 1,
		storage: 1,
		storagecommit: 1,
		textinput: 1
	};

	function indexOf(array, element) {
		var
		index = -1,
		length = array.length;

		while (++index < length) {
			if (index in array && array[index] === element) {
				return index;
			}
		}

		return -1;
	}

	var existingProto = (window.Event && window.Event.prototype) || null;
	window.Event = Window.prototype.Event = function Event(type, eventInitDict) {
		if (!type) {
			throw new Error('Not enough arguments');
		}

		// Shortcut if browser supports createEvent
		if ('createEvent' in document) {
			var event = document.createEvent('Event');
			var bubbles = eventInitDict && eventInitDict.bubbles !== undefined ? eventInitDict.bubbles : false;
			var cancelable = eventInitDict && eventInitDict.cancelable !== undefined ? eventInitDict.cancelable : false;

			event.initEvent(type, bubbles, cancelable);

			return event;
		}

		var event = document.createEventObject();

		event.type = type;
		event.bubbles = eventInitDict && eventInitDict.bubbles !== undefined ? eventInitDict.bubbles : false;
		event.cancelable = eventInitDict && eventInitDict.cancelable !== undefined ? eventInitDict.cancelable : false;

		return event;
	};
	if (existingProto) {
		Object.defineProperty(window.Event, 'prototype', {
			configurable: false,
			enumerable: false,
			writable: true,
			value: existingProto
		});
	}

	if (!('createEvent' in document)) {
		window.addEventListener = Window.prototype.addEventListener = Document.prototype.addEventListener = Element.prototype.addEventListener = function addEventListener() {
			var
			element = this,
			type = arguments[0],
			listener = arguments[1];

			if (element === window && type in unlistenableWindowEvents) {
				throw new Error('In IE8 the event: ' + type + ' is not available on the window object. Please see https://github.com/Financial-Times/polyfill-service/issues/317 for more information.');
			}

			if (!element._events) {
				element._events = {};
			}

			if (!element._events[type]) {
				element._events[type] = function (event) {
					var
					list = element._events[event.type].list,
					events = list.slice(),
					index = -1,
					length = events.length,
					eventElement;

					event.preventDefault = function preventDefault() {
						if (event.cancelable !== false) {
							event.returnValue = false;
						}
					};

					event.stopPropagation = function stopPropagation() {
						event.cancelBubble = true;
					};

					event.stopImmediatePropagation = function stopImmediatePropagation() {
						event.cancelBubble = true;
						event.cancelImmediate = true;
					};

					event.currentTarget = element;
					event.relatedTarget = event.fromElement || null;
					event.target = event.target || event.srcElement || element;
					event.timeStamp = new Date().getTime();

					if (event.clientX) {
						event.pageX = event.clientX + document.documentElement.scrollLeft;
						event.pageY = event.clientY + document.documentElement.scrollTop;
					}

					while (++index < length && !event.cancelImmediate) {
						if (index in events) {
							eventElement = events[index];

							if (indexOf(list, eventElement) !== -1 && typeof eventElement === 'function') {
								eventElement.call(element, event);
							}
						}
					}
				};

				element._events[type].list = [];

				if (element.attachEvent) {
					element.attachEvent('on' + type, element._events[type]);
				}
			}

			element._events[type].list.push(listener);
		};

		window.removeEventListener = Window.prototype.removeEventListener = Document.prototype.removeEventListener = Element.prototype.removeEventListener = function removeEventListener() {
			var
			element = this,
			type = arguments[0],
			listener = arguments[1],
			index;

			if (element._events && element._events[type] && element._events[type].list) {
				index = indexOf(element._events[type].list, listener);

				if (index !== -1) {
					element._events[type].list.splice(index, 1);

					if (!element._events[type].list.length) {
						if (element.detachEvent) {
							element.detachEvent('on' + type, element._events[type]);
						}
						delete element._events[type];
					}
				}
			}
		};

		window.dispatchEvent = Window.prototype.dispatchEvent = Document.prototype.dispatchEvent = Element.prototype.dispatchEvent = function dispatchEvent(event) {
			if (!arguments.length) {
				throw new Error('Not enough arguments');
			}

			if (!event || typeof event.type !== 'string') {
				throw new Error('DOM Events Exception 0');
			}

			var element = this, type = event.type;

			try {
				if (!event.bubbles) {
					event.cancelBubble = true;

					var cancelBubbleEvent = function (event) {
						event.cancelBubble = true;

						(element || window).detachEvent('on' + type, cancelBubbleEvent);
					};

					this.attachEvent('on' + type, cancelBubbleEvent);
				}

				this.fireEvent('on' + type, event);
			} catch (error) {
				event.target = element;

				do {
					event.currentTarget = element;

					if ('_events' in element && typeof element._events[type] === 'function') {
						element._events[type].call(element, event);
					}

					if (typeof element['on' + type] === 'function') {
						element['on' + type].call(element, event);
					}

					element = element.nodeType === 9 ? element.parentWindow : element.parentNode;
				} while (element && !event.cancelBubble);
			}

			return true;
		};

		// Add the DOMContentLoaded Event
		document.attachEvent('onreadystatechange', function() {
			if (document.readyState === 'complete') {
				document.dispatchEvent(new Event('DOMContentLoaded', {
					bubbles: true
				}));
			}
		});
	}
}());

(function() {
    var exports, module, define = undefined;
    /* proxy-compat-disable */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Proxy = factory());
}(this, function () { 'use strict';

    function __extends(d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var _a = Object, getOwnPropertyNames = _a.getOwnPropertyNames, create = _a.create, keys = _a.keys, getOwnPropertyDescriptor = _a.getOwnPropertyDescriptor, preventExtensions = _a.preventExtensions, defineProperty = _a.defineProperty, hasOwnProperty = _a.hasOwnProperty, isExtensible = _a.isExtensible, getPrototypeOf = _a.getPrototypeOf, setPrototypeOf = _a.setPrototypeOf;
    var _b = Array.prototype, ArraySlice = _b.slice, ArrayShift = _b.shift, ArrayUnshift = _b.unshift, ArrayConcat = _b.concat;
    var isArray = Array.isArray;

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isUndefined(value) {
        return value === undefined;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getOwnPropertyDescriptor$1(replicaOrAny, key) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.getOwnPropertyDescriptor(key);
        }
        return getOwnPropertyDescriptor(replicaOrAny, key);
    }
    function getOwnPropertyNames$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.ownKeys().filter(function (key) { return key.constructor !== Symbol; }); // TODO: only strings
        }
        return getOwnPropertyNames(replicaOrAny);
    }
    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys
    // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys
    function OwnPropertyKeys(O) {
        return ArrayConcat.call(Object.getOwnPropertyNames(O), Object.getOwnPropertySymbols(O));
    }
    function assign(replicaOrAny) {
        if (replicaOrAny == null) { // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var to = Object(replicaOrAny);
        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];
            if (nextSource != null) { // Skip over if undefined or null
                var objectKeys = OwnPropertyKeys(nextSource);
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < objectKeys.length; i += 1) {
                    var nextKey = objectKeys[i];
                    var descriptor = getOwnPropertyDescriptor$1(nextSource, nextKey);
                    if (descriptor !== undefined && descriptor.enumerable === true) {
                        setKey(to, nextKey, getKey(nextSource, nextKey));
                    }
                }
            }
        }
        return to;
    }
    function hasOwnProperty$1(key) {
        if (isCompatProxy(this)) {
            var descriptor = this.getOwnPropertyDescriptor(key);
            return !isUndefined(descriptor);
        }
        else {
            return hasOwnProperty.call(this, key);
        }
    }
    function keys$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            var all = replicaOrAny.forIn();
            var result = [];
            // tslint:disable-next-line:forin
            for (var prop in all) {
                var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
                if (desc && desc.enumerable === true) {
                    result.push(prop);
                }
            }
            return result;
        }
        else {
            return keys(replicaOrAny);
        }
    }
    function values(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            var all = replicaOrAny.forIn();
            var result = [];
            // tslint:disable-next-line:forin
            for (var prop in all) {
                var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
                if (desc && desc.enumerable === true) {
                    result.push(getKey(replicaOrAny, prop));
                }
            }
            return result;
        }
        else {
            // Calling `Object.values` instead of dereferencing the method during the module evaluation
            // since `Object.values` gets polyfilled at the module evaluation.
            return Object.values(replicaOrAny);
        }
    }
    function entries(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            var all = replicaOrAny.forIn();
            var result = [];
            // tslint:disable-next-line:forin
            for (var prop in all) {
                var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
                if (desc && desc.enumerable === true) {
                    result.push([
                        prop,
                        getKey(replicaOrAny, prop)
                    ]);
                }
            }
            return result;
        }
        else {
            // Calling `Object.entries` instead of dereferencing the method during the module evaluation
            // since `Object.entries` gets polyfilled at the module evaluation.
            return Object.entries(replicaOrAny);
        }
    }
    function defineProperty$1(replicaOrAny, prop, descriptor) {
        if (isCompatProxy(replicaOrAny)) {
            replicaOrAny.defineProperty(prop, descriptor);
            return replicaOrAny;
        }
        else {
            return defineProperty(replicaOrAny, prop, descriptor);
        }
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ProxyTypeObject = 1;
    var ProxyTypeArray = 2;
    // Proto chain check might be needed because of usage of a limited polyfill
    // https://github.com/es-shims/get-own-property-symbols
    // In this case, because this polyfill is assing all the stuff to Object.prototype to keep
    // all the other invariants of Symbols, we need to do some manual checks here for the slow patch.
    var isNotNativeSymbol;
    var inOperator = function inOperatorCompat(obj, key) {
        if (isNotNativeSymbol === undefined) {
            if (typeof Symbol === 'undefined') {
                throw new Error('Symbol is not available. Make sure to apply symbol polyfill before calling inOperator');
            }
            isNotNativeSymbol = typeof Symbol() === 'object';
        }
        if (isNotNativeSymbol) {
            var getOwnPropertySymbols = Object.getOwnPropertySymbols;
            if (key && key.constructor === Symbol) {
                while (obj) {
                    if (getOwnPropertySymbols(obj).indexOf(key) !== -1) {
                        return true;
                    }
                    obj = getPrototypeOf(obj);
                }
                return false;
            }
            return key in obj;
        }
        return key in obj;
    };
    var defaultHandlerTraps = {
        get: function (target, key) {
            return target[key];
        },
        set: function (target, key, newValue) {
            target[key] = newValue;
            return true;
        },
        apply: function (targetFn, thisArg, argumentsList) {
            return targetFn.apply(thisArg, argumentsList);
        },
        construct: function (targetFn, argumentsList, newTarget) {
            return new (targetFn.bind.apply(targetFn, [void 0].concat(argumentsList)))();
        },
        defineProperty: function (target, property, descriptor) {
            defineProperty(target, property, descriptor);
            return true;
        },
        deleteProperty: function (target, property) {
            return delete target[property];
        },
        ownKeys: function (target) {
            return OwnPropertyKeys(target);
        },
        has: function (target, propertyKey) {
            return inOperator(target, propertyKey);
        },
        preventExtensions: function (target) {
            preventExtensions(target);
            return true;
        },
        getOwnPropertyDescriptor: getOwnPropertyDescriptor,
        getPrototypeOf: getPrototypeOf,
        isExtensible: isExtensible,
        setPrototypeOf: setPrototypeOf,
    };
    var lastRevokeFn;
    var proxyTrapFalsyErrors = {
        set: function (target, key) {
            throw new TypeError("'set' on proxy: trap returned falsish for property '" + key + "'");
        },
        deleteProperty: function (target, key) {
            throw new TypeError("'deleteProperty' on proxy: trap returned falsish for property '" + key + "'");
        },
        setPrototypeOf: function (target, proto) {
            throw new TypeError("'setPrototypeOf' on proxy: trap returned falsish");
        },
        preventExtensions: function (target, proto) {
            throw new TypeError("'preventExtensions' on proxy: trap returned falsish");
        },
        defineProperty: function (target, key, descriptor) {
            throw new TypeError("'defineProperty' on proxy: trap returned falsish for property '" + key + "'");
        }
    };
    function proxifyProperty(proxy, key, descriptor) {
        var enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        defineProperty(proxy, key, {
            enumerable: enumerable,
            configurable: configurable,
            get: function () {
                return proxy.get(key);
            },
            set: function (value) {
                proxy.set(key, value);
            },
        });
    }
    var XProxy = /** @class */ (function () {
        function XProxy(target, handler) {
            var targetIsFunction = typeof target === 'function';
            var targetIsArray = isArray(target);
            if ((typeof target !== 'object' || target === null) && !targetIsFunction) {
                throw new Error("Cannot create proxy with a non-object as target");
            }
            if (typeof handler !== 'object' || handler === null) {
                throw new Error("new XProxy() expects the second argument to an object");
            }
            // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.
            // The caller might get the wrong revoke function if a user replaces or wraps XProxy
            // to call itself, but that seems unlikely especially when using the polyfill.
            var throwRevoked = false;
            lastRevokeFn = function () {
                throwRevoked = true;
            };
            // Define proxy as Object, or Function (if either it's callable, or apply is set).
            // tslint:disable-next-line:no-this-assignment
            var proxy = this; // reusing the already created object, eventually the prototype will be resetted
            if (targetIsFunction) {
                proxy = function Proxy() {
                    var usingNew = (this && this.constructor === proxy);
                    var args = ArraySlice.call(arguments);
                    if (usingNew) {
                        return proxy.construct(args, this);
                    }
                    else {
                        return proxy.apply(this, args);
                    }
                };
            }
            var _loop_1 = function (trapName) {
                defineProperty(proxy, trapName, {
                    value: function () {
                        if (throwRevoked) {
                            throw new TypeError("Cannot perform '" + trapName + "' on a proxy that has been revoked");
                        }
                        var args = ArraySlice.call(arguments);
                        ArrayUnshift.call(args, target);
                        var h = handler[trapName] ? handler : defaultHandlerTraps;
                        var value = h[trapName].apply(h, args);
                        if (proxyTrapFalsyErrors[trapName] && value === false) {
                            proxyTrapFalsyErrors[trapName].apply(proxyTrapFalsyErrors, args);
                        }
                        return value;
                    },
                    writable: false,
                    enumerable: false,
                    configurable: false,
                });
            };
            // tslint:disable-next-line:forin
            for (var trapName in defaultHandlerTraps) {
                _loop_1(trapName);
            }
            var proxyDefaultHasInstance;
            var SymbolHasInstance = Symbol.hasInstance;
            var FunctionPrototypeSymbolHasInstance = Function.prototype[SymbolHasInstance];
            defineProperty(proxy, SymbolHasInstance, {
                get: function () {
                    var hasInstance = proxy.get(SymbolHasInstance);
                    // We do not want to deal with any Symbol.hasInstance here
                    // because we need to do special things to check prototypes.
                    // Symbol polyfill adds Symbol.hasInstance to the function prototype
                    // so if we have that here, we need to return our own.
                    // If the value we get from this function is different, that means
                    // user has supplied custom function so we need to respect that.
                    if (hasInstance === FunctionPrototypeSymbolHasInstance) {
                        return proxyDefaultHasInstance || (proxyDefaultHasInstance = function (inst) {
                            return defaultHasInstance(inst, proxy);
                        });
                    }
                    return hasInstance;
                },
                configurable: false,
                enumerable: false
            });
            defineProperty(proxy, '_ES5ProxyType', {
                value: targetIsArray ? ProxyTypeArray : ProxyTypeObject,
                configurable: false,
                enumerable: false,
                writable: true,
            });
            defineProperty(proxy, 'forIn', {
                value: function () {
                    return proxy.ownKeys().reduce(function (o, key) {
                        o[key] = void 0;
                        return o;
                    }, create(null));
                },
                configurable: false,
                enumerable: false,
                writable: false,
            });
            var SymbolIterator = Symbol.iterator;
            defineProperty(proxy, SymbolIterator, {
                enumerable: false,
                configurable: true,
                get: function () {
                    return this.get(SymbolIterator);
                },
                set: function (value) {
                    this.set(SymbolIterator, value);
                },
            });
            if (targetIsArray) {
                var trackedLength_1 = 0;
                var adjustArrayIndex_1 = function (newLength) {
                    // removing old indexes from proxy when needed
                    while (trackedLength_1 > newLength) {
                        delete proxy[--trackedLength_1];
                    }
                    // add new indexes to proxy when needed
                    for (var i = trackedLength_1; i < newLength; i += 1) {
                        proxifyProperty(proxy, i, {
                            enumerable: true,
                            configurable: true,
                        });
                    }
                    trackedLength_1 = newLength;
                };
                defineProperty(proxy, 'length', {
                    enumerable: false,
                    configurable: true,
                    get: function () {
                        var proxyLength = proxy.get('length');
                        // check if the trackedLength matches the length of the proxy
                        if (proxyLength !== trackedLength_1) {
                            adjustArrayIndex_1(proxyLength);
                        }
                        return proxyLength;
                    },
                    set: function (value) {
                        proxy.set('length', value);
                    },
                });
                // building the initial index. this is observable by the proxy
                // because we access the length property during the construction
                // of the proxy, but it should be fine...
                adjustArrayIndex_1(proxy.get('length'));
            }
            return proxy;
        }
        // tslint:disable-next-line:member-ordering
        XProxy.revocable = function (target, handler) {
            var p = new XProxy(target, handler);
            return {
                proxy: p,
                revoke: lastRevokeFn,
            };
        };
        XProxy.prototype.push = function () {
            var push$1 = this.get('push');
            if (push$1 === Array.prototype.push) {
                push$1 = push;
            }
            return push$1.apply(this, arguments);
        };
        XProxy.prototype.pop = function () {
            var pop$1 = this.get('pop');
            if (pop$1 === Array.prototype.pop) {
                pop$1 = pop;
            }
            return pop$1.apply(this, arguments);
        };
        XProxy.prototype.concat = function () {
            var concat = this.get('concat');
            if (concat === Array.prototype.concat) {
                concat = concat$1;
            }
            return concat.apply(this, arguments);
        };
        XProxy.prototype.splice = function () {
            var splice$1 = this.get('splice');
            if (splice$1 === Array.prototype.splice) {
                splice$1 = splice;
            }
            return splice$1.apply(this, arguments);
        };
        XProxy.prototype.shift = function () {
            var shift$1 = this.get('shift');
            if (shift$1 === Array.prototype.shift) {
                shift$1 = shift;
            }
            return shift$1.apply(this, arguments);
        };
        XProxy.prototype.unshift = function () {
            var unshift$1 = this.get('unshift');
            if (unshift$1 === Array.prototype.unshift) {
                unshift$1 = unshift;
            }
            return unshift$1.apply(this, arguments);
        };
        XProxy.prototype.toJSON = function () {
            if (this._ES5ProxyType === ProxyTypeArray) {
                var unwrappedArray = [];
                var length = this.get('length');
                for (var i = 0; i < length; i++) {
                    unwrappedArray[i] = this.get(i);
                }
                return unwrappedArray;
            }
            else {
                var toJSON = this.get('toJSON');
                if (toJSON !== undefined && typeof toJSON === 'function') {
                    return toJSON.apply(this, arguments);
                }
                var keys = this.ownKeys();
                var unwrappedObject = {};
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var enumerable = this.getOwnPropertyDescriptor(key).enumerable;
                    if (enumerable) {
                        unwrappedObject[key] = this.get(key);
                    }
                }
                return unwrappedObject;
            }
        };
        return XProxy;
    }());

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function defaultHasInstance(instance, Type) {
        // We have to grab getPrototypeOf here
        // because caching it at the module level is too early.
        // We need our shimmed version.
        var getPrototypeOf = Object.getPrototypeOf;
        var instanceProto = getPrototypeOf(instance);
        var TypeProto = getKey(Type, 'prototype');
        while (instanceProto !== null) {
            if (instanceProto === TypeProto) {
                return true;
            }
            instanceProto = getPrototypeOf(instanceProto);
        }
        return false;
    }
    // NOTE: For performance reasons, the "_ES5ProxyType" key should be checked without
    // using this function, unless `replicaOrAny._ES5ProxyType` might throw unexpectedly.
    function isCompatProxy(replicaOrAny) {
        return replicaOrAny && replicaOrAny._ES5ProxyType;
    }
    var getKey = function (replicaOrAny, k1) {
        return replicaOrAny._ES5ProxyType ?
            replicaOrAny.get(k1) :
            replicaOrAny[k1];
    };
    var getKeys2 = function (replicaOrAny, k1, k2) {
        var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
        return replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
    };
    var getKeys3 = function (replicaOrAny, k1, k2, k3) {
        var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
        var replicaOrAny2 = replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
        return replicaOrAny2._ES5ProxyType ? replicaOrAny2.get(k3) : replicaOrAny2[k3];
    };
    var getKeys4 = function (replicaOrAny, k1, k2, k3, k4) {
        var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
        var replicaOrAny2 = replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
        var replicaOrAny3 = replicaOrAny2._ES5ProxyType ? replicaOrAny2.get(k3) : replicaOrAny2[k3];
        return replicaOrAny3._ES5ProxyType ? replicaOrAny3.get(k4) : replicaOrAny3[k4];
    };
    var getKeys = function (replicaOrAny) {
        var l = arguments.length;
        for (var i = 1; i < l; i++) {
            var key = arguments[i];
            replicaOrAny = replicaOrAny._ES5ProxyType ? replicaOrAny.get(key) : replicaOrAny[key];
        }
        return replicaOrAny;
    };
    var callKey0 = function (replicaOrAny, key) {
        return getKey(replicaOrAny, key).call(replicaOrAny);
    };
    var callKey1 = function (replicaOrAny, key, a1) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1);
    };
    var callKey2 = function (replicaOrAny, key, a1, a2) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2);
    };
    var callKey3 = function (replicaOrAny, key, a1, a2, a3) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2, a3);
    };
    var callKey4 = function (replicaOrAny, key, a1, a2, a3, a4) {
        return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2, a3, a4);
    };
    var callKey = function (replicaOrAny, key) {
        var fn = getKey(replicaOrAny, key);
        var l = arguments.length;
        var args = [];
        for (var i = 2; i < l; i++) {
            args[i - 2] = arguments[i];
        }
        return fn.apply(replicaOrAny, args);
    };
    var setKey = function (replicaOrAny, key, newValue) {
        return replicaOrAny._ES5ProxyType ?
            replicaOrAny.set(key, newValue) :
            replicaOrAny[key] = newValue;
    };
    var setKeyPostfixIncrement = function (replicaOrAny, key) {
        var originalValue = getKey(replicaOrAny, key);
        setKey(replicaOrAny, key, originalValue + 1);
        return originalValue;
    };
    var setKeyPostfixDecrement = function (replicaOrAny, key) {
        var originalValue = getKey(replicaOrAny, key);
        setKey(replicaOrAny, key, originalValue - 1);
        return originalValue;
    };
    var deleteKey = function (replicaOrAny, key) {
        if (replicaOrAny._ES5ProxyType) {
            return replicaOrAny.deleteProperty(key);
        }
        delete replicaOrAny[key];
    };
    var inKey = function (replicaOrAny, key) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.has(key);
        }
        return inOperator(replicaOrAny, key);
    };
    var iterableKey = function (replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.forIn();
        }
        return replicaOrAny;
    };
    function instanceOfKey(instance, Type) {
        var instanceIsCompatProxy = isCompatProxy(instance);
        if (!isCompatProxy(Type) && !instanceIsCompatProxy) {
            return instance instanceof Type;
        }
        // TODO: Once polyfills are transpiled to compat
        // We can probably remove the below check
        if (instanceIsCompatProxy) {
            return defaultHasInstance(instance, Type);
        }
        return Type[Symbol.hasInstance](instance);
    }
    function concat(replicaOrAny) {
        var fn = getKey(replicaOrAny, 'concat');
        if (fn === Array.prototype.concat) {
            fn = concat$1;
        }
        var args = [];
        var l = arguments.length;
        for (var i = 1; i < l; i++) {
            args[i - 1] = arguments[i];
        }
        return fn.apply(replicaOrAny, args);
    }
    function hasOwnProperty$2(replicaOrAny) {
        var fn = getKey(replicaOrAny, 'hasOwnProperty');
        if (fn === hasOwnProperty) {
            fn = hasOwnProperty$1;
        }
        var args = [];
        var l = arguments.length;
        for (var i = 1; i < l; i++) {
            args[i - 1] = arguments[i];
        }
        return fn.apply(replicaOrAny, args);
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // https://tc39.github.io/ecma262/#sec-array.isarray
    // Important: The Array.isArray method is not dereferenced. This way it calls the polyfilled
    // version of it, even if the polyfill is applied after the proxy-compat evaluation.
    function isArray$1(replicaOrAny) {
        return isCompatProxy(replicaOrAny) ?
            replicaOrAny._ES5ProxyType === ProxyTypeArray :
            Array.isArray(replicaOrAny);
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.pop
    function pop() {
        // 1. Let O be ? ToObject(this value).
        var O = Object(this);
        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = O.length;
        // 3. If len is zero, then
        if (len === 0) {
            // a. Perform ? Set(O, "length", 0, true). noop
            // b. Return undefined.
            return undefined;
            // 4. Else len > 0,
        }
        else if (len > 0) {
            // a. Let newLen be len-1.
            var newLen = len - 1;
            // b. Let index be ! ToString(newLen).
            var index = newLen;
            // c. Let element be ? Get(O, index).
            var element = getKey(O, index);
            // d. Perform ? DeletePropertyOrThrow(O, index).
            deleteKey(O, index);
            // e. Perform ? Set(O, "length", newLen, true).
            setKey(O, 'length', newLen);
            // f. Return element.
            return element;
        }
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.push
    function push() {
        var O = Object(this);
        var n = O.length;
        var items = ArraySlice.call(arguments);
        while (items.length) {
            var E = ArrayShift.call(items);
            setKey(O, n, E);
            n += 1;
        }
        setKey(O, 'length', n);
        return O.length;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.concat
    function concat$1() {
        var O = Object(this);
        var A = [];
        var N = 0;
        var items = ArraySlice.call(arguments);
        ArrayUnshift.call(items, O);
        while (items.length) {
            var E = ArrayShift.call(items);
            if (isArray$1(E)) {
                var k = 0;
                var length = E.length;
                for (k; k < length; k += 1, N += 1) {
                    var subElement = getKey(E, k);
                    A[N] = subElement;
                }
            }
            else {
                A[N] = E;
                N += 1;
            }
        }
        return A;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.shift
    function shift() {
        // 1. Let O be ? ToObject(this value).
        var O = Object(this);
        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = O.length;
        // 3. If len is zero, then
        if (len === 0) {
            // a. Perform ? Set(O, "length", 0, true). noop
            // b. Return undefined.
            return undefined;
        }
        // 4. Let first be ? Get(O, "0").
        var first = getKey(O, 0);
        // 5. Let k be 1.
        var k = 1;
        // 6. Repeat, while k < len
        while (k < len) {
            // a. Let from be ! ToString(k).
            var from = k;
            // b. Let to be ! ToString(k-1).
            var to = k - 1;
            // c. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = hasOwnProperty$1.call(O, from);
            // d. If fromPresent is true, then
            if (fromPresent) {
                // i. Let fromVal be ? Get(O, from).
                var fromVal = getKey(O, from);
                // ii. Perform ? Set(O, to, fromVal, true).
                setKey(O, to, fromVal);
            }
            else { // e. Else fromPresent is false,
                // i. Perform ? DeletePropertyOrThrow(O, to).
                deleteKey(O, to);
            }
            // f. Increase k by 1.
            k += 1;
        }
        // 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len-1)).
        deleteKey(O, len - 1);
        // 8. Perform ? Set(O, "length", len-1, true).
        setKey(O, 'length', len - 1);
        // 9. Return first.
        return first;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.unshift
    function unshift() {
        var O = Object(this);
        var len = O.length;
        var argCount = arguments.length;
        var k = len;
        while (k > 0) {
            var from = k - 1;
            var to = k + argCount - 1;
            var fromPresent = hasOwnProperty$1.call(O, from);
            if (fromPresent) {
                var fromValue = O[from];
                setKey(O, to, fromValue);
            }
            else {
                deleteKey(O, to);
            }
            k -= 1;
        }
        var j = 0;
        var items = ArraySlice.call(arguments);
        while (items.length) {
            var E = ArrayShift.call(items);
            setKey(O, j, E);
            j += 1;
        }
        O.length = len + argCount;
        return O.length;
    }
    // http://www.ecma-international.org/ecma-262/#sec-array.prototype.splice
    function splice(start, deleteCount) {
        var argLength = arguments.length;
        // 1. Let O be ? ToObject(this value).
        var O = Object(this);
        // 2. Let len be ? ToLength(? Get(O, "length")).
        var len = O.length;
        // 3. Let relativeStart be ? ToInteger(start).
        var relativeStart = start;
        // 4. If relativeStart < 0, let actualStart be max((len + relativeStart), 0);
        // else let actualStart be min(relativeStart, len).
        var actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        var actualDeleteCount;
        // 5. If the number of actual arguments is 0, then
        if (argLength === 0) {
            // a. Let insertCount be 0.
            // insertCount = 0 // not needed
            // b. Let actualDeleteCount be 0.
            actualDeleteCount = 0;
        }
        else if (argLength === 1) {
            // 6. Else if the number of actual arguments is 1, then
            // a. Let insertCount be 0.
            // insertCount = 0 // not needed
            // b. Let actualDeleteCount be len - actualStart.
            actualDeleteCount = len - actualStart;
        }
        else {
            // 7. Else,
            // a. Let insertCount be the number of actual arguments minus 2.
            // insertCount = argLength - 2; //not neede
            // b. Let dc be ? ToInteger(deleteCount).
            var dc = deleteCount;
            // c. Let actualDeleteCount be min(max(dc, 0), len - actualStart).
            actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
        }
        // 8. If len+insertCount-actualDeleteCount > 2^53-1, throw a TypeError exception
        // (noop)
        // 9. Let A be ? ArraySpeciesCreate(O, actualDeleteCount).
        var A = [];
        // 10. Let k be 0.
        var k = 0;
        // 11. Repeat, while k < actualDeleteCount
        while (k < actualDeleteCount) {
            // a. Let from be ! ToString(actualStart+k).
            var from = actualStart + k;
            // b. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = hasOwnProperty$1.call(O, from);
            // c. If fromPresent is true, then
            if (fromPresent) {
                // i. Let fromValue be ? Get(O, from).
                var fromValue = O[from];
                // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue).
                A[k] = fromValue;
            }
            // d. Increment k by 1.
            k++;
        }
        // 12. Perform ? Set(A, "length", actualDeleteCount, true).
        // A.length = actualDeleteCount;
        // 13. Let items be a List whose elements are, in left to right order, the portion of the actual argument
        //     list starting with the third argument. The list is empty if fewer than three arguments were passed.
        var items = ArraySlice.call(arguments, 2) || [];
        // 14. Let itemCount be the number of elements in items.
        var itemCount = items.length;
        // 15. If itemCount < actualDeleteCount, then
        if (itemCount < actualDeleteCount) {
            // a. Let k be actualStart.
            k = actualStart;
            // b. Repeat, while k < (len - actualDeleteCount)
            while (k < len - actualDeleteCount) {
                // i. Let from be ! ToString(k+actualDeleteCount).
                var from = k + actualDeleteCount;
                // ii. Let to be ! ToString(k+itemCount).
                var to = k + itemCount;
                // iii. Let fromPresent be ? HasProperty(O, from).
                var fromPresent = hasOwnProperty$1.call(O, from);
                // iv. If fromPresent is true, then
                if (fromPresent) {
                    // 1. Let fromValue be ? Get(O, from).
                    var fromValue = O[from];
                    // 2. Perform ? Set(O, to, fromValue, true).
                    setKey(O, to, fromValue);
                }
                else {
                    // v. Else fromPresent is false,
                    // 1. Perform ? DeletePropertyOrThrow(O, to).
                    deleteKey(O, to);
                }
                // vi. Increase k by 1.
                k++;
            }
            // c. Let k be len.
            k = len;
            // d. Repeat, while k > (len - actualDeleteCount + itemCount)
            while (k > len - actualDeleteCount + itemCount) {
                // i. Perform ? DeletePropertyOrThrow(O, ! ToString(k-1)).
                deleteKey(O, k - 1);
                // ii. Decrease k by 1.
                k--;
            }
        }
        else if (itemCount > actualDeleteCount) {
            // 16. Else if itemCount > actualDeleteCount, then
            // a. Let k be (len - actualDeleteCount).
            k = len - actualDeleteCount;
            // b. Repeat, while k > actualStart
            while (k > actualStart) {
                // i. Let from be ! ToString(k + actualDeleteCount - 1).
                var from = k + actualDeleteCount - 1;
                // ii. Let to be ! ToString(k + itemCount - 1).
                var to = k + itemCount - 1;
                // iii. Let fromPresent be ? HasProperty(O, from).
                var fromPresent = hasOwnProperty$1.call(O, from);
                // iv. If fromPresent is true, then
                if (fromPresent) {
                    // 1. Let fromValue be ? Get(O, from).
                    var fromValue = O[from];
                    // 2. Perform ? Set(O, to, fromValue, true).
                    setKey(O, to, fromValue);
                }
                else {
                    // v. Else fromPresent is false,
                    // 1. Perform ? DeletePropertyOrThrow(O, to).
                    deleteKey(O, to);
                }
                // vi. Decrease k by 1.
                k--;
            }
        }
        // 17. Let k be actualStart.
        k = actualStart;
        // 18. Repeat, while items is not empty
        while (items.length) {
            // a. Remove the first element from items and let E be the value of that element.
            var E = items.shift();
            // b. Perform ? Set(O, ! ToString(k), E, true).
            setKey(O, k, E);
            // c. Increase k by 1.
            k++;
        }
        // 19. Perform ? Set(O, "length", len - actualDeleteCount + itemCount, true).
        setKey(O, 'length', len - actualDeleteCount + itemCount);
        // 20. Return A.
        return A;
    }

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getPrototypeOf$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.getPrototypeOf();
        }
        return getPrototypeOf(replicaOrAny);
    }
    function setPrototypeOf$1(replicaOrAny, proto) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.setPrototypeOf(proto);
        }
        return setPrototypeOf(replicaOrAny, proto);
    }
    function preventExtensions$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.preventExtensions();
        }
        return preventExtensions(replicaOrAny);
    }
    function isExtensible$1(replicaOrAny) {
        if (isCompatProxy(replicaOrAny)) {
            return replicaOrAny.isExtensible();
        }
        return isExtensible(replicaOrAny);
    }
    // Object patches
    // TODO: Instead of monkey patching, move all of these to be compatInstrinsicMethods
    // like the ones right below.
    Object.preventExtensions = preventExtensions$1;
    Object.getOwnPropertyNames = getOwnPropertyNames$1;
    Object.isExtensible = isExtensible$1;
    Object.setPrototypeOf = setPrototypeOf$1;
    Object.getPrototypeOf = getPrototypeOf$1;
    // We need to ensure that added compat methods are not-enumerable to avoid leaking
    // when using for ... in without guarding via Object.hasOwnProperty.
    Object.defineProperties(Object, {
        compatKeys: { value: keys$1, enumerable: false },
        compatValues: { value: values, enumerable: false },
        compatEntries: { value: entries, enumerable: false },
        compatDefineProperty: { value: defineProperty$1, enumerable: false },
        compatAssign: { value: assign, enumerable: false },
        compatGetOwnPropertyDescriptor: { value: getOwnPropertyDescriptor$1, enumerable: false }
    });
    Object.defineProperties(Object.prototype, {
        compatHasOwnProperty: { value: hasOwnProperty$1, enumerable: false }
    });
    // Array patches
    Object.defineProperties(Array, {
        compatIsArray: { value: isArray$1, enumerable: false }
    });
    Object.defineProperties(Array.prototype, {
        compatUnshift: { value: unshift, enumerable: false },
        compatConcat: { value: concat$1, enumerable: false },
        compatPush: { value: push, enumerable: false },
    });
    function overrideProxy() {
        return Proxy.__COMPAT__;
    }
    function makeGlobal(obj) {
        var global = (function () { return this; })() || Function('return this')();
        global.Proxy = obj;
    }
    // At this point Proxy can be the real Proxy (function) a noop-proxy (object with noop-keys) or undefined
    var FinalProxy = typeof Proxy !== 'undefined' ? Proxy : {};
    if (typeof FinalProxy !== 'function' || overrideProxy()) {
        FinalProxy = /** @class */ (function (_super) {
            __extends(Proxy, _super);
            function Proxy() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return Proxy;
        }(XProxy));
    }
    FinalProxy.isCompat = true;
    FinalProxy.getKey = getKey;
    FinalProxy.getKeys = getKeys;
    FinalProxy.getKeys2 = getKeys2;
    FinalProxy.getKeys3 = getKeys3;
    FinalProxy.getKeys4 = getKeys4;
    FinalProxy.callKey = callKey;
    FinalProxy.callKey0 = callKey0;
    FinalProxy.callKey1 = callKey1;
    FinalProxy.callKey2 = callKey2;
    FinalProxy.callKey3 = callKey3;
    FinalProxy.callKey4 = callKey4;
    FinalProxy.setKey = setKey;
    FinalProxy.setKeyPostfixIncrement = setKeyPostfixIncrement;
    FinalProxy.setKeyPostfixDecrement = setKeyPostfixDecrement;
    FinalProxy.deleteKey = deleteKey;
    FinalProxy.inKey = inKey;
    FinalProxy.iterableKey = iterableKey;
    FinalProxy.instanceOfKey = instanceOfKey;
    FinalProxy.concat = concat;
    FinalProxy.hasOwnProperty = hasOwnProperty$2;
    if (typeof Proxy === 'undefined') {
        makeGlobal(FinalProxy);
    }
    var FinalProxy$1 = FinalProxy;

    return FinalProxy$1;

}));

}());

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 75);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(14);
var hide = __webpack_require__(11);
var redefine = __webpack_require__(8);
var ctx = __webpack_require__(12);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(54)('wks');
var uid = __webpack_require__(20);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(4)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(7);
var IE8_DOM_DEFINE = __webpack_require__(49);
var toPrimitive = __webpack_require__(18);
var dP = Object.defineProperty;

exports.f = __webpack_require__(5) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(11);
var has = __webpack_require__(9);
var SRC = __webpack_require__(20)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(14).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 9 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var createDesc = __webpack_require__(33);
module.exports = __webpack_require__(5) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(21);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(34);
var defined = __webpack_require__(13);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(19);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(3);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 20 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(13);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(6).f;
var has = __webpack_require__(9);
var TAG = __webpack_require__(1)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(12);
var IObject = __webpack_require__(34);
var toObject = __webpack_require__(22);
var toLength = __webpack_require__(16);
var asc = __webpack_require__(110);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var dP = __webpack_require__(6);
var DESCRIPTORS = __webpack_require__(5);
var SPECIES = __webpack_require__(1)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(12);
var call = __webpack_require__(121);
var isArrayIter = __webpack_require__(122);
var anObject = __webpack_require__(7);
var toLength = __webpack_require__(16);
var getIterFn = __webpack_require__(123);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(8);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(20)('meta');
var isObject = __webpack_require__(3);
var has = __webpack_require__(9);
var setDesc = __webpack_require__(6).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(4)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(8);
var redefineAll = __webpack_require__(29);
var meta = __webpack_require__(30);
var forOf = __webpack_require__(28);
var anInstance = __webpack_require__(27);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(4);
var $iterDetect = __webpack_require__(71);
var setToStringTag = __webpack_require__(24);
var inheritIfRequired = __webpack_require__(39);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(10);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(54)('keys');
var uid = __webpack_require__(20);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(55);
var createDesc = __webpack_require__(33);
var toIObject = __webpack_require__(15);
var toPrimitive = __webpack_require__(18);
var has = __webpack_require__(9);
var IE8_DOM_DEFINE = __webpack_require__(49);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(5) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
var setPrototypeOf = __webpack_require__(84).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var defined = __webpack_require__(13);
var fails = __webpack_require__(4);
var spaces = __webpack_require__(41);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(7);
var dPs = __webpack_require__(50);
var enumBugKeys = __webpack_require__(37);
var IE_PROTO = __webpack_require__(35)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(32)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(58).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(64);
var defined = __webpack_require__(13);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(1)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(36);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(8);
var hide = __webpack_require__(11);
var Iterators = __webpack_require__(23);
var $iterCreate = __webpack_require__(107);
var setToStringTag = __webpack_require__(24);
var getPrototypeOf = __webpack_require__(56);
var ITERATOR = __webpack_require__(1)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(1)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(11)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(7);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(11);
var redefine = __webpack_require__(8);
var fails = __webpack_require__(4);
var defined = __webpack_require__(13);
var wks = __webpack_require__(1);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(5) && !__webpack_require__(4)(function () {
  return Object.defineProperty(__webpack_require__(32)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6);
var anObject = __webpack_require__(7);
var getKeys = __webpack_require__(51);

module.exports = __webpack_require__(5) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(52);
var enumBugKeys = __webpack_require__(37);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(9);
var toIObject = __webpack_require__(15);
var arrayIndexOf = __webpack_require__(78)(false);
var IE_PROTO = __webpack_require__(35)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(19);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(14);
var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(36) ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 55 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(9);
var toObject = __webpack_require__(22);
var IE_PROTO = __webpack_require__(35)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(52);
var hiddenKeys = __webpack_require__(37).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(19);
var defined = __webpack_require__(13);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(3);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat;
var $trim = __webpack_require__(40).trim;

module.exports = 1 / $parseFloat(__webpack_require__(41) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt;
var $trim = __webpack_require__(40).trim;
var ws = __webpack_require__(41);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(19);
var defined = __webpack_require__(13);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(3);
var cof = __webpack_require__(10);
var MATCH = __webpack_require__(1)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(10);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(5) && /./g.flags != 'g') __webpack_require__(6).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(47)
});


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(10);
var TAG = __webpack_require__(1)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(12);
var invoke = __webpack_require__(125);
var html = __webpack_require__(58);
var cel = __webpack_require__(32);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(10)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(21);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(1)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(51);
var gOPS = __webpack_require__(131);
var pIE = __webpack_require__(55);
var toObject = __webpack_require__(22);
var IObject = __webpack_require__(34);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(4)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(29);
var getWeak = __webpack_require__(30).getWeak;
var anObject = __webpack_require__(7);
var isObject = __webpack_require__(3);
var anInstance = __webpack_require__(27);
var forOf = __webpack_require__(28);
var createArrayMethod = __webpack_require__(25);
var $has = __webpack_require__(9);
var validate = __webpack_require__(17);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(6).f;
var create = __webpack_require__(42);
var redefineAll = __webpack_require__(29);
var ctx = __webpack_require__(12);
var anInstance = __webpack_require__(27);
var forOf = __webpack_require__(28);
var $iterDefine = __webpack_require__(45);
var step = __webpack_require__(66);
var setSpecies = __webpack_require__(26);
var DESCRIPTORS = __webpack_require__(5);
var fastKey = __webpack_require__(30).fastKey;
var validate = __webpack_require__(17);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(76);
__webpack_require__(77);
__webpack_require__(79);
__webpack_require__(81);
__webpack_require__(82);
__webpack_require__(83);
__webpack_require__(85);
__webpack_require__(87);
__webpack_require__(88);
__webpack_require__(89);
__webpack_require__(90);
__webpack_require__(91);
__webpack_require__(92);
__webpack_require__(93);
__webpack_require__(94);
__webpack_require__(95);
__webpack_require__(96);
__webpack_require__(97);
__webpack_require__(98);
__webpack_require__(99);
__webpack_require__(100);
__webpack_require__(101);
__webpack_require__(102);
__webpack_require__(103);
__webpack_require__(104);
__webpack_require__(105);
__webpack_require__(106);
__webpack_require__(108);
__webpack_require__(109);
__webpack_require__(112);
__webpack_require__(113);
__webpack_require__(114);
__webpack_require__(115);
__webpack_require__(116);
__webpack_require__(67);
__webpack_require__(117);
__webpack_require__(118);
__webpack_require__(119);
__webpack_require__(120);
__webpack_require__(130);
__webpack_require__(132);
__webpack_require__(133);
__webpack_require__(134);
__webpack_require__(136);
__webpack_require__(137);
__webpack_require__(139);
__webpack_require__(140);
__webpack_require__(141);
module.exports = __webpack_require__(142);


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(5), 'Object', { defineProperty: __webpack_require__(6).f });


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(5), 'Object', { defineProperties: __webpack_require__(50) });


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(15);
var toLength = __webpack_require__(16);
var toAbsoluteIndex = __webpack_require__(53);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(15);
var $getOwnPropertyDescriptor = __webpack_require__(38).f;

__webpack_require__(80)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(14);
var fails = __webpack_require__(4);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(6).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(5) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(3);
var getPrototypeOf = __webpack_require__(56);
var HAS_INSTANCE = __webpack_require__(1)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(6).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var has = __webpack_require__(9);
var cof = __webpack_require__(10);
var inheritIfRequired = __webpack_require__(39);
var toPrimitive = __webpack_require__(18);
var fails = __webpack_require__(4);
var gOPN = __webpack_require__(57).f;
var gOPD = __webpack_require__(38).f;
var dP = __webpack_require__(6).f;
var $trim = __webpack_require__(40).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(42)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(5) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(8)(global, NUMBER, $Number);
}


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(3);
var anObject = __webpack_require__(7);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(12)(Function.call, __webpack_require__(38).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toInteger = __webpack_require__(19);
var aNumberValue = __webpack_require__(86);
var repeat = __webpack_require__(59);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(4)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(10);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(60) });


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(60);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(61);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(62);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(62);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(61);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(53);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(15);
var toLength = __webpack_require__(16);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $at = __webpack_require__(63)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(16);
var context = __webpack_require__(43);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(44)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(43);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(44)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(59)
});


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(16);
var context = __webpack_require__(43);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(44)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(63)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(45)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(42);
var descriptor = __webpack_require__(33);
var setToStringTag = __webpack_require__(24);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(11)(IteratorPrototype, __webpack_require__(1)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(65) });


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(25)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(46)(KEY);


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(111);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(3);
var isArray = __webpack_require__(65);
var SPECIES = __webpack_require__(1)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(25)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(46)(KEY);


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(46);
var step = __webpack_require__(66);
var Iterators = __webpack_require__(23);
var toIObject = __webpack_require__(15);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(45)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(26)('Array');


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var inheritIfRequired = __webpack_require__(39);
var dP = __webpack_require__(6).f;
var gOPN = __webpack_require__(57).f;
var isRegExp = __webpack_require__(64);
var $flags = __webpack_require__(47);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(5) && (!CORRECT_NEW || __webpack_require__(4)(function () {
  re2[__webpack_require__(1)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(8)(global, 'RegExp', $RegExp);
}

__webpack_require__(26)('RegExp');


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(67);
var anObject = __webpack_require__(7);
var $flags = __webpack_require__(47);
var DESCRIPTORS = __webpack_require__(5);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(8)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(4)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(48)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(48)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(48)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(36);
var global = __webpack_require__(2);
var ctx = __webpack_require__(12);
var classof = __webpack_require__(68);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(3);
var aFunction = __webpack_require__(21);
var anInstance = __webpack_require__(27);
var forOf = __webpack_require__(28);
var speciesConstructor = __webpack_require__(124);
var task = __webpack_require__(69).set;
var microtask = __webpack_require__(126)();
var newPromiseCapabilityModule = __webpack_require__(70);
var perform = __webpack_require__(127);
var userAgent = __webpack_require__(128);
var promiseResolve = __webpack_require__(129);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(1)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(29)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(24)($Promise, PROMISE);
__webpack_require__(26)(PROMISE);
Wrapper = __webpack_require__(14)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(71)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(7);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(23);
var ITERATOR = __webpack_require__(1)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(68);
var ITERATOR = __webpack_require__(1)('iterator');
var Iterators = __webpack_require__(23);
module.exports = __webpack_require__(14).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(7);
var aFunction = __webpack_require__(21);
var SPECIES = __webpack_require__(1)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 125 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(69).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(10)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 127 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(7);
var isObject = __webpack_require__(3);
var newPromiseCapability = __webpack_require__(70);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(72) });


/***/ }),
/* 131 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(22);
var toPrimitive = __webpack_require__(18);

$export($export.P + $export.F * __webpack_require__(4)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(135);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(4);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(8)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(1)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(138));


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(7);
var toPrimitive = __webpack_require__(18);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(25)(0);
var redefine = __webpack_require__(8);
var meta = __webpack_require__(30);
var assign = __webpack_require__(72);
var weak = __webpack_require__(73);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(4);
var validate = __webpack_require__(17);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(31)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(73);
var validate = __webpack_require__(17);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(31)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(74);
var validate = __webpack_require__(17);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(31)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(74);
var validate = __webpack_require__(17);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(31)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ })
/******/ ]);/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ../proxy-compat/setKey.js
/* harmony default export */ var setKey = (Proxy.setKey);
// CONCATENATED MODULE: ../proxy-compat/callKey4.js
/* harmony default export */ var callKey4 = (Proxy.callKey4);
// CONCATENATED MODULE: ../proxy-compat/callKey2.js
/* harmony default export */ var callKey2 = (Proxy.callKey2);
// CONCATENATED MODULE: ../proxy-compat/callKey1.js
/* harmony default export */ var callKey1 = (Proxy.callKey1);
// CONCATENATED MODULE: ../proxy-compat/iterableKey.js
/* harmony default export */ var iterableKey = (Proxy.iterableKey);
// CONCATENATED MODULE: ../proxy-compat/callKey3.js
/* harmony default export */ var callKey3 = (Proxy.callKey3);
// CONCATENATED MODULE: ../proxy-compat/inKey.js
/* harmony default export */ var inKey = (Proxy.inKey);
// CONCATENATED MODULE: ../proxy-compat/concat.js
/* harmony default export */ var concat = (Proxy.concat);
// CONCATENATED MODULE: ../proxy-compat/deleteKey.js
/* harmony default export */ var deleteKey = (Proxy.deleteKey);
// CONCATENATED MODULE: ../proxy-compat/callKey0.js
/* harmony default export */ var callKey0 = (Proxy.callKey0);
// CONCATENATED MODULE: ../proxy-compat/instanceOfKey.js
/* harmony default export */ var instanceOfKey = (Proxy.instanceOfKey);
// CONCATENATED MODULE: ./dist/ecma-polyfills.compat.js












/******/
(function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules._ES5ProxyType ? installedModules.get(moduleId) : installedModules[moduleId]) {
      var _moduleId, _exports;

      /******/
      return _moduleId = installedModules._ES5ProxyType ? installedModules.get(moduleId) : installedModules[moduleId], _exports = _moduleId._ES5ProxyType ? _moduleId.get("exports") : _moduleId.exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = setKey(installedModules, moduleId, {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    });
    /******/

    /******/
    // Execute the module function

    /******/


    callKey4(modules._ES5ProxyType ? modules.get(moduleId) : modules[moduleId], "call", module._ES5ProxyType ? module.get("exports") : module.exports, module, module._ES5ProxyType ? module.get("exports") : module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/


    setKey(module, "l", true);
    /******/

    /******/
    // Return the exports of the module

    /******/


    return module._ES5ProxyType ? module.get("exports") : module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  setKey(__webpack_require__, "m", modules);
  /******/

  /******/
  // expose the module cache

  /******/


  setKey(__webpack_require__, "c", installedModules);
  /******/

  /******/
  // define getter function for harmony exports

  /******/


  setKey(__webpack_require__, "d", function (exports, name, getter) {
    /******/
    if (!callKey2(__webpack_require__, "o", exports, name)) {
      /******/
      Object.compatDefineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  });
  /******/

  /******/
  // define __esModule on exports

  /******/


  setKey(__webpack_require__, "r", function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.compatDefineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.compatDefineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  });
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  setKey(__webpack_require__, "t", function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && typeof value === 'object' && value && (value._ES5ProxyType ? value.get("__esModule") : value.__esModule)) return value;
    /******/

    var ns = Object.create(null);
    /******/

    callKey1(__webpack_require__, "r", ns);
    /******/


    Object.compatDefineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in iterableKey(value)) callKey3(__webpack_require__, "d", ns, key, callKey2(function (key) {
      return value._ES5ProxyType ? value.get(key) : value[key];
    }, "bind", null, key));
    /******/

    return ns;
    /******/
  });
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  setKey(__webpack_require__, "n", function (module) {
    /******/
    var getter = module && (module._ES5ProxyType ? module.get("__esModule") : module.__esModule) ?
    /******/
    function getDefault() {
      return module._ES5ProxyType ? module.get('default') : module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    callKey3(__webpack_require__, "d", getter, 'a', getter);
    /******/


    return getter;
    /******/
  });
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  setKey(__webpack_require__, "o", function (object, property) {
    return callKey2(Object.prototype._ES5ProxyType ? Object.prototype.get("compatHasOwnProperty") : Object.prototype.compatHasOwnProperty, "call", object, property);
  });
  /******/

  /******/
  // __webpack_public_path__

  /******/


  setKey(__webpack_require__, "p", "");
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/


  return __webpack_require__(setKey(__webpack_require__, "s", 44));
  /******/
})(
/************************************************************************/

/******/
[
/* 0 */

/***/
function (module, exports, __webpack_require__) {
  var global = __webpack_require__(2);

  var core = __webpack_require__(10);

  var hide = __webpack_require__(15);

  var redefine = __webpack_require__(33);

  var ctx = __webpack_require__(34);

  var PROTOTYPE = 'prototype';

  var $export = function (type, name, source) {
    var _ref, _PROTOTYPE;

    var IS_FORCED = type & ($export._ES5ProxyType ? $export.get("F") : $export.F);
    var IS_GLOBAL = type & ($export._ES5ProxyType ? $export.get("G") : $export.G);
    var IS_STATIC = type & ($export._ES5ProxyType ? $export.get("S") : $export.S);
    var IS_PROTO = type & ($export._ES5ProxyType ? $export.get("P") : $export.P);
    var IS_BIND = type & ($export._ES5ProxyType ? $export.get("B") : $export.B);
    var target = IS_GLOBAL ? global : IS_STATIC ? (global._ES5ProxyType ? global.get(name) : global[name]) || setKey(global, name, {}) : (_ref = (global._ES5ProxyType ? global.get(name) : global[name]) || {}, _PROTOTYPE = _ref._ES5ProxyType ? _ref.get(PROTOTYPE) : _ref[PROTOTYPE]);
    var exports = IS_GLOBAL ? core : (core._ES5ProxyType ? core.get(name) : core[name]) || setKey(core, name, {});

    var expProto = (exports._ES5ProxyType ? exports.get(PROTOTYPE) : exports[PROTOTYPE]) || setKey(exports, PROTOTYPE, {});

    var key, own, out, exp;
    if (IS_GLOBAL) source = name;

    for (key in iterableKey(source)) {
      var _ref2, _key;

      // contains in native
      own = !IS_FORCED && target && (target._ES5ProxyType ? target.get(key) : target[key]) !== undefined; // export native or passed

      out = (_ref2 = own ? target : source, _key = _ref2._ES5ProxyType ? _ref2.get(key) : _ref2[key]); // bind timers to global for call from export context

      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

      if (target) redefine(target, key, out, type & ($export._ES5ProxyType ? $export.get("U") : $export.U)); // export

      if ((exports._ES5ProxyType ? exports.get(key) : exports[key]) != out) hide(exports, key, exp);
      if (IS_PROTO && (expProto._ES5ProxyType ? expProto.get(key) : expProto[key]) != out) setKey(expProto, key, out);
    }
  };

  setKey(global, "core", core); // type bitmap


  setKey($export, "F", 1); // forced


  setKey($export, "G", 2); // global


  setKey($export, "S", 4); // static


  setKey($export, "P", 8); // proto


  setKey($export, "B", 16); // bind


  setKey($export, "W", 32); // wrap


  setKey($export, "U", 64); // safe


  setKey($export, "R", 128); // real proto method for `library`


  setKey(module, "exports", $export);
  /***/

},
/* 1 */

/***/
function (module, exports) {
  setKey(module, "exports", function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  });
  /***/

},
/* 2 */

/***/
function (module, exports) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = setKey(module, "exports", typeof window != 'undefined' && (window._ES5ProxyType ? window.get("Math") : window.Math) == Math ? window : typeof self != 'undefined' && (self._ES5ProxyType ? self.get("Math") : self.Math) == Math ? self // eslint-disable-next-line no-new-func
  : Function('return this')());

  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

  /***/
},
/* 3 */

/***/
function (module, exports, __webpack_require__) {
  // most Object methods by ES6 should accept primitives
  var $export = __webpack_require__(0);

  var core = __webpack_require__(10);

  var fails = __webpack_require__(9);

  setKey(module, "exports", function (KEY, exec) {
    var _ref3, _KEY;

    var fn = (_ref3 = (core._ES5ProxyType ? core.get("Object") : core.Object) || {}, _KEY = _ref3._ES5ProxyType ? _ref3.get(KEY) : _ref3[KEY]) || Object[KEY];
    var exp = {};

    setKey(exp, KEY, exec(fn));

    $export(($export._ES5ProxyType ? $export.get("S") : $export.S) + ($export._ES5ProxyType ? $export.get("F") : $export.F) * fails(function () {
      fn(1);
    }), 'Object', exp);
  });
  /***/

},
/* 4 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__, _Symbol;

  var store = __webpack_require__(21)('wks');

  var uid = __webpack_require__(13);

  var Symbol = (_webpack_require__ = __webpack_require__(2), _Symbol = _webpack_require__._ES5ProxyType ? _webpack_require__.get("Symbol") : _webpack_require__.Symbol);
  var USE_SYMBOL = typeof Symbol == 'function';

  var $exports = setKey(module, "exports", function (name) {
    return (store._ES5ProxyType ? store.get(name) : store[name]) || setKey(store, name, USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
  });

  setKey($exports, "store", store);
  /***/

},
/* 5 */

/***/
function (module, exports) {
  var _ref4, _compatHasOwnProperty;

  var hasOwnProperty = (_ref4 = {}, _compatHasOwnProperty = _ref4._ES5ProxyType ? _ref4.get("compatHasOwnProperty") : _ref4.compatHasOwnProperty);

  setKey(module, "exports", function (it, key) {
    return callKey2(hasOwnProperty, "call", it, key);
  });
  /***/

},
/* 6 */

/***/
function (module, exports, __webpack_require__) {
  var anObject = __webpack_require__(11);

  var IE8_DOM_DEFINE = __webpack_require__(31);

  var toPrimitive = __webpack_require__(20);

  var dP = Object.compatDefineProperty;

  setKey(exports, "f", __webpack_require__(8) ? Object.compatDefineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
      return dP(O, P, Attributes);
    } catch (e) {
      /* empty */
    }
    if (inKey(Attributes, 'get') || inKey(Attributes, 'set')) throw TypeError('Accessors not supported!');
    if (inKey(Attributes, 'value')) setKey(O, P, Attributes._ES5ProxyType ? Attributes.get("value") : Attributes.value);
    return O;
  });
  /***/

},
/* 7 */

/***/
function (module, exports, __webpack_require__) {
  // to indexed object, toObject with fallback for non-array-like ES3 strings
  var IObject = __webpack_require__(50);

  var defined = __webpack_require__(37);

  setKey(module, "exports", function (it) {
    return IObject(defined(it));
  });
  /***/

},
/* 8 */

/***/
function (module, exports, __webpack_require__) {
  // Thank's IE8 for his funny defineProperty
  setKey(module, "exports", !__webpack_require__(9)(function () {
    var _Object$compatDefineP, _a;

    return (_Object$compatDefineP = Object.compatDefineProperty({}, 'a', {
      get: function () {
        return 7;
      }
    }), _a = _Object$compatDefineP._ES5ProxyType ? _Object$compatDefineP.get("a") : _Object$compatDefineP.a) != 7;
  }));
  /***/

},
/* 9 */

/***/
function (module, exports) {
  setKey(module, "exports", function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  });
  /***/

},
/* 10 */

/***/
function (module, exports) {
  var core = setKey(module, "exports", {
    version: '2.5.7'
  });

  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

  /***/
},
/* 11 */

/***/
function (module, exports, __webpack_require__) {
  var isObject = __webpack_require__(1);

  setKey(module, "exports", function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  });
  /***/

},
/* 12 */

/***/
function (module, exports, __webpack_require__) {
  // 7.1.13 ToObject(argument)
  var defined = __webpack_require__(37);

  setKey(module, "exports", function (it) {
    return Object(defined(it));
  });
  /***/

},
/* 13 */

/***/
function (module, exports) {
  var id = 0;
  var px = Math.random();

  setKey(module, "exports", function (key) {
    return concat('Symbol(', key === undefined ? '' : key, ')_', callKey1(++id + px, "toString", 36));
  });
  /***/

},
/* 14 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var $keys = __webpack_require__(36);

  var enumBugKeys = __webpack_require__(26);

  setKey(module, "exports", Object.compatKeys || function keys(O) {
    return $keys(O, enumBugKeys);
  });
  /***/

},
/* 15 */

/***/
function (module, exports, __webpack_require__) {
  var dP = __webpack_require__(6);

  var createDesc = __webpack_require__(16);

  setKey(module, "exports", __webpack_require__(8) ? function (object, key, value) {
    return callKey3(dP, "f", object, key, createDesc(1, value));
  } : function (object, key, value) {
    setKey(object, key, value);

    return object;
  });
  /***/

},
/* 16 */

/***/
function (module, exports) {
  setKey(module, "exports", function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  });
  /***/

},
/* 17 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__2, _f;

  var META = __webpack_require__(13)('meta');

  var isObject = __webpack_require__(1);

  var has = __webpack_require__(5);

  var setDesc = (_webpack_require__2 = __webpack_require__(6), _f = _webpack_require__2._ES5ProxyType ? _webpack_require__2.get("f") : _webpack_require__2.f);
  var id = 0;

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var FREEZE = !__webpack_require__(9)(function () {
    return isExtensible(Object.preventExtensions({}));
  });

  var setMeta = function (it) {
    setDesc(it, META, {
      value: {
        i: 'O' + ++id,
        // object ID
        w: {} // weak collections IDs

      }
    });
  };

  var fastKey = function (it, create) {
    var _META, _i;

    // return primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMeta(it); // return object ID
    }

    return _META = it._ES5ProxyType ? it.get(META) : it[META], _i = _META._ES5ProxyType ? _META.get("i") : _META.i;
  };

  var getWeak = function (it, create) {
    var _META2, _w;

    if (!has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMeta(it); // return hash weak collections IDs
    }

    return _META2 = it._ES5ProxyType ? it.get(META) : it[META], _w = _META2._ES5ProxyType ? _META2.get("w") : _META2.w;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function (it) {
    if (FREEZE && (meta._ES5ProxyType ? meta.get("NEED") : meta.NEED) && isExtensible(it) && !has(it, META)) setMeta(it);
    return it;
  };

  var meta = setKey(module, "exports", {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  });
  /***/

},
/* 18 */

/***/
function (module, exports, __webpack_require__) {
  // 7.1.15 ToLength
  var toInteger = __webpack_require__(39);

  var min = Math.min;

  setKey(module, "exports", function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
  });
  /***/

},
/* 19 */

/***/
function (module, exports) {
  var _ref5, _propertyIsEnumerable;

  setKey(exports, "f", (_ref5 = {}, _propertyIsEnumerable = _ref5._ES5ProxyType ? _ref5.get("propertyIsEnumerable") : _ref5.propertyIsEnumerable));
  /***/

},
/* 20 */

/***/
function (module, exports, __webpack_require__) {
  // 7.1.1 ToPrimitive(input [, PreferredType])
  var isObject = __webpack_require__(1); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string


  setKey(module, "exports", function (it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it._ES5ProxyType ? it.get("toString") : it.toString) == 'function' && !isObject(val = callKey1(fn, "call", it))) return val;
    if (typeof (fn = it._ES5ProxyType ? it.get("valueOf") : it.valueOf) == 'function' && !isObject(val = callKey1(fn, "call", it))) return val;
    if (!S && typeof (fn = it._ES5ProxyType ? it.get("toString") : it.toString) == 'function' && !isObject(val = callKey1(fn, "call", it))) return val;
    throw TypeError("Can't convert object to primitive value");
  });
  /***/

},
/* 21 */

/***/
function (module, exports, __webpack_require__) {
  var core = __webpack_require__(10);

  var global = __webpack_require__(2);

  var SHARED = '__core-js_shared__';

  var store = (global._ES5ProxyType ? global.get(SHARED) : global[SHARED]) || setKey(global, SHARED, {});

  setKey(module, "exports", function (key, value) {
    return (store._ES5ProxyType ? store.get(key) : store[key]) || setKey(store, key, value !== undefined ? value : {});
  })('versions', []).push({
    version: core._ES5ProxyType ? core.get("version") : core.version,
    mode: __webpack_require__(22) ? 'pure' : 'global',
    copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
  });
  /***/

},
/* 22 */

/***/
function (module, exports) {
  setKey(module, "exports", false);
  /***/

},
/* 23 */

/***/
function (module, exports) {
  var _ref6, _toString;

  var toString = (_ref6 = {}, _toString = _ref6._ES5ProxyType ? _ref6.get("toString") : _ref6.toString);

  setKey(module, "exports", function (it) {
    return callKey2(callKey1(toString, "call", it), "slice", 8, -1);
  });
  /***/

},
/* 24 */

/***/
function (module, exports, __webpack_require__) {
  var toInteger = __webpack_require__(39);

  var max = Math.max;
  var min = Math.min;

  setKey(module, "exports", function (index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  });
  /***/

},
/* 25 */

/***/
function (module, exports, __webpack_require__) {
  var shared = __webpack_require__(21)('keys');

  var uid = __webpack_require__(13);

  setKey(module, "exports", function (key) {
    return (shared._ES5ProxyType ? shared.get(key) : shared[key]) || setKey(shared, key, uid(key));
  });
  /***/

},
/* 26 */

/***/
function (module, exports) {
  // IE 8- don't enum bug keys
  setKey(module, "exports", callKey1('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf', "split", ','));
  /***/

},
/* 27 */

/***/
function (module, exports) {
  setKey(exports, "f", Object.getOwnPropertySymbols);
  /***/

},
/* 28 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  var $keys = __webpack_require__(36);

  var hiddenKeys = concat(__webpack_require__(26), 'length', 'prototype');

  setKey(exports, "f", Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return $keys(O, hiddenKeys);
  });
  /***/

},
/* 29 */

/***/
function (module, exports, __webpack_require__) {
  "use strict";

  var $defineProperty = __webpack_require__(6);

  var createDesc = __webpack_require__(16);

  setKey(module, "exports", function (object, index, value) {
    if (inKey(object, index)) callKey3($defineProperty, "f", object, index, createDesc(0, value));else setKey(object, index, value);
  });
  /***/

},
/* 30 */

/***/
function (module, exports, __webpack_require__) {
  // 22.1.3.31 Array.prototype[@@unscopables]
  var UNSCOPABLES = __webpack_require__(4)('unscopables');

  var ArrayProto = Array.prototype;
  if ((ArrayProto._ES5ProxyType ? ArrayProto.get(UNSCOPABLES) : ArrayProto[UNSCOPABLES]) == undefined) __webpack_require__(15)(ArrayProto, UNSCOPABLES, {});

  setKey(module, "exports", function (key) {
    setKey(ArrayProto._ES5ProxyType ? ArrayProto.get(UNSCOPABLES) : ArrayProto[UNSCOPABLES], key, true);
  });
  /***/

},
/* 31 */

/***/
function (module, exports, __webpack_require__) {
  setKey(module, "exports", !__webpack_require__(8) && !__webpack_require__(9)(function () {
    var _Object$compatDefineP2, _a2;

    return (_Object$compatDefineP2 = Object.compatDefineProperty(__webpack_require__(32)('div'), 'a', {
      get: function () {
        return 7;
      }
    }), _a2 = _Object$compatDefineP2._ES5ProxyType ? _Object$compatDefineP2.get("a") : _Object$compatDefineP2.a) != 7;
  }));
  /***/

},
/* 32 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__3, _document;

  var isObject = __webpack_require__(1);

  var document = (_webpack_require__3 = __webpack_require__(2), _document = _webpack_require__3._ES5ProxyType ? _webpack_require__3.get("document") : _webpack_require__3.document); // typeof document.createElement is 'object' in old IE

  var is = isObject(document) && isObject(document._ES5ProxyType ? document.get("createElement") : document.createElement);

  setKey(module, "exports", function (it) {
    return is ? callKey1(document, "createElement", it) : {};
  });
  /***/

},
/* 33 */

/***/
function (module, exports, __webpack_require__) {
  var global = __webpack_require__(2);

  var hide = __webpack_require__(15);

  var has = __webpack_require__(5);

  var SRC = __webpack_require__(13)('src');

  var TO_STRING = 'toString';
  var $toString = Function[TO_STRING];

  var TPL = callKey1('' + $toString, "split", TO_STRING);

  setKey(__webpack_require__(10), "inspectSource", function (it) {
    return callKey1($toString, "call", it);
  });

  setKey(module, "exports", function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) has(val, 'name') || hide(val, 'name', key);
    if ((O._ES5ProxyType ? O.get(key) : O[key]) === val) return;
    if (isFunction) has(val, SRC) || hide(val, SRC, (O._ES5ProxyType ? O.get(key) : O[key]) ? '' + (O._ES5ProxyType ? O.get(key) : O[key]) : callKey1(TPL, "join", String(key)));

    if (O === global) {
      setKey(O, key, val);
    } else if (!safe) {
      deleteKey(O, key);

      hide(O, key, val);
    } else if (O._ES5ProxyType ? O.get(key) : O[key]) {
      setKey(O, key, val);
    } else {
      hide(O, key, val);
    } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && (this._ES5ProxyType ? this.get(SRC) : this[SRC]) || callKey1($toString, "call", this);
  });
  /***/

},
/* 34 */

/***/
function (module, exports, __webpack_require__) {
  // optional / simple context binding
  var aFunction = __webpack_require__(46);

  setKey(module, "exports", function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 1:
        return function (a) {
          return callKey2(fn, "call", that, a);
        };

      case 2:
        return function (a, b) {
          return callKey3(fn, "call", that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return callKey4(fn, "call", that, a, b, c);
        };
    }

    return function ()
    /* ...args */
    {
      return callKey2(fn, "apply", that, arguments);
    };
  });
  /***/

},
/* 35 */

/***/
function (module, exports, __webpack_require__) {
  setKey(exports, "f", __webpack_require__(4));
  /***/

},
/* 36 */

/***/
function (module, exports, __webpack_require__) {
  var has = __webpack_require__(5);

  var toIObject = __webpack_require__(7);

  var arrayIndexOf = __webpack_require__(38)(false);

  var IE_PROTO = __webpack_require__(25)('IE_PROTO');

  setKey(module, "exports", function (object, names) {
    var O = toIObject(object);
    var i = 0;
    var result = [];
    var key;

    for (key in iterableKey(O)) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys


    while ((names._ES5ProxyType ? names.get("length") : names.length) > i) {
      var _ref7, _ref8;

      if (has(O, key = (_ref7 = i++, _ref8 = names._ES5ProxyType ? names.get(_ref7) : names[_ref7]))) {
        ~arrayIndexOf(result, key) || result.push(key);
      }
    }

    return result;
  });
  /***/

},
/* 37 */

/***/
function (module, exports) {
  // 7.2.1 RequireObjectCoercible(argument)
  setKey(module, "exports", function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  });
  /***/

},
/* 38 */

/***/
function (module, exports, __webpack_require__) {
  // false -> Array#indexOf
  // true  -> Array#includes
  var toIObject = __webpack_require__(7);

  var toLength = __webpack_require__(18);

  var toAbsoluteIndex = __webpack_require__(24);

  setKey(module, "exports", function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIObject($this);
      var length = toLength(O._ES5ProxyType ? O.get("length") : O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare

      if (IS_INCLUDES && el != el) while (length > index) {
        var _ref9, _ref10;

        value = (_ref9 = index++, _ref10 = O._ES5ProxyType ? O.get(_ref9) : O[_ref9]); // eslint-disable-next-line no-self-compare

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) if (IS_INCLUDES || inKey(O, index)) {
        if ((O._ES5ProxyType ? O.get(index) : O[index]) === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  });
  /***/

},
/* 39 */

/***/
function (module, exports) {
  // 7.1.4 ToInteger
  var ceil = Math.ceil;
  var floor = Math.floor;

  setKey(module, "exports", function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  });
  /***/

},
/* 40 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__4, _f2, _ref11, _toString2;

  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  var toIObject = __webpack_require__(7);

  var gOPN = (_webpack_require__4 = __webpack_require__(28), _f2 = _webpack_require__4._ES5ProxyType ? _webpack_require__4.get("f") : _webpack_require__4.f);
  var toString = (_ref11 = {}, _toString2 = _ref11._ES5ProxyType ? _ref11.get("toString") : _ref11.toString);
  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return gOPN(it);
    } catch (e) {
      return callKey0(windowNames, "slice");
    }
  };

  setKey(module._ES5ProxyType ? module.get("exports") : module.exports, "f", function getOwnPropertyNames(it) {
    return windowNames && callKey1(toString, "call", it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
  });
  /***/

},
/* 41 */

/***/
function (module, exports, __webpack_require__) {
  var pIE = __webpack_require__(19);

  var createDesc = __webpack_require__(16);

  var toIObject = __webpack_require__(7);

  var toPrimitive = __webpack_require__(20);

  var has = __webpack_require__(5);

  var IE8_DOM_DEFINE = __webpack_require__(31);

  var gOPD = Object.compatGetOwnPropertyDescriptor;

  setKey(exports, "f", __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = toIObject(O);
    P = toPrimitive(P, true);
    if (IE8_DOM_DEFINE) try {
      return gOPD(O, P);
    } catch (e) {
      /* empty */
    }
    if (has(O, P)) return createDesc(!callKey2(pIE._ES5ProxyType ? pIE.get("f") : pIE.f, "call", O, P), O._ES5ProxyType ? O.get(P) : O[P]);
  });
  /***/

},
/* 42 */

/***/
function (module, exports) {
  setKey(module, "exports", {});
  /***/

},
/* 43 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__5, _f3;

  var getKeys = __webpack_require__(14);

  var toIObject = __webpack_require__(7);

  var isEnum = (_webpack_require__5 = __webpack_require__(19), _f3 = _webpack_require__5._ES5ProxyType ? _webpack_require__5.get("f") : _webpack_require__5.f);

  setKey(module, "exports", function (isEntries) {
    return function (it) {
      var O = toIObject(it);
      var keys = getKeys(O);
      var length = keys._ES5ProxyType ? keys.get("length") : keys.length;
      var i = 0;
      var result = [];
      var key;

      while (length > i) {
        var _ref12, _ref13;

        if (callKey2(isEnum, "call", O, key = (_ref12 = i++, _ref13 = keys._ES5ProxyType ? keys.get(_ref12) : keys[_ref12]))) {
          result.push(isEntries ? [key, O._ES5ProxyType ? O.get(key) : O[key]] : O._ES5ProxyType ? O.get(key) : O[key]);
        }
      }

      return result;
    };
  });
  /***/

},
/* 44 */

/***/
function (module, exports, __webpack_require__) {
  __webpack_require__(45);

  __webpack_require__(55);

  __webpack_require__(57);

  __webpack_require__(58);

  __webpack_require__(59);

  __webpack_require__(60);

  __webpack_require__(61);

  __webpack_require__(62);

  __webpack_require__(63);

  __webpack_require__(64);

  __webpack_require__(65);

  __webpack_require__(67);

  __webpack_require__(73);

  __webpack_require__(74);

  __webpack_require__(76);

  __webpack_require__(78);

  __webpack_require__(79);

  __webpack_require__(81);

  setKey(module, "exports", __webpack_require__(82));
  /***/

},
/* 45 */

/***/
function (module, exports, __webpack_require__) {
  "use strict"; // ECMAScript 6 symbols shim

  var _webpack_require__6, _KEY2, _ref14, _propertyIsEnumerable2, _PROTOTYPE2, _findChild, _PROTOTYPE3, _TO_PRIMITIVE, _PROTOTYPE4, _valueOf;

  var global = __webpack_require__(2);

  var has = __webpack_require__(5);

  var DESCRIPTORS = __webpack_require__(8);

  var $export = __webpack_require__(0);

  var redefine = __webpack_require__(33);

  var META = (_webpack_require__6 = __webpack_require__(17), _KEY2 = _webpack_require__6._ES5ProxyType ? _webpack_require__6.get("KEY") : _webpack_require__6.KEY);

  var $fails = __webpack_require__(9);

  var shared = __webpack_require__(21);

  var setToStringTag = __webpack_require__(47);

  var uid = __webpack_require__(13);

  var wks = __webpack_require__(4);

  var wksExt = __webpack_require__(35);

  var wksDefine = __webpack_require__(48);

  var enumKeys = __webpack_require__(49);

  var isArray = __webpack_require__(51);

  var anObject = __webpack_require__(11);

  var isObject = __webpack_require__(1);

  var toIObject = __webpack_require__(7);

  var toPrimitive = __webpack_require__(20);

  var createDesc = __webpack_require__(16);

  var _create = __webpack_require__(52);

  var gOPNExt = __webpack_require__(40);

  var $GOPD = __webpack_require__(41);

  var $DP = __webpack_require__(6);

  var $keys = __webpack_require__(14);

  var gOPD = $GOPD._ES5ProxyType ? $GOPD.get("f") : $GOPD.f;
  var dP = $DP._ES5ProxyType ? $DP.get("f") : $DP.f;
  var gOPN = gOPNExt._ES5ProxyType ? gOPNExt.get("f") : gOPNExt.f;
  var $Symbol = global._ES5ProxyType ? global.get("Symbol") : global.Symbol;
  var $JSON = global._ES5ProxyType ? global.get("JSON") : global.JSON;

  var _stringify = $JSON && ($JSON._ES5ProxyType ? $JSON.get("stringify") : $JSON.stringify);

  var PROTOTYPE = 'prototype';
  var HIDDEN = wks('_hidden');
  var TO_PRIMITIVE = wks('toPrimitive');
  var isEnum = (_ref14 = {}, _propertyIsEnumerable2 = _ref14._ES5ProxyType ? _ref14.get("propertyIsEnumerable") : _ref14.propertyIsEnumerable);
  var SymbolRegistry = shared('symbol-registry');
  var AllSymbols = shared('symbols');
  var OPSymbols = shared('op-symbols');
  var ObjectProto = Object[PROTOTYPE];
  var USE_NATIVE = typeof $Symbol == 'function';
  var QObject = global._ES5ProxyType ? global.get("QObject") : global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

  var setter = !QObject || !(QObject._ES5ProxyType ? QObject.get(PROTOTYPE) : QObject[PROTOTYPE]) || !(_PROTOTYPE2 = QObject._ES5ProxyType ? QObject.get(PROTOTYPE) : QObject[PROTOTYPE], _findChild = _PROTOTYPE2._ES5ProxyType ? _PROTOTYPE2.get("findChild") : _PROTOTYPE2.findChild); // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

  var setSymbolDesc = DESCRIPTORS && $fails(function () {
    var _create2, _a3;

    return (_create2 = _create(dP({}, 'a', {
      get: function () {
        var _dP, _a4;

        return _dP = dP(this, 'a', {
          value: 7
        }), _a4 = _dP._ES5ProxyType ? _dP.get("a") : _dP.a;
      }
    })), _a3 = _create2._ES5ProxyType ? _create2.get("a") : _create2.a) != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD(ObjectProto, key);
    if (protoDesc) deleteKey(ObjectProto, key);
    dP(it, key, D);
    if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
  } : dP;

  var wrap = function (tag) {
    var sym = setKey(AllSymbols, tag, _create($Symbol._ES5ProxyType ? $Symbol.get(PROTOTYPE) : $Symbol[PROTOTYPE]));

    setKey(sym, "_k", tag);

    return sym;
  };

  var isSymbol = USE_NATIVE && typeof ($Symbol._ES5ProxyType ? $Symbol.get("iterator") : $Symbol.iterator) == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return instanceOfKey(it, $Symbol);
  };

  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
    anObject(it);
    key = toPrimitive(key, true);
    anObject(D);

    if (has(AllSymbols, key)) {
      if (!(D._ES5ProxyType ? D.get("enumerable") : D.enumerable)) {
        if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));

        setKey(it._ES5ProxyType ? it.get(HIDDEN) : it[HIDDEN], key, true);
      } else {
        var _HIDDEN, _key2;

        if (has(it, HIDDEN) && (_HIDDEN = it._ES5ProxyType ? it.get(HIDDEN) : it[HIDDEN], _key2 = _HIDDEN._ES5ProxyType ? _HIDDEN.get(key) : _HIDDEN[key])) setKey(it._ES5ProxyType ? it.get(HIDDEN) : it[HIDDEN], key, false);
        D = _create(D, {
          enumerable: createDesc(0, false)
        });
      }

      return setSymbolDesc(it, key, D);
    }

    return dP(it, key, D);
  };

  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P));
    var i = 0;
    var l = keys._ES5ProxyType ? keys.get("length") : keys.length;
    var key;

    while (l > i) {
      var _ref15, _ref16;

      $defineProperty(it, key = (_ref15 = i++, _ref16 = keys._ES5ProxyType ? keys.get(_ref15) : keys[_ref15]), P._ES5ProxyType ? P.get(key) : P[key]);
    }

    return it;
  };

  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };

  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var _HIDDEN2, _key3;

    var E = callKey2(isEnum, "call", this, key = toPrimitive(key, true));

    if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && (_HIDDEN2 = this._ES5ProxyType ? this.get(HIDDEN) : this[HIDDEN], _key3 = _HIDDEN2._ES5ProxyType ? _HIDDEN2.get(key) : _HIDDEN2[key]) ? E : true;
  };

  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var _HIDDEN3, _key4;

    it = toIObject(it);
    key = toPrimitive(key, true);
    if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
    var D = gOPD(it, key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && (_HIDDEN3 = it._ES5ProxyType ? it.get(HIDDEN) : it[HIDDEN], _key4 = _HIDDEN3._ES5ProxyType ? _HIDDEN3.get(key) : _HIDDEN3[key]))) setKey(D, "enumerable", true);
    return D;
  };

  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN(toIObject(it));
    var result = [];
    var i = 0;
    var key;

    while ((names._ES5ProxyType ? names.get("length") : names.length) > i) {
      var _ref17, _ref18;

      if (!has(AllSymbols, key = (_ref17 = i++, _ref18 = names._ES5ProxyType ? names.get(_ref17) : names[_ref17])) && key != HIDDEN && key != META) result.push(key);
    }

    return result;
  };

  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto;
    var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
    var result = [];
    var i = 0;
    var key;

    while ((names._ES5ProxyType ? names.get("length") : names.length) > i) {
      var _ref19, _ref20;

      if (has(AllSymbols, key = (_ref19 = i++, _ref20 = names._ES5ProxyType ? names.get(_ref19) : names[_ref19])) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols._ES5ProxyType ? AllSymbols.get(key) : AllSymbols[key]);
    }

    return result;
  }; // 19.4.1.1 Symbol([description])


  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (instanceOfKey(this, $Symbol)) throw TypeError('Symbol is not a constructor!');
      var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

      var $set = function (value) {
        if (this === ObjectProto) callKey2($set, "call", OPSymbols, value);
        if (has(this, HIDDEN) && has(this._ES5ProxyType ? this.get(HIDDEN) : this[HIDDEN], tag)) setKey(this._ES5ProxyType ? this.get(HIDDEN) : this[HIDDEN], tag, false);
        setSymbolDesc(this, tag, createDesc(1, value));
      };

      if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
        configurable: true,
        set: $set
      });
      return wrap(tag);
    };

    redefine($Symbol._ES5ProxyType ? $Symbol.get(PROTOTYPE) : $Symbol[PROTOTYPE], 'toString', function toString() {
      return this._ES5ProxyType ? this.get("_k") : this._k;
    });

    setKey($GOPD, "f", $getOwnPropertyDescriptor);

    setKey($DP, "f", $defineProperty);

    setKey(__webpack_require__(28), "f", setKey(gOPNExt, "f", $getOwnPropertyNames));

    setKey(__webpack_require__(19), "f", $propertyIsEnumerable);

    setKey(__webpack_require__(27), "f", $getOwnPropertySymbols);

    if (DESCRIPTORS && !__webpack_require__(22)) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }

    setKey(wksExt, "f", function (name) {
      return wrap(wks(name));
    });
  }

  $export(($export._ES5ProxyType ? $export.get("G") : $export.G) + ($export._ES5ProxyType ? $export.get("W") : $export.W) + ($export._ES5ProxyType ? $export.get("F") : $export.F) * !USE_NATIVE, {
    Symbol: $Symbol
  });

  for (var es6Symbols = callKey1( // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables', "split", ','), j = 0; (es6Symbols._ES5ProxyType ? es6Symbols.get("length") : es6Symbols.length) > j;) {
    var _ref21, _ref22;

    wks((_ref21 = j++, _ref22 = es6Symbols._ES5ProxyType ? es6Symbols.get(_ref21) : es6Symbols[_ref21]));
  }

  for (var wellKnownSymbols = $keys(wks._ES5ProxyType ? wks.get("store") : wks.store), k = 0; (wellKnownSymbols._ES5ProxyType ? wellKnownSymbols.get("length") : wellKnownSymbols.length) > k;) {
    var _ref23, _ref24;

    wksDefine((_ref23 = k++, _ref24 = wellKnownSymbols._ES5ProxyType ? wellKnownSymbols.get(_ref23) : wellKnownSymbols[_ref23]));
  }

  $export(($export._ES5ProxyType ? $export.get("S") : $export.S) + ($export._ES5ProxyType ? $export.get("F") : $export.F) * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function (key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry._ES5ProxyType ? SymbolRegistry.get(key) : SymbolRegistry[key] : setKey(SymbolRegistry, key, $Symbol(key));
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

      for (var key in iterableKey(SymbolRegistry)) if ((SymbolRegistry._ES5ProxyType ? SymbolRegistry.get(key) : SymbolRegistry[key]) === sym) return key;
    },
    useSetter: function () {
      setter = true;
    },
    useSimple: function () {
      setter = false;
    }
  });
  $export(($export._ES5ProxyType ? $export.get("S") : $export.S) + ($export._ES5ProxyType ? $export.get("F") : $export.F) * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
  }); // 24.3.2 JSON.stringify(value [, replacer [, space]])

  $JSON && $export(($export._ES5ProxyType ? $export.get("S") : $export.S) + ($export._ES5ProxyType ? $export.get("F") : $export.F) * (!USE_NATIVE || $fails(function () {
    var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols

    return _stringify([S]) != '[null]' || _stringify({
      a: S
    }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;

      while (arguments.length > i) args.push(arguments[i++]);

      $replacer = replacer = args._ES5ProxyType ? args.get(1) : args[1];
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = callKey3($replacer, "call", this, key, value);
        if (!isSymbol(value)) return value;
      };

      setKey(args, 1, replacer);

      return callKey2(_stringify, "apply", $JSON, args);
    }
  }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

  (_PROTOTYPE3 = $Symbol._ES5ProxyType ? $Symbol.get(PROTOTYPE) : $Symbol[PROTOTYPE], _TO_PRIMITIVE = _PROTOTYPE3._ES5ProxyType ? _PROTOTYPE3.get(TO_PRIMITIVE) : _PROTOTYPE3[TO_PRIMITIVE]) || __webpack_require__(15)($Symbol._ES5ProxyType ? $Symbol.get(PROTOTYPE) : $Symbol[PROTOTYPE], TO_PRIMITIVE, (_PROTOTYPE4 = $Symbol._ES5ProxyType ? $Symbol.get(PROTOTYPE) : $Symbol[PROTOTYPE], _valueOf = _PROTOTYPE4._ES5ProxyType ? _PROTOTYPE4.get("valueOf") : _PROTOTYPE4.valueOf)); // 19.4.3.5 Symbol.prototype[@@toStringTag]

  setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

  setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

  setToStringTag(global._ES5ProxyType ? global.get("JSON") : global.JSON, 'JSON', true);
  /***/
},
/* 46 */

/***/
function (module, exports) {
  setKey(module, "exports", function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  });
  /***/

},
/* 47 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__7, _f4;

  var def = (_webpack_require__7 = __webpack_require__(6), _f4 = _webpack_require__7._ES5ProxyType ? _webpack_require__7.get("f") : _webpack_require__7.f);

  var has = __webpack_require__(5);

  var TAG = __webpack_require__(4)('toStringTag');

  setKey(module, "exports", function (it, tag, stat) {
    if (it && !has(it = stat ? it : it._ES5ProxyType ? it.get("prototype") : it.prototype, TAG)) def(it, TAG, {
      configurable: true,
      value: tag
    });
  });
  /***/

},
/* 48 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__8, _f5;

  var global = __webpack_require__(2);

  var core = __webpack_require__(10);

  var LIBRARY = __webpack_require__(22);

  var wksExt = __webpack_require__(35);

  var defineProperty = (_webpack_require__8 = __webpack_require__(6), _f5 = _webpack_require__8._ES5ProxyType ? _webpack_require__8.get("f") : _webpack_require__8.f);

  setKey(module, "exports", function (name) {
    var $Symbol = (core._ES5ProxyType ? core.get("Symbol") : core.Symbol) || setKey(core, "Symbol", LIBRARY ? {} : (global._ES5ProxyType ? global.get("Symbol") : global.Symbol) || {});

    if (callKey1(name, "charAt", 0) != '_' && !inKey($Symbol, name)) defineProperty($Symbol, name, {
      value: callKey1(wksExt, "f", name)
    });
  });
  /***/

},
/* 49 */

/***/
function (module, exports, __webpack_require__) {
  // all enumerable object keys, includes symbols
  var getKeys = __webpack_require__(14);

  var gOPS = __webpack_require__(27);

  var pIE = __webpack_require__(19);

  setKey(module, "exports", function (it) {
    var result = getKeys(it);
    var getSymbols = gOPS._ES5ProxyType ? gOPS.get("f") : gOPS.f;

    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = pIE._ES5ProxyType ? pIE.get("f") : pIE.f;
      var i = 0;
      var key;

      while ((symbols._ES5ProxyType ? symbols.get("length") : symbols.length) > i) {
        var _ref25, _ref26;

        if (callKey2(isEnum, "call", it, key = (_ref25 = i++, _ref26 = symbols._ES5ProxyType ? symbols.get(_ref25) : symbols[_ref25]))) result.push(key);
      }
    }

    return result;
  });
  /***/

},
/* 50 */

/***/
function (module, exports, __webpack_require__) {
  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var cof = __webpack_require__(23); // eslint-disable-next-line no-prototype-builtins


  setKey(module, "exports", callKey1(Object('z'), "propertyIsEnumerable", 0) ? Object : function (it) {
    return cof(it) == 'String' ? callKey1(it, "split", '') : Object(it);
  });
  /***/

},
/* 51 */

/***/
function (module, exports, __webpack_require__) {
  // 7.2.2 IsArray(argument)
  var cof = __webpack_require__(23);

  setKey(module, "exports", Array.compatIsArray || function isArray(arg) {
    return cof(arg) == 'Array';
  });
  /***/

},
/* 52 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var anObject = __webpack_require__(11);

  var dPs = __webpack_require__(53);

  var enumBugKeys = __webpack_require__(26);

  var IE_PROTO = __webpack_require__(25)('IE_PROTO');

  var Empty = function () {
    /* empty */
  };

  var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

  var createDict = function () {
    var _contentWindow, _document2;

    // Thrash, waste and sodomy: IE GC bug
    var iframe = __webpack_require__(32)('iframe');

    var i = enumBugKeys._ES5ProxyType ? enumBugKeys.get("length") : enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;

    setKey(iframe._ES5ProxyType ? iframe.get("style") : iframe.style, "display", 'none');

    callKey1(__webpack_require__(54), "appendChild", iframe);

    setKey(iframe, "src", 'javascript:'); // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);


    iframeDocument = (_contentWindow = iframe._ES5ProxyType ? iframe.get("contentWindow") : iframe.contentWindow, _document2 = _contentWindow._ES5ProxyType ? _contentWindow.get("document") : _contentWindow.document);

    callKey0(iframeDocument, "open");

    callKey1(iframeDocument, "write", lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);

    callKey0(iframeDocument, "close");

    createDict = iframeDocument._ES5ProxyType ? iframeDocument.get("F") : iframeDocument.F;

    while (i--) deleteKey(createDict._ES5ProxyType ? createDict.get(PROTOTYPE) : createDict[PROTOTYPE], enumBugKeys._ES5ProxyType ? enumBugKeys.get(i) : enumBugKeys[i]);

    return createDict();
  };

  setKey(module, "exports", Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      setKey(Empty, PROTOTYPE, anObject(O));

      result = new Empty();

      setKey(Empty, PROTOTYPE, null); // add "__proto__" for Object.getPrototypeOf polyfill


      setKey(result, IE_PROTO, O);
    } else result = createDict();

    return Properties === undefined ? result : dPs(result, Properties);
  });
  /***/

},
/* 53 */

/***/
function (module, exports, __webpack_require__) {
  var dP = __webpack_require__(6);

  var anObject = __webpack_require__(11);

  var getKeys = __webpack_require__(14);

  setKey(module, "exports", __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = getKeys(Properties);
    var length = keys._ES5ProxyType ? keys.get("length") : keys.length;
    var i = 0;
    var P;

    while (length > i) {
      var _ref27, _ref28;

      callKey3(dP, "f", O, P = (_ref27 = i++, _ref28 = keys._ES5ProxyType ? keys.get(_ref27) : keys[_ref27]), Properties._ES5ProxyType ? Properties.get(P) : Properties[P]);
    }

    return O;
  });
  /***/

},
/* 54 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__9, _document3;

  var document = (_webpack_require__9 = __webpack_require__(2), _document3 = _webpack_require__9._ES5ProxyType ? _webpack_require__9.get("document") : _webpack_require__9.document);

  setKey(module, "exports", document && (document._ES5ProxyType ? document.get("documentElement") : document.documentElement));
  /***/

},
/* 55 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.9 Object.getPrototypeOf(O)
  var toObject = __webpack_require__(12);

  var $getPrototypeOf = __webpack_require__(56);

  __webpack_require__(3)('getPrototypeOf', function () {
    return function getPrototypeOf(it) {
      return $getPrototypeOf(toObject(it));
    };
  });
  /***/

},
/* 56 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var has = __webpack_require__(5);

  var toObject = __webpack_require__(12);

  var IE_PROTO = __webpack_require__(25)('IE_PROTO');

  var ObjectProto = Object.prototype;

  setKey(module, "exports", Object.getPrototypeOf || function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO)) return O._ES5ProxyType ? O.get(IE_PROTO) : O[IE_PROTO];

    if (typeof (O._ES5ProxyType ? O.get("constructor") : O.constructor) == 'function' && instanceOfKey(O, O._ES5ProxyType ? O.get("constructor") : O.constructor)) {
      var _constructor, _prototype;

      return _constructor = O._ES5ProxyType ? O.get("constructor") : O.constructor, _prototype = _constructor._ES5ProxyType ? _constructor.get("prototype") : _constructor.prototype;
    }

    return instanceOfKey(O, Object) ? ObjectProto : null;
  });
  /***/

},
/* 57 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.14 Object.keys(O)
  var toObject = __webpack_require__(12);

  var $keys = __webpack_require__(14);

  __webpack_require__(3)('keys', function () {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  /***/

},
/* 58 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  __webpack_require__(3)('getOwnPropertyNames', function () {
    var _webpack_require__10, _f6;

    return _webpack_require__10 = __webpack_require__(40), _f6 = _webpack_require__10._ES5ProxyType ? _webpack_require__10.get("f") : _webpack_require__10.f;
  });
  /***/

},
/* 59 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__11, _onFreeze;

  // 19.1.2.5 Object.freeze(O)
  var isObject = __webpack_require__(1);

  var meta = (_webpack_require__11 = __webpack_require__(17), _onFreeze = _webpack_require__11._ES5ProxyType ? _webpack_require__11.get("onFreeze") : _webpack_require__11.onFreeze);

  __webpack_require__(3)('freeze', function ($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(meta(it)) : it;
    };
  });
  /***/

},
/* 60 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__12, _onFreeze2;

  // 19.1.2.17 Object.seal(O)
  var isObject = __webpack_require__(1);

  var meta = (_webpack_require__12 = __webpack_require__(17), _onFreeze2 = _webpack_require__12._ES5ProxyType ? _webpack_require__12.get("onFreeze") : _webpack_require__12.onFreeze);

  __webpack_require__(3)('seal', function ($seal) {
    return function seal(it) {
      return $seal && isObject(it) ? $seal(meta(it)) : it;
    };
  });
  /***/

},
/* 61 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__13, _onFreeze3;

  // 19.1.2.15 Object.preventExtensions(O)
  var isObject = __webpack_require__(1);

  var meta = (_webpack_require__13 = __webpack_require__(17), _onFreeze3 = _webpack_require__13._ES5ProxyType ? _webpack_require__13.get("onFreeze") : _webpack_require__13.onFreeze);

  __webpack_require__(3)('preventExtensions', function ($preventExtensions) {
    return function preventExtensions(it) {
      return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
    };
  });
  /***/

},
/* 62 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.12 Object.isFrozen(O)
  var isObject = __webpack_require__(1);

  __webpack_require__(3)('isFrozen', function ($isFrozen) {
    return function isFrozen(it) {
      return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
  });
  /***/

},
/* 63 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.13 Object.isSealed(O)
  var isObject = __webpack_require__(1);

  __webpack_require__(3)('isSealed', function ($isSealed) {
    return function isSealed(it) {
      return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
  });
  /***/

},
/* 64 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.2.11 Object.isExtensible(O)
  var isObject = __webpack_require__(1);

  __webpack_require__(3)('isExtensible', function ($isExtensible) {
    return function isExtensible(it) {
      return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
  });
  /***/

},
/* 65 */

/***/
function (module, exports, __webpack_require__) {
  // 19.1.3.10 Object.is(value1, value2)
  var $export = __webpack_require__(0);

  $export($export._ES5ProxyType ? $export.get("S") : $export.S, 'Object', {
    is: __webpack_require__(66)
  });
  /***/
},
/* 66 */

/***/
function (module, exports) {
  // 7.2.9 SameValue(x, y)
  setKey(module, "exports", Object.is || function is(x, y) {
    // eslint-disable-next-line no-self-compare
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  });
  /***/

},
/* 67 */

/***/
function (module, exports, __webpack_require__) {
  "use strict";

  var ctx = __webpack_require__(34);

  var $export = __webpack_require__(0);

  var toObject = __webpack_require__(12);

  var call = __webpack_require__(68);

  var isArrayIter = __webpack_require__(69);

  var toLength = __webpack_require__(18);

  var createProperty = __webpack_require__(29);

  var getIterFn = __webpack_require__(70);

  $export(($export._ES5ProxyType ? $export.get("S") : $export.S) + ($export._ES5ProxyType ? $export.get("F") : $export.F) * !__webpack_require__(72)(function (iter) {
    Array.from(iter);
  }), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike
    /* , mapfn = undefined, thisArg = undefined */
    ) {
      var O = toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = getIterFn(O);
      var length, result, step, iterator;
      if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = callKey1(iterFn, "call", O), result = new C(); !(_step = step = callKey0(iterator, "next"), _done = _step._ES5ProxyType ? _step.get("done") : _step.done); index++) {
          var _step, _done;

          createProperty(result, index, mapping ? call(iterator, mapfn, [step._ES5ProxyType ? step.get("value") : step.value, index], true) : step._ES5ProxyType ? step.get("value") : step.value);
        }
      } else {
        length = toLength(O._ES5ProxyType ? O.get("length") : O.length);

        for (result = new C(length); length > index; index++) {
          createProperty(result, index, mapping ? mapfn(O._ES5ProxyType ? O.get(index) : O[index], index) : O._ES5ProxyType ? O.get(index) : O[index]);
        }
      }

      setKey(result, "length", index);

      return result;
    }
  });
  /***/
},
/* 68 */

/***/
function (module, exports, __webpack_require__) {
  // call something on iterator step with safe closing on error
  var anObject = __webpack_require__(11);

  setKey(module, "exports", function (iterator, fn, value, entries) {
    try {
      var _anObject, _;

      return entries ? fn((_anObject = anObject(value), _ = _anObject._ES5ProxyType ? _anObject.get(0) : _anObject[0]), value._ES5ProxyType ? value.get(1) : value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
      var ret = iterator._ES5ProxyType ? iterator.get('return') : iterator['return'];
      if (ret !== undefined) anObject(callKey1(ret, "call", iterator));
      throw e;
    }
  });
  /***/

},
/* 69 */

/***/
function (module, exports, __webpack_require__) {
  // check on default Array iterator
  var Iterators = __webpack_require__(42);

  var ITERATOR = __webpack_require__(4)('iterator');

  var ArrayProto = Array.prototype;

  setKey(module, "exports", function (it) {
    return it !== undefined && ((Iterators._ES5ProxyType ? Iterators.get("Array") : Iterators.Array) === it || (ArrayProto._ES5ProxyType ? ArrayProto.get(ITERATOR) : ArrayProto[ITERATOR]) === it);
  });
  /***/

},
/* 70 */

/***/
function (module, exports, __webpack_require__) {
  var classof = __webpack_require__(71);

  var ITERATOR = __webpack_require__(4)('iterator');

  var Iterators = __webpack_require__(42);

  setKey(module, "exports", setKey(__webpack_require__(10), "getIteratorMethod", function (it) {
    var _classof, _classof2;

    if (it != undefined) return (it._ES5ProxyType ? it.get(ITERATOR) : it[ITERATOR]) || (it._ES5ProxyType ? it.get('@@iterator') : it['@@iterator']) || (_classof = classof(it), _classof2 = Iterators._ES5ProxyType ? Iterators.get(_classof) : Iterators[_classof]);
  }));
  /***/

},
/* 71 */

/***/
function (module, exports, __webpack_require__) {
  // getting tag from 19.1.3.6 Object.prototype.toString()
  var cof = __webpack_require__(23);

  var TAG = __webpack_require__(4)('toStringTag'); // ES3 wrong here


  var ARG = cof(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function (it, key) {
    try {
      return it._ES5ProxyType ? it.get(key) : it[key];
    } catch (e) {
      /* empty */
    }
  };

  setKey(module, "exports", function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
    : ARG ? cof(O) // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof (O._ES5ProxyType ? O.get("callee") : O.callee) == 'function' ? 'Arguments' : B;
  });
  /***/

},
/* 72 */

/***/
function (module, exports, __webpack_require__) {
  var ITERATOR = __webpack_require__(4)('iterator');

  var SAFE_CLOSING = false;

  try {
    var riter = callKey0([7], ITERATOR);

    setKey(riter, 'return', function () {
      SAFE_CLOSING = true;
    }); // eslint-disable-next-line no-throw-literal


    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {
    /* empty */
  }

  setKey(module, "exports", function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;

    try {
      var arr = [7];

      var iter = callKey0(arr, ITERATOR);

      setKey(iter, "next", function () {
        return {
          done: safe = true
        };
      });

      setKey(arr, ITERATOR, function () {
        return iter;
      });

      exec(arr);
    } catch (e) {
      /* empty */
    }

    return safe;
  });
  /***/

},
/* 73 */

/***/
function (module, exports, __webpack_require__) {
  "use strict";

  var $export = __webpack_require__(0);

  var createProperty = __webpack_require__(29); // WebKit Array.of isn't generic


  $export(($export._ES5ProxyType ? $export.get("S") : $export.S) + ($export._ES5ProxyType ? $export.get("F") : $export.F) * __webpack_require__(9)(function () {
    function F() {
      /* empty */
    }

    return !instanceOfKey(callKey1(Array.of, "call", F), F);
  }), 'Array', {
    // 22.1.2.3 Array.of( ...items)
    of: function of()
    /* ...args */
    {
      var index = 0;
      var aLen = arguments.length;
      var result = new (typeof this == 'function' ? this : Array)(aLen);

      while (aLen > index) createProperty(result, index, arguments[index++]);

      setKey(result, "length", aLen);

      return result;
    }
  });
  /***/
},
/* 74 */

/***/
function (module, exports, __webpack_require__) {
  // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
  var $export = __webpack_require__(0);

  $export($export._ES5ProxyType ? $export.get("P") : $export.P, 'Array', {
    copyWithin: __webpack_require__(75)
  });

  __webpack_require__(30)('copyWithin');
  /***/

},
/* 75 */

/***/
function (module, exports, __webpack_require__) {
  "use strict"; // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

  var _ref29, _copyWithin;

  var toObject = __webpack_require__(12);

  var toAbsoluteIndex = __webpack_require__(24);

  var toLength = __webpack_require__(18);

  setKey(module, "exports", (_ref29 = [], _copyWithin = _ref29._ES5ProxyType ? _ref29.get("copyWithin") : _ref29.copyWithin) || function copyWithin(target
  /* = 0 */
  , start
  /* = 0, end = @length */
  ) {
    var O = toObject(this);
    var len = toLength(O._ES5ProxyType ? O.get("length") : O.length);
    var to = toAbsoluteIndex(target, len);
    var from = toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;

    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }

    while (count-- > 0) {
      if (inKey(O, from)) setKey(O, to, O._ES5ProxyType ? O.get(from) : O[from]);else deleteKey(O, to);
      to += inc;
      from += inc;
    }

    return O;
  });
  /***/

},
/* 76 */

/***/
function (module, exports, __webpack_require__) {
  // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
  var $export = __webpack_require__(0);

  $export($export._ES5ProxyType ? $export.get("P") : $export.P, 'Array', {
    fill: __webpack_require__(77)
  });

  __webpack_require__(30)('fill');
  /***/

},
/* 77 */

/***/
function (module, exports, __webpack_require__) {
  "use strict"; // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

  var toObject = __webpack_require__(12);

  var toAbsoluteIndex = __webpack_require__(24);

  var toLength = __webpack_require__(18);

  setKey(module, "exports", function fill(value
  /* , start = 0, end = @length */
  ) {
    var O = toObject(this);
    var length = toLength(O._ES5ProxyType ? O.get("length") : O.length);
    var aLen = arguments.length;
    var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
    var end = aLen > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

    while (endPos > index) setKey(O, index++, value);

    return O;
  });
  /***/

},
/* 78 */

/***/
function (module, exports, __webpack_require__) {
  "use strict"; // https://github.com/tc39/Array.prototype.includes

  var $export = __webpack_require__(0);

  var $includes = __webpack_require__(38)(true);

  $export($export._ES5ProxyType ? $export.get("P") : $export.P, 'Array', {
    includes: function includes(el
    /* , fromIndex = 0 */
    ) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  __webpack_require__(30)('includes');
  /***/

},
/* 79 */

/***/
function (module, exports, __webpack_require__) {
  // https://github.com/tc39/proposal-object-getownpropertydescriptors
  var $export = __webpack_require__(0);

  var ownKeys = __webpack_require__(80);

  var toIObject = __webpack_require__(7);

  var gOPD = __webpack_require__(41);

  var createProperty = __webpack_require__(29);

  $export($export._ES5ProxyType ? $export.get("S") : $export.S, 'Object', {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIObject(object);
      var getDesc = gOPD._ES5ProxyType ? gOPD.get("f") : gOPD.f;
      var keys = ownKeys(O);
      var result = {};
      var i = 0;
      var key, desc;

      while ((keys._ES5ProxyType ? keys.get("length") : keys.length) > i) {
        var _ref30, _ref31;

        desc = getDesc(O, key = (_ref30 = i++, _ref31 = keys._ES5ProxyType ? keys.get(_ref30) : keys[_ref30]));
        if (desc !== undefined) createProperty(result, key, desc);
      }

      return result;
    }
  });
  /***/
},
/* 80 */

/***/
function (module, exports, __webpack_require__) {
  var _webpack_require__14, _Reflect;

  // all object keys, includes non-enumerable and symbols
  var gOPN = __webpack_require__(28);

  var gOPS = __webpack_require__(27);

  var anObject = __webpack_require__(11);

  var Reflect = (_webpack_require__14 = __webpack_require__(2), _Reflect = _webpack_require__14._ES5ProxyType ? _webpack_require__14.get("Reflect") : _webpack_require__14.Reflect);

  setKey(module, "exports", Reflect && (Reflect._ES5ProxyType ? Reflect.get("ownKeys") : Reflect.ownKeys) || function ownKeys(it) {
    var keys = callKey1(gOPN, "f", anObject(it));

    var getSymbols = gOPS._ES5ProxyType ? gOPS.get("f") : gOPS.f;
    return getSymbols ? concat(keys, getSymbols(it)) : keys;
  });
  /***/

},
/* 81 */

/***/
function (module, exports, __webpack_require__) {
  // https://github.com/tc39/proposal-object-values-entries
  var $export = __webpack_require__(0);

  var $values = __webpack_require__(43)(false);

  $export($export._ES5ProxyType ? $export.get("S") : $export.S, 'Object', {
    values: function values(it) {
      return $values(it);
    }
  });
  /***/
},
/* 82 */

/***/
function (module, exports, __webpack_require__) {
  // https://github.com/tc39/proposal-object-values-entries
  var $export = __webpack_require__(0);

  var $entries = __webpack_require__(43)(true);

  $export($export._ES5ProxyType ? $export.get("S") : $export.S, 'Object', {
    entries: function entries(it) {
      return $entries(it);
    }
  });
  /***/
}]);

/***/ })
/******/ ]);
Object.defineSymbolProperty = Object.defineProperty;
Object.defineProperty = Object.definePropertyNative;
Object.defineSymbolProperties = Object.defineProperties;
Object.defineProperties = Object.definePropertiesNative;(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
var WebruntimeCompat = (function (exports) {
  'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object['define' + 'Property'](target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {},
        waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) {
        resolve(inner[key](value));
      });
      return {
        done: false,
        value: awaitWrap(value)
      };
    }

    if (typeof Symbol === "function" && Symbol.iterator) {
      iter[Symbol.iterator] = function () {
        return this;
      };
    }

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }

        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        return pump("return", value);
      };
    }

    return iter;
  }

  function _asyncIterator(iterable) {
    var method;

    if (typeof Symbol === "function") {
      if (Symbol.asyncIterator) {
        method = iterable[Symbol.asyncIterator];
        if (method != null) return method.call(iterable);
      }

      if (Symbol.iterator) {
        method = iterable[Symbol.iterator];
        if (method != null) return method.call(iterable);
      }
    }

    throw new TypeError("Object is not async iterable");
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _AwaitValue(value) {
    this.wrapped = value;
  }

  function _awaitAsyncGenerator(value) {
    return new _AwaitValue(value);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _classNameTDZError(name) {
    throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  }

  function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);

      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }

    return obj;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _iterableToArrayLimitLoose(arr, i) {
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  }

  function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _readOnlyError(name) {
    throw new Error("\"" + name + "\" is read-only");
  }

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  var _temporalUndefined = {};

  function _temporalRef(val, name) {
    if (val === _temporalUndefined) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    } else {
      return val;
    }
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _toPropertyKey(key) {
    if (_typeof(key) === "symbol") {
      return key;
    } else {
      return String(key);
    }
  }

  function _typeof$1(obj) {
    if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
      _typeof$1 = function _typeof$1(obj) {
        return _typeof(obj);
      };
    } else {
      _typeof$1 = function _typeof$1(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
      };
    }

    return _typeof$1(obj);
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        var wrappedAwait = value instanceof _AwaitValue;
        Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
          if (wrappedAwait) {
            resume("next", arg);
            return;
          }

          settle(result.done ? "return" : "normal", arg);
        }, function (err) {
          resume("throw", err);
        });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  var global = {};
  !function (global) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var inModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object";
    var runtime = global.regeneratorRuntime;

    if (runtime) {
      if (inModule) {
        module.exports = runtime;
      }

      return;
    }

    runtime = global.regeneratorRuntime = inModule ? module.exports : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    runtime.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;

        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    runtime.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    runtime.AsyncIterator = AsyncIterator;

    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
      return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator";

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    runtime.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };
  }(global);
  var regenerator = global.regeneratorRuntime;

  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  var babelHelpers = {
    applyDecoratedDescriptor: _applyDecoratedDescriptor,
    assertThisInitialized: _assertThisInitialized,
    arrayWithHoles: _arrayWithHoles,
    arrayWithoutHoles: _arrayWithoutHoles,
    asyncGeneratorDelegate: _asyncGeneratorDelegate,
    asyncIterator: _asyncIterator,
    asyncToGenerator: _asyncToGenerator,
    awaitAsyncGenerator: _awaitAsyncGenerator,
    classCallCheck: _classCallCheck,
    classNameTDZError: _classNameTDZError,
    construct: _construct,
    createClass: _createClass,
    defaults: _defaults,
    defineEnumerableProperties: _defineEnumerableProperties,
    defineProperty: _defineProperty,
    extends: _extends,
    get: _get,
    getPrototypeOf: _getPrototypeOf,
    inherits: _inherits,
    inheritsLoose: _inheritsLoose,
    initializerDefineProperty: _initializerDefineProperty,
    initializerWarningHelper: _initializerWarningHelper,
    iterableToArray: _iterableToArray,
    iterableToArrayLimit: _iterableToArrayLimit,
    iterableToArrayLimitLoose: _iterableToArrayLimitLoose,
    instanceof: _instanceof,
    isNativeFunction: _isNativeFunction,
    newArrowCheck: _newArrowCheck,
    nonIterableRest: _nonIterableRest,
    nonIterableSpread: _nonIterableSpread,
    objectDestructuringEmpty: _objectDestructuringEmpty,
    objectSpread: _objectSpread,
    objectWithoutProperties: _objectWithoutProperties,
    possibleConstructorReturn: _possibleConstructorReturn,
    readOnlyError: _readOnlyError,
    set: _set,
    setPrototypeOf: _setPrototypeOf,
    skipFirstGeneratorNext: _skipFirstGeneratorNext,
    slicedToArray: _slicedToArray,
    superPropBase: _superPropBase,
    taggedTemplateLiteral: _taggedTemplateLiteral,
    temporalRef: _temporalRef,
    toArray: _toArray,
    toConsumableArray: _toConsumableArray,
    toPropertyKey: _toPropertyKey,
    typeof: _typeof$1,
    temporalUndefined: _temporalUndefined,
    wrapNativeSuper: _wrapNativeSuper,
    wrapAsyncGenerator: _wrapAsyncGenerator
  };

  function getDeepKeys(obj) {
    var keys = [];

    var _loop = function _loop(key) {
      if (_typeof(obj[key]) === 'object') {
        var subkeys = getDeepKeys(obj[key]);
        keys = keys.concat(subkeys.map(function (subkey) {
          return {
            path: "".concat(key, "/").concat(subkey.path),
            module: subkey.module
          };
        }));
      } else {
        keys.push({
          path: key,
          module: obj[key]
        });
      }
    };

    for (var key in obj) {
      _loop(key);
    }

    return keys;
  }

  var compatModules = {};
  var PROXY_PREFIX = 'proxy-compat/';
  Object.keys(window.Proxy).forEach(function (helper) {
    compatModules[PROXY_PREFIX + helper] = window.Proxy[helper];
  });
  var RUNTIME_HELPERS_PREFIX = '@babel/runtime/helpers/';
  var babelModules = getDeepKeys(babelHelpers);
  babelModules.forEach(function (m) {
    compatModules[RUNTIME_HELPERS_PREFIX + m.path] = m.module;
  });
  var RUNTIME_REGENERATOR_PREFIX = '@babel/runtime/regenerator';
  compatModules[RUNTIME_REGENERATOR_PREFIX] = regenerator;
  var babelRuntime = {
    helpers: babelHelpers,
    regenerator: regenerator
  };

  exports.babel = babelRuntime;
  exports.modules = compatModules;

  return exports;

}({}));
(function (__callKey1, __setKey, __callKey2, __iterableKey, __inKey, __callKey0, __callKey3, __hasOwnProperty, __deleteKey, __concat, _slicedToArray, _regeneratorRuntime, _asyncToGenerator, _instanceof, _typeof, _defineProperty, _classCallCheck) {
  'use strict';

  __callKey1 = __callKey1 && __callKey1.hasOwnProperty('default') ? __callKey1['default'] : __callKey1;
  __setKey = __setKey && __setKey.hasOwnProperty('default') ? __setKey['default'] : __setKey;
  __callKey2 = __callKey2 && __callKey2.hasOwnProperty('default') ? __callKey2['default'] : __callKey2;
  __iterableKey = __iterableKey && __iterableKey.hasOwnProperty('default') ? __iterableKey['default'] : __iterableKey;
  __inKey = __inKey && __inKey.hasOwnProperty('default') ? __inKey['default'] : __inKey;
  __callKey0 = __callKey0 && __callKey0.hasOwnProperty('default') ? __callKey0['default'] : __callKey0;
  __callKey3 = __callKey3 && __callKey3.hasOwnProperty('default') ? __callKey3['default'] : __callKey3;
  __hasOwnProperty = __hasOwnProperty && __hasOwnProperty.hasOwnProperty('default') ? __hasOwnProperty['default'] : __hasOwnProperty;
  __deleteKey = __deleteKey && __deleteKey.hasOwnProperty('default') ? __deleteKey['default'] : __deleteKey;
  __concat = __concat && __concat.hasOwnProperty('default') ? __concat['default'] : __concat;
  _slicedToArray = _slicedToArray && _slicedToArray.hasOwnProperty('default') ? _slicedToArray['default'] : _slicedToArray;
  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;
  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;
  _instanceof = _instanceof && _instanceof.hasOwnProperty('default') ? _instanceof['default'] : _instanceof;
  _typeof = _typeof && _typeof.hasOwnProperty('default') ? _typeof['default'] : _typeof;
  _defineProperty = _defineProperty && _defineProperty.hasOwnProperty('default') ? _defineProperty['default'] : _defineProperty;
  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;

  /* Custom Lightning Web Runtime SystemJS bundle */
  var self = {};
  var System;
  var define;
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /**
   * This is a patch to override SystemJS globals, which attach themselves to the environment global.
   *
   * SystemJS creates global variables `System`, `define`, which this patch converts to local variables.
   *
   */

  /* NOTE: Our Rollup config will use `output.intro` to inject scoped variables self, System, global here. */
  // Workaround SystemJS sometimes referencing the globals directly,
  // and other times via self/global.System. Need to update the local
  // scoped variables when it does
  // eslint-disable-next-line no-restricted-globals

  Object.compatDefineProperty(self, 'System', {
    get: function get() {
      return System;
      /* eslint-disable-line no-undef */
    },
    set: function set(value) {
      System = value;
      /* eslint-disable-line no-undef */
    }
  }); // eslint-disable-next-line no-restricted-globals

  Object.compatDefineProperty(self, 'define', {
    get: function get() {
      return define;
      /* eslint-disable-line no-undef */
    },
    set: function set(value) {
      define = value;
      /* eslint-disable-line no-undef */
    }
  });
  /*
  * SystemJS 6.2.4
  */

  (function () {
    var hasSelf = typeof self !== 'undefined';
    var hasDocument = typeof document !== 'undefined';
    var envGlobal = hasSelf ? self : global;
    var baseUrl;

    if (hasDocument) {
      var baseEl = __callKey1(document, "querySelector", 'base[href]');

      if (baseEl) baseUrl = baseEl._ES5ProxyType ? baseEl.get("href") : baseEl.href;
    }

    if (!baseUrl && typeof location !== 'undefined') {
      var _location$href$split$, _, _location$href$split, _2;

      baseUrl = (_location$href$split$ = __callKey1((_location$href$split = __callKey1(location._ES5ProxyType ? location.get("href") : location.href, "split", '#'), _2 = _location$href$split._ES5ProxyType ? _location$href$split.get(0) : _location$href$split[0]), "split", '?'), _ = _location$href$split$._ES5ProxyType ? _location$href$split$.get(0) : _location$href$split$[0]);

      var lastSepIndex = __callKey1(baseUrl, "lastIndexOf", '/');

      if (lastSepIndex !== -1) baseUrl = __callKey2(baseUrl, "slice", 0, lastSepIndex + 1);
    }

    var backslashRegEx = /\\/g;

    function resolveIfNotPlainOrUrl(relUrl, parentUrl) {
      if (__callKey1(relUrl, "indexOf", '\\') !== -1) relUrl = __callKey2(relUrl, "replace", backslashRegEx, '/'); // protocol-relative

      if ((relUrl._ES5ProxyType ? relUrl.get(0) : relUrl[0]) === '/' && (relUrl._ES5ProxyType ? relUrl.get(1) : relUrl[1]) === '/') {
        return __callKey2(parentUrl, "slice", 0, __callKey1(parentUrl, "indexOf", ':') + 1) + relUrl;
      } // relative-url
      else if ((relUrl._ES5ProxyType ? relUrl.get(0) : relUrl[0]) === '.' && ((relUrl._ES5ProxyType ? relUrl.get(1) : relUrl[1]) === '/' || (relUrl._ES5ProxyType ? relUrl.get(1) : relUrl[1]) === '.' && ((relUrl._ES5ProxyType ? relUrl.get(2) : relUrl[2]) === '/' || (relUrl._ES5ProxyType ? relUrl.get("length") : relUrl.length) === 2 && (relUrl += '/')) || (relUrl._ES5ProxyType ? relUrl.get("length") : relUrl.length) === 1 && (relUrl += '/')) || (relUrl._ES5ProxyType ? relUrl.get(0) : relUrl[0]) === '/') {
          var _ref4, _ref5;

          var parentProtocol = __callKey2(parentUrl, "slice", 0, __callKey1(parentUrl, "indexOf", ':') + 1); // Disabled, but these cases will give inconsistent results for deep backtracking
          //if (parentUrl[parentProtocol.length] !== '/')
          //  throw Error('Cannot resolve');
          // read pathname from parent URL
          // pathname taken to be part after leading "/"


          var pathname;

          if ((_ref4 = (parentProtocol._ES5ProxyType ? parentProtocol.get("length") : parentProtocol.length) + 1, _ref5 = parentUrl._ES5ProxyType ? parentUrl.get(_ref4) : parentUrl[_ref4]) === '/') {
            // resolving to a :// so we need to read out the auth and host
            if (parentProtocol !== 'file:') {
              pathname = __callKey1(parentUrl, "slice", (parentProtocol._ES5ProxyType ? parentProtocol.get("length") : parentProtocol.length) + 2);
              pathname = __callKey1(pathname, "slice", __callKey1(pathname, "indexOf", '/') + 1);
            } else {
              pathname = __callKey1(parentUrl, "slice", 8);
            }
          } else {
            var _parentProtocol$lengt, _parentProtocol$lengt2;

            // resolving to :/ so pathname is the /... part
            pathname = __callKey1(parentUrl, "slice", (parentProtocol._ES5ProxyType ? parentProtocol.get("length") : parentProtocol.length) + ((_parentProtocol$lengt = parentProtocol._ES5ProxyType ? parentProtocol.get("length") : parentProtocol.length, _parentProtocol$lengt2 = parentUrl._ES5ProxyType ? parentUrl.get(_parentProtocol$lengt) : parentUrl[_parentProtocol$lengt]) === '/'));
          }

          if ((relUrl._ES5ProxyType ? relUrl.get(0) : relUrl[0]) === '/') return __callKey2(parentUrl, "slice", 0, (parentUrl._ES5ProxyType ? parentUrl.get("length") : parentUrl.length) - (pathname._ES5ProxyType ? pathname.get("length") : pathname.length) - 1) + relUrl; // join together and split for removal of .. and . segments
          // looping the string instead of anything fancy for perf reasons
          // '../../../../../z' resolved to 'x/y' is just 'z'

          var segmented = __callKey2(pathname, "slice", 0, __callKey1(pathname, "lastIndexOf", '/') + 1) + relUrl;
          var output = [];
          var segmentIndex = -1;

          for (var i = 0; i < (segmented._ES5ProxyType ? segmented.get("length") : segmented.length); i++) {
            // busy reading a segment - only terminate on '/'
            if (segmentIndex !== -1) {
              if ((segmented._ES5ProxyType ? segmented.get(i) : segmented[i]) === '/') {
                output.push(__callKey2(segmented, "slice", segmentIndex, i + 1));
                segmentIndex = -1;
              }
            } // new segment - check if it is relative
            else if ((segmented._ES5ProxyType ? segmented.get(i) : segmented[i]) === '.') {
                var _ref6, _ref7, _ref8, _ref9, _ref10, _ref11;

                // ../ segment
                if ((_ref6 = i + 1, _ref7 = segmented._ES5ProxyType ? segmented.get(_ref6) : segmented[_ref6]) === '.' && ((_ref8 = i + 2, _ref9 = segmented._ES5ProxyType ? segmented.get(_ref8) : segmented[_ref8]) === '/' || i + 2 === (segmented._ES5ProxyType ? segmented.get("length") : segmented.length))) {
                  output.pop();
                  i += 2;
                } // ./ segment
                else if ((_ref10 = i + 1, _ref11 = segmented._ES5ProxyType ? segmented.get(_ref10) : segmented[_ref10]) === '/' || i + 1 === (segmented._ES5ProxyType ? segmented.get("length") : segmented.length)) {
                    i += 1;
                  } else {
                    // the start of a new segment as below
                    segmentIndex = i;
                  }
              } // it is the start of a new segment
              else {
                  segmentIndex = i;
                }
          } // finish reading out the last segment


          if (segmentIndex !== -1) output.push(__callKey1(segmented, "slice", segmentIndex));
          return __callKey2(parentUrl, "slice", 0, (parentUrl._ES5ProxyType ? parentUrl.get("length") : parentUrl.length) - (pathname._ES5ProxyType ? pathname.get("length") : pathname.length)) + __callKey1(output, "join", '');
        }
    }
    /*
     * Import maps implementation
     *
     * To make lookups fast we pre-resolve the entire import map
     * and then match based on backtracked hash lookups
     *
     */


    function resolveUrl(relUrl, parentUrl) {
      return resolveIfNotPlainOrUrl(relUrl, parentUrl) || (__callKey1(relUrl, "indexOf", ':') !== -1 ? relUrl : resolveIfNotPlainOrUrl('./' + relUrl, parentUrl));
    }

    function objectAssign(to, from) {
      for (var p in __iterableKey(from)) {
        __setKey(to, p, from._ES5ProxyType ? from.get(p) : from[p]);
      }

      return to;
    }

    function resolveAndComposePackages(packages, outPackages, baseUrl, parentMap, parentUrl) {
      for (var p in __iterableKey(packages)) {
        var resolvedLhs = resolveIfNotPlainOrUrl(p, baseUrl) || p;
        var rhs = packages._ES5ProxyType ? packages.get(p) : packages[p]; // package fallbacks not currently supported

        if (typeof rhs !== 'string') continue;
        var mapped = resolveImportMap(parentMap, resolveIfNotPlainOrUrl(rhs, baseUrl) || rhs, parentUrl);
        if (!mapped) targetWarning(p, rhs, 'bare specifier did not resolve');else __setKey(outPackages, resolvedLhs, mapped);
      }
    }

    function resolveAndComposeImportMap(json, baseUrl, parentMap) {
      var outMap = {
        imports: objectAssign({}, parentMap._ES5ProxyType ? parentMap.get("imports") : parentMap.imports),
        scopes: objectAssign({}, parentMap._ES5ProxyType ? parentMap.get("scopes") : parentMap.scopes)
      };
      if (json._ES5ProxyType ? json.get("imports") : json.imports) resolveAndComposePackages(json._ES5ProxyType ? json.get("imports") : json.imports, outMap._ES5ProxyType ? outMap.get("imports") : outMap.imports, baseUrl, parentMap, null);
      if (json._ES5ProxyType ? json.get("scopes") : json.scopes) for (var s in __iterableKey(json._ES5ProxyType ? json.get("scopes") : json.scopes)) {
        var _scopes, _s, _scopes2, _resolvedScope;

        var resolvedScope = resolveUrl(s, baseUrl);
        resolveAndComposePackages((_scopes = json._ES5ProxyType ? json.get("scopes") : json.scopes, _s = _scopes._ES5ProxyType ? _scopes.get(s) : _scopes[s]), (_scopes2 = outMap._ES5ProxyType ? outMap.get("scopes") : outMap.scopes, _resolvedScope = _scopes2._ES5ProxyType ? _scopes2.get(resolvedScope) : _scopes2[resolvedScope]) || __setKey(outMap._ES5ProxyType ? outMap.get("scopes") : outMap.scopes, resolvedScope, {}), baseUrl, parentMap, resolvedScope);
      }
      return outMap;
    }

    function getMatch(path, matchObj) {
      if (matchObj._ES5ProxyType ? matchObj.get(path) : matchObj[path]) return path;
      var sepIndex = path._ES5ProxyType ? path.get("length") : path.length;

      do {
        var segment = __callKey2(path, "slice", 0, sepIndex + 1);

        if (__inKey(matchObj, segment)) return segment;
      } while ((sepIndex = __callKey2(path, "lastIndexOf", '/', sepIndex - 1)) !== -1);
    }

    function applyPackages(id, packages) {
      var pkgName = getMatch(id, packages);

      if (pkgName) {
        var _ref12, _ref13;

        var pkg = packages._ES5ProxyType ? packages.get(pkgName) : packages[pkgName];
        if (pkg === null) return;
        if ((id._ES5ProxyType ? id.get("length") : id.length) > (pkgName._ES5ProxyType ? pkgName.get("length") : pkgName.length) && (_ref12 = (pkg._ES5ProxyType ? pkg.get("length") : pkg.length) - 1, _ref13 = pkg._ES5ProxyType ? pkg.get(_ref12) : pkg[_ref12]) !== '/') targetWarning(pkgName, pkg, "should have a trailing '/'");else return pkg + __callKey1(id, "slice", pkgName._ES5ProxyType ? pkgName.get("length") : pkgName.length);
      }
    }

    function targetWarning(match, target, msg) {
      __callKey1(console, "warn", "Package target " + msg + ", resolving target '" + target + "' for " + match);
    }

    function resolveImportMap(importMap, resolvedOrPlain, parentUrl) {
      var scopeUrl = parentUrl && getMatch(parentUrl, importMap._ES5ProxyType ? importMap.get("scopes") : importMap.scopes);

      while (scopeUrl) {
        var _scopes3, _scopeUrl;

        var packageResolution = applyPackages(resolvedOrPlain, (_scopes3 = importMap._ES5ProxyType ? importMap.get("scopes") : importMap.scopes, _scopeUrl = _scopes3._ES5ProxyType ? _scopes3.get(scopeUrl) : _scopes3[scopeUrl]));
        if (packageResolution) return packageResolution;
        scopeUrl = getMatch(__callKey2(scopeUrl, "slice", 0, __callKey1(scopeUrl, "lastIndexOf", '/')), importMap._ES5ProxyType ? importMap.get("scopes") : importMap.scopes);
      }

      return applyPackages(resolvedOrPlain, importMap._ES5ProxyType ? importMap.get("imports") : importMap.imports) || __callKey1(resolvedOrPlain, "indexOf", ':') !== -1 && resolvedOrPlain;
    }
    /*
     * SystemJS Core
     * 
     * Provides
     * - System.import
     * - System.register support for
     *     live bindings, function hoisting through circular references,
     *     reexports, dynamic import, import.meta.url, top-level await
     * - System.getRegister to get the registration
     * - Symbol.toStringTag support in Module objects
     * - Hookable System.createContext to customize import.meta
     * - System.onload(err, id, deps) handler for tracing / hot-reloading
     * 
     * Core comes with no System.prototype.resolve or
     * System.prototype.instantiate implementations
     */


    var hasSymbol = typeof Symbol !== 'undefined';
    var toStringTag = hasSymbol && Symbol.toStringTag;
    var REGISTRY = hasSymbol ? Symbol() : '@';

    function SystemJS() {
      __setKey(this, REGISTRY, {});
    }

    var systemJSPrototype = SystemJS._ES5ProxyType ? SystemJS.get("prototype") : SystemJS.prototype;

    __setKey(systemJSPrototype, "prepareImport", function () {});

    __setKey(systemJSPrototype, "import", function (id, parentUrl) {
      var loader = this;
      return __callKey1(__callKey1(Promise.resolve(__callKey0(loader, "prepareImport")), "then", function () {
        return __callKey2(loader, "resolve", id, parentUrl);
      }), "then", function (id) {
        var load = getOrCreateLoad(loader, id);
        return (load._ES5ProxyType ? load.get("C") : load.C) || topLevelLoad(loader, load);
      });
    }); // Hookable createContext function -> allowing eg custom import meta


    __setKey(systemJSPrototype, "createContext", function (parentId) {
      return {
        url: parentId
      };
    }); // onLoad(err, id, deps) provided for tracing / hot-reloading


    __setKey(systemJSPrototype, "onload", function () {});

    function loadToId(load) {
      return load._ES5ProxyType ? load.get("id") : load.id;
    }

    function triggerOnload(loader, load, err) {
      __callKey3(loader, "onload", err, load._ES5ProxyType ? load.get("id") : load.id, (load._ES5ProxyType ? load.get("d") : load.d) && __callKey1(load._ES5ProxyType ? load.get("d") : load.d, "map", loadToId));

      if (err) throw err;
    }

    var lastRegister;

    __setKey(systemJSPrototype, "register", function (deps, declare) {
      lastRegister = [deps, declare];
    });
    /*
     * getRegister provides the last anonymous System.register call
     */


    __setKey(systemJSPrototype, "getRegister", function () {
      var _lastRegister = lastRegister;
      lastRegister = undefined;
      return _lastRegister;
    });

    function getOrCreateLoad(loader, id, firstParentUrl) {
      var _REGISTRY, _id2;

      var load = (_REGISTRY = loader._ES5ProxyType ? loader.get(REGISTRY) : loader[REGISTRY], _id2 = _REGISTRY._ES5ProxyType ? _REGISTRY.get(id) : _REGISTRY[id]);
      if (load) return load;
      var importerSetters = [];
      var ns = Object.create(null);
      if (toStringTag) Object.compatDefineProperty(ns, toStringTag, {
        value: 'Module'
      });

      var instantiatePromise = __callKey1(__callKey1(Promise.resolve(), "then", function () {
        return __callKey2(loader, "instantiate", id, firstParentUrl);
      }), "then", function (registration) {
        var _3, _length;

        if (!registration) throw Error('Module ' + id + ' did not instantiate');

        function _export(name, value) {
          // note if we have hoisted exports (including reexports)
          __setKey(load, "h", true);

          var changed = false;

          if (_typeof(name) !== 'object') {
            if (!__inKey(ns, name) || (ns._ES5ProxyType ? ns.get(name) : ns[name]) !== value) {
              __setKey(ns, name, value);

              changed = true;
            }
          } else {
            for (var p in __iterableKey(name)) {
              var _value = name._ES5ProxyType ? name.get(p) : name[p];

              if (!__inKey(ns, p) || (ns._ES5ProxyType ? ns.get(p) : ns[p]) !== _value) {
                __setKey(ns, p, _value);

                changed = true;
              }
            }

            if (name._ES5ProxyType ? name.get("__esModule") : name.__esModule) {
              __setKey(ns, "__esModule", name._ES5ProxyType ? name.get("__esModule") : name.__esModule);
            }
          }

          if (changed) for (var i = 0; i < (importerSetters._ES5ProxyType ? importerSetters.get("length") : importerSetters.length); i++) {
            __callKey1(importerSetters, i, ns);
          }
          return value;
        }

        var declared = __callKey2(registration, 1, _export, (_3 = registration._ES5ProxyType ? registration.get(1) : registration[1], _length = _3._ES5ProxyType ? _3.get("length") : _3.length) === 2 ? {
          import: function _import(importId) {
            return __callKey2(loader, "import", importId, id);
          },
          meta: __callKey1(loader, "createContext", id)
        } : undefined);

        __setKey(load, "e", (declared._ES5ProxyType ? declared.get("execute") : declared.execute) || function () {});

        return [registration._ES5ProxyType ? registration.get(0) : registration[0], (declared._ES5ProxyType ? declared.get("setters") : declared.setters) || []];
      });

      instantiatePromise = __callKey1(instantiatePromise, "catch", function (err) {
        triggerOnload(loader, load, err);
      });

      var linkPromise = __callKey1(instantiatePromise, "then", function (instantiation) {
        return __callKey1(Promise.all(__callKey1(instantiation._ES5ProxyType ? instantiation.get(0) : instantiation[0], "map", function (dep, i) {
          var _4, _i;

          var setter = (_4 = instantiation._ES5ProxyType ? instantiation.get(1) : instantiation[1], _i = _4._ES5ProxyType ? _4.get(i) : _4[i]);
          return __callKey1(Promise.resolve(__callKey2(loader, "resolve", dep, id)), "then", function (depId) {
            var depLoad = getOrCreateLoad(loader, depId, id); // depLoad.I may be undefined for already-evaluated

            return __callKey1(Promise.resolve(depLoad._ES5ProxyType ? depLoad.get("I") : depLoad.I), "then", function () {
              if (setter) {
                (depLoad._ES5ProxyType ? depLoad.get("i") : depLoad.i).push(setter); // only run early setters when there are hoisted exports of that module
                // the timing works here as pending hoisted export calls will trigger through importerSetters

                if ((depLoad._ES5ProxyType ? depLoad.get("h") : depLoad.h) || !(depLoad._ES5ProxyType ? depLoad.get("I") : depLoad.I)) setter(depLoad._ES5ProxyType ? depLoad.get("n") : depLoad.n);
              }

              return depLoad;
            });
          });
        })), "then", function (depLoads) {
          __setKey(load, "d", depLoads);
        });
      });

      __callKey1(linkPromise, "catch", function (err) {
        __setKey(load, "e", null);

        __setKey(load, "er", err);
      }); // Capital letter = a promise function


      return load = __setKey(loader._ES5ProxyType ? loader.get(REGISTRY) : loader[REGISTRY], id, {
        id: id,
        // importerSetters, the setters functions registered to this dependency
        // we retain this to add more later
        i: importerSetters,
        // module namespace object
        n: ns,
        // instantiate
        I: instantiatePromise,
        // link
        L: linkPromise,
        // whether it has hoisted exports
        h: false,
        // On instantiate completion we have populated:
        // dependency load records
        d: undefined,
        // execution function
        // set to NULL immediately after execution (or on any failure) to indicate execution has happened
        // in such a case, C should be used, and E, I, L will be emptied
        e: undefined,
        // On execution we have populated:
        // the execution error if any
        er: undefined,
        // in the case of TLA, the execution promise
        E: undefined,
        // On execution, L, I, E cleared
        // Promise for top-level completion
        C: undefined
      });
    }

    function instantiateAll(loader, load, loaded) {
      var _load$id, _load$id2;

      if (!(_load$id = load._ES5ProxyType ? load.get("id") : load.id, _load$id2 = loaded._ES5ProxyType ? loaded.get(_load$id) : loaded[_load$id])) {
        __setKey(loaded, load._ES5ProxyType ? load.get("id") : load.id, true); // load.L may be undefined for already-instantiated


        return __callKey1(Promise.resolve(load._ES5ProxyType ? load.get("L") : load.L), "then", function () {
          return Promise.all(__callKey1(load._ES5ProxyType ? load.get("d") : load.d, "map", function (dep) {
            return instantiateAll(loader, dep, loaded);
          }));
        });
      }
    }

    function topLevelLoad(loader, load) {
      return __setKey(load, "C", __callKey1(__callKey1(instantiateAll(loader, load, {}), "then", function () {
        return postOrderExec(loader, load, {});
      }), "then", function () {
        return load._ES5ProxyType ? load.get("n") : load.n;
      }));
    } // the closest we can get to call(undefined)


    var nullContext = Object.freeze(Object.create(null)); // returns a promise if and only if a top-level await subgraph
    // throws on sync errors

    function postOrderExec(loader, load, seen) {
      var _load$id3, _load$id4;

      if (_load$id3 = load._ES5ProxyType ? load.get("id") : load.id, _load$id4 = seen._ES5ProxyType ? seen.get(_load$id3) : seen[_load$id3]) return;

      __setKey(seen, load._ES5ProxyType ? load.get("id") : load.id, true);

      if (!(load._ES5ProxyType ? load.get("e") : load.e)) {
        if (load._ES5ProxyType ? load.get("er") : load.er) throw load._ES5ProxyType ? load.get("er") : load.er;
        if (load._ES5ProxyType ? load.get("E") : load.E) return load._ES5ProxyType ? load.get("E") : load.E;
        return;
      } // deps execute first, unless circular


      var depLoadPromises;

      __callKey1(load._ES5ProxyType ? load.get("d") : load.d, "forEach", function (depLoad) {
        {
          try {
            var depLoadPromise = postOrderExec(loader, depLoad, seen);

            if (depLoadPromise) {
              __callKey1(depLoadPromise, "catch", function (err) {
                triggerOnload(loader, load, err);
              });

              (depLoadPromises = depLoadPromises || []).push(depLoadPromise);
            }
          } catch (err) {
            triggerOnload(loader, load, err);
          }
        }
      });

      if (depLoadPromises) return __callKey1(Promise.all(depLoadPromises), "then", doExec);
      return doExec();

      function doExec() {
        try {
          var execPromise = __callKey1(load._ES5ProxyType ? load.get("e") : load.e, "call", nullContext);

          if (execPromise) {
            execPromise = __callKey2(execPromise, "then", function () {
              __setKey(load, "C", load._ES5ProxyType ? load.get("n") : load.n);

              __setKey(load, "E", null); // indicates completion


              triggerOnload(loader, load, null);
            }, function (err) {
              triggerOnload(loader, load, err);
            });
            return __setKey(load, "E", (load._ES5ProxyType ? load.get("E") : load.E) || execPromise);
          } // (should be a promise, but a minify optimization to leave out Promise.resolve)


          __setKey(load, "C", load._ES5ProxyType ? load.get("n") : load.n);

          triggerOnload(loader, load, null);
        } catch (err) {
          triggerOnload(loader, load, err);

          __setKey(load, "er", err);

          throw err;
        } finally {
          __setKey(load, "L", __setKey(load, "I", undefined));

          __setKey(load, "e", null);
        }
      }
    }

    __setKey(envGlobal, "System", new SystemJS());
    /*
     * Import map support for SystemJS
     * 
     * <script type="webruntime-importmap">{}</script>
     * OR
     * <script type="webruntime-importmap" src=package.json></script>
     * 
     * Only those import maps available at the time of SystemJS initialization will be loaded
     * and they will be loaded in DOM order.
     * 
     * There is no support for dynamic import maps injection currently.
     */


    var importMap = {
      imports: {},
      scopes: {}
    },
        importMapPromise;

    if (hasDocument) {
      __callKey2(Array.prototype._ES5ProxyType ? Array.prototype.get("forEach") : Array.prototype.forEach, "call", __callKey1(document, "querySelectorAll", 'script[type="webruntime-importmap"][src]'), function (script) {
        __setKey(script, "_j", __callKey1(fetch(script._ES5ProxyType ? script.get("src") : script.src), "then", function (res) {
          return __callKey0(res, "json");
        }));
      });
    }

    __setKey(systemJSPrototype, "prepareImport", function () {
      if (!importMapPromise) {
        importMapPromise = Promise.resolve();
        if (hasDocument) __callKey2(Array.prototype._ES5ProxyType ? Array.prototype.get("forEach") : Array.prototype.forEach, "call", __callKey1(document, "querySelectorAll", 'script[type="webruntime-importmap"]'), function (script) {
          importMapPromise = __callKey1(importMapPromise, "then", function () {
            return __callKey1((script._ES5ProxyType ? script.get("_j") : script._j) || (script._ES5ProxyType ? script.get("src") : script.src) && __callKey1(fetch(script._ES5ProxyType ? script.get("src") : script.src), "then", function (resp) {
              return __callKey0(resp, "json");
            }) || Promise.resolve(JSON.parse(script._ES5ProxyType ? script.get("innerHTML") : script.innerHTML)), "then", function (json) {
              importMap = resolveAndComposeImportMap(json, (script._ES5ProxyType ? script.get("src") : script.src) || baseUrl, importMap);
            });
          });
        });
      }

      return importMapPromise;
    });

    __setKey(systemJSPrototype, "resolve", function (id, parentUrl) {
      parentUrl = parentUrl || baseUrl;
      return resolveImportMap(importMap, resolveIfNotPlainOrUrl(id, parentUrl) || id, parentUrl) || throwUnresolved(id, parentUrl);
    });

    function throwUnresolved(id, parentUrl) {
      throw Error("Unable to resolve specifier '" + id + (parentUrl ? "' from " + parentUrl : "'"));
    }
    /*
     * Supports loading System.register via script tag injection
     */


    var systemRegister = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("register") : systemJSPrototype.register;

    __setKey(systemJSPrototype, "register", function (deps, declare) {
      __callKey3(systemRegister, "call", this, deps, declare);
    });

    __setKey(systemJSPrototype, "createScript", function (url) {
      var script = __callKey1(document, "createElement", 'script');

      __setKey(script, "charset", 'utf-8');

      __setKey(script, "async", true);

      __setKey(script, "crossOrigin", 'anonymous');

      __setKey(script, "src", url);

      return script;
    });

    var lastWindowErrorUrl, lastWindowError;
    if (hasDocument) __callKey2(window, "addEventListener", 'error', function (evt) {
      lastWindowErrorUrl = evt._ES5ProxyType ? evt.get("filename") : evt.filename;
      lastWindowError = evt._ES5ProxyType ? evt.get("error") : evt.error;
    });

    __setKey(systemJSPrototype, "instantiate", function (url, firstParentUrl) {
      var loader = this;
      return new Promise(function (resolve, reject) {
        var script = __callKey1(systemJSPrototype, "createScript", url);

        __callKey2(script, "addEventListener", 'error', function () {
          reject(Error('Error loading ' + url + (firstParentUrl ? ' from ' + firstParentUrl : '')));
        });

        __callKey2(script, "addEventListener", 'load', function () {
          __callKey1(document._ES5ProxyType ? document.get("head") : document.head, "removeChild", script); // Note that if an error occurs that isn't caught by this if statement,
          // that getRegister will return null and a "did not instantiate" error will be thrown.


          if (lastWindowErrorUrl === url) {
            reject(lastWindowError);
          } else {
            resolve(__callKey0(loader, "getRegister"));
          }
        });

        __callKey1(document._ES5ProxyType ? document.get("head") : document.head, "appendChild", script);
      });
    });

    if (hasDocument) {
      __callKey2(window, "addEventListener", 'DOMContentLoaded', loadScriptModules);

      loadScriptModules();
    }

    function loadScriptModules() {
      __callKey2(Array.prototype._ES5ProxyType ? Array.prototype.get("forEach") : Array.prototype.forEach, "call", __callKey1(document, "querySelectorAll", 'script[type="text/javascript"]:not([src])'), function (script) {
        if (script._ES5ProxyType ? script.get("src") : script.src) {
          __callKey1(System, "import", __callKey2(script._ES5ProxyType ? script.get("src") : script.src, "slice", 0, 7) === 'import:' ? __callKey1(script._ES5ProxyType ? script.get("src") : script.src, "slice", 7) : resolveUrl(script._ES5ProxyType ? script.get("src") : script.src, baseUrl));
        }
      });
    }
    /*
     * Supports loading System.register in workers
     */


    if (hasSelf && typeof importScripts === 'function') __setKey(systemJSPrototype, "instantiate", function (url) {
      var loader = this;
      return new Promise(function (resolve, reject) {
        try {
          importScripts(url);
        } catch (e) {
          reject(e);
        }

        resolve(__callKey0(loader, "getRegister"));
      });
    });
    /*
     * SystemJS global script loading support
     * Extra for the s.js build only
     * (Included by default in system.js build)
     */

    (function (global) {
      var _System, _constructor, _prototype;

      var systemJSPrototype = (_System = global._ES5ProxyType ? global.get("System") : global.System, _constructor = _System._ES5ProxyType ? _System.get("constructor") : _System.constructor, _prototype = _constructor._ES5ProxyType ? _constructor.get("prototype") : _constructor.prototype);
      var isIE = __callKey1(navigator._ES5ProxyType ? navigator.get("userAgent") : navigator.userAgent, "indexOf", 'Trident') !== -1; // safari unpredictably lists some new globals first or second in object order

      var firstGlobalProp, secondGlobalProp, lastGlobalProp;

      function getGlobalProp() {
        var cnt = 0;
        var lastProp;

        for (var p in __iterableKey(global)) {
          var _p, _parent;

          // do not check frames cause it could be removed during import
          if (!__hasOwnProperty(global, p) || !isNaN(p) && p < (global._ES5ProxyType ? global.get("length") : global.length) || isIE && (global._ES5ProxyType ? global.get(p) : global[p]) && (_p = global._ES5ProxyType ? global.get(p) : global[p], _parent = _p._ES5ProxyType ? _p.get("parent") : _p.parent) === window) continue;
          if (cnt === 0 && p !== firstGlobalProp || cnt === 1 && p !== secondGlobalProp) return p;
          cnt++;
          lastProp = p;
        }

        if (lastProp !== lastGlobalProp) return lastProp;
      }

      function noteGlobalProps() {
        // alternatively Object.keys(global).pop()
        // but this may be faster (pending benchmarks)
        firstGlobalProp = secondGlobalProp = undefined;

        for (var p in __iterableKey(global)) {
          var _p2, _parent2;

          // do not check frames cause it could be removed during import
          if (!__hasOwnProperty(global, p) || !isNaN(p) && p < (global._ES5ProxyType ? global.get("length") : global.length) || isIE && (global._ES5ProxyType ? global.get(p) : global[p]) && (_p2 = global._ES5ProxyType ? global.get(p) : global[p], _parent2 = _p2._ES5ProxyType ? _p2.get("parent") : _p2.parent) === window) continue;
          if (!firstGlobalProp) firstGlobalProp = p;else if (!secondGlobalProp) secondGlobalProp = p;
          lastGlobalProp = p;
        }

        return lastGlobalProp;
      }

      var impt = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("import") : systemJSPrototype.import;

      __setKey(systemJSPrototype, "import", function (id, parentUrl) {
        noteGlobalProps();
        return __callKey3(impt, "call", this, id, parentUrl);
      });

      var emptyInstantiation = [[], function () {
        return {};
      }];
      var getRegister = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("getRegister") : systemJSPrototype.getRegister;

      __setKey(systemJSPrototype, "getRegister", function () {
        var lastRegister = __callKey1(getRegister, "call", this);

        if (lastRegister) return lastRegister; // no registration -> attempt a global detection as difference from snapshot
        // when multiple globals, we take the global value to be the last defined new global object property
        // for performance, this will not support multi-version / global collisions as previous SystemJS versions did
        // note in Edge, deleting and re-adding a global does not change its ordering

        var globalProp = getGlobalProp();
        if (!globalProp) return emptyInstantiation;
        var globalExport;

        try {
          globalExport = global._ES5ProxyType ? global.get(globalProp) : global[globalProp];
        } catch (e) {
          return emptyInstantiation;
        }

        return [[], function (_export) {
          return {
            execute: function execute() {
              _export({
                default: globalExport,
                __useDefault: true
              });
            }
          };
        }];
      });
    })(typeof self !== 'undefined' ? self : global);
    /*
     * Loads JSON, CSS, Wasm module types based on file extensions
     * Supports application/javascript falling back to JS eval
     */


    (function (global) {
      var _System2, _constructor2, _prototype2;

      var systemJSPrototype = (_System2 = global._ES5ProxyType ? global.get("System") : global.System, _constructor2 = _System2._ES5ProxyType ? _System2.get("constructor") : _System2.constructor, _prototype2 = _constructor2._ES5ProxyType ? _constructor2.get("prototype") : _constructor2.prototype);
      var instantiate = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("instantiate") : systemJSPrototype.instantiate;
      var moduleTypesRegEx = /\.(css|html|json|wasm)$/;

      __setKey(systemJSPrototype, "shouldFetch", function (url) {
        var _url$split$0$split, _5, _url$split, _6;

        var path = (_url$split$0$split = __callKey1((_url$split = __callKey1(url, "split", '?'), _6 = _url$split._ES5ProxyType ? _url$split.get(0) : _url$split[0]), "split", '#'), _5 = _url$split$0$split._ES5ProxyType ? _url$split$0$split.get(0) : _url$split$0$split[0]);

        var ext = __callKey1(path, "slice", __callKey1(path, "lastIndexOf", '.'));

        return __callKey1(ext, "match", moduleTypesRegEx);
      });

      __setKey(systemJSPrototype, "fetch", function (url) {
        return fetch(url);
      });

      __setKey(systemJSPrototype, "instantiate", function (url, parent) {
        var loader = this;

        if (__callKey1(this, "shouldFetch", url)) {
          return __callKey1(__callKey1(this, "fetch", url), "then", function (res) {
            if (!(res._ES5ProxyType ? res.get("ok") : res.ok)) throw Error((res._ES5ProxyType ? res.get("status") : res.status) + ' ' + (res._ES5ProxyType ? res.get("statusText") : res.statusText) + ', loading ' + url + (parent ? ' from ' + parent : ''));

            var contentType = __callKey1(res._ES5ProxyType ? res.get("headers") : res.headers, "get", 'content-type');

            if (__callKey1(contentType, "match", /^(text|application)\/(x-)?javascript(;|$)/)) {
              return __callKey1(__callKey0(res, "text"), "then", function (source) {
                (0, eval)(source);
                return __callKey0(loader, "getRegister");
              });
            } else if (__callKey1(contentType, "match", /^application\/json(;|$)/)) {
              return __callKey1(__callKey0(res, "text"), "then", function (source) {
                return [[], function (_export) {
                  return {
                    execute: function execute() {
                      _export('default', JSON.parse(source));
                    }
                  };
                }];
              });
            } else if (__callKey1(contentType, "match", /^text\/css(;|$)/)) {
              return __callKey1(__callKey0(res, "text"), "then", function (source) {
                return [[], function (_export) {
                  return {
                    execute: function execute() {
                      // Relies on a Constructable Stylesheet polyfill
                      var stylesheet = new CSSStyleSheet();

                      __callKey1(stylesheet, "replaceSync", source);

                      _export('default', stylesheet);
                    }
                  };
                }];
              });
            } else if (__callKey1(contentType, "match", /^application\/wasm(;|$)/)) {
              return __callKey1((WebAssembly._ES5ProxyType ? WebAssembly.get("compileStreaming") : WebAssembly.compileStreaming) ? __callKey1(WebAssembly, "compileStreaming", res) : __callKey1(__callKey0(res, "arrayBuffer"), "then", WebAssembly._ES5ProxyType ? WebAssembly.get("compile") : WebAssembly.compile), "then", function (module) {
                var _Module, _imports;

                var deps = [];
                var setters = [];
                var importObj = {}; // we can only set imports if supported (eg early Safari doesnt support)

                if (_Module = WebAssembly._ES5ProxyType ? WebAssembly.get("Module") : WebAssembly.Module, _imports = _Module._ES5ProxyType ? _Module.get("imports") : _Module.imports) __callKey1(__callKey1(WebAssembly._ES5ProxyType ? WebAssembly.get("Module") : WebAssembly.Module, "imports", module), "forEach", function (impt) {
                  var key = impt._ES5ProxyType ? impt.get("module") : impt.module;

                  if (__callKey1(deps, "indexOf", key) === -1) {
                    deps.push(key);
                    setters.push(function (m) {
                      __setKey(importObj, key, m);
                    });
                  }
                });
                return [deps, function (_export) {
                  return {
                    setters: setters,
                    execute: function execute() {
                      return __callKey1(__callKey2(WebAssembly, "instantiate", module, importObj), "then", function (instance) {
                        _export(instance._ES5ProxyType ? instance.get("exports") : instance.exports);
                      });
                    }
                  };
                }];
              });
            } else {
              throw new Error('Unknown module type "' + contentType + '"');
            }
          });
        }

        return __callKey2(instantiate, "apply", this, arguments);
      });
    })(typeof self !== 'undefined' ? self : global);

    var toStringTag$1 = typeof Symbol !== 'undefined' && Symbol.toStringTag;

    __setKey(systemJSPrototype, "get", function (id) {
      var _REGISTRY2, _id3;

      var load = (_REGISTRY2 = this._ES5ProxyType ? this.get(REGISTRY) : this[REGISTRY], _id3 = _REGISTRY2._ES5ProxyType ? _REGISTRY2.get(id) : _REGISTRY2[id]);

      if (load && (load._ES5ProxyType ? load.get("e") : load.e) === null && !(load._ES5ProxyType ? load.get("E") : load.E)) {
        if (load._ES5ProxyType ? load.get("er") : load.er) return null;
        return load._ES5ProxyType ? load.get("n") : load.n;
      }
    });

    __setKey(systemJSPrototype, "set", function (id, module) {
      var _REGISTRY3, _id4;

      var ns;

      if (toStringTag$1 && (module._ES5ProxyType ? module.get(toStringTag$1) : module[toStringTag$1]) === 'Module') {
        ns = module;
      } else {
        ns = Object.compatAssign(Object.create(null), module);
        if (toStringTag$1) Object.compatDefineProperty(ns, toStringTag$1, {
          value: 'Module'
        });
      }

      var done = Promise.resolve(ns);

      var load = (_REGISTRY3 = this._ES5ProxyType ? this.get(REGISTRY) : this[REGISTRY], _id4 = _REGISTRY3._ES5ProxyType ? _REGISTRY3.get(id) : _REGISTRY3[id]) || __setKey(this._ES5ProxyType ? this.get(REGISTRY) : this[REGISTRY], id, {
        id: id,
        i: [],
        h: false,
        d: [],
        e: null,
        er: undefined,
        E: undefined
      });

      if ((load._ES5ProxyType ? load.get("e") : load.e) || (load._ES5ProxyType ? load.get("E") : load.E)) return false;
      Object.compatAssign(load, {
        n: ns,
        I: undefined,
        L: undefined,
        C: done
      });
      return ns;
    });

    __setKey(systemJSPrototype, "has", function (id) {
      var _REGISTRY4, _id5;

      var load = (_REGISTRY4 = this._ES5ProxyType ? this.get(REGISTRY) : this[REGISTRY], _id5 = _REGISTRY4._ES5ProxyType ? _REGISTRY4.get(id) : _REGISTRY4[id]);
      return !!load;
    }); // Delete function provided for hot-reloading use cases


    __setKey(systemJSPrototype, "delete", function (id) {
      var registry = this._ES5ProxyType ? this.get(REGISTRY) : this[REGISTRY];
      var load = registry._ES5ProxyType ? registry.get(id) : registry[id]; // in future we can support load.E case by failing load first
      // but that will require TLA callbacks to be implemented

      if (!load || (load._ES5ProxyType ? load.get("e") : load.e) !== null || (load._ES5ProxyType ? load.get("E") : load.E)) return false;
      var importerSetters = load._ES5ProxyType ? load.get("i") : load.i; // remove from importerSetters
      // (release for gc)

      if (load._ES5ProxyType ? load.get("d") : load.d) __callKey1(load._ES5ProxyType ? load.get("d") : load.d, "forEach", function (depLoad) {
        var importerIndex = __callKey1(depLoad._ES5ProxyType ? depLoad.get("i") : depLoad.i, "indexOf", load);

        if (importerIndex !== -1) (depLoad._ES5ProxyType ? depLoad.get("i") : depLoad.i).splice(importerIndex, 1);
      });

      __deleteKey(registry, id);

      return function () {
        var load = registry._ES5ProxyType ? registry.get(id) : registry[id];
        if (!load || !importerSetters || (load._ES5ProxyType ? load.get("e") : load.e) !== null || (load._ES5ProxyType ? load.get("E") : load.E)) return false; // add back the old setters

        __callKey1(importerSetters, "forEach", function (setter) {
          (load._ES5ProxyType ? load.get("i") : load.i).push(setter);
          setter(load._ES5ProxyType ? load.get("n") : load.n);
        });

        importerSetters = null;
      };
    });

    var iterator = typeof Symbol !== 'undefined' && Symbol.iterator;

    __setKey(systemJSPrototype, "entries", function () {
      var loader = this,
          keys = Object.compatKeys(loader._ES5ProxyType ? loader.get(REGISTRY) : loader[REGISTRY]);
      var index = 0,
          ns,
          key;
      var result = {
        next: function next() {
          while ((key = (_ref14 = index++, _ref15 = keys._ES5ProxyType ? keys.get(_ref14) : keys[_ref14])) !== undefined && (ns = __callKey1(loader, "get", key)) === undefined) {
            var _ref14, _ref15;
          }

          return {
            done: key === undefined,
            value: key !== undefined && [key, ns]
          };
        }
      };

      __setKey(result, iterator, function () {
        return this;
      });

      return result;
    });
  })();
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * This replaces the 'DOMContentLoaded'/loadScriptModules() event from systemjs.
   * The original event was made into a no-op in '../scripts/rollup.config.system.js'
   * This logic ensures the webruntime-modules are executed IN ORDER, instead of in parallel.
   */

  /* eslint-disable */


  (function () {
    if (typeof document !== 'undefined') {
      __callKey2(window, "addEventListener", 'DOMContentLoaded', loadScriptModules);

      loadScriptModules();
    }

    function loadScriptModules() {
      var scriptLoadPromise = Promise.resolve();

      __callKey2(Array.prototype._ES5ProxyType ? Array.prototype.get("forEach") : Array.prototype.forEach, "call", __callKey1(document, "querySelectorAll", 'script[type=webruntime-module]'), function (script) {
        if (script._ES5ProxyType ? script.get("src") : script.src) {
          // Original logic:
          // System.import(script.src.slice(0, 7) === 'import:' ? script.src.slice(7) : resolveUrl(script.src, baseUrl));
          // Create a Promise change for the modules so they execute in order, rather than in parallel.
          scriptLoadPromise = __callKey1(scriptLoadPromise, "then", function () {
            return __callKey1(System, "import", __callKey2(script._ES5ProxyType ? script.get("src") : script.src, "slice", 0, 7) === 'import:' ? __callKey1(script._ES5ProxyType ? script.get("src") : script.src, "slice", 7) : __callKey1(System, "resolve", script._ES5ProxyType ? script.get("src") : script.src));
          });
        }
      });
    }
  })();
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * Lightning Web Runtime: Override the systemjs createScript which sets crossOrigin="anonymous" by default.
   * The attribute is broken for Safari, we can remove this hook when it is fixed: https://bugs.webkit.org/show_bug.cgi?id=171566.
   *
   */

  /* eslint-disable */


  (function (global) {
    var _System3, _constructor3, _prototype3;

    var systemPrototype = (_System3 = global._ES5ProxyType ? global.get("System") : global.System, _constructor3 = _System3._ES5ProxyType ? _System3.get("constructor") : _System3.constructor, _prototype3 = _constructor3._ES5ProxyType ? _constructor3.get("prototype") : _constructor3.prototype);

    __setKey(systemPrototype, "createScript", function (url) {
      var _location, _hostname;

      var script = __callKey1(document, "createElement", 'script');

      __setKey(script, "charset", 'utf-8');

      __setKey(script, "async", true);

      __setKey(script, "src", url);

      var a = __callKey1(document, "createElement", 'a');

      __setKey(a, "href", url);

      if ((a._ES5ProxyType ? a.get("hostname") : a.hostname) !== (_location = window._ES5ProxyType ? window.get("location") : window.location, _hostname = _location._ES5ProxyType ? _location.get("hostname") : _location.hostname)) {
        __setKey(script, "crossOrigin", 'anonymous');
      }

      return script;
    });
  })(typeof self !== 'undefined' ? self : global);
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * Lightning Web Runtime: This is a modified version of the AMD extra from https://github.com/systemjs/systemjs/blob/master/src/extras/amd.js.
   * The changes here contain a temporary patch to support circular dependencies, and multiple defines in one file aka "bundled AMD modules".
   *
   * This modified file is a copy of version 6.1.4
   */

  /* eslint-disable */


  (function (global) {
    var _System4, _constructor4, _prototype4;

    var systemPrototype = (_System4 = global._ES5ProxyType ? global.get("System") : global.System, _constructor4 = _System4._ES5ProxyType ? _System4.get("constructor") : _System4.constructor, _prototype4 = _constructor4._ES5ProxyType ? _constructor4.get("prototype") : _constructor4.prototype);
    var emptyInstantiation = [[], function () {
      return {};
    }];

    function unsupportedRequire() {
      throw Error('AMD require not supported.');
    } // LWR change: not used due to bundling changes, see comment in `addToRegisterRegistry`


    var tmpRegister; //, firstNamedDefine;

    function emptyFn() {}

    var requireExportsModule = ['require', 'exports', 'module'];

    function createAMDRegister(amdDefineDeps, amdDefineExec) {
      var exports = {};
      var module = {
        exports: exports
      };
      var depModules = [];
      var setters = [];
      var splice = 0;

      for (var i = 0; i < (amdDefineDeps._ES5ProxyType ? amdDefineDeps.get("length") : amdDefineDeps.length); i++) {
        var id = amdDefineDeps._ES5ProxyType ? amdDefineDeps.get(i) : amdDefineDeps[i];
        var index = setters._ES5ProxyType ? setters.get("length") : setters.length;

        if (id === 'require') {
          __setKey(depModules, i, unsupportedRequire);

          splice++;
        } else if (id === 'module') {
          __setKey(depModules, i, module);

          splice++;
        } else if (id === 'exports') {
          __setKey(depModules, i, exports);

          splice++;
        } else {
          (function () {
            // needed for ie11 lack of iteration scope
            var idx = i;
            setters.push(function (ns) {
              __setKey(depModules, idx, (ns._ES5ProxyType ? ns.get("__useDefault") : ns.__useDefault) ? ns._ES5ProxyType ? ns.get("default") : ns.default : ns);
            });
          })();
        }

        if (splice) __setKey(amdDefineDeps, index, id);
      }

      if (splice) __setKey(amdDefineDeps, "length", (amdDefineDeps._ES5ProxyType ? amdDefineDeps.get("length") : amdDefineDeps.length) - splice);
      var amdExec = amdDefineExec;
      return [amdDefineDeps, function (_export) {
        _export({
          default: exports,
          __useDefault: true
        });

        return {
          setters: setters,
          execute: __callKey2(function (deps) {
            var _loop = function _loop() {
              var dep = deps._ES5ProxyType ? deps.get(i) : deps[i];

              if (dep !== 'exports' && dep !== 'module' && dep !== 'require' && !__callKey1(dep, "startsWith", './') && !__callKey1(System, "get", __callKey1(System, "resolve", dep))) {
                var tmp = function tmp() {
                  var module = __callKey1(System, "get", __callKey1(System, "resolve", dep));

                  return (module._ES5ProxyType ? module.get("__useDefault") : module.__useDefault) ? module._ES5ProxyType ? module.get("default") : module.default : module;
                }; // __circular__ expected by LWC engine workaround


                __setKey(tmp, "__circular__", true);

                __setKey(depModules, i, tmp);
              }
            };

            // Workaround to handle circular/recursive dependencies.
            // This workaround is required until https://github.com/rollup/rollup/issues/3384 is resolved
            for (var i = 0; i < (deps._ES5ProxyType ? deps.get("length") : deps.length); i++) {
              _loop();
            } // START: Fix to ensure falsy modules (eg: empty strings, false, etc) are returned.
            // module.exports = amdExec.apply(exports, depModules) || module.exports;


            var amdResult = __callKey2(amdExec, "apply", exports, depModules);

            if (amdResult !== null && amdResult !== undefined) __setKey(module, "exports", amdResult); // END: falsy module fix

            if (exports !== (module._ES5ProxyType ? module.get("exports") : module.exports)) _export('default', module._ES5ProxyType ? module.get("exports") : module.exports);
          }, "bind", null, amdDefineDeps)
        };
      }];
    } // hook System.register to know the last declaration binding


    var lastRegisterDeclare;
    var systemRegister = systemPrototype._ES5ProxyType ? systemPrototype.get("register") : systemPrototype.register;

    __setKey(systemPrototype, "register", function (name, deps, declare) {
      lastRegisterDeclare = typeof name === 'string' ? declare : deps;

      __callKey2(systemRegister, "apply", this, arguments);
    });

    var instantiate = systemPrototype._ES5ProxyType ? systemPrototype.get("instantiate") : systemPrototype.instantiate;

    __setKey(systemPrototype, "instantiate", function () {
      // Reset "currently executing script"
      amdDefineDeps = null;
      bundleDefineQueue = [];
      return __callKey2(instantiate, "apply", this, arguments);
    });

    var getRegister = systemPrototype._ES5ProxyType ? systemPrototype.get("getRegister") : systemPrototype.getRegister;

    __setKey(systemPrototype, "getRegister", function () {
      if (tmpRegister) return tmpRegister; // const _firstNamedDefine = firstNamedDefine;
      // firstNamedDefine = null;

      var register = __callKey1(getRegister, "call", this); // if its an actual System.register leave it


      if (register && (register._ES5ProxyType ? register.get(1) : register[1]) === lastRegisterDeclare) return register; // const _amdDefineDeps = amdDefineDeps;

      var _ref = (bundleDefineQueue._ES5ProxyType ? bundleDefineQueue.get("length") : bundleDefineQueue.length) && bundleDefineQueue.pop(),
          _amdDefineDeps = _ref._ES5ProxyType ? _ref.get("amdDefineDeps") : _ref.amdDefineDeps,
          _amdDefineExec = _ref._ES5ProxyType ? _ref.get("amdDefineExec") : _ref.amdDefineExec;

      amdDefineDeps = null; // If the script registered a named module, return that module instead of re-instantiating it.
      // if (_firstNamedDefine) return _firstNamedDefine;
      // otherwise AMD takes priority
      // no registration -> attempt AMD detection

      if (!_amdDefineDeps) return register || emptyInstantiation;
      return createAMDRegister(_amdDefineDeps, _amdDefineExec);
    });
    /**
     * WebRuntime change:
     * Add queue of define dependencies to support
     * bundling for NAMED modules only (it doesn't make sense to bundle unamed).
     * The unmodified AMD extra only expects a single define when
     * a file is loaded.  It updates the scope global `amdDefineDeps`
     * with the `deps` of the `define`.  When there are multiple defines
     * in a file, `amdDefineDeps` is set to the `deps` of the last `define` call.
     * By the time `getRegister` is called, the expected deps doesn't match what it thinks
     * should be the deps from the first (and what it thinks is the only) `define`.
     *
     * The solution is to maintain a queue of the `deps` of each define call.  This will
     * match each `define` call to the expecting `getRegister` call.  Note that this also means
     * when requesting a specific component from a bundle, that component MUST be included *last*
     * in the bundle, or the component returned from the System.import() will not match.
     *
     * Eg System.import('myapp') // myapp --> /bundle.js through import-map
     *
     * // bundle.js - myapp must be last.
     * define('dep1',[],function(){});
     * define('myapp',['dep'], function(){})
     */


    var amdDefineDeps; // , amdDefineExec;

    var bundleDefineQueue = [];

    __setKey(global, "define", function (name, deps, execute) {
      // define('', [], function () {})
      if (typeof name === 'string') {
        var _depsAndExec = getDepsAndExec(deps, execute);

        if (amdDefineDeps) {
          if (!(System._ES5ProxyType ? System.get("registerRegistry") : System.registerRegistry)) throw Error('Include the named register extension for SystemJS named AMD support.');
          addToRegisterRegistry(name, createAMDRegister(_depsAndExec._ES5ProxyType ? _depsAndExec.get(0) : _depsAndExec[0], _depsAndExec._ES5ProxyType ? _depsAndExec.get(1) : _depsAndExec[1]));
          amdDefineDeps = [];
          amdDefineExec = emptyFn;
          return;
        } else {
          if (System._ES5ProxyType ? System.get("registerRegistry") : System.registerRegistry) addToRegisterRegistry(name, createAMDRegister(__concat([], _depsAndExec._ES5ProxyType ? _depsAndExec.get(0) : _depsAndExec[0]), _depsAndExec._ES5ProxyType ? _depsAndExec.get(1) : _depsAndExec[1]));
          name = deps;
          deps = execute;
        }
      }

      var depsAndExec = getDepsAndExec(name, deps);
      bundleDefineQueue.push({
        amdDefineDeps: depsAndExec._ES5ProxyType ? depsAndExec.get(0) : depsAndExec[0],
        amdDefineExec: depsAndExec._ES5ProxyType ? depsAndExec.get(1) : depsAndExec[1]
      });
    });

    __setKey(global._ES5ProxyType ? global.get("define") : global.define, "amd", {});

    function getDepsAndExec(arg1, arg2) {
      // define([], function () {})
      if (_instanceof(arg1, Array)) {
        return [arg1, arg2];
      } // define({})
      else if (_typeof(arg1) === 'object') {
          return [[], function () {
            return arg1;
          }];
        } // define(function () {})
        else if (typeof arg1 === 'function') {
            return [requireExportsModule, arg1];
          }
    }

    function addToRegisterRegistry(name, define) {
      // LWR change: This was added to fix a race condition in https://github.com/systemjs/systemjs/pull/2121
      // however, with our custom bundling changes, it is not required.

      /*if (!firstNamedDefine) {
          firstNamedDefine = define;
          setTimeout(function() {
              firstNamedDefine = null;
          });
      }*/
      // We must call System.getRegister() here to give other extras, such as the named-exports extra,
      // a chance to modify the define before it's put into the registerRegistry.
      // See https://github.com/systemjs/systemjs/issues/2073
      tmpRegister = define;

      __setKey(System._ES5ProxyType ? System.get("registerRegistry") : System.registerRegistry, name, __callKey0(System, "getRegister"));

      tmpRegister = null;
    }
  })(typeof self !== 'undefined' ? self : global);
  /*
   * Named exports support for legacy module formats in SystemJS 2.0
   */


  (function (global) {
    var _System5, _constructor5, _prototype5;

    var systemJSPrototype = (_System5 = global._ES5ProxyType ? global.get("System") : global.System, _constructor5 = _System5._ES5ProxyType ? _System5.get("constructor") : _System5.constructor, _prototype5 = _constructor5._ES5ProxyType ? _constructor5.get("prototype") : _constructor5.prototype); // hook System.register to know the last declaration binding

    var lastRegisterDeclare;
    var systemRegister = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("register") : systemJSPrototype.register;

    __setKey(systemJSPrototype, "register", function (name, deps, declare) {
      lastRegisterDeclare = typeof name === 'string' ? declare : deps;

      __callKey2(systemRegister, "apply", this, arguments);
    });

    var getRegister = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("getRegister") : systemJSPrototype.getRegister;

    __setKey(systemJSPrototype, "getRegister", function () {
      var _7, _length2;

      var register = __callKey1(getRegister, "call", this); // if it is an actual System.register call, then its ESM
      // -> dont add named exports


      if (!register || (register._ES5ProxyType ? register.get(1) : register[1]) === lastRegisterDeclare || (_7 = register._ES5ProxyType ? register.get(1) : register[1], _length2 = _7._ES5ProxyType ? _7.get("length") : _7.length) === 0) return register; // otherwise it was provided by a custom instantiator
      // -> extend the registration with named exports support

      var registerDeclare = register._ES5ProxyType ? register.get(1) : register[1];

      __setKey(register, 1, function (_export, _context) {
        // hook the _export function to note the default export
        var defaultExport,
            hasDefaultExport = false;

        var declaration = __callKey3(registerDeclare, "call", this, function (name, value) {
          if (_typeof(name) === 'object' && (name._ES5ProxyType ? name.get("__useDefault") : name.__useDefault)) defaultExport = name._ES5ProxyType ? name.get("default") : name.default, hasDefaultExport = true;else if (name === 'default') defaultExport = value;else if (name === '__useDefault') hasDefaultExport = true;

          _export(name, value);
        }, _context); // hook the execute function


        var execute = declaration._ES5ProxyType ? declaration.get("execute") : declaration.execute;
        if (execute) __setKey(declaration, "execute", function () {
          __callKey1(execute, "call", this); // do a bulk export of the default export object
          // to export all its names as named exports


          if (hasDefaultExport && _typeof(defaultExport) === 'object') for (var name in __iterableKey(defaultExport)) {
            // default is not a named export
            if (name !== 'default') {
              _export(name, defaultExport._ES5ProxyType ? defaultExport.get(name) : defaultExport[name]);
            }
          }
        });
        return declaration;
      });

      return register;
    });
  })(typeof self !== 'undefined' ? self : global);
  /*
   * SystemJS named register extension
   * Supports System.register('name', [..deps..], function (_export, _context) { ... })
   * 
   * Names are written to the registry as-is
   * System.register('x', ...) can be imported as System.import('x')
   */


  (function (global) {
    var _constructor6, _prototype6;

    var System = global._ES5ProxyType ? global.get("System") : global.System;
    setRegisterRegistry(System);
    var systemJSPrototype = (_constructor6 = System._ES5ProxyType ? System.get("constructor") : System.constructor, _prototype6 = _constructor6._ES5ProxyType ? _constructor6.get("prototype") : _constructor6.prototype);
    var constructor = System._ES5ProxyType ? System.get("constructor") : System.constructor;

    var SystemJS = function SystemJS() {
      __callKey1(constructor, "call", this);

      setRegisterRegistry(this);
    };

    __setKey(SystemJS, "prototype", systemJSPrototype);

    __setKey(System, "constructor", SystemJS);

    var firstNamedDefine;

    function setRegisterRegistry(systemInstance) {
      __setKey(systemInstance, "registerRegistry", Object.create(null));
    }

    var register = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("register") : systemJSPrototype.register;

    __setKey(systemJSPrototype, "register", function (name, deps, declare) {
      if (typeof name !== 'string') return __callKey2(register, "apply", this, arguments);
      var define = [deps, declare];

      __setKey(this._ES5ProxyType ? this.get("registerRegistry") : this.registerRegistry, name, define);

      if (!firstNamedDefine) {
        firstNamedDefine = define;
        setTimeout(function () {
          firstNamedDefine = null;
        });
      }

      return __callKey2(register, "apply", this, arguments);
    });

    var resolve = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("resolve") : systemJSPrototype.resolve;

    __setKey(systemJSPrototype, "resolve", function (id, parentURL) {
      try {
        // Prefer import map (or other existing) resolution over the registerRegistry
        return __callKey3(resolve, "call", this, id, parentURL);
      } catch (err) {
        if (__inKey(this._ES5ProxyType ? this.get("registerRegistry") : this.registerRegistry, id)) {
          return id;
        }

        throw err;
      }
    });

    var instantiate = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("instantiate") : systemJSPrototype.instantiate;

    __setKey(systemJSPrototype, "instantiate", function (url, firstParentUrl) {
      var _registerRegistry, _url;

      var result = (_registerRegistry = this._ES5ProxyType ? this.get("registerRegistry") : this.registerRegistry, _url = _registerRegistry._ES5ProxyType ? _registerRegistry.get(url) : _registerRegistry[url]);

      if (result) {
        __setKey(this._ES5ProxyType ? this.get("registerRegistry") : this.registerRegistry, url, null);

        return result;
      } else {
        return __callKey3(instantiate, "call", this, url, firstParentUrl);
      }
    });

    var getRegister = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("getRegister") : systemJSPrototype.getRegister;

    __setKey(systemJSPrototype, "getRegister", function () {
      // Calling getRegister() because other extras need to know it was called so they can perform side effects
      var register = __callKey1(getRegister, "call", this);

      var result = firstNamedDefine || register;
      firstNamedDefine = null;
      return result;
    });
  })(typeof self !== 'undefined' ? self : global);
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /*
   * Lightning Web Runtime: this patches the named-register plugin when resolving
   * named modules, see https://github.com/systemjs/systemjs/issues/2030
   */

  /* eslint-disable */


  (function (global) {
    var _constructor7, _prototype7;

    var System = global._ES5ProxyType ? global.get("System") : global.System;
    var systemJSPrototype = (_constructor7 = System._ES5ProxyType ? System.get("constructor") : System.constructor, _prototype7 = _constructor7._ES5ProxyType ? _constructor7.get("prototype") : _constructor7.prototype);
    /**
     * WebRuntime change: instead of resolving the ID for named modules,
     * we need to check if it is in the module registry as the URL.
     *
     * Works around module resolution issue with named modules:
     * https://github.com/systemjs/systemjs/issues/2030
     */

    var resolve = systemJSPrototype._ES5ProxyType ? systemJSPrototype.get("resolve") : systemJSPrototype.resolve;

    __setKey(systemJSPrototype, "resolve", function (id, parentURL) {
      if (__inKey(this._ES5ProxyType ? this.get("registerRegistry") : this.registerRegistry, id)) {
        // Get the import map URL value
        try {
          var importMapValue = __callKey3(resolve, "call", this, id, parentURL);

          if (__callKey1(this, "has", importMapValue)) {
            return importMapValue;
          }
        } catch (ignore) {
          /*ignore*/
        }

        return id;
      }

      return __callKey3(resolve, "call", this, id, parentURL);
    });
  })(typeof self !== 'undefined' ? self : global);
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */


  var localSystem = System;
  /* eslint-disable-line no-undef */

  var localDefine = define;
  /* eslint-disable-line no-undef */

  /** @hidden */

  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  function invariant(condition, errorInfo) {
    if (!condition) {
      throw new Error(__concat(__concat("LWR", errorInfo._ES5ProxyType ? errorInfo.get("code") : errorInfo.code, ": "), errorInfo._ES5ProxyType ? errorInfo.get("message") : errorInfo.message));
    }
  }

  var messages = {
    MISSING_NAME: {
      code: 3000,
      message: 'A module name is required.',
      level: 0,
      url: ''
    },
    INVALID_DEPS: {
      code: 3001,
      message: 'Unexpected value received for dependencies argument; expected an array.',
      level: 0,
      url: ''
    }
  };
  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /**
   * A module loader supporting import maps for module resolution.
   */

  var loader = {
    /**
     * "Declares" a single module, caching the metadata: name (if given), dependencies, and the function.
     * Once a module is executed (eg requested via a loader.load), or as a dependency of another executed module,
     * its dependencies are asynchronously resolved and the module function is called.
     *
     * @param {string} name - The name of the module to add
     * @param {string[]} dependencies - An array literal of the module ids that are dependencies required by the module that is being defined
     * @param {Function} execute - A function that should be executed to instantiate the module or an object
     */
    define: function define(name, dependencies, execute) {
      var _registerRegistry2, _name;

      invariant(typeof name === 'string', messages._ES5ProxyType ? messages.get("MISSING_NAME") : messages.MISSING_NAME);
      var ctor = execute;
      var deps = dependencies; // Convert no dependencies form `define('name', function(){});`
      // to: `define('name', [], function(){})`

      if (typeof deps === 'function') {
        ctor = dependencies;
        deps = [];
      }

      invariant(Array.compatIsArray(deps), messages._ES5ProxyType ? messages.get("INVALID_DEPS") : messages.INVALID_DEPS); // ignore if module is already registered

      if (!(_registerRegistry2 = localSystem._ES5ProxyType ? localSystem.get("registerRegistry") : localSystem.registerRegistry, _name = _registerRegistry2._ES5ProxyType ? _registerRegistry2.get(name) : _registerRegistry2[name])) {
        localDefine(name, deps, ctor);
      }
    },

    /**
     * Polyfill for dynamic import(). Loads a module by name or URL
     *
     * @param {string} id - The name or URL of the module to load
     */
    load: function () {
      var _load = _asyncToGenerator(
      /*#__PURE__*/
      __callKey1(_regeneratorRuntime, "mark", function _callee(id) {
        return __callKey2(_regeneratorRuntime, "wrap", function _callee$(_context2) {
          while (1) {
            switch (__setKey(_context2, "prev", _context2._ES5ProxyType ? _context2.get("next") : _context2.next)) {
              case 0:
                return __callKey2(_context2, "abrupt", "return", __callKey1(localSystem, "import", id));

              case 1:
              case "end":
                return __callKey0(_context2, "stop");
            }
          }
        }, _callee);
      }));

      function load(_x) {
        return __callKey2(_load, "apply", this, arguments);
      }

      return load;
    }(),

    /**
     * Check if registrry contains module
     *
     * @param {string} id - The name or URL of the module to check
     */
    has: function has(id) {
      return !!__callKey1(localSystem, "has", id);
    },

    /**
     * Get the module from the module registry
     *
     * @param {string} id - The name or URL of the module to get
     * @param {boolean} [resolve = false] - Resolve the module ID
     */
    get: function get(id) {
      return __callKey1(localSystem, "get", id);
    },

    /**
     * Resolve the resolved URL for a module id
     *
     * @param {string} id - The name or URL of the module to get
     */
    resolve: function resolve(id) {
      return __callKey1(localSystem, "resolve", id);
    },

    /**
     * "Declares" multiple modules to the registry by name.
     *
     * @param {object.<string, module>} modulesByName - An object where key is the name of
     *                                  the module to register, and the value is module
     */
    defineModules: function defineModules(modulesByName) {
      if (modulesByName) {
        __callKey1(Object.compatEntries(modulesByName), "forEach", function (_ref2) {
          var _registerRegistry3, _name2;

          var _ref3 = _slicedToArray(_ref2, 2),
              name = _ref3._ES5ProxyType ? _ref3.get(0) : _ref3[0],
              module = _ref3._ES5ProxyType ? _ref3.get(1) : _ref3[1];

          // ignore if module is already registered
          if (!(_registerRegistry3 = localSystem._ES5ProxyType ? localSystem.get("registerRegistry") : localSystem.registerRegistry, _name2 = _registerRegistry3._ES5ProxyType ? _registerRegistry3.get(name) : _registerRegistry3[name])) {
            localDefine(name, [], function () {
              return module;
            });
          }
        });
      }
    },
    delete: function _delete(specifier) {
      var _registerRegistry4, _specifier;

      if (_registerRegistry4 = localSystem._ES5ProxyType ? localSystem.get("registerRegistry") : localSystem.registerRegistry, _specifier = _registerRegistry4._ES5ProxyType ? _registerRegistry4.get(specifier) : _registerRegistry4[specifier]) {
        __deleteKey(localSystem._ES5ProxyType ? localSystem.get("registerRegistry") : localSystem.registerRegistry, specifier);
      }

      var result = __callKey1(localSystem, "delete", specifier);

      try {
        var url = __callKey1(localSystem, "resolve", specifier);

        return __callKey1(localSystem, "delete", url);
      } catch (exception) {
        // resolve might fail with url if import was with specifier
        return result;
      }
    }
  };
  var define$1 = loader._ES5ProxyType ? loader.get("define") : loader.define,
      load = loader._ES5ProxyType ? loader.get("load") : loader.load,
      get = loader._ES5ProxyType ? loader.get("get") : loader.get,
      has = loader._ES5ProxyType ? loader.get("has") : loader.has,
      resolve = loader._ES5ProxyType ? loader.get("resolve") : loader.resolve,
      defineModules = loader._ES5ProxyType ? loader.get("defineModules") : loader.defineModules,
      deleteModule = loader._ES5ProxyType ? loader.get("delete") : loader.delete; // For testing only, since no support for instances yet

  var _create, _create2;

  /* proxy-compat-disable */
  function invariant$1(value, msg) {
    if (!value) {
      throw new Error("Invariant Violation: ".concat(msg));
    }
  }

  function isTrue(value, msg) {
    if (!value) {
      throw new Error("Assert Violation: ".concat(msg));
    }
  }

  function isFalse(value, msg) {
    if (value) {
      throw new Error("Assert Violation: ".concat(msg));
    }
  }

  function fail(msg) {
    throw new Error(msg);
  }

  var assert = Object.freeze({
    __proto__: null,
    invariant: invariant$1,
    isTrue: isTrue,
    isFalse: isFalse,
    fail: fail
  });
  var assign = Object.assign,
      create = Object.create,
      defineProperties = Object.defineProperties,
      defineProperty = Object.defineProperty,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
      getPrototypeOf = Object.getPrototypeOf,
      hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf;
  var isArray = Array.isArray;
  var _Array$prototype = Array.prototype,
      ArrayFilter = _Array$prototype.filter,
      ArrayFind = _Array$prototype.find,
      forEach = _Array$prototype.forEach,
      ArrayIndexOf = _Array$prototype.indexOf,
      ArrayJoin = _Array$prototype.join,
      ArrayMap = _Array$prototype.map,
      ArrayPush = _Array$prototype.push,
      ArrayReduce = _Array$prototype.reduce,
      ArrayReverse = _Array$prototype.reverse,
      ArraySlice = _Array$prototype.slice,
      ArraySplice = _Array$prototype.splice,
      ArrayUnshift = _Array$prototype.unshift;
  var _String$prototype = String.prototype,
      StringCharCodeAt = _String$prototype.charCodeAt;

  function isUndefined(obj) {
    return obj === undefined;
  }

  function isNull(obj) {
    return obj === null;
  }

  function isTrue$1(obj) {
    return obj === true;
  }

  function isFalse$1(obj) {
    return obj === false;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function isObject(obj) {
    return _typeof(obj) === 'object';
  }

  var OtS = {}.toString;

  function toString(obj) {
    if (obj && obj.toString) {
      if (isArray(obj)) {
        return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
      }

      return obj.toString();
    } else if (_typeof(obj) === 'object') {
      return OtS.call(obj);
    } else {
      return obj + emptyString;
    }
  }

  function getPropertyDescriptor(o, p) {
    do {
      var d = getOwnPropertyDescriptor(o, p);

      if (!isUndefined(d)) {
        return d;
      }

      o = getPrototypeOf(o);
    } while (o !== null);
  }

  var emptyString = '';
  var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';

  function createHiddenField(key, namespace) {
    return hasNativeSymbolsSupport ? Symbol(key) : "$$lwc-".concat(namespace, "-").concat(key, "$$");
  }

  var hiddenFieldsMap = new WeakMap();

  function setHiddenField(o, field, value) {
    var valuesByField = hiddenFieldsMap.get(o);

    if (isUndefined(valuesByField)) {
      valuesByField = create(null);
      hiddenFieldsMap.set(o, valuesByField);
    }

    valuesByField[field] = value;
  }

  function getHiddenField(o, field) {
    var valuesByField = hiddenFieldsMap.get(o);

    if (!isUndefined(valuesByField)) {
      return valuesByField[field];
    }
  }

  var _Node = Node,
      DOCUMENT_POSITION_CONTAINED_BY = _Node.DOCUMENT_POSITION_CONTAINED_BY,
      DOCUMENT_POSITION_CONTAINS = _Node.DOCUMENT_POSITION_CONTAINS,
      DOCUMENT_POSITION_PRECEDING = _Node.DOCUMENT_POSITION_PRECEDING,
      DOCUMENT_POSITION_FOLLOWING = _Node.DOCUMENT_POSITION_FOLLOWING,
      ELEMENT_NODE = _Node.ELEMENT_NODE,
      TEXT_NODE = _Node.TEXT_NODE,
      CDATA_SECTION_NODE = _Node.CDATA_SECTION_NODE,
      PROCESSING_INSTRUCTION_NODE = _Node.PROCESSING_INSTRUCTION_NODE,
      COMMENT_NODE = _Node.COMMENT_NODE;
  var _Node$prototype = Node.prototype,
      appendChild = _Node$prototype.appendChild,
      cloneNode = _Node$prototype.cloneNode,
      compareDocumentPosition = _Node$prototype.compareDocumentPosition,
      insertBefore = _Node$prototype.insertBefore,
      removeChild = _Node$prototype.removeChild,
      replaceChild = _Node$prototype.replaceChild,
      hasChildNodes = _Node$prototype.hasChildNodes;
  var contains = HTMLElement.prototype.contains;
  var firstChildGetter = getOwnPropertyDescriptor(Node.prototype, 'firstChild').get;
  var lastChildGetter = getOwnPropertyDescriptor(Node.prototype, 'lastChild').get;
  var textContentGetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
  var parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
  var ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
  var parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement') ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
  var textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
  var childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes') ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
  var isConnected = hasOwnProperty.call(Node.prototype, 'isConnected') ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get : function () {
    var doc = ownerDocumentGetter.call(this);
    return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  };
  var _Element$prototype = Element.prototype,
      addEventListener = _Element$prototype.addEventListener,
      getAttribute = _Element$prototype.getAttribute,
      getBoundingClientRect = _Element$prototype.getBoundingClientRect,
      getElementsByTagName = _Element$prototype.getElementsByTagName,
      getElementsByTagNameNS = _Element$prototype.getElementsByTagNameNS,
      hasAttribute = _Element$prototype.hasAttribute,
      querySelectorAll = _Element$prototype.querySelectorAll,
      removeAttribute = _Element$prototype.removeAttribute,
      removeEventListener = _Element$prototype.removeEventListener,
      setAttribute = _Element$prototype.setAttribute;
  var attachShadow = hasOwnProperty.call(Element.prototype, 'attachShadow') ? Element.prototype.attachShadow : function () {
    throw new TypeError('attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components');
  };
  var childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;
  var firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
  var lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;
  var innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'innerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');
  var innerHTMLGetter = innerHTMLDescriptor.get;
  var innerHTMLSetter = innerHTMLDescriptor.set;
  var outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'outerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML');
  var outerHTMLGetter = outerHTMLDescriptor.get;
  var outerHTMLSetter = outerHTMLDescriptor.set;
  var tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
  var tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');
  var tabIndexGetter = tabIndexDescriptor.get;
  var tabIndexSetter = tabIndexDescriptor.set;
  var matches = hasOwnProperty.call(Element.prototype, 'matches') ? Element.prototype.matches : Element.prototype.msMatchesSelector;
  var childrenGetter = hasOwnProperty.call(Element.prototype, 'children') ? getOwnPropertyDescriptor(Element.prototype, 'children').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
  var getElementsByClassName = HTMLElement.prototype.getElementsByClassName;
  var shadowRootGetter = hasOwnProperty.call(Element.prototype, 'shadowRoot') ? getOwnPropertyDescriptor(Element.prototype, 'shadowRoot').get : function () {
    return null;
  };
  var assignedNodes, assignedElements;

  if (typeof HTMLSlotElement !== 'undefined') {
    assignedNodes = HTMLSlotElement.prototype.assignedNodes;
    assignedElements = HTMLSlotElement.prototype.assignedElements;
  } else {
    assignedNodes = function assignedNodes() {
      throw new TypeError("assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };

    assignedElements = function assignedElements() {
      throw new TypeError("assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
  }

  var dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
  var eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
  var eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
  var focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;
  var DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
  var elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint') ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
  var defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
  var _Document$prototype = Document.prototype,
      createComment = _Document$prototype.createComment,
      querySelectorAll$1 = _Document$prototype.querySelectorAll,
      getElementById = _Document$prototype.getElementById,
      getElementsByClassName$1 = _Document$prototype.getElementsByClassName,
      getElementsByTagName$1 = _Document$prototype.getElementsByTagName,
      getElementsByTagNameNS$1 = _Document$prototype.getElementsByTagNameNS;
  var getElementsByName = HTMLDocument.prototype.getElementsByName;
  var _window = window,
      windowAddEventListener = _window.addEventListener,
      windowRemoveEventListener = _window.removeEventListener;
  var MO = MutationObserver;
  var MutationObserverObserve = MO.prototype.observe;

  function detect() {
    return typeof HTMLSlotElement === 'undefined';
  }

  var createElement = Document.prototype.createElement;
  var CHAR_S = 115;
  var CHAR_L = 108;
  var CHAR_O = 111;
  var CHAR_T = 116;

  function apply() {
    var HTMLSlotElement = function HTMLSlotElement() {
      _classCallCheck(this, HTMLSlotElement);
    };

    setPrototypeOf(HTMLSlotElement, HTMLElement.constructor);
    setPrototypeOf(HTMLSlotElement.prototype, HTMLElement.prototype);
    Window.prototype.HTMLSlotElement = HTMLSlotElement;
    defineProperty(Document.prototype, 'createElement', {
      value: function value(tagName, _options) {
        var elm = createElement.apply(this, ArraySlice.call(arguments));

        if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
          setPrototypeOf(elm, HTMLSlotElement.prototype);
        }

        return elm;
      }
    });
  }

  if (detect()) {
    apply();
  }

  var create$1 = Object.create;
  var hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';

  var _globalThis;

  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object') {
    _globalThis = globalThis;
  }

  function getGlobalThis() {
    if (_typeof(_globalThis) === 'object') {
      return _globalThis;
    }

    try {
      Object.defineProperty(Object.prototype, '__magic__', {
        get: function get() {
          return this;
        },
        configurable: true
      });
      _globalThis = __magic__;
      delete Object.prototype.__magic__;
    } catch (ex) {} finally {
      if (typeof _globalThis === 'undefined') {
        _globalThis = window;
      }
    }

    return _globalThis;
  }

  var _globalThis$1 = getGlobalThis();

  if (!_globalThis$1.lwcRuntimeFlags) {
    Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {
      value: create$1(null)
    });
  }

  var runtimeFlags = _globalThis$1.lwcRuntimeFlags;

  function getOwnerDocument(node) {
    var doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
  }

  function getOwnerWindow(node) {
    var doc = getOwnerDocument(node);
    var win = defaultViewGetter.call(doc);

    if (win === null) {
      throw new TypeError();
    }

    return win;
  }

  var skipGlobalPatching;

  function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
      var ownerDocument = getOwnerDocument(node);
      skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') === 'temporary-bypass';
    }

    return isTrue$1(skipGlobalPatching);
  }

  function arrayFromCollection(collection) {
    var size = collection.length;
    var cloned = [];

    if (size > 0) {
      for (var i = 0; i < size; i++) {
        cloned[i] = collection[i];
      }
    }

    return cloned;
  }

  function pathComposer(startNode, composed) {
    var composedPath = [];
    var current = startNode;
    var startRoot = _instanceof(startNode, Window) ? startNode : startNode.getRootNode();

    while (!isNull(current)) {
      composedPath.push(current);
      var assignedSlot = null;

      if (_instanceof(current, Element)) {
        assignedSlot = current.assignedSlot;
      }

      if (!isNull(assignedSlot)) {
        current = assignedSlot;
      } else if (_instanceof(current, ShadowRoot) && (composed || current !== startRoot)) {
        current = current.host;
      } else {
        current = current.parentNode;
      }
    }

    var doc;

    if (_instanceof(startNode, Window)) {
      doc = startNode.document;
    } else {
      doc = getOwnerDocument(startNode);
    }

    if (composedPath[composedPath.length - 1] === doc) {
      composedPath.push(window);
    }

    return composedPath;
  }

  function retarget(refNode, path) {
    if (isNull(refNode)) {
      return null;
    }

    var refNodePath = pathComposer(refNode, true);
    var p$ = path;

    for (var i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
      ancestor = p$[i];
      root = _instanceof(ancestor, Window) ? ancestor : ancestor.getRootNode();

      if (root !== lastRoot) {
        rootIdx = refNodePath.indexOf(root);
        lastRoot = root;
      }

      if (!_instanceof(root, SyntheticShadowRoot) || !isUndefined(rootIdx) && rootIdx > -1) {
        return ancestor;
      }
    }

    return null;
  }

  var EventListenerContext;

  (function (EventListenerContext) {
    EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
    EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
  })(EventListenerContext || (EventListenerContext = {}));

  var eventToContextMap = new WeakMap();

  function isChildNode(root, node) {
    return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
  }

  var GET_ROOT_NODE_CONFIG_FALSE = {
    composed: false
  };

  function getRootNodeHost(node, options) {
    var rootNode = node.getRootNode(options);

    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
      rootNode = getHost(rootNode);
    }

    return rootNode;
  }

  function targetGetter() {
    var originalCurrentTarget = eventCurrentTargetGetter.call(this);
    var originalTarget = eventTargetGetter.call(this);
    var composedPath = pathComposer(originalTarget, this.composed);
    var doc = getOwnerDocument(originalTarget);

    if (!_instanceof(originalCurrentTarget, Node)) {
      if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    } else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
      if (isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    }

    var eventContext = eventToContextMap.get(this);
    var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
    return retarget(currentTarget, composedPath);
  }

  function composedPathValue() {
    var originalTarget = eventTargetGetter.call(this);
    var originalCurrentTarget = eventCurrentTargetGetter.call(this);
    return isNull(originalCurrentTarget) ? [] : pathComposer(originalTarget, this.composed);
  }

  function patchEvent(event) {
    if (eventToContextMap.has(event)) {
      return;
    }

    defineProperties(event, {
      target: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      composedPath: {
        value: composedPathValue,
        writable: true,
        enumerable: true,
        configurable: true
      },
      srcElement: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      path: {
        get: composedPathValue,
        enumerable: true,
        configurable: true
      }
    });
    var originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');

    if (!isUndefined(originalRelatedTargetDescriptor)) {
      var relatedTargetGetter = originalRelatedTargetDescriptor.get;
      defineProperty(event, 'relatedTarget', {
        get: function get() {
          var eventContext = eventToContextMap.get(this);
          var originalCurrentTarget = eventCurrentTargetGetter.call(this);
          var relatedTarget = relatedTargetGetter.call(this);

          if (isNull(relatedTarget)) {
            return null;
          }

          var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
          return retarget(currentTarget, pathComposer(relatedTarget, true));
        },
        enumerable: true,
        configurable: true
      });
    }

    eventToContextMap.set(event, 0);
  }

  var customElementToWrappedListeners = new WeakMap();

  function getEventMap(elm) {
    var listenerInfo = customElementToWrappedListeners.get(elm);

    if (isUndefined(listenerInfo)) {
      listenerInfo = create(null);
      customElementToWrappedListeners.set(elm, listenerInfo);
    }

    return listenerInfo;
  }

  var shadowRootEventListenerMap = new WeakMap();

  function getWrappedShadowRootListener(sr, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    var shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);

    if (isUndefined(shadowRootWrappedListener)) {
      shadowRootWrappedListener = function shadowRootWrappedListener(event) {
        var composed = event.composed;
        var target = eventTargetGetter.call(event);
        var currentTarget = eventCurrentTargetGetter.call(event);

        if (target !== currentTarget) {
          var rootNode = getRootNodeHost(target, {
            composed: composed
          });

          if (isChildNode(rootNode, currentTarget) || composed === false && rootNode === currentTarget) {
            listener.call(sr, event);
          }
        }
      };

      shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;

      {
        shadowRootWrappedListener.original = listener;
      }

      shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }

    return shadowRootWrappedListener;
  }

  var customElementEventListenerMap = new WeakMap();

  function getWrappedCustomElementListener(elm, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    var customElementWrappedListener = customElementEventListenerMap.get(listener);

    if (isUndefined(customElementWrappedListener)) {
      customElementWrappedListener = function customElementWrappedListener(event) {
        if (isValidEventForCustomElement(event)) {
          listener.call(elm, event);
        }
      };

      customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;

      {
        customElementWrappedListener.original = listener;
      }

      customElementEventListenerMap.set(listener, customElementWrappedListener);
    }

    return customElementWrappedListener;
  }

  function domListener(evt) {
    patchEvent(evt);
    var immediatePropagationStopped = false;
    var propagationStopped = false;
    var type = evt.type,
        stopImmediatePropagation = evt.stopImmediatePropagation,
        stopPropagation = evt.stopPropagation;
    var currentTarget = eventCurrentTargetGetter.call(evt);
    var listenerMap = getEventMap(currentTarget);
    var listeners = listenerMap[type];
    defineProperty(evt, 'stopImmediatePropagation', {
      value: function value() {
        immediatePropagationStopped = true;
        stopImmediatePropagation.call(evt);
      },
      writable: true,
      enumerable: true,
      configurable: true
    });
    defineProperty(evt, 'stopPropagation', {
      value: function value() {
        propagationStopped = true;
        stopPropagation.call(evt);
      },
      writable: true,
      enumerable: true,
      configurable: true
    });
    var bookkeeping = ArraySlice.call(listeners);

    function invokeListenersByPlacement(placement) {
      forEach.call(bookkeeping, function (listener) {
        if (isFalse$1(immediatePropagationStopped) && listener.placement === placement) {
          if (ArrayIndexOf.call(listeners, listener) !== -1) {
            listener.call(undefined, evt);
          }
        }
      });
    }

    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);

    if (isFalse$1(immediatePropagationStopped) && isFalse$1(propagationStopped)) {
      eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
      invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    }

    eventToContextMap.set(evt, 0);
  }

  function attachDOMListener(elm, type, wrappedListener) {
    var listenerMap = getEventMap(elm);
    var cmpEventHandlers = listenerMap[type];

    if (isUndefined(cmpEventHandlers)) {
      cmpEventHandlers = listenerMap[type] = [];
    }

    if (cmpEventHandlers.length === 0) {
      addEventListener.call(elm, type, domListener);
    }

    ArrayPush.call(cmpEventHandlers, wrappedListener);
  }

  function detachDOMListener(elm, type, wrappedListener) {
    var listenerMap = getEventMap(elm);
    var p;
    var listeners;

    if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
      ArraySplice.call(listeners, p, 1);

      if (listeners.length === 0) {
        removeEventListener.call(elm, type, domListener);
      }
    }
  }

  function isValidEventForCustomElement(event) {
    var target = eventTargetGetter.call(event);
    var currentTarget = eventCurrentTargetGetter.call(event);
    var composed = event.composed;
    return composed === true || target === currentTarget || isChildNode(getRootNodeHost(target, GET_ROOT_NODE_CONFIG_FALSE), currentTarget);
  }

  function addCustomElementEventListener(elm, type, listener, _options) {
    {
      if (!isFunction(listener)) {
        throw new TypeError("Invalid second argument for Element.addEventListener() in ".concat(toString(elm), " for event \"").concat(type, "\". Expected an EventListener but received ").concat(listener, "."));
      }
    }

    var wrappedListener = getWrappedCustomElementListener(elm, listener);
    attachDOMListener(elm, type, wrappedListener);
  }

  function removeCustomElementEventListener(elm, type, listener, _options) {
    var wrappedListener = getWrappedCustomElementListener(elm, listener);
    detachDOMListener(elm, type, wrappedListener);
  }

  function addShadowRootEventListener(sr, type, listener, _options) {
    {
      if (!isFunction(listener)) {
        throw new TypeError("Invalid second argument for ShadowRoot.addEventListener() in ".concat(toString(sr), " for event \"").concat(type, "\". Expected an EventListener but received ").concat(listener, "."));
      }
    }

    var elm = getHost(sr);
    var wrappedListener = getWrappedShadowRootListener(sr, listener);
    attachDOMListener(elm, type, wrappedListener);
  }

  function removeShadowRootEventListener(sr, type, listener, _options) {
    var elm = getHost(sr);
    var wrappedListener = getWrappedShadowRootListener(sr, listener);
    detachDOMListener(elm, type, wrappedListener);
  }

  function getTextContent(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          var childNodes = getFilteredChildNodes(node);
          var content = '';

          for (var i = 0, len = childNodes.length; i < len; i += 1) {
            var currentNode = childNodes[i];

            if (currentNode.nodeType !== COMMENT_NODE) {
              content += getTextContent(currentNode);
            }
          }

          return content;
        }

      default:
        return node.nodeValue;
    }
  }

  var Items = createHiddenField('StaticNodeListItems', 'synthetic-shadow');

  function StaticNodeList() {
    throw new TypeError('Illegal constructor');
  }

  StaticNodeList.prototype = create(NodeList.prototype, (_create = {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticNodeList
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(index) {
        return this[index];
      }
    },
    length: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return getHiddenField(this, Items).length;
      }
    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items), cb, thisArg);
      }
    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        return ArrayMap.call(getHiddenField(this, Items), function (v, i) {
          return [i, v];
        });
      }
    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        return ArrayMap.call(getHiddenField(this, Items), function (_v, i) {
          return i;
        });
      }
    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        return getHiddenField(this, Items);
      }
    }
  }, _defineProperty(_create, Symbol.iterator, {
    writable: true,
    configurable: true,
    value: function value() {
      var _this = this;

      var nextIndex = 0;
      return {
        next: function next() {
          var items = getHiddenField(_this, Items);
          return nextIndex < items.length ? {
            value: items[nextIndex++],
            done: false
          } : {
            done: true
          };
        }
      };
    }
  }), _defineProperty(_create, Symbol.toStringTag, {
    configurable: true,
    get: function get() {
      return 'NodeList';
    }
  }), _defineProperty(_create, "toString", {
    writable: true,
    configurable: true,
    value: function value() {
      return '[object NodeList]';
    }
  }), _create));
  setPrototypeOf(StaticNodeList, NodeList);

  function createStaticNodeList(items) {
    var nodeList = create(StaticNodeList.prototype);
    setHiddenField(nodeList, Items, items);
    forEach.call(items, function (item, index) {
      defineProperty(nodeList, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return nodeList;
  }

  var Items$1 = createHiddenField('StaticHTMLCollectionItems', 'synthetic-shadow');

  function StaticHTMLCollection() {
    throw new TypeError('Illegal constructor');
  }

  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, (_create2 = {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticHTMLCollection
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(index) {
        return this[index];
      }
    },
    length: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return getHiddenField(this, Items$1).length;
      }
    },
    namedItem: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(name) {
        if (name === '') {
          return null;
        }

        var items = getHiddenField(this, Items$1);

        for (var i = 0, len = items.length; i < len; i++) {
          var item = items[len];

          if (name === getAttribute.call(item, 'id') || name === getAttribute.call(item, 'name')) {
            return item;
          }
        }

        return null;
      }
    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items$1), cb, thisArg);
      }
    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        return ArrayMap.call(getHiddenField(this, Items$1), function (v, i) {
          return [i, v];
        });
      }
    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        return ArrayMap.call(getHiddenField(this, Items$1), function (v, i) {
          return i;
        });
      }
    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        return getHiddenField(this, Items$1);
      }
    }
  }, _defineProperty(_create2, Symbol.iterator, {
    writable: true,
    configurable: true,
    value: function value() {
      var _this2 = this;

      var nextIndex = 0;
      return {
        next: function next() {
          var items = getHiddenField(_this2, Items$1);
          return nextIndex < items.length ? {
            value: items[nextIndex++],
            done: false
          } : {
            done: true
          };
        }
      };
    }
  }), _defineProperty(_create2, Symbol.toStringTag, {
    configurable: true,
    get: function get() {
      return 'HTMLCollection';
    }
  }), _defineProperty(_create2, "toString", {
    writable: true,
    configurable: true,
    value: function value() {
      return '[object HTMLCollection]';
    }
  }), _create2));
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);

  function createStaticHTMLCollection(items) {
    var collection = create(StaticHTMLCollection.prototype);
    setHiddenField(collection, Items$1, items);
    forEach.call(items, function (item, index) {
      defineProperty(collection, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return collection;
  }

  function getInnerHTML(node) {
    var s = '';
    var childNodes = getFilteredChildNodes(node);

    for (var i = 0, len = childNodes.length; i < len; i += 1) {
      s += getOuterHTML(childNodes[i]);
    }

    return s;
  }

  var escapeAttrRegExp = /[&\u00A0"]/g;
  var escapeDataRegExp = /[&\u00A0<>]/g;
  var _String$prototype2 = String.prototype,
      replace = _String$prototype2.replace,
      toLowerCase = _String$prototype2.toLowerCase;

  function escapeReplace(c) {
    switch (c) {
      case '&':
        return '&amp;';

      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '"':
        return '&quot;';

      case "\xA0":
        return '&nbsp;';

      default:
        return '';
    }
  }

  function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
  }

  function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
  }

  var voidElements = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);
  var plaintextParents = new Set(['STYLE', 'SCRIPT', 'XMP', 'IFRAME', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT', 'NOSCRIPT']);

  function getOuterHTML(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          var attrs = node.attributes;
          var tagName = tagNameGetter.call(node);
          var s = '<' + toLowerCase.call(tagName);

          for (var i = 0, attr; attr = attrs[i]; i++) {
            s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
          }

          s += '>';

          if (voidElements.has(tagName)) {
            return s;
          }

          return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
        }

      case TEXT_NODE:
        {
          var data = node.data,
              parentNode = node.parentNode;

          if (_instanceof(parentNode, Element) && plaintextParents.has(tagNameGetter.call(parentNode))) {
            return data;
          }

          return escapeData(data);
        }

      case CDATA_SECTION_NODE:
        {
          return "<!CDATA[[".concat(node.data, "]]>");
        }

      case PROCESSING_INSTRUCTION_NODE:
        {
          return "<?".concat(node.target, " ").concat(node.data, "?>");
        }

      case COMMENT_NODE:
        {
          return "<!--".concat(node.data, "-->");
        }

      default:
        {
          return '';
        }
    }
  }

  var InternalSlot = createHiddenField('shadowRecord', 'synthetic-shadow');
  var _document = document,
      createDocumentFragment = _document.createDocumentFragment;

  function getInternalSlot(root) {
    var record = getHiddenField(root, InternalSlot);

    if (isUndefined(record)) {
      throw new TypeError();
    }

    return record;
  }

  var ShadowRootResolverKey = '$shadowResolver$';
  var ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
  defineProperty(Node.prototype, ShadowRootResolverKey, {
    set: function set(fn) {
      this[ShadowResolverPrivateKey] = fn;
      setNodeOwnerKey(this, fn.nodeKey);
    },
    get: function get() {
      return this[ShadowResolverPrivateKey];
    },
    configurable: true,
    enumerable: true
  });

  function getShadowRootResolver(node) {
    return node[ShadowRootResolverKey];
  }

  function setShadowRootResolver(node, fn) {
    node[ShadowRootResolverKey] = fn;
  }

  function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
  }

  function getHost(root) {
    return getInternalSlot(root).host;
  }

  function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
  }

  function isHostElement(elm) {
    return !isUndefined(getHiddenField(elm, InternalSlot));
  }

  var uid = 0;

  function attachShadow$1(elm, options) {
    if (!isUndefined(getHiddenField(elm, InternalSlot))) {
      throw new Error("Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.");
    }

    var mode = options.mode,
        delegatesFocus = options.delegatesFocus;
    var doc = getOwnerDocument(elm);
    var sr = createDocumentFragment.call(doc);
    var record = {
      mode: mode,
      delegatesFocus: !!delegatesFocus,
      host: elm,
      shadowRoot: sr
    };
    setHiddenField(sr, InternalSlot, record);
    setHiddenField(elm, InternalSlot, record);

    var shadowResolver = function shadowResolver() {
      return sr;
    };

    var x = shadowResolver.nodeKey = uid++;
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
  }

  var SyntheticShadowRootDescriptors = {
    constructor: {
      writable: true,
      configurable: true,
      value: SyntheticShadowRoot
    },
    toString: {
      writable: true,
      configurable: true,
      value: function value() {
        return "[object ShadowRoot]";
      }
    }
  };
  var ShadowRootDescriptors = {
    activeElement: {
      enumerable: true,
      configurable: true,
      get: function get() {
        var host = getHost(this);
        var doc = getOwnerDocument(host);
        var activeElement = DocumentPrototypeActiveElement.call(doc);

        if (isNull(activeElement)) {
          return activeElement;
        }

        if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
          return null;
        }

        var node = activeElement;

        while (!isNodeOwnedBy(host, node)) {
          node = parentElementGetter.call(node);
        }

        if (isSlotElement(node)) {
          return null;
        }

        return node;
      }
    },
    delegatesFocus: {
      configurable: true,
      get: function get() {
        return getInternalSlot(this).delegatesFocus;
      }
    },
    elementFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(left, top) {
        var host = getHost(this);
        var doc = getOwnerDocument(host);
        var element = elementFromPoint.call(doc, left, top);

        if (isNull(element)) {
          return element;
        }

        return retarget(this, pathComposer(element, true));
      }
    },
    elementsFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(_left, _top) {
        throw new Error();
      }
    },
    getSelection: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        throw new Error();
      }
    },
    host: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return getHost(this);
      }
    },
    mode: {
      configurable: true,
      get: function get() {
        return getInternalSlot(this).mode;
      }
    },
    styleSheets: {
      enumerable: true,
      configurable: true,
      get: function get() {
        throw new Error();
      }
    }
  };
  var NodePatchDescriptors = {
    insertBefore: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(newChild, refChild) {
        insertBefore.call(getHost(this), newChild, refChild);
        return newChild;
      }
    },
    removeChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(oldChild) {
        removeChild.call(getHost(this), oldChild);
        return oldChild;
      }
    },
    appendChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(newChild) {
        appendChild.call(getHost(this), newChild);
        return newChild;
      }
    },
    replaceChild: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(newChild, oldChild) {
        replaceChild.call(getHost(this), newChild, oldChild);
        return oldChild;
      }
    },
    addEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(type, listener, options) {
        addShadowRootEventListener(this, type, listener);
      }
    },
    removeEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(type, listener, options) {
        removeShadowRootEventListener(this, type, listener);
      }
    },
    baseURI: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return getHost(this).baseURI;
      }
    },
    childNodes: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return createStaticNodeList(shadowRootChildNodes(this));
      }
    },
    compareDocumentPosition: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(otherNode) {
        var host = getHost(this);

        if (this === otherNode) {
          return 0;
        } else if (this.contains(otherNode)) {
          return 20;
        } else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
          return 37;
        } else {
          return 35;
        }
      }
    },
    contains: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(otherNode) {
        if (this === otherNode) {
          return true;
        }

        var host = getHost(this);
        return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
      }
    },
    firstChild: {
      enumerable: true,
      configurable: true,
      get: function get() {
        var childNodes = getInternalChildNodes(this);
        return childNodes[0] || null;
      }
    },
    lastChild: {
      enumerable: true,
      configurable: true,
      get: function get() {
        var childNodes = getInternalChildNodes(this);
        return childNodes[childNodes.length - 1] || null;
      }
    },
    hasChildNodes: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value() {
        var childNodes = getInternalChildNodes(this);
        return childNodes.length > 0;
      }
    },
    isConnected: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return isConnected.call(getHost(this));
      }
    },
    nextSibling: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return null;
      }
    },
    previousSibling: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return null;
      }
    },
    nodeName: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return '#document-fragment';
      }
    },
    nodeType: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return 11;
      }
    },
    nodeValue: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return null;
      }
    },
    ownerDocument: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return getHost(this).ownerDocument;
      }
    },
    parentElement: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return null;
      }
    },
    parentNode: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return null;
      }
    },
    textContent: {
      enumerable: true,
      configurable: true,
      get: function get() {
        var childNodes = getInternalChildNodes(this);
        var textContent = '';

        for (var i = 0, len = childNodes.length; i < len; i += 1) {
          var currentNode = childNodes[i];

          if (currentNode.nodeType !== COMMENT_NODE) {
            textContent += getTextContent(currentNode);
          }
        }

        return textContent;
      },
      set: function set(v) {
        var host = getHost(this);
        textContextSetter.call(host, v);
      }
    },
    getRootNode: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(options) {
        return !isUndefined(options) && isTrue$1(options.composed) ? getHost(this).getRootNode(options) : this;
      }
    }
  };
  var ElementPatchDescriptors = {
    innerHTML: {
      enumerable: true,
      configurable: true,
      get: function get() {
        var childNodes = getInternalChildNodes(this);
        var innerHTML = '';

        for (var i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
        }

        return innerHTML;
      },
      set: function set(v) {
        var host = getHost(this);
        innerHTMLSetter.call(host, v);
      }
    }
  };
  var ParentNodePatchDescriptors = {
    childElementCount: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return this.children.length;
      }
    },
    children: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), function (elm) {
          return _instanceof(elm, Element);
        }));
      }
    },
    firstElementChild: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return this.children[0] || null;
      }
    },
    lastElementChild: {
      enumerable: true,
      configurable: true,
      get: function get() {
        var children = this.children;
        return children.item(children.length - 1) || null;
      }
    },
    querySelector: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(selectors) {
        return shadowRootQuerySelector(this, selectors);
      }
    },
    querySelectorAll: {
      writable: true,
      enumerable: true,
      configurable: true,
      value: function value(selectors) {
        return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
      }
    }
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);

  function SyntheticShadowRoot() {
    throw new TypeError('Illegal constructor');
  }

  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);

  function getIE11FakeShadowRootPlaceholder(host) {
    var shadowRoot = getShadowRoot(host);
    var c = shadowRoot.$$placeholder$$;

    if (!isUndefined(c)) {
      return c;
    }

    var doc = getOwnerDocument(host);
    c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
    defineProperties(c, {
      childNodes: {
        get: function get() {
          return shadowRoot.childNodes;
        },
        enumerable: true,
        configurable: true
      },
      tagName: {
        get: function get() {
          return "#shadow-root (".concat(shadowRoot.mode, ")");
        },
        enumerable: true,
        configurable: true
      }
    });
    return c;
  }

  function foldSlotElement(slot) {
    var parent = parentElementGetter.call(slot);

    while (!isNull(parent) && isSlotElement(parent)) {
      slot = parent;
      parent = parentElementGetter.call(slot);
    }

    return slot;
  }

  function isNodeSlotted(host, node) {
    {
      assert.invariant(_instanceof(host, HTMLElement), "isNodeSlotted() should be called with a host as the first argument instead of ".concat(host));
      assert.invariant(_instanceof(node, Node), "isNodeSlotted() should be called with a node as the second argument instead of ".concat(node));
      assert.invariant(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, "isNodeSlotted() should never be called with a node that is not a child node of ".concat(host));
    }

    var hostKey = getNodeKey(host);
    var currentElement = _instanceof(node, Element) ? node : parentElementGetter.call(node);

    while (!isNull(currentElement) && currentElement !== host) {
      var elmOwnerKey = getNodeNearestOwnerKey(currentElement);
      var parent = parentElementGetter.call(currentElement);

      if (elmOwnerKey === hostKey) {
        return isSlotElement(currentElement);
      } else if (parent === host) {
        return false;
      } else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
        if (isSlotElement(parent)) {
          currentElement = getNodeOwner(foldSlotElement(parent));

          if (!isNull(currentElement)) {
            if (currentElement === host) {
              return true;
            } else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        currentElement = parent;
      }
    }

    return false;
  }

  function getNodeOwner(node) {
    if (!_instanceof(node, Node)) {
      return null;
    }

    var ownerKey = getNodeNearestOwnerKey(node);

    if (isUndefined(ownerKey)) {
      return null;
    }

    var nodeOwner = node;

    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
      nodeOwner = parentNodeGetter.call(nodeOwner);
    }

    if (isNull(nodeOwner)) {
      return null;
    }

    return nodeOwner;
  }

  function isSlotElement(node) {
    return _instanceof(node, HTMLSlotElement);
  }

  function isNodeOwnedBy(owner, node) {
    {
      assert.invariant(_instanceof(owner, HTMLElement), "isNodeOwnedBy() should be called with an element as the first argument instead of ".concat(owner));
      assert.invariant(_instanceof(node, Node), "isNodeOwnedBy() should be called with a node as the second argument instead of ".concat(node));
      assert.invariant(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, "isNodeOwnedBy() should never be called with a node that is not a child node of ".concat(owner));
    }

    var ownerKey = getNodeNearestOwnerKey(node);
    return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
  }

  function shadowRootChildNodes(root) {
    var elm = getHost(root);
    return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }

  function getAllSlottedMatches(host, nodeList) {
    var filteredAndPatched = [];

    for (var i = 0, len = nodeList.length; i < len; i += 1) {
      var node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }

  function getFirstSlottedMatch(host, nodeList) {
    for (var i = 0, len = nodeList.length; i < len; i += 1) {
      var node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        return node;
      }
    }

    return null;
  }

  function getAllMatches(owner, nodeList) {
    var filteredAndPatched = [];

    for (var i = 0, len = nodeList.length; i < len; i += 1) {
      var node = nodeList[i];
      var isOwned = isNodeOwnedBy(owner, node);

      if (isOwned) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }

  function getFirstMatch(owner, nodeList) {
    for (var i = 0, len = nodeList.length; i < len; i += 1) {
      if (isNodeOwnedBy(owner, nodeList[i])) {
        return nodeList[i];
      }
    }

    return null;
  }

  function shadowRootQuerySelector(root, selector) {
    var elm = getHost(root);
    var nodeList = arrayFromCollection(querySelectorAll.call(elm, selector));
    return getFirstMatch(elm, nodeList);
  }

  function shadowRootQuerySelectorAll(root, selector) {
    var elm = getHost(root);
    var nodeList = querySelectorAll.call(elm, selector);
    return getAllMatches(elm, arrayFromCollection(nodeList));
  }

  function getFilteredChildNodes(node) {
    var children;

    if (!isHostElement(node) && !isSlotElement(node)) {
      children = childNodesGetter.call(node);
      return arrayFromCollection(children);
    }

    if (isHostElement(node)) {
      var slots = arrayFromCollection(querySelectorAll.call(node, 'slot'));
      var resolver = getShadowRootResolver(getShadowRoot(node));
      return ArrayReduce.call(slots, function (seed, slot) {
        if (resolver === getShadowRootResolver(slot)) {
          ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
        }

        return seed;
      }, []);
    } else {
      children = arrayFromCollection(childNodesGetter.call(node));

      var _resolver = getShadowRootResolver(node);

      return ArrayReduce.call(children, function (seed, child) {
        if (_resolver === getShadowRootResolver(child)) {
          ArrayPush.call(seed, child);
        }

        return seed;
      }, []);
    }
  }

  function getFilteredSlotAssignedNodes(slot) {
    var owner = getNodeOwner(slot);

    if (isNull(owner)) {
      return [];
    }

    var childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, function (seed, child) {
      if (!isNodeOwnedBy(owner, child)) {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  var OwnKey = '$$OwnKey$$';
  var OwnerKey = '$$OwnerKey$$';
  var hasNativeSymbolsSupport$2 = Symbol('x').toString() === 'Symbol(x)';

  function getNodeOwnerKey(node) {
    return node[OwnerKey];
  }

  function setNodeOwnerKey(node, value) {
    {
      defineProperty(node, OwnerKey, {
        value: value,
        configurable: true
      });
    }
  }

  function getNodeKey(node) {
    return node[OwnKey];
  }

  function setNodeKey(node, value) {
    {
      defineProperty(node, OwnKey, {
        value: value
      });
    }
  }

  function getNodeNearestOwnerKey(node) {
    var ownerNode = node;
    var ownerKey;

    while (!isNull(ownerNode)) {
      ownerKey = getNodeOwnerKey(ownerNode);

      if (!isUndefined(ownerKey)) {
        return ownerKey;
      }

      ownerNode = parentNodeGetter.call(ownerNode);
    }
  }

  function isNodeShadowed(node) {
    return !isUndefined(getNodeOwnerKey(node));
  }

  function isNodeDeepShadowed(node) {
    return !isUndefined(getNodeNearestOwnerKey(node));
  }

  function hasMountedChildren(node) {
    return isSlotElement(node) || isHostElement(node);
  }

  function getShadowParent(node, value) {
    var owner = getNodeOwner(node);

    if (value === owner) {
      return getShadowRoot(owner);
    } else if (_instanceof(value, Element)) {
      if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
        return value;
      } else if (!isNull(owner) && isSlotElement(value)) {
        var slotOwner = getNodeOwner(value);

        if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
          return slotOwner;
        }
      }
    }

    return null;
  }

  function hasChildNodesPatched() {
    return getInternalChildNodes(this).length > 0;
  }

  function firstChildGetterPatched() {
    var childNodes = getInternalChildNodes(this);
    return childNodes[0] || null;
  }

  function lastChildGetterPatched() {
    var childNodes = getInternalChildNodes(this);
    return childNodes[childNodes.length - 1] || null;
  }

  function textContentGetterPatched() {
    return getTextContent(this);
  }

  function textContentSetterPatched(value) {
    textContextSetter.call(this, value);
  }

  function parentNodeGetterPatched() {
    var value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return value;
    }

    return getShadowParent(this, value);
  }

  function parentElementGetterPatched() {
    var value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return null;
    }

    var parentNode = getShadowParent(this, value);
    return _instanceof(parentNode, Element) ? parentNode : null;
  }

  function compareDocumentPositionPatched(otherNode) {
    if (this.getRootNode() === otherNode) {
      return 10;
    } else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return 35;
    }

    return compareDocumentPosition.call(this, otherNode);
  }

  function containsPatched(otherNode) {
    if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return false;
    }

    return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }

  function cloneNodePatched(deep) {
    var clone = cloneNode.call(this, false);

    if (!deep) {
      return clone;
    }

    var childNodes = getInternalChildNodes(this);

    for (var i = 0, len = childNodes.length; i < len; i += 1) {
      clone.appendChild(childNodes[i].cloneNode(true));
    }

    return clone;
  }

  function childNodesGetterPatched() {
    if (_instanceof(this, Element) && isHostElement(this)) {
      var owner = getNodeOwner(this);
      var childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));

      if ( isFalse$1(hasNativeSymbolsSupport$2) && isExternalChildNodeAccessorFlagOn()) {
        ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
      }

      return createStaticNodeList(childNodes);
    }

    return childNodesGetter.call(this);
  }

  var nativeGetRootNode = Node.prototype.getRootNode;
  var getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function () {
    var node = this;
    var nodeParent;

    while (!isNull(nodeParent = parentNodeGetter.call(node))) {
      node = nodeParent;
    }

    return node;
  };

  function getNearestRoot(node) {
    var ownerNode = getNodeOwner(node);

    if (isNull(ownerNode)) {
      return getDocumentOrRootNode.call(node);
    }

    return getShadowRoot(ownerNode);
  }

  function getRootNodePatched(options) {
    var composed = isUndefined(options) ? false : !!options.composed;
    return isTrue$1(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }

  defineProperties(Node.prototype, {
    firstChild: {
      get: function get() {
        if (hasMountedChildren(this)) {
          return firstChildGetterPatched.call(this);
        }

        return firstChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    lastChild: {
      get: function get() {
        if (hasMountedChildren(this)) {
          return lastChildGetterPatched.call(this);
        }

        return lastChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    textContent: {
      get: function get() {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return textContentGetterPatched.call(this);
          }

          return textContentGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return textContentGetter.call(this);
        }

        return textContentGetterPatched.call(this);
      },
      set: textContentSetterPatched,
      enumerable: true,
      configurable: true
    },
    parentNode: {
      get: function get() {
        if (isNodeShadowed(this)) {
          return parentNodeGetterPatched.call(this);
        }

        return parentNodeGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    parentElement: {
      get: function get() {
        if (isNodeShadowed(this)) {
          return parentElementGetterPatched.call(this);
        }

        return parentElementGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    childNodes: {
      get: function get() {
        if (hasMountedChildren(this)) {
          return childNodesGetterPatched.call(this);
        }

        return childNodesGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    hasChildNodes: {
      value: function value() {
        if (hasMountedChildren(this)) {
          return hasChildNodesPatched.call(this);
        }

        return hasChildNodes.call(this);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    compareDocumentPosition: {
      value: function value(otherNode) {
        if (isGlobalPatchingSkipped(this)) {
          return compareDocumentPosition.call(this, otherNode);
        }

        return compareDocumentPositionPatched.call(this, otherNode);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    contains: {
      value: function value(otherNode) {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (otherNode == null) {
            return false;
          }

          if (isNodeShadowed(this) || isHostElement(this)) {
            return containsPatched.call(this, otherNode);
          }

          return contains.call(this, otherNode);
        }

        if (isGlobalPatchingSkipped(this)) {
          return contains.call(this, otherNode);
        }

        return containsPatched.call(this, otherNode);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    cloneNode: {
      value: function value(deep) {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return cloneNodePatched.call(this, deep);
          }

          return cloneNode.call(this, deep);
        }

        if (isTrue$1(deep)) {
          if (isGlobalPatchingSkipped(this)) {
            return cloneNode.call(this, deep);
          }

          return cloneNodePatched.call(this, deep);
        }

        return cloneNode.call(this, deep);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    getRootNode: {
      value: getRootNodePatched,
      enumerable: true,
      configurable: true,
      writable: true
    },
    isConnected: {
      enumerable: true,
      configurable: true,
      get: function get() {
        return isConnected.call(this);
      }
    }
  });
  var internalChildNodeAccessorFlag = false;

  function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
  }

  var getInternalChildNodes =  isFalse$1(hasNativeSymbolsSupport$2) ? function (node) {
    internalChildNodeAccessorFlag = true;
    var childNodes;
    var error = null;

    try {
      childNodes = node.childNodes;
    } catch (e) {
      error = e;
    } finally {
      internalChildNodeAccessorFlag = false;

      if (!isNull(error)) {
        throw error;
      }
    }

    return childNodes;
  } : function (node) {
    return node.childNodes;
  };

  if (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {
    defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(Node.prototype, 'contains'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {
    defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(Node.prototype, 'parentElement'));
  }

  function elemFromPoint(left, top) {
    var element = elementFromPoint.call(this, left, top);

    if (isNull(element)) {
      return element;
    }

    return retarget(this, pathComposer(element, true));
  }

  Document.prototype.elementFromPoint = elemFromPoint;
  defineProperty(Document.prototype, 'activeElement', {
    get: function get() {
      var node = DocumentPrototypeActiveElement.call(this);

      if (isNull(node)) {
        return node;
      }

      while (!isUndefined(getNodeOwnerKey(node))) {
        node = parentElementGetter.call(node);

        if (isNull(node)) {
          return null;
        }
      }

      if (node.tagName === 'HTML') {
        node = this.body;
      }

      return node;
    },
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementById', {
    value: function value() {
      var elm = getElementById.apply(this, ArraySlice.call(arguments));

      if (isNull(elm)) {
        return null;
      }

      return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelector', {
    value: function value() {
      var elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      var filtered = ArrayFind.call(elements, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm);
      });
      return !isUndefined(filtered) ? filtered : null;
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelectorAll', {
    value: function value() {
      var elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      var filtered = ArrayFilter.call(elements, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm);
      });
      return createStaticNodeList(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByClassName', {
    value: function value() {
      var elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
      var filtered = ArrayFilter.call(elements, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm);
      });
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagName', {
    value: function value() {
      var elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
      var filtered = ArrayFilter.call(elements, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm);
      });
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagNameNS', {
    value: function value() {
      var elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
      var filtered = ArrayFilter.call(elements, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm);
      });
      return createStaticHTMLCollection(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName') ? HTMLDocument.prototype : Document.prototype, 'getElementsByName', {
    value: function value() {
      var elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
      var filtered = ArrayFilter.call(elements, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm);
      });
      return createStaticNodeList(filtered);
    },
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(window, 'ShadowRoot', {
    value: SyntheticShadowRoot,
    configurable: true,
    writable: true
  });

  function doesEventNeedsPatch(e) {
    var originalTarget = eventTargetGetter.call(e);
    return _instanceof(originalTarget, Node) && isNodeDeepShadowed(originalTarget);
  }

  function isValidEventListener(listener) {
    return isFunction(listener) || !isNull(listener) && isObject(listener) && isFunction(listener.handleEvent);
  }

  function getEventListenerWrapper(listener) {
    if ('$$lwcEventWrapper$$' in listener) {
      return listener.$$lwcEventWrapper$$;
    }

    var isHandlerFunction = isFunction(listener);

    var wrapperFn = listener.$$lwcEventWrapper$$ = function (e) {
      if (doesEventNeedsPatch(e)) {
        patchEvent(e);
      }

      return isHandlerFunction ? listener.call(this, e) : listener.handleEvent && listener.handleEvent(e);
    };

    return wrapperFn;
  }

  function windowAddEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    var wrapperFn = getEventListenerWrapper(listener);
    windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function windowRemoveEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    var wrapperFn = getEventListenerWrapper(listener);
    windowRemoveEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  function addEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    var wrapperFn = getEventListenerWrapper(listener);
    addEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function removeEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    var wrapperFn = getEventListenerWrapper(listener);
    removeEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  window.addEventListener = windowAddEventListener$1;
  window.removeEventListener = windowRemoveEventListener$1;
  var protoToBePatched = typeof EventTarget !== 'undefined' ? EventTarget.prototype : Node.prototype;
  defineProperties(protoToBePatched, {
    addEventListener: {
      value: addEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: removeEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  var composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');

  function detect$1() {
    if (!composedDescriptor) {
      return false;
    }

    var clickEvent = new Event('click');
    var button = document.createElement('button');
    button.addEventListener('click', function (event) {
      return clickEvent = event;
    });
    button.click();
    return !composedDescriptor.get.call(clickEvent);
  }

  var originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');

  function handleClick(event) {
    Object.defineProperty(event, 'composed', {
      configurable: true,
      enumerable: true,
      get: function get() {
        return true;
      }
    });
  }

  function apply$1() {
    HTMLElement.prototype.click = function () {
      addEventListener.call(this, 'click', handleClick);

      try {
        originalClickDescriptor.value.call(this);
      } finally {
        removeEventListener.call(this, 'click', handleClick);
      }
    };
  }

  if (detect$1()) {
    apply$1();
  }

  function detect$2() {
    return new Event('test', {
      composed: true
    }).composed !== true;
  }

  function apply$2() {
    var composedEvents = assign(create(null), {
      blur: 1,
      focus: 1,
      focusin: 1,
      focusout: 1,
      click: 1,
      dblclick: 1,
      mousedown: 1,
      mouseenter: 1,
      mouseleave: 1,
      mousemove: 1,
      mouseout: 1,
      mouseover: 1,
      mouseup: 1,
      wheel: 1,
      beforeinput: 1,
      input: 1,
      keydown: 1,
      keyup: 1,
      compositionstart: 1,
      compositionupdate: 1,
      compositionend: 1,
      touchstart: 1,
      touchend: 1,
      touchmove: 1,
      touchcancel: 1,
      pointerover: 1,
      pointerenter: 1,
      pointerdown: 1,
      pointermove: 1,
      pointerup: 1,
      pointercancel: 1,
      pointerout: 1,
      pointerleave: 1,
      gotpointercapture: 1,
      lostpointercapture: 1,
      dragstart: 1,
      drag: 1,
      dragenter: 1,
      dragleave: 1,
      dragover: 1,
      drop: 1,
      dragend: 1,
      DOMActivate: 1,
      DOMFocusIn: 1,
      DOMFocusOut: 1,
      keypress: 1
    });
    var EventConstructor = Event;

    function PatchedEvent(type, eventInitDict) {
      var event = new EventConstructor(type, eventInitDict);
      var isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
        composed: {
          get: function get() {
            return isComposed;
          },
          configurable: true,
          enumerable: true
        }
      });
      return event;
    }

    PatchedEvent.prototype = EventConstructor.prototype;
    PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;
    PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;
    PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;
    PatchedEvent.NONE = EventConstructor.NONE;
    window.Event = PatchedEvent;
    Object.defineProperties(Event.prototype, {
      composed: {
        get: function get() {
          var type = this.type;
          return composedEvents[type] === 1;
        },
        configurable: true,
        enumerable: true
      }
    });
  }

  if (detect$2()) {
    apply$2();
  }

  var CustomEventConstructor = CustomEvent;

  function PatchedCustomEvent(type, eventInitDict) {
    var event = new CustomEventConstructor(type, eventInitDict);
    var isComposed = !!(eventInitDict && eventInitDict.composed);
    Object.defineProperties(event, {
      composed: {
        get: function get() {
          return isComposed;
        },
        configurable: true,
        enumerable: true
      }
    });
    return event;
  }

  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;
  var originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed').get;
  Object.defineProperties(FocusEvent.prototype, {
    composed: {
      get: function get() {
        var isTrusted = this.isTrusted;
        var composed = originalComposedGetter.call(this);

        if (isTrusted && composed === false) {
          return true;
        }

        return composed;
      },
      enumerable: true,
      configurable: true
    }
  });

  function detect$3() {
    return typeof HTMLIFrameElement !== 'undefined';
  }

  function apply$3() {
    var desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
    var originalGetter = desc.get;

    desc.get = function () {
      var original = originalGetter.call(this);

      if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
        return original;
      }

      return wrapIframeWindow(original);
    };

    defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
  }

  function wrapIframeWindow(win) {
    return {
      addEventListener: function addEventListener() {
        return win.addEventListener.apply(win, arguments);
      },
      blur: function blur() {
        return win.blur.apply(win, arguments);
      },
      close: function close() {
        return win.close.apply(win, arguments);
      },
      focus: function focus() {
        return win.focus.apply(win, arguments);
      },
      postMessage: function postMessage() {
        return win.postMessage.apply(win, arguments);
      },
      removeEventListener: function removeEventListener() {
        return win.removeEventListener.apply(win, arguments);
      },

      get closed() {
        return win.closed;
      },

      get frames() {
        return win.frames;
      },

      get length() {
        return win.length;
      },

      get location() {
        return win.location;
      },

      set location(value) {
        win.location = value;
      },

      get opener() {
        return win.opener;
      },

      get parent() {
        return win.parent;
      },

      get self() {
        return win.self;
      },

      get top() {
        return win.top;
      },

      get window() {
        return win.window;
      }

    };
  }

  if (detect$3()) {
    apply$3();
  }

  var OriginalMutationObserver = MutationObserver;
  var _OriginalMutationObse = OriginalMutationObserver.prototype,
      originalDisconnect = _OriginalMutationObse.disconnect,
      originalObserve = _OriginalMutationObse.observe,
      originalTakeRecords = _OriginalMutationObse.takeRecords;
  var wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
  var observerLookupField = '$$lwcNodeObservers$$';
  var observerToNodesMap = new WeakMap();

  function getNodeObservers(node) {
    return node[observerLookupField];
  }

  function setNodeObservers(node, observers) {
    node[observerLookupField] = observers;
  }

  function retargetMutationRecord(originalRecord) {
    var addedNodes = originalRecord.addedNodes,
        removedNodes = originalRecord.removedNodes,
        target = originalRecord.target,
        type = originalRecord.type;
    var retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
      addedNodes: {
        get: function get() {
          return addedNodes;
        },
        enumerable: true,
        configurable: true
      },
      removedNodes: {
        get: function get() {
          return removedNodes;
        },
        enumerable: true,
        configurable: true
      },
      type: {
        get: function get() {
          return type;
        },
        enumerable: true,
        configurable: true
      },
      target: {
        get: function get() {
          return target.shadowRoot;
        },
        enumerable: true,
        configurable: true
      }
    });
    return retargetedRecord;
  }

  function isQualifiedObserver(observer, target) {
    var parentNode = target;

    while (!isNull(parentNode)) {
      var parentNodeObservers = getNodeObservers(parentNode);

      if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer || ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
        return true;
      }

      parentNode = parentNode.parentNode;
    }

    return false;
  }

  function filterMutationRecords(mutations, observer) {
    return ArrayReduce.call(mutations, function (filteredSet, record) {
      var target = record.target,
          addedNodes = record.addedNodes,
          removedNodes = record.removedNodes,
          type = record.type;

      if (type === 'childList' && !isUndefined(getNodeKey(target))) {
        if (addedNodes.length > 0) {
          var sampleNode = addedNodes[0];

          if (isQualifiedObserver(observer, sampleNode)) {
            var nodeObservers = getNodeObservers(target);

            if (nodeObservers && (nodeObservers[0] === observer || ArrayIndexOf.call(nodeObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, record);
            } else {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        } else {
          var shadowRoot = target.shadowRoot;
          var _sampleNode = removedNodes[0];

          if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(_sampleNode) && isQualifiedObserver(observer, target)) {
            ArrayPush.call(filteredSet, record);
          } else if (shadowRoot) {
            var shadowRootObservers = getNodeObservers(shadowRoot);

            if (shadowRootObservers && (shadowRootObservers[0] === observer || ArrayIndexOf.call(shadowRootObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        }
      } else {
        if (isQualifiedObserver(observer, target)) {
          ArrayPush.call(filteredSet, record);
        }
      }

      return filteredSet;
    }, []);
  }

  function getWrappedCallback(callback) {
    var wrappedCallback = callback[wrapperLookupField];

    if (isUndefined(wrappedCallback)) {
      wrappedCallback = callback[wrapperLookupField] = function (mutations, observer) {
        var filteredRecords = filterMutationRecords(mutations, observer);

        if (filteredRecords.length === 0) {
          return;
        }

        callback.call(observer, filteredRecords, observer);
      };
    }

    return wrappedCallback;
  }

  function PatchedMutationObserver(callback) {
    var wrappedCallback = getWrappedCallback(callback);
    var observer = new OriginalMutationObserver(wrappedCallback);
    return observer;
  }

  function patchedDisconnect() {
    var _this3 = this;

    originalDisconnect.call(this);
    var observedNodes = observerToNodesMap.get(this);

    if (!isUndefined(observedNodes)) {
      forEach.call(observedNodes, function (observedNode) {
        var observers = observedNode[observerLookupField];

        if (!isUndefined(observers)) {
          var index = ArrayIndexOf.call(observers, _this3);

          if (index !== -1) {
            ArraySplice.call(observers, index, 1);
          }
        }
      });
      observedNodes.length = 0;
    }
  }

  function patchedObserve(target, options) {
    var targetObservers = getNodeObservers(target);

    if (isUndefined(targetObservers)) {
      targetObservers = [];
      setNodeObservers(target, targetObservers);
    }

    if (ArrayIndexOf.call(targetObservers, this) === -1) {
      ArrayPush.call(targetObservers, this);
    }

    if (_instanceof(target, SyntheticShadowRoot)) {
      target = target.host;
    }

    if (observerToNodesMap.has(this)) {
      var observedNodes = observerToNodesMap.get(this);

      if (ArrayIndexOf.call(observedNodes, target) === -1) {
        ArrayPush.call(observedNodes, target);
      }
    } else {
      observerToNodesMap.set(this, [target]);
    }

    return originalObserve.call(this, target, options);
  }

  function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
  }

  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, 'MutationObserver', {
    value: PatchedMutationObserver,
    configurable: true,
    writable: true
  });
  var observer;
  var observerConfig = {
    childList: true
  };
  var SlotChangeKey = createHiddenField('slotchange', 'synthetic-shadow');

  function initSlotObserver() {
    return new MO(function (mutations) {
      var slots = [];
      forEach.call(mutations, function (mutation) {
        {
          assert.invariant(mutation.type === 'childList', "Invalid mutation type: ".concat(mutation.type, ". This mutation handler for slots should only handle \"childList\" mutations."));
        }

        var slot = mutation.target;

        if (ArrayIndexOf.call(slots, slot) === -1) {
          ArrayPush.call(slots, slot);
          dispatchEvent.call(slot, new CustomEvent('slotchange'));
        }
      });
    });
  }

  function getFilteredSlotFlattenNodes(slot) {
    var childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, function (seed, child) {
      if (_instanceof(child, Element) && isSlotElement(child)) {
        ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
      } else {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  function assignedSlotGetterPatched() {
    var parentNode = parentNodeGetter.call(this);

    if (isNull(parentNode) || !isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
      return null;
    }

    return parentNode;
  }

  defineProperties(HTMLSlotElement.prototype, {
    addEventListener: {
      value: function value(type, listener, options) {
        HTMLElement.prototype.addEventListener.call(this, type, listener, options);

        if (type === 'slotchange' && !getHiddenField(this, SlotChangeKey)) {
          setHiddenField(this, SlotChangeKey, true);

          if (!observer) {
            observer = initSlotObserver();
          }

          MutationObserverObserve.call(observer, this, observerConfig);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedElements: {
      value: function value(options) {
        if (isNodeShadowed(this)) {
          var flatten = !isUndefined(options) && isTrue$1(options.flatten);
          var nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
          return ArrayFilter.call(nodes, function (node) {
            return _instanceof(node, Element);
          });
        } else {
          return assignedElements.apply(this, ArraySlice.call(arguments));
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedNodes: {
      value: function value(options) {
        if (isNodeShadowed(this)) {
          var flatten = !isUndefined(options) && isTrue$1(options.flatten);
          return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        } else {
          return assignedNodes.apply(this, ArraySlice.call(arguments));
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    name: {
      get: function get() {
        var name = getAttribute.call(this, 'name');
        return isNull(name) ? '' : name;
      },
      set: function set(value) {
        setAttribute.call(this, 'name', value);
      },
      enumerable: true,
      configurable: true
    },
    childNodes: {
      get: function get() {
        if (isNodeShadowed(this)) {
          var owner = getNodeOwner(this);
          var childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
          return createStaticNodeList(childNodes);
        }

        return childNodesGetter.call(this);
      },
      enumerable: true,
      configurable: true
    }
  });
  defineProperties(Text.prototype, {
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
    var filtered;
    var ownerKey = getNodeOwnerKey(context);

    if (!isUndefined(ownerKey)) {
      if (isHostElement(context)) {
        var owner = getNodeOwner(context);

        if (isNull(owner)) {
          filtered = [];
        } else if (getNodeKey(context)) {
          filtered = getAllSlottedMatches(context, unfilteredNodes);
        } else {
          filtered = getAllMatches(owner, unfilteredNodes);
        }
      } else {
        filtered = ArrayFilter.call(unfilteredNodes, function (elm) {
          return getNodeNearestOwnerKey(elm) === ownerKey;
        });
      }
    } else if (_instanceof(context, HTMLBodyElement)) {
      filtered = ArrayFilter.call(unfilteredNodes, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context);
      });
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }

    return filtered;
  }

  var ShadowDomSemantic;

  (function (ShadowDomSemantic) {
    ShadowDomSemantic[ShadowDomSemantic["Disabled"] = 0] = "Disabled";
    ShadowDomSemantic[ShadowDomSemantic["Enabled"] = 1] = "Enabled";
  })(ShadowDomSemantic || (ShadowDomSemantic = {}));

  function innerHTMLGetterPatched() {
    var childNodes = getInternalChildNodes(this);
    var innerHTML = '';

    for (var i = 0, len = childNodes.length; i < len; i += 1) {
      innerHTML += getOuterHTML(childNodes[i]);
    }

    return innerHTML;
  }

  function outerHTMLGetterPatched() {
    return getOuterHTML(this);
  }

  function attachShadowPatched(options) {
    if (isTrue$1(options['$$lwc-synthetic-mode$$'])) {
      return attachShadow$1(this, options);
    } else {
      return attachShadow.call(this, options);
    }
  }

  function shadowRootGetterPatched() {
    if (isHostElement(this)) {
      var shadow = getShadowRoot(this);

      if (shadow.mode === 'open') {
        return shadow;
      }
    }

    return shadowRootGetter.call(this);
  }

  function childrenGetterPatched() {
    var owner = getNodeOwner(this);
    var childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
    return createStaticHTMLCollection(ArrayFilter.call(childNodes, function (node) {
      return _instanceof(node, Element);
    }));
  }

  function childElementCountGetterPatched() {
    return this.children.length;
  }

  function firstElementChildGetterPatched() {
    return this.children[0] || null;
  }

  function lastElementChildGetterPatched() {
    var children = this.children;
    return children.item(children.length - 1) || null;
  }

  defineProperties(Element.prototype, {
    innerHTML: {
      get: function get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return innerHTMLGetterPatched.call(this);
          }

          return innerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return innerHTMLGetter.call(this);
        }

        return innerHTMLGetterPatched.call(this);
      },
      set: function set(v) {
        innerHTMLSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    outerHTML: {
      get: function get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return outerHTMLGetterPatched.call(this);
          }

          return outerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return outerHTMLGetter.call(this);
        }

        return outerHTMLGetterPatched.call(this);
      },
      set: function set(v) {
        outerHTMLSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    attachShadow: {
      value: attachShadowPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    shadowRoot: {
      get: shadowRootGetterPatched,
      enumerable: true,
      configurable: true
    },
    children: {
      get: function get() {
        if (hasMountedChildren(this)) {
          return childrenGetterPatched.call(this);
        }

        return childrenGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    childElementCount: {
      get: function get() {
        if (hasMountedChildren(this)) {
          return childElementCountGetterPatched.call(this);
        }

        return childElementCountGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    firstElementChild: {
      get: function get() {
        if (hasMountedChildren(this)) {
          return firstElementChildGetterPatched.call(this);
        }

        return firstElementChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    lastElementChild: {
      get: function get() {
        if (hasMountedChildren(this)) {
          return lastElementChildGetterPatched.call(this);
        }

        return lastElementChildGetter.call(this);
      },
      enumerable: true,
      configurable: true
    },
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  if (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {
    defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {
    defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'children')) {
    defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));
  }

  function querySelectorPatched() {
    var _this4 = this;

    var nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

    if (isHostElement(this)) {
      var owner = getNodeOwner(this);

      if (isNull(owner)) {
        return null;
      } else if (getNodeKey(this)) {
        return getFirstSlottedMatch(this, nodeList);
      } else {
        return getFirstMatch(owner, nodeList);
      }
    } else if (isNodeShadowed(this)) {
      var ownerKey = getNodeOwnerKey(this);

      if (!isUndefined(ownerKey)) {
        var elm = ArrayFind.call(nodeList, function (elm) {
          return getNodeNearestOwnerKey(elm) === ownerKey;
        });
        return isUndefined(elm) ? null : elm;
      } else {
        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          return nodeList.length === 0 ? null : nodeList[0];
        }

        var contextNearestOwnerKey = getNodeNearestOwnerKey(this);

        var _elm = ArrayFind.call(nodeList, function (elm) {
          return getNodeNearestOwnerKey(elm) === contextNearestOwnerKey;
        });

        return isUndefined(_elm) ? null : _elm;
      }
    } else {
      if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
        if (!_instanceof(this, HTMLBodyElement)) {
          var _elm3 = nodeList[0];
          return isUndefined(_elm3) ? null : _elm3;
        }
      }

      var _elm2 = ArrayFind.call(nodeList, function (elm) {
        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(_this4);
      });

      return isUndefined(_elm2) ? null : _elm2;
    }
  }

  function getFilteredArrayOfNodes(context, unfilteredNodes, shadowDomSemantic) {
    var filtered;

    if (isHostElement(context)) {
      var owner = getNodeOwner(context);

      if (isNull(owner)) {
        filtered = [];
      } else if (getNodeKey(context)) {
        filtered = getAllSlottedMatches(context, unfilteredNodes);
      } else {
        filtered = getAllMatches(owner, unfilteredNodes);
      }
    } else if (isNodeShadowed(context)) {
      var ownerKey = getNodeOwnerKey(context);

      if (!isUndefined(ownerKey)) {
        filtered = ArrayFilter.call(unfilteredNodes, function (elm) {
          return getNodeNearestOwnerKey(elm) === ownerKey;
        });
      } else if (shadowDomSemantic === ShadowDomSemantic.Enabled) {
        var contextNearestOwnerKey = getNodeNearestOwnerKey(context);
        filtered = ArrayFilter.call(unfilteredNodes, function (elm) {
          return getNodeNearestOwnerKey(elm) === contextNearestOwnerKey;
        });
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    } else {
      if (_instanceof(context, HTMLBodyElement) || shadowDomSemantic === ShadowDomSemantic.Enabled) {
        filtered = ArrayFilter.call(unfilteredNodes, function (elm) {
          return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context);
        });
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    }

    return filtered;
  }

  defineProperties(Element.prototype, {
    querySelector: {
      value: querySelectorPatched,
      writable: true,
      enumerable: true,
      configurable: true
    },
    querySelectorAll: {
      value: function value() {
        var nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          var filteredResults = getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Disabled);
          return createStaticNodeList(filteredResults);
        }

        return createStaticNodeList(getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Enabled));
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  {
    defineProperties(Element.prototype, {
      getElementsByClassName: {
        value: function value() {
          var elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          var filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagName: {
        value: function value() {
          var elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          var filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagNameNS: {
        value: function value() {
          var elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          var filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },
        writable: true,
        enumerable: true,
        configurable: true
      }
    });
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {
    defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));
  }

  var TabbableElementsQuery = "\n    button:not([tabindex=\"-1\"]):not([disabled]),\n    [contenteditable]:not([tabindex=\"-1\"]),\n    video[controls]:not([tabindex=\"-1\"]),\n    audio[controls]:not([tabindex=\"-1\"]),\n    [href]:not([tabindex=\"-1\"]),\n    input:not([tabindex=\"-1\"]):not([disabled]),\n    select:not([tabindex=\"-1\"]):not([disabled]),\n    textarea:not([tabindex=\"-1\"]):not([disabled]),\n    [tabindex=\"0\"]\n";
  var DidAddMouseDownListener = createHiddenField('DidAddMouseDownListener', 'synthetic-shadow');

  function isVisible(element) {
    var _getBoundingClientRec = getBoundingClientRect.call(element),
        width = _getBoundingClientRec.width,
        height = _getBoundingClientRec.height;

    var noZeroSize = width > 0 || height > 0;
    return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
  }

  function isTabbable(element) {
    return matches.call(element, TabbableElementsQuery) && isVisible(element);
  }

  function getTabbableSegments(host) {
    var doc = getOwnerDocument(host);
    var all = arrayFromCollection(querySelectorAll$1.call(doc, TabbableElementsQuery));
    var inner = arrayFromCollection(querySelectorAll.call(host, TabbableElementsQuery));

    {
      assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), "The focusin event is only relevant when the tabIndex property is -1 on the host.");
    }

    var firstChild = inner[0];
    var lastChild = inner[inner.length - 1];
    var hostIndex = ArrayIndexOf.call(all, host);
    var firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
    var lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
    var prev = ArraySlice.call(all, 0, firstChildIndex);
    var next = ArraySlice.call(all, lastChildIndex);
    return {
      prev: prev,
      inner: inner,
      next: next
    };
  }

  function getActiveElement(host) {
    var doc = getOwnerDocument(host);
    var activeElement = DocumentPrototypeActiveElement.call(doc);

    if (isNull(activeElement)) {
      return activeElement;
    }

    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
  }

  function relatedTargetPosition(host, relatedTarget) {
    var pos = compareDocumentPosition.call(host, relatedTarget);

    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
      return 0;
    } else if (pos & DOCUMENT_POSITION_PRECEDING) {
      return 1;
    } else if (pos & DOCUMENT_POSITION_FOLLOWING) {
      return 2;
    }

    return -1;
  }

  function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, 'focusin', muteEvent, true);
    windowAddEventListener.call(win, 'focusout', muteEvent, true);
    func();
    windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
    windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
  }

  function focusOnNextOrBlur(segment, target, relatedTarget) {
    var win = getOwnerWindow(relatedTarget);
    var next = getNextTabbable(segment, relatedTarget);

    if (isNull(next)) {
      muteFocusEventsDuringExecution(win, function () {
        target.blur();
      });
    } else {
      muteFocusEventsDuringExecution(win, function () {
        next.focus();
      });
    }
  }

  var letBrowserHandleFocus = false;

  function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
  }

  function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
  }

  function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    var host = eventCurrentTargetGetter.call(event);
    var target = eventTargetGetter.call(event);

    if (host !== target) {
      return;
    }

    var relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    var segments = getTabbableSegments(host);
    var position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      var findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
      var first = ArrayFind.call(segments.inner, findTabbableElms);

      if (!isUndefined(first)) {
        var win = getOwnerWindow(first);
        muteFocusEventsDuringExecution(win, function () {
          first.focus();
        });
      } else {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
    } else if (host === target) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    var relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    var host = eventCurrentTargetGetter.call(event);
    var segments = getTabbableSegments(host);

    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
      return;
    }

    var target = eventTargetGetter.call(event);
    var position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      focusOnNextOrBlur(segments.next, target, relatedTarget);
    }

    if (position === 2) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
      return false;
    }

    var ownerDocument = getOwnerDocument(toElm);
    var root = toElm.getRootNode();

    while (root !== ownerDocument && root !== fromRoot) {
      var sr = root;
      var host = sr.host;

      if (getAttribute.call(host, 'tabindex') === '-1') {
        return false;
      }

      root = host && host.getRootNode();
    }

    return true;
  }

  function getNextTabbable(tabbables, relatedTarget) {
    var len = tabbables.length;

    if (len > 0) {
      for (var i = 0; i < len; i += 1) {
        var next = tabbables[i];

        if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
          return next;
        }
      }
    }

    return null;
  }

  function handleFocus(elm) {
    {
      assert.invariant(isDelegatingFocus(elm), "Invalid attempt to handle focus event for ".concat(toString(elm), ". ").concat(toString(elm), " should have delegates focus true, but is not delegating focus"));
    }

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener.call(elm, 'focusin', skipHostHandler, true);
  }

  function ignoreFocus(elm) {
    removeEventListener.call(elm, 'focusin', skipHostHandler, true);
  }

  function bindDocumentMousedownMouseupHandlers(elm) {
    var ownerDocument = getOwnerDocument(elm);

    if (!getHiddenField(ownerDocument, DidAddMouseDownListener)) {
      setHiddenField(ownerDocument, DidAddMouseDownListener, true);
      addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
      addEventListener.call(ownerDocument, 'mouseup', function () {
        setTimeout(enableKeyboardFocusNavigationRoutines);
      }, true);
    }
  }

  function handleFocusIn(elm) {
    {
      assert.invariant(tabIndexGetter.call(elm) === -1, "Invalid attempt to handle focus in  ".concat(toString(elm), ". ").concat(toString(elm), " should have tabIndex -1, but has tabIndex ").concat(tabIndexGetter.call(elm)));
    }

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  function ignoreFocusIn(elm) {
    removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  var _HTMLElement$prototyp = HTMLElement.prototype,
      blur = _HTMLElement$prototyp.blur,
      focus = _HTMLElement$prototyp.focus;

  function tabIndexGetterPatched() {
    if (isDelegatingFocus(this) && isFalse$1(hasAttribute.call(this, 'tabindex'))) {
      return 0;
    }

    return tabIndexGetter.call(this);
  }

  function tabIndexSetterPatched(value) {
    var delegatesFocus = isDelegatingFocus(this);
    var prevValue = tabIndexGetter.call(this);
    var prevHasAttr = hasAttribute.call(this, 'tabindex');
    tabIndexSetter.call(this, value);
    var currValue = tabIndexGetter.call(this);
    var currHasAttr = hasAttribute.call(this, 'tabindex');
    var didValueChange = prevValue !== currValue;

    if (prevHasAttr && (didValueChange || isFalse$1(currHasAttr))) {
      if (prevValue === -1) {
        ignoreFocusIn(this);
      }

      if (prevValue === 0 && delegatesFocus) {
        ignoreFocus(this);
      }
    }

    if (isFalse$1(currHasAttr)) {
      return;
    }

    if (prevHasAttr && currHasAttr && isFalse$1(didValueChange)) {
      return;
    }

    if (currValue === -1) {
      handleFocusIn(this);
    }

    if (currValue === 0 && delegatesFocus) {
      handleFocus(this);
    }
  }

  function blurPatched() {
    if (isDelegatingFocus(this)) {
      var currentActiveElement = getActiveElement(this);

      if (!isNull(currentActiveElement)) {
        currentActiveElement.blur();
        return;
      }
    }

    return blur.call(this);
  }

  function focusPatched() {
    disableKeyboardFocusNavigationRoutines();
    focus.call(this);
    enableKeyboardFocusNavigationRoutines();
  }

  defineProperties(HTMLElement.prototype, {
    tabIndex: {
      get: function get() {
        if (isHostElement(this)) {
          return tabIndexGetterPatched.call(this);
        }

        return tabIndexGetter.call(this);
      },
      set: function set(v) {
        if (isHostElement(this)) {
          return tabIndexSetterPatched.call(this, v);
        }

        return tabIndexSetter.call(this, v);
      },
      enumerable: true,
      configurable: true
    },
    blur: {
      value: function value() {
        if (isHostElement(this)) {
          return blurPatched.call(this);
        }

        blur.call(this);
      },
      enumerable: true,
      writable: true,
      configurable: true
    },
    focus: {
      value: function value() {
        focusPatched.call(this);
      },
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  var _Node$prototype2 = Node.prototype,
      superAddEventListener = _Node$prototype2.addEventListener,
      superRemoveEventListener = _Node$prototype2.removeEventListener;

  function addEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      addCustomElementEventListener(this, type, listener);
    } else {
      superAddEventListener.call(this, type, listener, options);
    }
  }

  function removeEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      removeCustomElementEventListener(this, type, listener);
    } else {
      superRemoveEventListener.call(this, type, listener, options);
    }
  }

  if (typeof EventTarget !== 'undefined') {
    defineProperties(EventTarget.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  } else {
    defineProperties(Node.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  }

  var ShadowTokenKey = '$shadowToken$';
  var ShadowTokenPrivateKey = '$$ShadowTokenKey$$';

  function getShadowToken(node) {
    return node[ShadowTokenKey];
  }

  function setShadowToken(node, shadowToken) {
    node[ShadowTokenKey] = shadowToken;
  }

  defineProperty(Element.prototype, '$shadowToken$', {
    set: function set(shadowToken) {
      var oldShadowToken = this[ShadowTokenPrivateKey];

      if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
        removeAttribute.call(this, oldShadowToken);
      }

      if (!isUndefined(shadowToken)) {
        setAttribute.call(this, shadowToken, '');
      }

      this[ShadowTokenPrivateKey] = shadowToken;
    },
    get: function get() {
      return this[ShadowTokenPrivateKey];
    },
    configurable: true
  });
  var DomManualPrivateKey = '$$DomManualKey$$';

  var DocumentResolverFn = function DocumentResolverFn() {};

  var portalObserver;
  var portalObserverConfig = {
    childList: true
  };

  function adoptChildNode(node, fn, shadowToken) {
    var previousNodeShadowResolver = getShadowRootResolver(node);

    if (previousNodeShadowResolver === fn) {
      return;
    }

    setShadowRootResolver(node, fn);

    if (_instanceof(node, Element)) {
      setShadowToken(node, shadowToken);

      if (isHostElement(node)) {
        return;
      }

      if (isUndefined(previousNodeShadowResolver)) {
        MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
      }

      var childNodes = childNodesGetter.call(node);

      for (var i = 0, len = childNodes.length; i < len; i += 1) {
        adoptChildNode(childNodes[i], fn, shadowToken);
      }
    }
  }

  function initPortalObserver() {
    return new MO(function (mutations) {
      forEach.call(mutations, function (mutation) {
        var elm = mutation.target,
            addedNodes = mutation.addedNodes,
            removedNodes = mutation.removedNodes;
        var fn = getShadowRootResolver(elm);
        var shadowToken = getShadowToken(elm);

        for (var i = 0, len = removedNodes.length; i < len; i += 1) {
          var node = removedNodes[i];

          if (!(compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            adoptChildNode(node, DocumentResolverFn, undefined);
          }
        }

        for (var _i = 0, _len = addedNodes.length; _i < _len; _i += 1) {
          var _node = addedNodes[_i];

          if (compareDocumentPosition.call(elm, _node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            adoptChildNode(_node, fn, shadowToken);
          }
        }
      });
    });
  }

  function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
      portalObserver = initPortalObserver();
    }

    if (isUndefined(getShadowRootResolver(elm))) {
      throw new Error("Invalid Element");
    }

    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
  }

  defineProperty(Element.prototype, '$domManual$', {
    set: function set(v) {
      this[DomManualPrivateKey] = v;

      if (isTrue$1(v)) {
        markElementAsPortal(this);
      }
    },
    get: function get() {
      return this[DomManualPrivateKey];
    },
    configurable: true
  });
  /** version: 1.1.13-224.5 */

  var _WebruntimeCompat, _modules;

  if ( (window._ES5ProxyType ? window.get("WebruntimeCompat") : window.WebruntimeCompat) && (_WebruntimeCompat = window._ES5ProxyType ? window.get("WebruntimeCompat") : window.WebruntimeCompat, _modules = _WebruntimeCompat._ES5ProxyType ? _WebruntimeCompat.get("modules") : _WebruntimeCompat.modules)) {
    var _WebruntimeCompat2, _modules2;

    __callKey1(loader, "defineModules", (_WebruntimeCompat2 = window._ES5ProxyType ? window.get("WebruntimeCompat") : window.WebruntimeCompat, _modules2 = _WebruntimeCompat2._ES5ProxyType ? _WebruntimeCompat2.get("modules") : _WebruntimeCompat2.modules));
  } // Register framework modules


  __callKey1(loader, "defineModules", {
    'webruntime_loader/loader': loader
  });

  __setKey(window, "Webruntime", Object.freeze({
    define: loader._ES5ProxyType ? loader.get("define") : loader.define
  }));

}(Proxy.callKey1, Proxy.setKey, Proxy.callKey2, Proxy.iterableKey, Proxy.inKey, Proxy.callKey0, Proxy.callKey3, Proxy.hasOwnProperty, Proxy.deleteKey, Proxy.concat, WebruntimeCompat.babel.helpers.slicedToArray, WebruntimeCompat.babel.regenerator, WebruntimeCompat.babel.helpers.asyncToGenerator, WebruntimeCompat.babel.helpers.instanceof, WebruntimeCompat.babel.helpers.typeof, WebruntimeCompat.babel.helpers.defineProperty, WebruntimeCompat.babel.helpers.classCallCheck));
