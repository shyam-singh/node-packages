#!/usr/bin/env node

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
'use strict';

const fs = require('fs-extra');
const path = require('path');

const metadata = require('../../ui-lightning-components/gold-files/raptor.json');
const pathToRoot = path.join(__dirname, '..');
const coreStubs = path.join(pathToRoot, 'modules', 'lightning-stubs', 'core');
const platformStubs = path.join(pathToRoot, 'modules', 'lightning-stubs', 'platform');

const htmlHeader = `<!--
Copyright (c) 2018, salesforce.com, inc.
All rights reserved.
SPDX-License-Identifier: MIT
For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
-->
`;

const jsHeader = `/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
`;

/**
 * TODO(W-6119384): revisit after raptor.js metadata goldfile is revived. Button
 * extends PrimitiveButton which inherits the `disabled` prop. The metadata file
 * these stubs are generated from does not take inheritance into account yet.
 */
const ignoreList = [
    'button',
    'buttonIcon',
    'buttonIconStateful',

    // need to see usages to determine what stub should look like
    'iconSvgTemplates',
    'iconSvgTemplatesAction',
    'iconSvgTemplatesActionRtl',
    'iconSvgTemplatesCustom',
    'iconSvgTemplatesCustomRtl',
    'iconSvgTemplatesDoctype',
    'iconSvgTemplatesRtl',
    'iconSvgTemplatesStandard',
    'iconSvgTemplatesStandardRtl',
    'iconSvgTemplatesUtility',
    'iconSvgTemplatesUtilityRtl',

    // metadata file filters out global HTML attributes
    'card',
];

// js only libs are not accounted for in the metadata file and must be managed manually
const customMocks = [
    'configProvider',
    'datatableKeyboardMixins',
    'empApi',
    'messageService',
    'navigation',
    'pageReferenceUtils',
    'platformResourceLoader',
    'platformShowToastEvent',
    'uiListApi',
    'uiObjectInfoApi',
    'uiRecordApi',
];

// js only libs that are only exposed to core
const customMocksCore = [
    'clickToDialService',
    'deprecatedOverlayLibrary',
    'deprecatedOverlayUtils',
    'fieldDependencyManager',
    // 'fieldUtils', // is this actually used anywhere?
    // 'iconSvgTemplates', // how to mock this? need to find usage.
    'iconUtils',
    'internalLocalizationService',
    'messageDispatcher',
    'outputFieldUtils',
    'platformNotificationUtils',
    'platformOverlayUtils',
    'quillLib',
    'recordUtils',
    'routingService',
    'uiActionsApi',
    'uiLayoutApi',
    'uiLookupsApi',
    'uiRecordActionsApi',
    'uiRecordAvatarApi',
    'uiRelatedListApi',
    'unstable_uiObjectInfoApi',
    'unstable_uiRecordApi',
    'utils',
    'commerceApi',
    'communityNavigationMenuApi',
];

// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement#Methods
const GLOBAL_METHOD_SET = new Set(['attachInternals', 'blur', 'click', 'focus', 'forceSpellCheck']);

function generateJavascript(filtered, cmpName) {
    const className = cmpName.charAt(0).toUpperCase() + cmpName.substring(1);
    const cmp = filtered[cmpName];

    let properties = [];
    cmp.properties &&
        cmp.properties.forEach(prop => {
            properties.push(`@api ${prop.name};`);
        });

    let methods = [];
    cmp.methods &&
        cmp.methods.forEach(method => {
            const name = method.name;
            if (!GLOBAL_METHOD_SET.has(name)) {
                methods.push(`@api ${name}() {}`);
            }
        });

    let propsAndMethods = properties.join('\n    ');
    if (methods.length) {
        propsAndMethods += '\n    ' + methods.join('\n    ');
    }

    let template;
    if (propsAndMethods.length === 0) {
        template = `import { LightningElement } from 'lwc';

export default class ${className} extends LightningElement {}\n`;
    } else {
        template = `import { LightningElement, api } from 'lwc';

export default class ${className} extends LightningElement {
    ${propsAndMethods}
}\n`;
    }

    return template;
}

function generateHtml(filtered, cmpName) {
    const cmp = filtered[cmpName];

    // all bundles with an html file will have a slotNames entry
    if (!cmp.slotNames) {
        return null;
    }

    let slots = [];
    cmp.slotNames.forEach(slotName => {
        if (slotName === '') {
            slots.push(`\n    <slot></slot>`);
        } else {
            slots.push(`\n    <slot name="${slotName}"></slot>`);
        }
    });

    return `<template>${slots.length ? slots.join('') + '\n' : ''}</template>\n`;
}

// only generate a mock for entries that have some data and aren't a manually managed stub
const filtered = Object.keys(metadata)
    .filter(
        cmp =>
            !!(metadata[cmp].slotNames || metadata[cmp].properties || metadata[cmp].methods) &&
            !customMocks.some(lib => lib === cmp) &&
            !customMocksCore.some(lib => lib === cmp) &&
            !ignoreList.some(ignore => ignore === cmp),
    )
    .reduce((acc, key) => {
        return {
            ...acc,
            [key]: metadata[key],
        };
    }, {});

// generate stubs based off metadata file and copy into core and/or platform directories
Object.keys(filtered).forEach(cmpName => {
    const coreStubsDir = path.join(coreStubs, cmpName);
    const platformStubsDir = path.join(platformStubs, cmpName);

    const javascript = generateJavascript(filtered, cmpName);
    const html = generateHtml(filtered, cmpName);

    fs.ensureDirSync(coreStubsDir);
    fs.writeFileSync(path.join(coreStubsDir, cmpName + '.js'), jsHeader + javascript);

    // only write to the platform folder if minVersion is present
    if (filtered[cmpName].minVersion) {
        fs.ensureDirSync(platformStubsDir);
        fs.writeFileSync(path.join(platformStubsDir, cmpName + '.js'), jsHeader + javascript);
    }

    if (html) {
        fs.writeFileSync(path.join(coreStubsDir, cmpName + '.html'), htmlHeader + html);

        if (filtered[cmpName].minVersion) {
            fs.writeFileSync(path.join(platformStubsDir, cmpName + '.html'), htmlHeader + html);
        }
    }
});

// copy in custom mocks that must be manually managed
const customMocksDir = path.join(__dirname, '..', 'customMocks');
customMocks.forEach(mockName => {
    const mockDir = path.join(customMocksDir, mockName);
    const coreDest = path.join(coreStubs, mockName);
    const platformDest = path.join(platformStubs, mockName);

    fs.ensureDirSync(coreDest);
    fs.copySync(mockDir, coreDest);

    fs.ensureDirSync(platformDest);
    fs.copySync(mockDir, platformDest);
});

// some custom mocks are only exposed in core
customMocksCore.forEach(mockName => {
    const mockDir = path.join(customMocksDir, mockName);
    const coreDest = path.join(coreStubs, mockName);

    fs.ensureDirSync(coreDest);
    fs.copySync(mockDir, coreDest);
});
