import { LightningElement } from 'lwc';
import createContextWireAdapter from './createContextWireAdapter';
import getUniqueEventName from './getUniqueContextName';

// caching this method so subclasses can't intercept the event name
const { addEventListener } = LightningElement.prototype;

// Per Context Component Constructor, track the metadata of the adapter
const ContextProviderMetaMap = new Map();
// Per Context Component Instance, track the current context data
const ContextDataMap = new WeakMap();

function getWireAdapterMeta(ctor) {
    let adapterMeta = ContextProviderMetaMap.get(ctor);
    if (adapterMeta === undefined) {
        const eventName = getUniqueEventName();
        const wireAdapter = createContextWireAdapter(eventName, ctor);
        // name and adapter per constructor
        adapterMeta = {
            wireAdapter,
            eventName,
        };
        ContextProviderMetaMap.set(ctor, adapterMeta);
    }
    return adapterMeta;
}

function getContextData(eventTarget) {
    let contextData = ContextDataMap.get(eventTarget);
    if (contextData === undefined) {
        // collection of consumers' callbacks and default context value per provider instance
        contextData = {
            listeners: [],
            value: null, // initial value for an installed provider
        };
        ContextDataMap.set(eventTarget, contextData);
    }
    return contextData;
}

function disconnectConsumer(eventTarget, contextData, callback) {
    const i = contextData.listeners.indexOf(callback);
    if (i >= 0) {
        contextData.listeners.splice(i, 1);
    } else {
        throw new SyntaxError(`Invalid context operation in ${eventTarget}.`);
    }
}

function setupNewContextProvider(eventTarget) {
    const adapterMeta = getWireAdapterMeta(eventTarget.constructor);
    let contextData; // lazy initialization
    addEventListener.call(eventTarget, adapterMeta.eventName, event => {
        // this event must have a full stop when it is intercepted by a provider
        event.stopImmediatePropagation();
        // the new child provides a callback as a communication channel
        const { detail: callback } = event;
        // once the first consumer gets connected, then we create the contextData object
        if (contextData === undefined) {
            contextData = getContextData(eventTarget);
        }
        // registering the new callback
        contextData.listeners.push(callback);
        // emit the current value and provide disconnect callback
        callback(contextData.value, () =>
            disconnectConsumer(eventTarget, contextData, callback)
        );
    });
}

function emitNewContextValue(eventTarget, newValue) {
    const contextData = getContextData(eventTarget);
    contextData.value = newValue;
    contextData.listeners.forEach(callback =>
        callback(newValue, () =>
            disconnectConsumer(eventTarget, contextData, callback)
        )
    );
}

export default class LightningContext extends LightningElement {
    constructor() {
        super();
        setupNewContextProvider(this);
    }

    setContext(newValue) {
        emitNewContextValue(this, newValue);
    }

    static get Provider() {
        return getWireAdapterMeta(this).wireAdapter;
    }

    static getDefaultContext() {
        return undefined;
    }
}
