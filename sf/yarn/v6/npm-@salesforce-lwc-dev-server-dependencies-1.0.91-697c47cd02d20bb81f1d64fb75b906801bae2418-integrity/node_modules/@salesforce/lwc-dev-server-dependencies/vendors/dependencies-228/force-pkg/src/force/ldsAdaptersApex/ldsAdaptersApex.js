/*  *******************************************************************************************
 *  ATTENTION!
 *  THIS IS A GENERATED FILE FROM https://github.com/salesforce/lds-lightning-platform
 *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
 *  Any changes made to this file in p4 will be automatically overwritten.
 *  *******************************************************************************************
 */
/* proxy-compat-disable */
export { getSObjectValue } from './lds-apex-static-utils';
import { createLDSAdapter, createWireAdapterConstructor } from 'force/ldsBindings';
export { refresh as refreshApex } from 'force/ldsBindings';

const { keys, values } = Object;
const { isArray } = Array;
const { stringify } = JSON;

/**
 * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
 * This is needed because insertion order for JSON.stringify(object) affects output:
 * JSON.stringify({a: 1, b: 2})
 *      "{"a":1,"b":2}"
 * JSON.stringify({b: 2, a: 1})
 *      "{"b":2,"a":1}"
 * @param data Data to be JSON-stringified.
 * @returns JSON.stringified value with consistent ordering of keys.
 */
function stableJSONStringify(node) {
    // This is for Date values.
    if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
    }
    if (node === undefined) {
        return;
    }
    if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
    }
    if (typeof node !== 'object') {
        return stringify(node);
    }
    let i;
    let out;
    if (isArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
            if (i) {
                out += ',';
            }
            out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
    }
    if (node === null) {
        return 'null';
    }
    const keys$1 = keys(node).sort();
    out = '';
    for (i = 0; i < keys$1.length; i++) {
        const key = keys$1[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
            continue;
        }
        if (out) {
            out += ',';
        }
        out += stringify(key) + ':' + value;
    }
    return '{' + out + '}';
}

function createResourceRequest(config) {
    const headers = {};
    return {
        baseUri: '',
        basePath: '/apex',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        ingest: null,
        headers,
    };
}

const { isArray: ArrayIsArray } = Array;
function isPromise(value) {
    return value.then !== undefined;
}
function untrustedIsObject(untrusted) {
    return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray(untrusted) === false;
}
function refreshable(adapter, resolve) {
    return (config) => {
        const result = adapter(config);
        if (result === null) {
            return result;
        }
        if (isPromise(result)) {
            return result.then(snapshot => {
                snapshot.refresh = {
                    config,
                    resolve,
                };
                return snapshot;
            });
        }
        result.refresh = {
            config,
            resolve,
        };
        return result;
    };
}

const { freeze: ObjectFreeze, keys: ObjectKeys } = Object;
const { isArray: ArrayIsArray$1 } = Array;
function deepFreeze(value) {
    // No need to freeze primitives
    if (typeof value !== 'object' || value === null) {
        return;
    }
    if (ArrayIsArray$1(value)) {
        for (let i = 0, len = value.length; i < len; i += 1) {
            deepFreeze(value[i]);
        }
    }
    else {
        const keys = ObjectKeys(value);
        for (let i = 0, len = keys.length; i < len; i += 1) {
            deepFreeze(value[keys[i]]);
        }
    }
    ObjectFreeze(value);
}
function createLink(ref) {
    return {
        __ref: ref,
    };
}

function cache(lds, config, namespace, classname, method, isContinuation) {
    const recordId = getApexId(namespace, classname, method, isContinuation, config);
    const cacheableSnap = lds.storeLookup({
        recordId: recordId + '_cacheable',
        node: {
            kind: 'Fragment',
            private: [],
            selections: [
                {
                    kind: 'Scalar',
                    name: 'cacheable',
                },
            ],
        },
        variables: {},
    });
    // adapter always storeIngest the response, but only cacheable response should be used
    if (cacheableSnap.state !== 'Fulfilled' || cacheableSnap.data.cacheable === false) {
        return null;
    }
    const snap = lds.storeLookup({
        recordId,
        node: { kind: 'Fragment', opaque: true, private: [] },
        variables: {},
    });
    if (snap.state !== 'Fulfilled') {
        return null;
    }
    return snap;
}
// TODO: APEX_TTL, apexResponseEquals, apexResponseIngest, and validateAdapterConfig should have been code generated
// however compiler does not support response body type any so hand roll for now
/**
 * Time to live for the Apex cache value. 5 minutes.
 */
const APEX_TTL = 5 * 60 * 1000;
function apexResponseEquals(existing, incoming) {
    return stringify(incoming) === stringify(existing);
}
const apexResponseIngest = (input, path, _lds, store, timestamp) => {
    // skip validation since input type is any
    const key = path.fullPath;
    const existingRecord = store.records[key];
    // no normalization
    let incomingRecord = input;
    deepFreeze(input);
    if (existingRecord === undefined ||
        apexResponseEquals(existingRecord, incomingRecord) === false) {
        store.publish(key, incomingRecord);
    }
    store.setExpiration(key, timestamp + APEX_TTL);
    return createLink(key);
};
/**
 *  Validates the apex request configuration passed in from @wire.
 *  @param config The configuration object passed from @wire.
 *  @returns True if config is null/undefined or false if it does not contain undefined values.
 */
function validateAdapterConfig(untrustedConfig) {
    if (untrustedIsObject(untrustedConfig)) {
        const values$1 = values(untrustedConfig);
        return values$1.indexOf(undefined) === -1;
    }
    return true;
}
function network(lds, config, namespace, classname, method, isContinuation, cacheable) {
    const recordId = getApexId(namespace, classname, method, isContinuation, config);
    const select = {
        recordId,
        node: { kind: 'Fragment', opaque: true, private: [] },
        variables: {},
    };
    const body = {
        namespace,
        classname,
        method,
        isContinuation,
        params: config,
        cacheable,
    };
    const requestConfig = { body };
    const request = {
        ...createResourceRequest(requestConfig),
        ingest: apexResponseIngest,
    };
    return lds.dispatchResourceRequest(request).then(resp => {
        const { cacheable } = resp.headers;
        if (cacheable === true) {
            lds.storePublish(recordId + '_cacheable', resp.headers);
            lds.storeIngest(recordId, request, resp.body);
            lds.storeBroadcast();
            return lds.storeLookup(select);
        }
        // if cacheable is not set or set to false, return a synthetic snapshot
        return {
            recordId,
            variables: {},
            seenRecords: {},
            select,
            state: 'Fulfilled',
            data: resp.body,
        };
    }, (err) => {
        return lds.errorSnapshot(err);
    });
}
const factory = (lds, invokerParams) => {
    const { namespace, classname, method, isContinuation } = invokerParams;
    const adapter = getLdsAdapterFactory(lds, namespace, classname, method, isContinuation, true);
    return refreshable(function apexWireAdapter(untrustedConfig) {
        // Invalid or incomplete config
        if (!validateAdapterConfig(untrustedConfig)) {
            return null;
        }
        return adapter(untrustedConfig);
    }, (untrustedConfig) => {
        // This should never happen
        if (!validateAdapterConfig(untrustedConfig)) {
            throw new Error('Invalid config passed to "apexWireAdapter" refresh function');
        }
        return network(lds, untrustedConfig, namespace, classname, method, isContinuation, true);
    });
};
const invoker = (lds, invokerParams) => {
    const { namespace, classname, method, isContinuation } = invokerParams;
    const ldsAdapter = getLdsAdapterFactory(lds, namespace, classname, method, isContinuation, false);
    return getInvoker(ldsAdapter);
};
function getInvoker(ldsAdapter) {
    return (config) => {
        const snapshotOrPromise = ldsAdapter(config);
        return Promise.resolve(snapshotOrPromise).then((snapshot) => {
            if (snapshot.state === 'Error') {
                throw snapshot.error;
            }
            return snapshot.data;
        });
    };
}
/**
 * A standard delimiter when producing cache keys.
 */
const KEY_DELIM = ':';
function isEmptyParam(param) {
    return (param === undefined ||
        param === null ||
        (typeof param === 'object' && keys(param).length === 0));
}
/**
 * Constructs a cache key for the Apex value type.
 * @param namespace The name space.
 * @param classname The class name.
 * @param functionName The function name.
 * @param isContinuation Indicates whether the Apex method returns a continuation.
 * @param params The params.
 * @returns A new cache key representing the Apex value type.
 */
function getApexId(namespace, classname, functionName, isContinuation, params) {
    return [
        namespace,
        classname,
        functionName,
        isContinuation,
        isEmptyParam(params) ? '' : stableJSONStringify(params),
    ].join(`${KEY_DELIM}`);
}
function getLdsAdapterFactory(lds, namespace, classname, method, isContinuation, cacheable) {
    return (config) => {
        const snap = cache(lds, config, namespace, classname, method, isContinuation);
        if (snap !== null) {
            return snap;
        }
        return network(lds, config, namespace, classname, method, isContinuation, cacheable);
    };
}

/**
 * Apex
 */
const getApexInvoker = function (namespace, classname, method, isContinuation) {
    const adapterName = `getApex_${namespace}_${classname}_${method}_${isContinuation}`;
    const invokeApexImperative = createLDSAdapter(adapterName, lds => invoker(lds, {
        namespace,
        classname,
        method,
        isContinuation,
    }));
    invokeApexImperative.adapter = createWireAdapterConstructor(adapterName, lds => factory(lds, { namespace, classname, method, isContinuation }));
    return invokeApexImperative;
};

export { getApexInvoker };
