{
  "manifest": {
    "name": "observable-membrane",
    "version": "0.26.1",
    "description": "A Javascript Membrane implementation using Proxies to observe mutation on an object graph",
    "main": "dist/commonjs/observable-membrane.js",
    "module": "dist/modules/observable-membrane.js",
    "typings": "dist/types/main.d.ts",
    "license": "MIT",
    "author": {
      "name": "David Turissini",
      "email": "dturissini@salesforce.com"
    },
    "keywords": [
      "proxy",
      "membrane",
      "observe",
      "mutation"
    ],
    "homepage": "https://github.com/salesforce/observable-membrane",
    "bugs": {
      "url": "https://github.com/salesforce/observable-membrane/issues"
    },
    "repository": {
      "type": "git",
      "url": "git@github.com:salesforce/observable-membrane.git"
    },
    "files": [
      "dist"
    ],
    "scripts": {
      "lint": "tslint -p tsconfig.json",
      "test": "jest --config jest.config.js --coverage",
      "prebuild": "rm -rf dist",
      "build": "tsc --emitDeclarationOnly && rollup -c",
      "changelog": "yarn changelog:generate && yarn changelog:publish",
      "changelog:generate": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0",
      "changelog:publish": "git add CHANGELOG.md && git commit -m 'docs(changelog): publish release changelog' && git push"
    },
    "devDependencies": {
      "@types/jest": "~23.1.0",
      "@types/node": "8.9.4",
      "conventional-changelog-cli": "^2.0.1",
      "jest": "~23.1.0",
      "rollup": "^1.4.1",
      "rollup-plugin-replace": "^2.1.0",
      "rollup-plugin-terser": "^4.0.4",
      "rollup-plugin-typescript": "~0.8.1",
      "ts-jest": "~22.0.4",
      "tslint": "~5.9.1",
      "typescript": "2.7.2"
    },
    "_registry": "npm",
    "_loc": "C:\\Users\\csmku\\AppData\\Local\\sf\\yarn\\v6\\npm-observable-membrane-0.26.1-5619a7b2f4b0414d62b3e6cc2ea65734a08cce7a-integrity\\node_modules\\observable-membrane\\package.json",
    "readmeFilename": "README.md",
    "readme": "# Observable Membrane\nCreating robust JavaScript code becomes increasingly important as web applications become more sophisticated. The dynamic nature of JavaScript code at runtime has always presented challenges for developers.\n\nThis package implements an observable membrane in JavaScript using Proxies.\n\nA membrane can be created to control access to a module graph, observe what the other part is attempting to do with the objects that were handed over to them, and even distort the way they see the module graph.\n\n## What is a Membrane\n\n* [Tom van Cutsem's original article, \"Isolating application sub-components with membranes\"](https://tvcutsem.github.io/membranes)\n* [Tom van Cutsem's original article, \"Membranes in JavaScript\"](https://tvcutsem.github.io/js-membranes)\n* [es-membrane library by Alexander J. Vincent](https://github.com/ajvincent/es-membrane)\n\n## Use Cases\n\nOne of the prime use-cases for observable membranes is the popular `@observed` or `@tracked` decorator used in components to detect mutations on the state of the component to re-render the component when needed. In this case, any object value set into a decorated field can be wrapped into an observable membrane to monitor if the object is accessed during the rendering phase, and if so, the component must be re-rendered when mutations on the object value are detected. And this process is applied not only at the object value level, but at any level in the object graph accessible via the observed object value.\n\nAdditionally, it supports distorting objects within an object graph, which could be used for:\n\n* Avoid leaking symbols and other non-observables objects.\n* Distorting values observed through the membrane.\n\n### Usage\n\nThe following example illustrates how to create an observable membrane, and proxies:\n\n```js\nimport ObservableMembrane from 'observable-membrane';\n\nconst membrane = new ObservableMembrane();\n\nconst o = {\n    x: 2,\n    y: {\n        z: 1\n    },\n};\n\nconst p = membrane.getProxy(o);\n\np.x;\n// yields 2\n\np.y.z;\n// yields 1\n```\n\n_Note: If the value that you're accessing via the membrane is an object that can be observed then the membrane will return a new proxy. In the example above, `o.y !== p.y` because it is a proxy that applies the exact same mechanism. In other words, the membrane is applicable to an entire object graph._\n\n#### Observing Access and Mutations\n\nThe most basic operation in an observable membrane is to observe property member access and mutations. For that, the constructor accepts an optional arguments `options` that accepts two callbacks, `valueObserved` and `valueMutated`:\n\n```js\nimport ObservableMembrane from 'observable-membrane';\n\nconst membrane = new ObservableMembrane({\n    valueObserved(target, key) {\n        // where target is the object that was accessed\n        // and key is the key that was read\n        console.log('accessed ', key);\n    },\n    valueMutated(target, key) {\n        // where target is the object that was mutated\n        // and key is the key that was mutated\n        console.log('mutated ', key);\n    },\n});\n\nconst o = {\n    x: 2,\n    y: {\n        z: 1\n    },\n};\n\nconst p = membrane.getProxy(o);\n\np.x;\n// console output -> 'accessed x'\n// yields 2\n\np.y.z;\n// console output -> 'accessed z'\n// yields 1\n\np.y.z = 3;\n// console output -> 'mutated z'\n// yields 3\n```\n\n#### Read Only Proxies\n\nAnother use-case for observable membranes is to prevent mutations in the object graph. For that, `ObservableMembrane` provides an additional method that gets a read-only version of any object value. One of the prime use-cases for read-only membranes is to hand over an object to another actor, observe how the actor uses that object reference, but prevent the actor from mutating the object. E.g.: passing an object property down to a child component that can consume the object value but not mutate it.\n\nThis is also a very cheap way of doing deep-freeze, although it is not exactly the same, but can cover a lot of ground without having to actually freeze the original object, or a copy of it:\n\n\n```js\nimport ObservableMembrane from 'observable-membrane';\n\nconst membrane = new ObservableMembrane({\n    valueObserved(target, key) {\n        // where target is the object that was accessed\n        // and key is the key that was read\n        console.log('accessed ', key);\n    },\n});\n\nconst o = {\n    x: 2,\n    y: {\n        z: 1\n    },\n};\n\nconst r = membrane.getReadOnlyProxy(o);\n\nr.x;\n// yields 2\n\nr.y.z;\n// yields 1\n\nr.y.z = 2;\n// throws Error in dev-mode, and does nothing in production mode\n```\n\n#### Distortion\n\nAs described above, you can use distortions to avoid leaking non-observable objects and distorting values observed through the membrane:\n\n```js\nimport ObservableMembrane from 'observable-membrane';\n\nconst membrane = new ObservableMembrane({\n    valueDistortion(value) {\n        if (value instanceof Node) {\n            throw new ReferenceError(`Invalid access to a non-observable Node`);\n        }\n        console.log('distorting ', value);\n        if (value === 1) {\n            return 10;\n        }\n        return value;\n    },\n});\n\nconst o = {\n    x: 2,\n    y: {\n        z: 1,\n        node: document.createElement('p'),\n    },\n};\n\nconst p = membrane.getProxy(o);\n\np.x;\n// console output -> 'distorting 2'\n// yields 2\n\np.y.z;\n// console output -> 'distorting 1'\n// yields 10\n\np.y.node;\n// throws ReferenceError\n```\n\n_Note: You could use a `WeakMap` to remap symbols to avoid leaking the original symbols and other non-observable objects through the distortion mechanism._\n\n#### Unwrapping Proxies\n\nFor advanced usages, the observable membrane instance offers the ability to unwrap any proxy generated by the membrane. This can be used to detect membrane presence and other detections that may be useful to framework authors. E.g.:\n\n```js\nimport ObservableMembrane from 'observable-membrane';\n\nconst membrane = new ObservableMembrane();\n\nconst o = {\n    x: 2,\n    y: {\n        z: 1,\n    },\n};\n\nconst p = membrane.getProxy(o);\n\no.y !== p.x;\n// yields true because `p` is a proxy of `o`\n\no.y === membrane.unwrapProxy(p.y);\n// yields true because `membrane.unwrapProxy(p.y)` returns the original target `o.y`\n```\n\n## Example\n\nThere are [runnable examples](https://github.com/salesforce/observable-membrane/tree/master/examples) in this Git repository. You must build this package as described in the [Contributing Guide](CONTRIBUTING.md) before attempting to run the examples. Additionally, some of the examples might be relying on features that are not supported in all browsers (e.g.: [reactivo-element](https://github.com/salesforce/observable-membrane/tree/master/examples/reactivo-element) example relies on Web Components APIs).\n\n## API\n\n### `new ObservableMembrane([config])`\n\nCreate a new membrane.\n\n**Parameters**\n\n* `config` [Object] [Optional] The membrane configuration\n    * `valueObserved` [Function] [Optional] Callback invoked when an observed  property is accessed. This function receives as argument the original target and the property key.\n    * `valueMutated` [Function] [Optional] Callback invoked when an observed property is mutated. This function receives as argument the original target and the property key.\n    * `valueDistortion` [Function] [Optional] Callback to apply distortion to the objects present in the object graph. This function receives as argument a newly added object in the object graph.\n\n\n### `ObservableMembrane.prototype.getProxy(object)`\n\nWrap an object in the membrane. If the `object` is observable it will return a proxified version of the object, otherwise it returns the original value.\n\n**Parameters**\n\n* `object` [Object] The object to wrap in the membrane.\n\n\n### `ObservableMembrane.prototype.getReadOnlyProxy(object)`\n\nWrap an object in the read-only membrane. If the `object` is observable it will return a proxified version of the object, otherwise it returns the original value.\n\n**Parameters**\n\n* `object` [Object] The object to wrap in the membrane.\n\n\n### `ObservableMembrane.prototype.unwrapProxy(proxy)`\n\nUnwrap the proxified version of the object from the membrane and return it's original value.\n\n**Parameters**\n\n* `proxy` [Object] Proxified object to unwrap from the membrane.\n\n\n## Limitations and Other Features\n\n* This membrane implementation is tailored for observable objects, which are objects with the prototype chain set to `Object.prototype` or `null`. Any other object is not wrapped in a Proxy by design.\n* Distortion of Symbols and other built-in objects is possible via `valueDistortion` mechanism to avoid leaking internal.\n* The ability for the membrane creator to revoke all proxies within it to prevent further mutations to the underlying objects (aka, membrane shutdown switch) is not supported at the moment.\n* A value mutation that is set to a read-only proxy value is allowed, but the subtree will still be read-only, e.g.: `const p = membrane.getProxy({}); p.abc = membrane.getReadOnlyProxy({}); p.abc.qwe = 1;` will throw because the value assigned to `abc` is still read only.\n\n## Browser Compatibility\n\nObservable membranes requires Proxy (ECMAScript 6) [to be available](https://caniuse.com/#search=proxy).\n\n## Development State\n\nThis library is production ready, it has been used at Salesforce in production for over a year. It is very lightweight (~1k - minified and gzipped), that can be used with any framework or library. It is designed to be very performant.\n\n## Contribution\n\nPlease make sure to read the [Contributing Guide](CONTRIBUTING.md) before making a pull request.\n\n## License\n\n[MIT](http://opensource.org/licenses/MIT)\n\nCopyright (C) 2017 salesforce.com, Inc.\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017 Salesforce\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/observable-membrane/-/observable-membrane-0.26.1.tgz#5619a7b2f4b0414d62b3e6cc2ea65734a08cce7a",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/observable-membrane/-/observable-membrane-0.26.1.tgz",
    "hash": "5619a7b2f4b0414d62b3e6cc2ea65734a08cce7a",
    "integrity": "sha512-fBxLHtd0pUFI/rKh6Dfn9fxjEgY4NkRIqlPEKa9fR28rC9CQDfQ5P+t292CtAArtXOQ1mF8Nq9m1cF52IdN8DA==",
    "registry": "npm",
    "packageName": "observable-membrane",
    "cacheIntegrity": "sha512-fBxLHtd0pUFI/rKh6Dfn9fxjEgY4NkRIqlPEKa9fR28rC9CQDfQ5P+t292CtAArtXOQ1mF8Nq9m1cF52IdN8DA== sha1-VhmnsvSwQU1is+bMLqZXNKCMzno="
  },
  "registry": "npm",
  "hash": "5619a7b2f4b0414d62b3e6cc2ea65734a08cce7a"
}