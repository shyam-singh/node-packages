{
  "manifest": {
    "name": "path-to-regexp",
    "version": "6.2.1",
    "publishConfig": {
      "access": "public"
    },
    "description": "Express style path to RegExp utility",
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/pillarjs/path-to-regexp.git"
    },
    "main": "dist/index.js",
    "module": "dist.es2015/index.js",
    "scripts": {
      "build": "ts-scripts build",
      "format": "ts-scripts format",
      "lint": "ts-scripts lint",
      "prepare": "ts-scripts install && npm run build",
      "size": "size-limit",
      "specs": "ts-scripts specs",
      "test": "ts-scripts test && npm run size"
    },
    "files": [
      "dist.es2015/",
      "dist/"
    ],
    "keywords": [
      "express",
      "regexp",
      "route",
      "routing"
    ],
    "devDependencies": {
      "@borderless/ts-scripts": "^0.8.0",
      "@size-limit/preset-small-lib": "^7.0.8",
      "@types/jest": "^27.4.0",
      "@types/node": "^17.0.17",
      "@types/semver": "^7.3.1",
      "semver": "^7.3.5",
      "size-limit": "^7.0.8",
      "typescript": "^4.5.5"
    },
    "typings": "dist/index.d.ts",
    "sideEffects": false,
    "size-limit": [
      {
        "path": "dist.es2015/index.js",
        "limit": "2.1 kB"
      }
    ],
    "ts-scripts": {
      "dist": [
        "dist",
        "dist.es2015"
      ],
      "project": [
        "tsconfig.build.json",
        "tsconfig.es2015.json"
      ]
    },
    "_registry": "npm",
    "_loc": "C:\\Users\\csmku\\AppData\\Local\\sf\\yarn\\v6\\npm-path-to-regexp-6.2.1-d54934d6798eb9e5ef14e7af7962c945906918e5-integrity\\node_modules\\path-to-regexp\\package.json",
    "readmeFilename": "Readme.md",
    "readme": "# Path-to-RegExp\n\n> Turn a path string such as `/user/:name` into a regular expression.\n\n[![NPM version][npm-image]][npm-url]\n[![NPM downloads][downloads-image]][downloads-url]\n[![Build status][build-image]][build-url]\n[![Build coverage][coverage-image]][coverage-url]\n[![License][license-image]][license-url]\n\n## Installation\n\n```\nnpm install path-to-regexp --save\n```\n\n## Usage\n\n```javascript\nconst { pathToRegexp, match, parse, compile } = require(\"path-to-regexp\");\n\n// pathToRegexp(path, keys?, options?)\n// match(path)\n// parse(path)\n// compile(path)\n```\n\n### Path to regexp\n\nThe `pathToRegexp` function will return a regular expression object based on the provided `path` argument. It accepts the following arguments:\n\n- **path** A string, array of strings, or a regular expression.\n- **keys** _(optional)_ An array to populate with keys found in the path.\n- **options** _(optional)_\n  - **sensitive** When `true` the regexp will be case sensitive. (default: `false`)\n  - **strict** When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n  - **end** When `true` the regexp will match to the end of the string. (default: `true`)\n  - **start** When `true` the regexp will match from the beginning of the string. (default: `true`)\n  - **delimiter** The default delimiter for segments, e.g. `[^/#?]` for `:named` patterns. (default: `'/#?'`)\n  - **endsWith** Optional character, or list of characters, to treat as \"end\" characters.\n  - **encode** A function to encode strings before inserting into `RegExp`. (default: `x => x`)\n  - **prefixes** List of characters to automatically consider prefixes when parsing. (default: `./`)\n\n```javascript\nconst keys = [];\nconst regexp = pathToRegexp(\"/foo/:bar\", keys);\n// regexp = /^\\/foo(?:\\/([^\\/#\\?]+?))[\\/#\\?]?$/i\n// keys = [{ name: 'bar', prefix: '/', suffix: '', pattern: '[^\\\\/#\\\\?]+?', modifier: '' }]\n```\n\n**Please note:** The `RegExp` returned by `path-to-regexp` is intended for ordered data (e.g. pathnames, hostnames). It can not handle arbitrarily ordered data (e.g. query strings, URL fragments, JSON, etc). When using paths that contain query strings, you need to escape the question mark (`?`) to ensure it does not flag the parameter as [optional](#optional).\n\n### Parameters\n\nThe path argument is used to define parameters and populate keys.\n\n#### Named Parameters\n\nNamed parameters are defined by prefixing a colon to the parameter name (`:foo`).\n\n```js\nconst regexp = pathToRegexp(\"/:foo/:bar\");\n// keys = [{ name: 'foo', prefix: '/', ... }, { name: 'bar', prefix: '/', ... }]\n\nregexp.exec(\"/test/route\");\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n**Please note:** Parameter names must use \"word characters\" (`[A-Za-z0-9_]`).\n\n##### Custom Matching Parameters\n\nParameters can have a custom regexp, which overrides the default match (`[^/]+`). For example, you can match digits or names in a path:\n\n```js\nconst regexpNumbers = pathToRegexp(\"/icon-:foo(\\\\d+).png\");\n// keys = [{ name: 'foo', ... }]\n\nregexpNumbers.exec(\"/icon-123.png\");\n//=> ['/icon-123.png', '123']\n\nregexpNumbers.exec(\"/icon-abc.png\");\n//=> null\n\nconst regexpWord = pathToRegexp(\"/(user|u)\");\n// keys = [{ name: 0, ... }]\n\nregexpWord.exec(\"/u\");\n//=> ['/u', 'u']\n\nregexpWord.exec(\"/users\");\n//=> null\n```\n\n**Tip:** Backslashes need to be escaped with another backslash in JavaScript strings.\n\n##### Custom Prefix and Suffix\n\nParameters can be wrapped in `{}` to create custom prefixes or suffixes for your segment:\n\n```js\nconst regexp = pathToRegexp(\"/:attr1?{-:attr2}?{-:attr3}?\");\n\nregexp.exec(\"/test\");\n// => ['/test', 'test', undefined, undefined]\n\nregexp.exec(\"/test-test\");\n// => ['/test', 'test', 'test', undefined]\n```\n\n#### Unnamed Parameters\n\nIt is possible to write an unnamed parameter that only consists of a regexp. It works the same the named parameter, except it will be numerically indexed:\n\n```js\nconst regexp = pathToRegexp(\"/:foo/(.*)\");\n// keys = [{ name: 'foo', ... }, { name: 0, ... }]\n\nregexp.exec(\"/test/route\");\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n#### Modifiers\n\nModifiers must be placed after the parameter (e.g. `/:foo?`, `/(test)?`, `/:foo(test)?`, or `{-:foo(test)}?`).\n\n##### Optional\n\nParameters can be suffixed with a question mark (`?`) to make the parameter optional.\n\n```js\nconst regexp = pathToRegexp(\"/:foo/:bar?\");\n// keys = [{ name: 'foo', ... }, { name: 'bar', prefix: '/', modifier: '?' }]\n\nregexp.exec(\"/test\");\n//=> [ '/test', 'test', undefined, index: 0, input: '/test', groups: undefined ]\n\nregexp.exec(\"/test/route\");\n//=> [ '/test/route', 'test', 'route', index: 0, input: '/test/route', groups: undefined ]\n```\n\n**Tip:** The prefix is also optional, escape the prefix `\\/` to make it required.\n\nWhen dealing with query strings, escape the question mark (`?`) so it doesn't mark the parameter as optional. Handling unordered data is outside the scope of this library.\n\n```js\nconst regexp = pathToRegexp(\"/search/:tableName\\\\?useIndex=true&term=amazing\");\n\nregexp.exec(\"/search/people?useIndex=true&term=amazing\");\n//=> [ '/search/people?useIndex=true&term=amazing', 'people', index: 0, input: '/search/people?useIndex=true&term=amazing', groups: undefined ]\n\n// This library does not handle query strings in different orders\nregexp.exec(\"/search/people?term=amazing&useIndex=true\");\n//=> null\n```\n\n##### Zero or more\n\nParameters can be suffixed with an asterisk (`*`) to denote a zero or more parameter matches.\n\n```js\nconst regexp = pathToRegexp(\"/:foo*\");\n// keys = [{ name: 'foo', prefix: '/', modifier: '*' }]\n\nregexp.exec(\"/\");\n//=> [ '/', undefined, index: 0, input: '/', groups: undefined ]\n\nregexp.exec(\"/bar/baz\");\n//=> [ '/bar/baz', 'bar/baz', index: 0, input: '/bar/baz', groups: undefined ]\n```\n\n##### One or more\n\nParameters can be suffixed with a plus sign (`+`) to denote a one or more parameter matches.\n\n```js\nconst regexp = pathToRegexp(\"/:foo+\");\n// keys = [{ name: 'foo', prefix: '/', modifier: '+' }]\n\nregexp.exec(\"/\");\n//=> null\n\nregexp.exec(\"/bar/baz\");\n//=> [ '/bar/baz','bar/baz', index: 0, input: '/bar/baz', groups: undefined ]\n```\n\n### Match\n\nThe `match` function will return a function for transforming paths into parameters:\n\n```js\n// Make sure you consistently `decode` segments.\nconst fn = match(\"/user/:id\", { decode: decodeURIComponent });\n\nfn(\"/user/123\"); //=> { path: '/user/123', index: 0, params: { id: '123' } }\nfn(\"/invalid\"); //=> false\nfn(\"/user/caf%C3%A9\"); //=> { path: '/user/caf%C3%A9', index: 0, params: { id: 'café' } }\n```\n\nThe `match` function can be used to custom match named parameters. For example, this can be used to whitelist a small number of valid paths:\n\n```js\nconst urlMatch = match(\"/users/:id/:tab(home|photos|bio)\", {\n  decode: decodeURIComponent,\n});\n\nurlMatch(\"/users/1234/photos\");\n//=> { path: '/users/1234/photos', index: 0, params: { id: '1234', tab: 'photos' } }\n\nurlMatch(\"/users/1234/bio\");\n//=> { path: '/users/1234/bio', index: 0, params: { id: '1234', tab: 'bio' } }\n\nurlMatch(\"/users/1234/otherstuff\");\n//=> false\n```\n\n#### Process Pathname\n\nYou should make sure variations of the same path match the expected `path`. Here's one possible solution using `encode`:\n\n```js\nconst fn = match(\"/café\", { encode: encodeURI });\n\nfn(\"/caf%C3%A9\"); //=> { path: '/caf%C3%A9', index: 0, params: {} }\n```\n\n**Note:** [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) encodes paths, so `/café` would be normalized to `/caf%C3%A9` and match in the above example.\n\n##### Alternative Using Normalize\n\nSometimes you won't have already normalized paths to use, so you could normalize it yourself before matching:\n\n```js\n/**\n * Normalize a pathname for matching, replaces multiple slashes with a single\n * slash and normalizes unicode characters to \"NFC\". When using this method,\n * `decode` should be an identity function so you don't decode strings twice.\n */\nfunction normalizePathname(pathname: string) {\n  return (\n    decodeURI(pathname)\n      // Replaces repeated slashes in the URL.\n      .replace(/\\/+/g, \"/\")\n      // Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize\n      // Note: Missing native IE support, may want to skip this step.\n      .normalize()\n  );\n}\n\n// Two possible ways of writing `/café`:\nconst re = pathToRegexp(\"/caf\\u00E9\");\nconst input = encodeURI(\"/cafe\\u0301\");\n\nre.test(input); //=> false\nre.test(normalizePathname(input)); //=> true\n```\n\n### Parse\n\nThe `parse` function will return a list of strings and keys from a path string:\n\n```js\nconst tokens = parse(\"/route/:foo/(.*)\");\n\nconsole.log(tokens[0]);\n//=> \"/route\"\n\nconsole.log(tokens[1]);\n//=> { name: 'foo', prefix: '/', suffix: '', pattern: '[^\\\\/#\\\\?]+?', modifier: '' }\n\nconsole.log(tokens[2]);\n//=> { name: 0, prefix: '/', suffix: '', pattern: '.*', modifier: '' }\n```\n\n**Note:** This method only works with strings.\n\n### Compile (\"Reverse\" Path-To-RegExp)\n\nThe `compile` function will return a function for transforming parameters into a valid path:\n\n```js\n// Make sure you encode your path segments consistently.\nconst toPath = compile(\"/user/:id\", { encode: encodeURIComponent });\n\ntoPath({ id: 123 }); //=> \"/user/123\"\ntoPath({ id: \"café\" }); //=> \"/user/caf%C3%A9\"\ntoPath({ id: \"/\" }); //=> \"/user/%2F\"\n\ntoPath({ id: \":/\" }); //=> \"/user/%3A%2F\"\n\n// Without `encode`, you need to make sure inputs are encoded correctly.\nconst toPathRaw = compile(\"/user/:id\");\n\ntoPathRaw({ id: \"%3A%2F\" }); //=> \"/user/%3A%2F\"\ntoPathRaw({ id: \":/\" }, { validate: false }); //=> \"/user/:/\"\n\nconst toPathRepeated = compile(\"/:segment+\");\n\ntoPathRepeated({ segment: \"foo\" }); //=> \"/foo\"\ntoPathRepeated({ segment: [\"a\", \"b\", \"c\"] }); //=> \"/a/b/c\"\n\nconst toPathRegexp = compile(\"/user/:id(\\\\d+)\");\n\ntoPathRegexp({ id: 123 }); //=> \"/user/123\"\ntoPathRegexp({ id: \"123\" }); //=> \"/user/123\"\ntoPathRegexp({ id: \"abc\" }); //=> Throws `TypeError`.\ntoPathRegexp({ id: \"abc\" }, { validate: false }); //=> \"/user/abc\"\n```\n\n**Note:** The generated function will throw on invalid input.\n\n### Working with Tokens\n\nPath-To-RegExp exposes the two functions used internally that accept an array of tokens:\n\n- `tokensToRegexp(tokens, keys?, options?)` Transform an array of tokens into a matching regular expression.\n- `tokensToFunction(tokens)` Transform an array of tokens into a path generator function.\n\n#### Token Information\n\n- `name` The name of the token (`string` for named or `number` for unnamed index)\n- `prefix` The prefix string for the segment (e.g. `\"/\"`)\n- `suffix` The suffix string for the segment (e.g. `\"\"`)\n- `pattern` The RegExp used to match this token (`string`)\n- `modifier` The modifier character used for the segment (e.g. `?`)\n\n## Compatibility with Express <= 4.x\n\nPath-To-RegExp breaks compatibility with Express <= `4.x`:\n\n- RegExp special characters can only be used in a parameter\n  - Express.js 4.x supported `RegExp` special characters regardless of position - this is considered a bug\n- Parameters have suffixes that augment meaning - `*`, `+` and `?`. E.g. `/:user*`\n- No wildcard asterisk (`*`) - use parameters instead (`(.*)` or `:splat*`)\n\n## Live Demo\n\nYou can see a live demo of this library in use at [express-route-tester](http://forbeslindesay.github.io/express-route-tester/).\n\n## License\n\nMIT\n\n[npm-image]: https://img.shields.io/npm/v/path-to-regexp\n[npm-url]: https://npmjs.org/package/path-to-regexp\n[downloads-image]: https://img.shields.io/npm/dm/path-to-regexp\n[downloads-url]: https://npmjs.org/package/path-to-regexp\n[build-image]: https://img.shields.io/github/workflow/status/pillarjs/path-to-regexp/CI/master\n[build-url]: https://github.com/pillarjs/path-to-regexp/actions/workflows/ci.yml?query=branch%3Amaster\n[coverage-image]: https://img.shields.io/codecov/c/gh/pillarjs/path-to-regexp\n[coverage-url]: https://codecov.io/gh/pillarjs/path-to-regexp\n[license-image]: http://img.shields.io/npm/l/path-to-regexp.svg?style=flat\n[license-url]: LICENSE.md\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2014 Blake Embrey (hello@blakeembrey.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/path-to-regexp/-/path-to-regexp-6.2.1.tgz#d54934d6798eb9e5ef14e7af7962c945906918e5",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/path-to-regexp/-/path-to-regexp-6.2.1.tgz",
    "hash": "d54934d6798eb9e5ef14e7af7962c945906918e5",
    "integrity": "sha512-JLyh7xT1kizaEvcaXOQwOc2/Yhw6KZOvPf1S8401UyLk86CU79LN3vl7ztXGm/pZ+YjoyAJ4rxmHwbkBXJX+yw==",
    "registry": "npm",
    "packageName": "path-to-regexp",
    "cacheIntegrity": "sha512-JLyh7xT1kizaEvcaXOQwOc2/Yhw6KZOvPf1S8401UyLk86CU79LN3vl7ztXGm/pZ+YjoyAJ4rxmHwbkBXJX+yw== sha1-1Uk01nmOueXvFOeveWLJRZBpGOU="
  },
  "registry": "npm",
  "hash": "d54934d6798eb9e5ef14e7af7962c945906918e5"
}