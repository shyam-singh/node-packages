/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { guid, invariant, messages } from 'webruntime_navigation/utils';

/*
 * Provide eventing support for navigation events and navigation tree building.
 * Extended by Router.
 */

// Event fired when a component calls navigate().
const NAV_EVENT = `universalcontainernavigationevent${guid()}`;

// Internal event fired to find nearest ancestor.
const PARENT_EVENT = `universalcontainerparentevent${guid()}`;

export default class NavNode {
    // DOM node to which this is attached.
    node = window;

    // A reference to this node's parent and child.
    parent = null;
    child = null;

    // Event name(s).
    static navigationEvent = NAV_EVENT;

    /**
     * Merge properties and create NavNode.
     *
     * @param {HTMLElement} node - DOM node to attach to
     */
    constructor(node = window) {
        // The node property is locked in during construction.
        Object.assign(this, { node });
    }

    /**
     * Return the properties and methods that define this node as a navigation context provider.
     * This function is expected to be overridden by extender classes.
     */
    get context() {
        return this;
    }

    /**
     * Create a function which calls the given fcn, with extra parameters (...rest).
     * If fcn does not exist, use a fallback.
     *
     * @param {function} fcn - Function to transform
     * @param {function} fallbackFcn - Function to use as a fallback
     * @param  {...any} rest - Additional arguments to pass to the new function
     */
    _fallback(fcn, fallbackFcn, ...rest) {
        return fcn
            ? (...args) => {
                  return fcn(...args, ...rest);
              }
            : fallbackFcn;
    }

    /***** Set up and tear down event listeners *****/

    /**
     * Fire an event to find the nearest ancestor NavNode.
     * Add the NavNode as this one's parent.
     * Add this one as the NavNode's child.
     */
    connectToParent() {
        this.node.dispatchEvent(
            new CustomEvent(PARENT_EVENT, {
                bubbles: true,
                composed: true,
                detail: parent => {
                    this.parent = parent;
                    parent.addChild(this);
                },
            })
        );
    }

    /**
     * Add the given node as a child to this node, if it doesn't already have one.
     * The Error prevents sibling nodes from being added under this node.
     *
     * @param {NavNode} child
     */
    addChild(child) {
        // Temp fix for https://github.com/salesforce/lwc/issues/1894
        /* eslint-disable-next-line */
        setTimeout(() => {
            invariant(!this.child, messages.MULTIPLE_CHILDREN);
            this.child = child;
        }, 0);
    }

    /**
     * Connect this node to the tree hierarchy and eventing.
     */
    connect() {
        // Connect this node as a child to its closest ancestor.
        this.connectToParent();

        // Add listeners for parent discovery and navigation events.
        this.handleParentEvent = this._handleParentEvent.bind(this);
        this.handleNavEvent = this._handleEvent.bind(this);
        this.node.addEventListener(PARENT_EVENT, this.handleParentEvent);
        this.node.addEventListener(NavNode.navigationEvent, this.handleNavEvent);
    }

    /**
     * Disconnect this node to the tree hierarchy and eventing.
     */
    disconnect() {
        // Remove event listeners.
        this.node.removeEventListener(PARENT_EVENT, this.handleParentEvent);
        this.node.removeEventListener(NavNode.navigationEvent, this.handleNavEvent);

        // Detach from parent.
        if (this.parent) {
            this.parent.child = null;
        }
        this.parent = null;

        // Detach from child.
        if (this.child) {
            this.child.parent = null;
        }
        this.child = null;
    }

    /***** Tree pointer info *****/

    /**
     * This node is the root if it does not have a parent.
     *
     * @returns {boolean}
     */
    get isRoot() {
        return !this.parent;
    }

    /**
     * Search up the node chain until the root node is hit.
     *
     * @returns {NavNode}
     */
    get root() {
        let maybe = this;
        while (!maybe.isRoot) {
            maybe = maybe.parent;
        }
        return maybe;
    }

    /***** Navigation and parent location event handlers *****/

    /**
     * Be discovered as a parent for descendent components.
     * Stop immediate propagation because we only want 1 parent to be found.
     *
     * @param {Event} event - With detail: callback
     */
    _handleParentEvent(event) {
        event.stopImmediatePropagation();
        if (event && event.detail) {
            event.detail(this);
        }
    }

    /**
     * Inspect a navigation event bubbling up from a descendent component.
     * This node can choose to stop the event by returning false.
     * If propagation is not stopped, and this node is the root (no parent),
     *      then begin the root -> leaf processing of this new route.
     *      This will update the navigation event subscribers in each NavNode, top down.
     *
     * @param {Event} event - With detail: { url, options }
     */
    _handleEvent(event) {
        const { url, options, input } = event.detail;
        if (!this.handleEvent(input, options)) {
            event.stopPropagation();
        } else if (this.isRoot) {
            this.process(url, options);
        }
    }

    /**
     * A hook for when an event is bubbling up through this node.
     * Return false if propagation of the event should be stopped.
     * This default implementation is a no-op.
     *
     * @returns {boolean}
     */
    handleEvent() {
        return true;
    }

    /**
     * The work a node needs to do during an "event".
     * This default implementation is a no-op.
     *
     * @returns {boolean}
     */
    process() {
        return true;
    }
}
