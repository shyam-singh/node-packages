{
  "manifest": {
    "name": "applicationinsights",
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/microsoft/ApplicationInsights-node.js/issues"
    },
    "version": "1.8.10",
    "description": "Microsoft Application Insights module for Node.js",
    "repository": {
      "type": "git",
      "url": "https://github.com/microsoft/ApplicationInsights-node.js"
    },
    "main": "./out/applicationinsights.js",
    "types": "./out/applicationinsights.d.ts",
    "keywords": [
      "exception monitoring",
      "request monitoring",
      "performance monitoring",
      "application insights",
      "microsoft",
      "azure",
      "cloud",
      "tracing",
      "telemetry",
      "analytics",
      "apm"
    ],
    "contributors": [
      {
        "name": "Application Insights Developer Support",
        "email": "aidevsupport@microsoft.com"
      },
      {
        "name": "Application Insights SDK Maintainers",
        "email": "appinsightssdk@microsoft.com"
      }
    ],
    "scripts": {
      "clean": "rm -rf ./out && rm -rf ./node_modules",
      "build": "npm run build:deps && npm run build:compile",
      "build:deps": "npm update --dev",
      "build:compile": "tsc --project ./tsconfig.json",
      "prepare": "npm run build:compile",
      "prepublishOnly": "npm run build",
      "pretest": "npm run build",
      "test": "npm run test:ts && npm run test:js",
      "test:debug": "mocha ./out/Tests --inspect-brk --recursive --no-exit",
      "test:ts": "mocha ./out/Tests --recursive --no-exit",
      "test:js": "mocha ./Tests/js --recursive --no-exit",
      "functionaltest": "npm run build && npm pack && node --use_strict ./Tests/FunctionalTests/RunFunctionalTests.js",
      "backcompattest": "npm run build && npm pack && node --use_strict ./Tests/BackCompatibility/RunBackCompatTests.js"
    },
    "devDependencies": {
      "@types/cls-hooked": "^4.3.3",
      "@types/mocha": "2.2.48",
      "@types/node": "4.2.4",
      "@types/sinon": "2.1.2",
      "applicationinsights-native-metrics": "0.0.5",
      "mocha": "3.5.2",
      "node-mocks-http": "1.2.3",
      "sinon": "1.17.6",
      "typescript": "2.4.2"
    },
    "dependencies": {
      "cls-hooked": "^4.2.2",
      "continuation-local-storage": "^3.2.1",
      "diagnostic-channel": "0.3.1",
      "diagnostic-channel-publishers": "0.4.4"
    },
    "_registry": "npm",
    "_loc": "C:\\Users\\csmku\\AppData\\Local\\sf\\yarn\\v6\\npm-applicationinsights-1.8.10-fffa482cd1519880fb888536a87081ac05130667-integrity\\node_modules\\applicationinsights\\package.json",
    "readmeFilename": "README.md",
    "readme": "# Application Insights for Node.js\n\n[![npm version](https://badge.fury.io/js/applicationinsights.svg)](http://badge.fury.io/js/applicationinsights)\n[![Build Status](https://travis-ci.org/Microsoft/ApplicationInsights-node.js.svg?branch=master)](https://travis-ci.org/Microsoft/ApplicationInsights-node.js)\n![Integration Tests CI](https://github.com/microsoft/ApplicationInsights-node.js/workflows/Integration%20Tests%20CI/badge.svg)\n![Node.js CI](https://github.com/microsoft/ApplicationInsights-node.js/workflows/Node.js%20CI/badge.svg)\n![Back Compatability CI](https://github.com/microsoft/ApplicationInsights-node.js/workflows/Back%20Compatability%20CI/badge.svg)\n\n[Azure Application Insights][] monitors your backend services and components after\nyou deploy them to help you [discover and rapidly diagnose performance and other\nissues][]. Add this SDK to your Node.js services to include deep info about Node.js\nprocesses and their external dependencies such as database and cache services.\nYou can use this SDK for your Node.js services hosted anywhere: your datacenter,\nAzure VMs and Web Apps, and even other public clouds.\n\n[Azure Application Insights]: https://azure.microsoft.com/documentation/articles/app-insights-overview/\n[discover and rapidly diagnose performance and other issues]: https://docs.microsoft.com/azure/application-insights/app-insights-detect-triage-diagnose\n\nThis library tracks the following out-of-the-box:\n- Incoming and outgoing HTTP requests\n- Important system metrics such as CPU usage\n- Unhandled exceptions\n- Events from many popular third-party libraries ([see Automatic third-party instrumentation](#automatic-third-party-instrumentation))\n\nYou can manually track more aspects of your app and system using the API described in the\n[Track custom telemetry](#track-custom-telemetry) section.\n\n## Getting Started\n\n1. Create an Application Insights resource in Azure by following [these instructions][].\n2. Grab the _Instrumentation Key_ (aka \"ikey\") from the resource you created in\n   step 1. Later, you'll either add it to your app's environment variables or\n   use it directly in your scripts.\n3. Add the Application Insights Node.js SDK to your app's dependencies and\n   package.json:\n     ```bash\n     npm install --save applicationinsights\n     ```\n     > *Note:* If you're using TypeScript, do not install a separate \"typings\" package.\n     > This NPM package contains built-in typings.\n4. As early as possible in your app's code, load the Application Insights\n   package:\n     ```javascript\n     let appInsights = require('applicationinsights');\n     ```\n5. Configure the local SDK by calling `appInsights.setup('_your_ikey_');`, using\n   the ikey you grabbed in step 2. Or put this ikey in the\n   `APPINSIGHTS_INSTRUMENTATIONKEY` environment variable and call\n   `appInsights.setup()` without parameters.\n   > For more configuration options see below.\n6. Finally, start automatically collecting and sending data by calling\n   `appInsights.start();`.\n\n[these instructions]: https://docs.microsoft.com/azure/application-insights/app-insights-nodejs\n\n\n## Basic Usage\n\n> *Important:* `applicationinsights` must be setup *and* started *before* you import anything else. There may be resulting telemetry loss if other libraries are imported first.\n\nFor out-of-the-box collection of HTTP requests, popular third-party library events,\nunhandled exceptions, and system metrics:\n\n```javascript\nlet appInsights = require(\"applicationinsights\");\nappInsights.setup(\"_your_ikey_\").start();\n```\n\n* If the instrumentation key is set in the environment variable\n  APPINSIGHTS\\_INSTRUMENTATIONKEY, `.setup()` can be called with no\n  arguments. This makes it easy to use different ikeys for different\n  environments.\n\nLoad the Application Insights library (i.e. `require(\"applicationinsights\")`) as\nearly as possible in your scripts, before loading other packages. This is needed\nso that the Application Insights library can prepare later packages for tracking.\nIf you encounter conflicts with other libraries doing similar preparation, try\nloading the Application Insights library after those.\n\nBecause of the way JavaScript handles callbacks, additional work is necessary to\ntrack a request across external dependencies and later callbacks. By default\nthis additional tracking is enabled; disable it by calling\n`setAutoDependencyCorrelation(false)` as described in the\nConfiguration section below.\n\n## Azure Functions\n\nDue to how Azure Functions (and other FaaS services) handle incoming requests, they are not seen as `http` requests to the Node.js runtime. For this reason, Request -> Dependency correlelation will **not** work out of the box.\nTo enable tracking here, you simply need to grab the context from your Function request handler, and wrap your Function with that context.\n\n### Setting up Auto-Correlation for Azure Functions\n\nYou do not need to make any changes to your existing Function logic.\nInstead, you can update the `default` export of your `httpTrigger` to be wrapped with some Application Insights logic:\n\n```js\n...\n\n// Default export wrapped with Application Insights FaaS context propagation\nexport default async function contextPropagatingHttpTrigger(context, req) {\n    // Start an AI Correlation Context using the provided Function context\n    const correlationContext = appInsights.startOperation(context, req);\n\n    // Wrap the Function runtime with correlationContext\n    return appInsights.wrapWithCorrelationContext(async () => {\n        const startTime = Date.now(); // Start trackRequest timer\n\n        // Run the Function\n        await httpTrigger(context, req);\n\n        // Track Request on completion\n        appInsights.defaultClient.trackRequest({\n            name: context.req.method + \" \" + context.req.url,\n            resultCode: context.res.status,\n            success: true,\n            url: req.url,\n            duration: Date.now() - startTime,\n            id: correlationContext.operation.parentId,\n        });\n        appInsights.defaultClient.flush();\n    }, correlationContext)();\n};\n```\n\n### Azure Functions Example\n\nAn example of making an `axios` call to <https://httpbin.org> and returning the reponse.\n\n```js\nconst appInsights = require(\"applicationinsights\");\nappInsights.setup(\"ikey\")\n    .setAutoCollectPerformance(false)\n    .start();\n\nconst axios = require(\"axios\");\n\n/**\n * No changes required to your existing Function logic\n */\nconst httpTrigger = async function (context, req) {\n    const response = await axios.get(\"https://httpbin.org/status/200\");\n\n    context.res = {\n        status: response.status,\n        body: response.statusText,\n    };\n};\n\n// Default export wrapped with Application Insights FaaS context propagation\nexport default async function contextPropagatingHttpTrigger(context, req) {\n    // Start an AI Correlation Context using the provided Function context\n    const correlationContext = appInsights.startOperation(context, req);\n\n    // Wrap the Function runtime with correlationContext\n    return appInsights.wrapWithCorrelationContext(async () => {\n        const startTime = Date.now(); // Start trackRequest timer\n\n        // Run the Function\n        await httpTrigger(context, req);\n\n        // Track Request on completion\n        appInsights.defaultClient.trackRequest({\n            name: context.req.method + \" \" + context.req.url,\n            resultCode: context.res.status,\n            success: true,\n            url: req.url,\n            duration: Date.now() - startTime,\n            id: correlationContext.operation.parentId,\n        });\n        appInsights.defaultClient.flush();\n    }, correlationContext)();\n};\n```\n\n## Configuration\n\nThe appInsights object provides a number of configuration methods. They are\nlisted in the following snippet with their default values.\n\n```javascript\nlet appInsights = require(\"applicationinsights\");\nappInsights.setup(\"<instrumentation_key>\")\n    .setAutoDependencyCorrelation(true)\n    .setAutoCollectRequests(true)\n    .setAutoCollectPerformance(true, true)\n    .setAutoCollectExceptions(true)\n    .setAutoCollectDependencies(true)\n    .setAutoCollectConsole(true)\n    .setUseDiskRetryCaching(true)\n    .setSendLiveMetrics(false)\n    .setDistributedTracingMode(appInsights.DistributedTracingModes.AI_AND_W3C)\n    .start();\n```\n\nPlease review their descriptions in your IDE's built-in type hinting, or [applicationinsights.ts](https://github.com/microsoft/ApplicationInsights-node.js/tree/develop/applicationinsights.ts) for\ndetailed information on what these control, and optional secondary arguments.\n\nNote that by default `setAutoCollectConsole` is configured to *exclude* calls to `console.log`\n(and other `console` methods). By default, only calls to supported third-party loggers\n(e.g. `winston`, `bunyan`) will be collected. You can change this behavior to *include* calls\nto `console` methods by using `setAutoCollectConsole(true, true)`.\n\n### Sampling\n\nBy default, the SDK will send all collected data to the Application Insights service. If you collect a lot of data, you might want to enable sampling to reduce the amount of data sent. Set the `samplingPercentage` field on the Config object of a Client to accomplish this. Setting `samplingPercentage` to 100 (the default) means all data will be sent, and 0 means nothing will be sent.\n\nIf you are using automatic correlation, all data associated with a single request will be included or excluded as a unit.\n\nAdd code such as the following to enable sampling:\n\n```javascript\nconst appInsights = require(\"applicationinsights\");\nappInsights.setup(\"<instrumentation_key>\");\nappInsights.defaultClient.config.samplingPercentage = 33; // 33% of all telemetry will be sent to Application Insights\nappInsights.start();\n```\n\n### Multiple roles for multi-component applications\n\nIf your application consists of multiple components that you wish to instrument all with the same Instrumentation Key and still see these components as separate units in the Portal as if they were using separate Instrumentation Keys (for example, as separate nodes on the Application Map) you may need to manually configure the RoleName field to distinguish one component's telemetry from other components sending data to your Application Insights resource. (See [Monitor multi-component applications with Application Insights (preview)](https://docs.microsoft.com/azure/application-insights/app-insights-monitor-multi-role-apps))\n\nUse the following to set the RoleName field:\n\n```javascript\nconst appInsights = require(\"applicationinsights\");\nappInsights.setup(\"<instrumentation_key>\");\nappInsights.defaultClient.context.tags[appInsights.defaultClient.context.keys.cloudRole] = \"MyRoleName\";\nappInsights.start();\n```\n\nIf running in Azure App service or Azure functions the SDK will automatically populate the cloud role when following code is added:\n```javascript\nconst appInsights = require(\"applicationinsights\");\nappInsights.setup(\"<instrumentation_key>\");\nappInsights.defaultClient.setAutoPopulateAzureProperties(true);\nappInsights.start();\n```\n\n\n### Automatic third-party instrumentation\n\nIn order to track context across asynchronous calls, some changes are required in third party libraries such as mongodb and redis.\nBy default ApplicationInsights will use [`diagnostic-channel-publishers`](https://github.com/microsoft/node-diagnostic-channel/tree/master/src/diagnostic-channel-publishers)\nto monkey-patch some of these libraries.\nThis can be disabled by setting the `APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL` environment variable. Note that by setting that\nenvironment variable, events may no longer be correctly associated with the right operation. Individual monkey-patches can be\ndisabled by setting the `APPLICATION_INSIGHTS_NO_PATCH_MODULES` environment variable to a comma separated list of packages to\ndisable, e.g. `APPLICATION_INSIGHTS_NO_PATCH_MODULES=console,redis` to avoid patching the `console` and `redis` packages.\n\nCurrently there are 9 packages which are instrumented: `bunyan`, `console`, `mongodb`, `mongodb-core`, `mysql`, `redis`, `winston`,\n`pg`, and `pg-pool`. Visit the [diagnostic-channel-publishers' README](https://github.com/microsoft/node-diagnostic-channel/blob/master/src/diagnostic-channel-publishers/README.md)\nfor information about exactly which versions of these packages are patched.\n\nThe `bunyan`, `winston`, and `console` patches will generate Application Insights Trace events based on whether `setAutoCollectConsole` is enabled.\nThe rest will generate Application Insights Dependency events based on whether `setAutoCollectDependencies` is enabled. Make sure that `applicationinsights` is imported **before** any 3rd-party packages for them to be instrumented successfully.\n\nAutomatic instrumentation for several Azure SDKs is also available, you must manually install @opentelemetry/tracing to enable this automatic tracing. No additional configuration is required\nCurrently Cognitive Search, Communication Common and Cosmos DB SDKs are not supported.\n[Javascript Azure SDKs](https://azure.github.io/azure-sdk/releases/latest/index.html#javascript)\n\n\n### Live Metrics\nTo enable sending live metrics of your app to Azure, use `setSendLiveMetrics(true)`. Filtering of live metrics in the Portal is currently not supported.\n\n### Extended Metrics\n>***Note:*** The ability to send extended native metrics was added in version `1.4.0`\n\nTo enable sending extended native metrics of your app to Azure, simply install the separate native metrics package. The SDK will automatically load it when it is installed and start collecting Node.js native metrics.\n```zsh\nnpm install applicationinsights-native-metrics\n```\nCurrently, the native metrics package performs autocollection of Garbage Collection CPU time, Event Loop ticks, and heap usage:\n- **Garbage Collection:** The amount of CPU time spent on each type of garbage collection, and how many occurrences of each type.\n- **Event Loop:** How many ticks occurred and how much CPU time was spent in total.\n- **Heap vs Non-Heap:** How much of your app's memory usage is in the heap or non-heap.\n\n### Distributed Tracing Modes\nBy default, this SDK will send headers understood by other applications/services instrumented with an Application Insights SDK. You can optionally enable sending/receiving of [W3C Trace Context](https://github.com/w3c/trace-context) headers in addition to the existing AI headers, so you will not break correlation with any of your existing legacy services. Enabling W3C headers will allow your app to correlate with other services not instrumented with Application Insights, but do adopt this W3C standard.\n\n```js\nconst appInsights = require(\"applicationinsights\");\nappInsights\n  .setup(\"<your ikey>\")\n  .setDistributedTracingMode(appInsights.DistributedTracingModes.AI_AND_W3C)\n  .start()\n```\n\n## Track custom telemetry\n\nYou can track any request, event, metric or exception using the Application\nInsights client. Examples follow:\n\n```javascript\nlet appInsights = require(\"applicationinsights\");\nappInsights.setup().start(); // assuming ikey in env var. start() can be omitted to disable any non-custom data\nlet client = appInsights.defaultClient;\nclient.trackEvent({name: \"my custom event\", properties: {customProperty: \"custom property value\"}});\nclient.trackException({exception: new Error(\"handled exceptions can be logged with this method\")});\nclient.trackMetric({name: \"custom metric\", value: 3});\nclient.trackTrace({message: \"trace message\"});\nclient.trackDependency({target:\"http://dbname\", name:\"select customers proc\", data:\"SELECT * FROM Customers\", duration:231, resultCode:0, success: true, dependencyTypeName: \"ZSQL\"});\nclient.trackRequest({name:\"GET /customers\", url:\"http://myserver/customers\", duration:309, resultCode:200, success:true});\n\nlet http = require(\"http\");\nhttp.createServer( (req, res) => {\n  client.trackNodeHttpRequest({request: req, response: res}); // Place at the beginning of your request handler\n});\n```\n\nNote that custom properties are converted to their string representation before being sent, see [Using properties](https://docs.microsoft.com/azure/azure-monitor/app/api-custom-events-metrics#properties) for more information.\n\nAn example utility using `trackMetric` to measure how long event loop scheduling takes:\n\n```javascript\nfunction startMeasuringEventLoop() {\n  var startTime = process.hrtime();\n  var sampleSum = 0;\n  var sampleCount = 0;\n\n  // Measure event loop scheduling delay\n  setInterval(() => {\n    var elapsed = process.hrtime(startTime);\n    startTime = process.hrtime();\n    sampleSum += elapsed[0] * 1e9 + elapsed[1];\n    sampleCount++;\n  }, 0);\n\n  // Report custom metric every second\n  setInterval(() => {\n    var samples = sampleSum;\n    var count = sampleCount;\n    sampleSum = 0;\n    sampleCount = 0;\n\n    if (count > 0) {\n      var avgNs = samples / count;\n      var avgMs = Math.round(avgNs / 1e6);\n      client.trackMetric({name: \"Event Loop Delay\", value: avgMs});\n    }\n  }, 1000);\n}\n```\n\n## Preprocess data with Telemetry Processors\n\n```javascript\npublic addTelemetryProcessor(telemetryProcessor: (envelope: Contracts.Envelope, context: { http.RequestOptions, http.ClientRequest, http.ClientResponse, correlationContext }) => boolean)\n```\n\nYou can process and filter collected data before it is sent for retention using\n_Telemetry Processors_. Telemetry processors are called one by one in the\norder they were added before the telemetry item is sent to the cloud.\n\nIf a telemetry processor returns false that telemetry item will not be sent.\n\nAll telemetry processors receive the telemetry data and its envelope to inspect and\nmodify. They also receive a context object. The contents of this object is defined by\nthe `contextObjects` parameter when calling a track method for manually tracked telemetry.\nFor automatically collected telemetry, this object is filled with available request information\nand the persistent request context as provided by `appInsights.getCorrelationContext()` (if\nautomatic dependency correlation is enabled).\n\nThe TypeScript type for a telemetry processor is:\n\n```typescript\ntelemetryProcessor: (envelope: ContractsModule.Contracts.Envelope, context: { http.RequestOptions, http.ClientRequest, http.ClientResponse, correlationContext }) => boolean;\n```\n\nFor example, a processor that removes stack trace data from exceptions might be\nwritten and added as follows:\n\n```javascript\nfunction removeStackTraces ( envelope, context ) {\n  if (envelope.data.baseType === \"ExceptionData\") {\n    var data = envelope.data.baseData;\n    if (data.exceptions && data.exceptions.length > 0) {\n      for (var i = 0; i < data.exceptions.length; i++) {\n        var exception = data.exceptions[i];\n        exception.parsedStack = null;\n        exception.hasFullStack = false;\n      }\n    }\n  }\n  return true;\n}\n\nappInsights.defaultClient.addTelemetryProcessor(removeStackTraces);\n```\n\nMore info on the telemetry API is available in [the docs][].\n\n[the docs]: https://azure.microsoft.com/documentation/articles/app-insights-api-custom-events-metrics/\n\n## Use multiple instrumentation keys\n\nYou can create multiple Azure Application Insights resources and send different\ndata to each by using their respective instrumentation keys (\"ikey\"). For\nexample:\n\n```javascript\nlet appInsights = require(\"applicationinsights\");\n\n// configure auto-collection under one ikey\nappInsights.setup(\"_ikey-A_\").start();\n\n// track some events manually under another ikey\nlet otherClient = new appInsights.TelemetryClient(\"_ikey-B_\");\notherClient.trackEvent({name: \"my custom event\"});\n```\n\n## Examples\n\n* Track dependencies\n\n    ```javascript\n    let appInsights = require(\"applicationinsights\");\n    let client = new appInsights.TelemetryClient();\n\n    var success = false;\n    let startTime = Date.now();\n    // execute dependency call here....\n    let duration = Date.now() - startTime;\n    success = true;\n\n    client.trackDependency({target:\"http://dbname\", name:\"select customers proc\", data:\"SELECT * FROM Customers\", duration:duration, resultCode:0, success: true, dependencyTypeName: \"ZSQL\"});\n    ```\n\n* Assign custom properties to be included with all events\n\n    ```javascript\n    appInsights.defaultClient.commonProperties = {\n      environment: process.env.SOME_ENV_VARIABLE\n    };\n    ```\n\n* Manually track all HTTP GET requests\n\n    Note that all requests are tracked by default. To disable automatic\n    collection, call `.setAutoCollectRequests(false)` before calling `start()`.\n\n    ```javascript\n    appInsights.defaultClient.trackRequest({name:\"GET /customers\", url:\"http://myserver/customers\", duration:309, resultCode:200, success:true});\n    ```\n    Alternatively you can track requests using ```trackNodeHttpRequest``` method:\n\n    ```javascript\n    var server = http.createServer((req, res) => {\n      if ( req.method === \"GET\" ) {\n          appInsights.defaultClient.trackNodeHttpRequest({request:req, response:res});\n      }\n      // other work here....\n      res.end();\n    });\n    ```\n\n* Track server startup time\n\n    ```javascript\n    let start = Date.now();\n    server.on(\"listening\", () => {\n      let duration = Date.now() - start;\n      appInsights.defaultClient.trackMetric({name: \"server startup time\", value: duration});\n    });\n    ```\n\n## Advanced configuration options\nThe Client object contains a `config` property with many optional settings for\nadvanced scenarios. These can be set as follows:\n```\nclient.config.PROPERTYNAME = VALUE;\n```\nThese properties are client specific, so you can configure `appInsights.defaultClient`\nseparately from clients created with `new appInsights.TelemetryClient()`.\n\n| Property                        | Description                                                                                                |\n| ------------------------------- |------------------------------------------------------------------------------------------------------------|\n| instrumentationKey              | An identifier for your Application Insights resource                                                       |\n| endpointUrl                     | The ingestion endpoint to send telemetry payloads to                                                       |\n| quickPulseHost                  | The Live Metrics Stream host to send live metrics telemetry to                                             |\n| proxyHttpUrl                    | A proxy server for SDK HTTP traffic (Optional, Default pulled from `http_proxy` environment variable)      |\n| proxyHttpsUrl                   | A proxy server for SDK HTTPS traffic (Optional, Default pulled from `https_proxy` environment variable)    |\n| httpAgent                       | An http.Agent to use for SDK HTTP traffic (Optional, Default undefined)                                    |\n| httpsAgent                      | An https.Agent to use for SDK HTTPS traffic (Optional, Default undefined)                                  |\n| maxBatchSize                    | The maximum number of telemetry items to include in a payload to the ingestion endpoint (Default `250`)    |\n| maxBatchIntervalMs              | The maximum amount of time to wait to for a payload to reach maxBatchSize (Default `15000`)                |\n| disableAppInsights              | A flag indicating if telemetry transmission is disabled (Default `false`)                                  |\n| samplingPercentage              | The percentage of telemetry items tracked that should be transmitted (Default `100`)                       |\n| correlationIdRetryIntervalMs    | The time to wait before retrying to retrieve the id for cross-component correlation (Default `30000`)      |\n| correlationHeaderExcludedDomains| A list of domains to exclude from cross-component correlation header injection (Default See [Config.ts][]) |\n\n[Config.ts]: https://github.com/microsoft/ApplicationInsights-node.js/blob/develop/Library/Config.ts\n\n## Migrating to [`applicationinsights@2.0.0`](https://github.com/microsoft/ApplicationInsights-node.js/tree/applicationinsights%402.0.0) (Beta)\n\nAn experimental / beta version of the SDK is also available, but not recommended for production. It is built on top of the [OpenTelemetry SDK + APIs](http://github.com/open-telemetry/opentelemetry-js), while keeping the API surface of this SDK the same.\n\n```zsh\nnpm install applicationinsights@beta\n```\n\n### `applicationinsights@2.0.0` Overview\n\n- Autocollection parity with `applicationinsights@1.x`\n- API parity with `applicationinsights@1.x`\n- \"Getting Started\" parity with `applicationinsights@1.x`\n- New autocollection scenarios out-of-the-box contribued by the [OpenTelemetry community](https://github.com/open-telemetry/opentelemetry-js#node-plugins), e.g. `gRPC`, `express`, `ioredis`\n- Built on top of an [Open Standard](https://github.com/open-telemetry/opentelemetry-specification) for Telemetry APIs and SDKs\n\nMigrating from `1.x` to `2.x` is meant to be seamless and straightforward, there should be no breaking API changes at all. Please file a bug if something doesn't look right to you!\n\nIncluded in `applicationinsights@2.0.0` is [every Node.js Plugin available in the default OpenTelemetry Node.js SDK](https://github.com/open-telemetry/opentelemetry-js#node-plugins). Please check out the [projects board](https://github.com/microsoft/ApplicationInsights-node.js/projects) for progress updates on `2.x`.\n\n## Branches\n\n- Ongoing development takes place on the [develop][] branch. **Please submit\n  pull requests to this branch.**\n- Releases are merged to the [master][] branch and published to [npm][].\n\n[master]: https://github.com/microsoft/ApplicationInsights-node.js/tree/master\n[develop]: https://github.com/microsoft/ApplicationInsights-node.js/tree/develop\n[npm]: https://www.npmjs.com/package/applicationinsights\n\n## Contributing\n\n1. Install all dependencies with `npm install`.\n2. Set an environment variable to your instrumentation key (optional).\n    ```bash\n    // windows\n    set APPINSIGHTS_INSTRUMENTATIONKEY=<insert_your_instrumentation_key_here>\n    // linux/macos\n    export APPINSIGHTS_INSTRUMENTATIONKEY=<insert_your_instrumentation_key_here>\n    ```\n3. Run tests\n    ```bash\n    npm run test\n    npm run backcompattest\n    npm run functionaltest\n    ```\n    _Note: Functional tests require Docker_\n\n---\n\nThis project has adopted the [Microsoft Open Source Code of Conduct][]. For more\ninformation see the [Code of Conduct FAQ][] or contact\n[opencode@microsoft.com][] with any additional questions or comments.\n\n[Microsoft Open Source Code of Conduct]: https://opensource.microsoft.com/codeofconduct/\n[Code of Conduct FAQ]: https://opensource.microsoft.com/codeofconduct/faq/\n[opencode@microsoft.com]: mailto:opencode@microsoft.com\n",
    "licenseText": "﻿The MIT License (MIT) \nCopyright © Microsoft Corporation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/applicationinsights/-/applicationinsights-1.8.10.tgz#fffa482cd1519880fb888536a87081ac05130667",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/applicationinsights/-/applicationinsights-1.8.10.tgz",
    "hash": "fffa482cd1519880fb888536a87081ac05130667",
    "integrity": "sha512-ZLDA7mShh4mP2Z/HlFolmvhBPX1LfnbIWXrselyYVA7EKjHhri1fZzpu2EiWAmfbRxNBY6fRjoPJWbx5giKy4A==",
    "registry": "npm",
    "packageName": "applicationinsights",
    "cacheIntegrity": "sha512-ZLDA7mShh4mP2Z/HlFolmvhBPX1LfnbIWXrselyYVA7EKjHhri1fZzpu2EiWAmfbRxNBY6fRjoPJWbx5giKy4A== sha1-//pILNFRmID7iIU2qHCBrAUTBmc="
  },
  "registry": "npm",
  "hash": "fffa482cd1519880fb888536a87081ac05130667"
}