"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("@webruntime/api");
const common_1 = require("@communities-webruntime/common");
const compiler_1 = require("@webruntime/compiler");
const metadata_service_1 = require("../metadata/metadata-service");
const view_template_generator_1 = require("../views/view-template-generator");
const context_service_1 = require("../context/context-service");
const { getContext } = context_service_1.ContextService;
const uri = `/view/:uid/:mode/:locale/:name`;
/**
 * Addressable service responsible for generating view modules
 * from the Communities template metadata
 */
class ViewService extends api_1.AddressableService {
    get mappings() {
        return metadata_service_1.MetadataService.getAllViews().reduce((m, view) => {
            return {
                ...m,
                [common_1.getViewModuleSpecifier(view.devName)]: `/view/:uid/:mode/:locale/${view.devName}`,
            };
        }, {});
    }
    constructor() {
        super(uri);
    }
    initialize() {
        // noop
    }
    async request(specifier, pivots, { compilerConfig }) {
        var _a, _b;
        const [namespace, devName] = specifier.split('/');
        // get the view metadata
        const view = metadata_service_1.MetadataService.getAllViews().filter(v => v.devName === devName)[0];
        if (!view) {
            return {
                type: api_1.RequestOutputTypes.JSON,
                specifier,
                success: false,
                diagnostics: [
                    {
                        code: 'COMM-0002',
                        message: `Cannot find view '${devName}'`,
                        level: 0,
                    },
                ],
            };
        }
        const files = generateViewFiles(view);
        const config = {
            ...compilerConfig,
            input: `./view/${devName}/${devName}.js`,
            namespace,
            name: devName,
            files,
        };
        const moduleDef = await compiler_1.compile(config);
        return {
            type: api_1.RequestOutputTypes.COMPONENT,
            specifier,
            resource: moduleDef.result,
            metadata: {
                dependencies: ((_a = moduleDef.metadata) === null || _a === void 0 ? void 0 : _a.dependencies) || [],
                dynamicImports: ((_b = moduleDef.metadata) === null || _b === void 0 ? void 0 : _b.dynamicImports) || [],
            },
            success: moduleDef.success,
            diagnostics: moduleDef.diagnostics,
        };
    }
    toSpecifier(url) {
        const { name } = this.parseUrl(url);
        return common_1.getViewModuleSpecifier(name);
    }
}
exports.ViewService = ViewService;
function generateViewFiles({ devName, component, themeLayoutType }) {
    const { isDesignMode } = getContext();
    // generate a template HTML based on the view metadata
    const { html: generatedTemplate, attributes } = view_template_generator_1.template(component, !themeLayoutType, isDesignMode);
    const generatedJavascript = view_template_generator_1.javascript(devName, attributes);
    // pass the generated javascript and HTML as virtual modules to the compiler
    return {
        [`./view/${devName}/${devName}.js`]: generatedJavascript,
        [`./view/${devName}/${devName}.html`]: generatedTemplate,
    };
}
//# sourceMappingURL=view-service.js.map