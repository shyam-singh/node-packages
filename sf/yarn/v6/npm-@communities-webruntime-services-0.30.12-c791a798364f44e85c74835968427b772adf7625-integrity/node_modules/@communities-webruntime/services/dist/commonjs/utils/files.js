"use strict";
/** @hidden */
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const compiler_1 = require("@webruntime/compiler");
const context_service_1 = require("../context/context-service");
const fs = __importStar(require("../utils/filesystem"));
const { getContext } = context_service_1.ContextService;
const cache = new compiler_1.LoadingCache();
/**
 * Reads a file synchronously, caching it for
 * the current value of the `versionKey`.
 *
 * @param {*} path The path of the file to read
 * @returns The file content
 */
function readFile(path) {
    const { versionKey } = getContext();
    try {
        return cache.get(`${path}@${versionKey}`, () => {
            return fs.readFileSync(path, 'utf8');
        });
    }
    catch (_a) {
        throw new Error(`Failed to read file: ${path}`);
    }
}
/**
 * Reads a JSON file synchronously, caching it for
 * the current value of the `versionKey`.
 *
 * @param {*} path The path of the file to read.
 * @returns The file content as a JSON object
 */
function readJsonFile(path) {
    return JSON.parse(readFile(path));
}
exports.readJsonFile = readJsonFile;
/**
 * Reads a folder's content synchronously, caching it for
 * the current value of the `versionKey`.
 *
 * @param {*} path The path of the folder to read.
 * @param {*} extension The extension of the files to read.
 * @returns Map of the file name and the file content
 */
function readFolder(path, extension) {
    const { versionKey } = getContext();
    return cache.get(`${path}@${versionKey}`, () => {
        try {
            return fs.readdirSync(path).reduce((result, fileName) => {
                if (!fileName.endsWith(extension)) {
                    return result;
                }
                result[fileName] = fs.readFileSync(`${path}/${fileName}`, 'utf8');
                return result;
            }, {});
        }
        catch (_a) {
            // path does not exist, return empty; faster than checking whether path exists.
            return {};
        }
    });
}
exports.readFolder = readFolder;
//# sourceMappingURL=files.js.map