'use strict';

/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
/** required */
const rollup_1 = require("rollup");
const terser_1 = __importDefault(require("terser"));
require("colors");
const errors_1 = require("@lwc/errors");
const rollup_plugin_1 = __importDefault(require("@lwc/rollup-plugin"));
const rollup_plugin_replace_1 = __importDefault(require("rollup-plugin-replace"));
const rollup_plugin_compat_1 = __importDefault(require("rollup-plugin-compat"));
const rollup_plugin_node_resolve_1 = __importDefault(require("rollup-plugin-node-resolve"));
const rollup_plugin_commonjs_1 = __importDefault(require("rollup-plugin-commonjs"));
const performance_1 = require("@webruntime/performance");
const messages_1 = require("./messages");
const utils_1 = require("./utils");
const onwarn_1 = require("./plugins/onwarn");
const rollup_plugin_eslint_1 = __importDefault(require("./plugins/rollup-plugin-eslint"));
const rollup_plugin_virtual_1 = __importDefault(require("./plugins/rollup-plugin-virtual"));
// Caching for Rollup.
const modulesCache = {
    cache: {},
};
function genCacheKey(compat, minify, env) {
    const compatStr = compat ? 'compat' : 'noncompat';
    const minifyStr = minify ? 'minify' : 'nonminify';
    return `${compatStr};${minifyStr};${env}`;
}
// Minify separately.
function minifyCode(src, sourceMap) {
    const { code, error } = terser_1.default.minify(src, { sourceMap });
    if (!error && code) {
        return code;
    }
    throw error;
}
/**
 * Create a client-side bundle based on the given config.
 *
 * @param options - Compiler config (see README for object documentation)
 */
async function compile(options) {
    // Parse options.
    const { name, namespace, files, input, format, formatConfig, plugins: customPlugins, external: customExternals, inlineConfig, outputConfig, lwcOptions, } = utils_1.validateOptions(options);
    const { sourcemap = false, compat = false, minify = false, env: { NODE_ENV: env = 'development' } = {}, } = outputConfig;
    const id = namespace ? `${namespace}/${name}` : name;
    const measure = performance_1.startMeasure(`compiler:compile:${input || id}`);
    const cacheKey = genCacheKey(compat, minify, env);
    // Initialize output properties.
    let success = false;
    let result;
    const diagnostics = [];
    const metadata = { dependencies: [], dynamicImports: [] };
    // Call rollup.
    try {
        const bundler = await rollup_1.rollup({
            input: input || id,
            external: utils_1.createExternals(id, inlineConfig, customExternals),
            plugins: [
                rollup_plugin_eslint_1.default(utils_1.lintConfig),
                ...customPlugins,
                rollup_plugin_virtual_1.default(files, namespace),
                rollup_plugin_1.default(lwcOptions),
                rollup_plugin_node_resolve_1.default(),
                rollup_plugin_commonjs_1.default(),
                rollup_plugin_replace_1.default({ 'process.env.NODE_ENV': JSON.stringify(env) }),
                compat && rollup_plugin_compat_1.default({ polyfills: false }),
            ],
            onwarn: onwarn_1.handleRollupWarning(diagnostics),
            cache: modulesCache.cache[cacheKey] && {
                modules: Object.values(modulesCache.cache[cacheKey]),
            },
        });
        // Update the cache.
        if (bundler.cache) {
            // eslint-disable-next-line require-atomic-updates
            modulesCache.cache[cacheKey] = modulesCache.cache[cacheKey] || {};
            const modules = bundler.cache.modules;
            if (modules !== undefined) {
                Object.assign(modulesCache.cache[cacheKey], modules.reduce((entries, module) => {
                    entries[module.id] = module;
                    return entries;
                }, {}));
            }
        }
        // Call rollup bundler.generate
        const amdOutput = {
            id,
            define: formatConfig !== undefined ? formatConfig.amd.define : undefined,
        };
        const outputOptions = {
            name,
            format,
            amd: format === 'amd' ? amdOutput : undefined,
            sourcemap: sourcemap,
        };
        const { output } = await bundler.generate(outputOptions);
        // Rollup produces multiple chunks when a module uses "import()" with a relative import
        // path. We need to ensure the compiled module only contains the main chunk.
        if (output.length > 1) {
            const error = errors_1.ModuleResolutionErrors.RELATIVE_DYNAMIC_IMPORT;
            throw new errors_1.CompilerError(error.code, error.message);
        }
        let code = output[0].code;
        const { map, imports, dynamicImports } = output[0];
        // Minify content, if needed.
        if (minify) {
            code = await minifyCode(code, sourcemap);
        }
        // Parse RuntimeCompilerOutput properties:
        success = true;
        result = {
            code,
            map,
            outputConfig,
        };
        metadata.dependencies = imports;
        metadata.dynamicImports = dynamicImports.map(utils_1.parsePivots);
    }
    catch (error) {
        // Add uncaught errors to the diagnostic array.
        const diagnostic = errors_1.normalizeToDiagnostic(messages_1.compilerMessages.COMPILE_ERROR, error);
        // Remove double message error code.
        diagnostic.message = diagnostic.message.replace(/^LWC\d{4}: /, '');
        diagnostic.originalError = error;
        diagnostics.push(diagnostic);
    }
    performance_1.endMeasure(measure);
    return {
        success,
        diagnostics,
        result,
        version: '0.30.11',
        metadata,
    };
}
exports.compile = compile;
