"use strict";
/** @hidden */
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const rollup_pluginutils_1 = require("rollup-pluginutils");
/**
 * Return true if a given resource ID is part of a LWC (eg: cmp.html or cmp.css)
 *
 * @param id - A virtual resource ID (eg: 'x/cmp.css')
 * @param modules - The map of all virtual modules
 */
function isLwcResource(id, modules) {
    const ext = path_1.default.extname(id);
    const cmpName = id.replace(ext, '.js');
    if ((ext === '.html' || ext === '.css') && modules[cmpName]) {
        return true;
    }
    return false;
}
/**
 * Plugin that will resolve and load "virtual" modules
 * i.e. generated modules that are present in memory
 * but not present on the file system.
 *
 * @param {object} modules - The modules to load, keyed by module id with the
 *                          modules source as values.
 * @param {string} namespace - The namespace for this bundle
 */
function plugin(modules, namespace) {
    // Resolve paths of module ids starting with '.'
    // or those that are CSS and HTML LWC resources.
    // Add the source to the modules map to allow
    // relative imports between virtual modules
    modules = Object.entries(modules).reduce((acc, [id, src]) => {
        if (id.startsWith('.') || isLwcResource(id, modules)) {
            acc[path_1.default.resolve(id)] = src;
        }
        return acc;
    }, { ...modules });
    return {
        name: 'webruntime-virtual',
        load(importee) {
            return modules[importee];
        },
        resolveId(importee, importer) {
            let resolvedId = importee;
            // We need to return an absolute path since it is used
            // by the LWC compiler to get the namespace and module name.
            if (importee.startsWith('.') && importer) {
                resolvedId = path_1.default.resolve(path_1.default.dirname(importer), resolvedId);
            }
            // Add .js extension if needed; LWC plugin needs it.
            resolvedId = rollup_pluginutils_1.addExtension(resolvedId, '.js');
            if (modules[resolvedId]) {
                // Find modified ID.
                return resolvedId;
            }
            else if (importee in modules) {
                // Point modified ID to importee code.
                modules[resolvedId] = modules[importee];
                return resolvedId;
            }
            // The relative virtual file may be stored as absolute.
            // eg: './utils/util.js' may be stored as 'utils/util.js'
            if (importee.startsWith('./')) {
                const absoluteId = importee.replace('./', '');
                if (absoluteId in modules) {
                    modules[resolvedId] = modules[absoluteId];
                }
            }
            // The virtual file may be stored without the namespace.
            // eg: {
            //  name: 'cmp',
            //  namespace: 'x',
            //  files: {
            //     'cmp.js': '...',
            //     'cmp.html': '...',
            // }
            //      ^--- should match specifier of 'x/cmp'
            if (namespace && importee.startsWith(`${namespace}/`)) {
                const nameId = resolvedId.replace(`${namespace}/`, '');
                if (nameId in modules) {
                    modules[resolvedId] = modules[nameId];
                }
            }
            return null;
        },
    };
}
exports.default = plugin;
//# sourceMappingURL=rollup-plugin-virtual.js.map