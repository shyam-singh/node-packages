"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const ajv_1 = __importDefault(require("ajv"));
const yamljs_1 = __importDefault(require("yamljs"));
require("colors");
class MetadataValidator {
    constructor(configId) {
        this.ajv = new ajv_1.default({ allErrors: true, extendRefs: true, verbose: true });
        this.allSchemas = new Map();
        const configPath = path_1.default.resolve(__dirname, '../config', `${configId}.config.yaml`);
        const config = yamljs_1.default.load(configPath);
        this.compileSchemas(config.schemas);
    }
    compileSchemas(schemasToCompile) {
        schemasToCompile.forEach(schemaId => {
            const schema = this.loadSchema(schemaId);
            this.allSchemas.set(schemaId, schema);
            this.ajv.addSchema(schema);
        });
    }
    validate(data, schema) {
        return this.internalValidate(this.ajv, schema, data);
    }
    internalValidate(ajv, schemaId, data) {
        return new Promise((resolve, reject) => {
            const matchingSchemaIds = [...this.allSchemas.keys()].filter(schema => {
                return schema.includes(schemaId);
            });
            if (!(matchingSchemaIds && matchingSchemaIds.length > 0)) {
                reject({
                    errors: [`No precompiled schemas found for schemaId: ${schemaId}`],
                    schemaId,
                    id: data.id || data.devName,
                });
            }
            matchingSchemaIds.forEach(matchingSchemaId => {
                const schema = this.allSchemas.get(matchingSchemaId);
                let errors = [];
                try {
                    const validate = ajv.compile(schema);
                    const valid = validate(data);
                    if (!valid && validate.errors) {
                        errors = validate.errors;
                    }
                }
                catch (error) {
                    errors = [error.message];
                }
                if (errors.length) {
                    reject({ errors, schemaId: matchingSchemaId, id: data.name || data.devName });
                }
            });
            resolve(`✔️ Validated ${matchingSchemaIds.join(', ')}`);
        });
    }
    loadSchema(schemaId) {
        const schemaDir = path_1.default.resolve(__dirname, '../schema');
        const schemaPath = path_1.default.resolve(schemaDir, `${schemaId}.schema.yaml`);
        const schema = yamljs_1.default.load(schemaPath);
        return schema;
    }
}
exports.default = MetadataValidator;
//# sourceMappingURL=index.js.map