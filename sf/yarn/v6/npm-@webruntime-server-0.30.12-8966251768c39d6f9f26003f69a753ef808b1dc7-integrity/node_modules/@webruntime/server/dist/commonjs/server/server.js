"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const uuidv4_1 = __importDefault(require("uuidv4"));
const express_1 = __importDefault(require("express"));
const helmet_1 = __importDefault(require("helmet"));
const compression_1 = __importDefault(require("compression"));
const get_port_1 = __importDefault(require("get-port"));
const api_1 = require("@webruntime/api");
const performance_1 = require("@webruntime/performance");
const container_1 = require("../container/container");
const messages_1 = require("../utils/messages");
const middleware_1 = require("./middleware");
const extensions_1 = require("./extensions");
const { error, log } = console;
/**
 * Given an Express app, return one rooted at the basePath
 *
 * @param app
 * @param basePath
 */
function getRootApp(app, basePath) {
    if (basePath) {
        const rootApp = express_1.default();
        rootApp.use(basePath, app);
        return rootApp;
    }
    return app;
}
class Server extends events_1.EventEmitter {
    constructor(options = {}) {
        super();
        this._httpServer = null;
        // Normalize config
        const { config = {}, configFiles = [], additionalProperties = {} } = options;
        this.config = api_1.buildConfig({ dynamicConfig: config, configFiles });
        // Create container
        this.container = new container_1.Container(this.config, additionalProperties);
        // Create the root app
        this._app = express_1.default();
    }
    async initialize() {
        var _a;
        // Check if server is already running
        api_1.invariant(!this._httpServer, messages_1.serverMessages.INVALID_INIT);
        // Initialize the container
        try {
            await this.container.initialize();
            // GZIP all assets by default
            this._app.use(compression_1.default());
            this._app.use((req, res, next) => {
                res.locals.nonce = uuidv4_1.default();
                next();
            });
            const { server: { extensions, contentSecurityPolicy }, } = this.config;
            const cspConfig = {};
            cspConfig.directives = {};
            // ensure scriptSrc is set, always add self and nonce
            if ((_a = contentSecurityPolicy) === null || _a === void 0 ? void 0 : _a.directives) {
                for (const key in contentSecurityPolicy.directives) {
                    if (key === 'scriptSrc' || key === 'script-src') {
                        contentSecurityPolicy.directives[key].forEach(item => {
                            if (cspConfig.directives && !cspConfig.directives.scriptSrc) {
                                cspConfig.directives.scriptSrc = [];
                            }
                            cspConfig.directives.scriptSrc.push(item);
                        });
                    }
                    else {
                        cspConfig.directives[key] = contentSecurityPolicy.directives[key];
                    }
                }
                cspConfig.directives.scriptSrc = cspConfig.directives.scriptSrc || [];
                cspConfig.directives.scriptSrc.push(`'self'`, (req, res) => `'nonce-${res.locals.nonce}'`);
            }
            else {
                cspConfig.directives.scriptSrc = [
                    `'self'`,
                    (req, res) => `'nonce-${res.locals.nonce}'`,
                ];
            }
            // Web Assembly used by the native loader shim requires 'unsafe-eval' for CSP.
            // We can disable it for experimental format for now.
            // https://bugs.chromium.org/p/chromium/issues/detail?id=948834
            if (!this.container.isUsingExperimentalModules()) {
                this._app.use(helmet_1.default({
                    contentSecurityPolicy: cspConfig,
                }));
            }
            // Execute Server Extension(s) first
            if (extensions) {
                const app = this._app;
                extensions.forEach(extension => {
                    if (extensions_1.isAppExtensionHook(extension)) {
                        extension.extendApp({
                            app,
                            options: this.container.publicConfig,
                        });
                    }
                });
            }
            // Mount the container middleware:
            //  1) Component Addressable Service(s)
            //  2) Static resources
            //  3) Page middleware
            middleware_1.mountMiddleware(this.container, this._app, this.config);
        }
        catch (err) {
            log(err.stack);
            process.exit(1);
        }
    }
    async start() {
        const { basePath } = this.config.server;
        const httpServer = getRootApp(this._app, basePath).listen(this.port ? this.port : await get_port_1.default());
        this._httpServer = httpServer;
        const serverListening = new Promise(resolve => {
            httpServer.on('listening', resolve);
        });
        // Gracefully handle bubbled uncaught exceptions.
        process.on('uncaughtException', async (err) => {
            await this.shutdown();
            log(err.stack);
            process.exit(1);
        });
        // Gracefully handle <Ctrl>+C signals
        process.on('SIGINT', async () => {
            await this.shutdown();
            process.exit(0);
        });
        // TODO: future consideration of restart support
        // process.on('SIGHUP', this.restart);
        await serverListening;
        const addr = httpServer.address();
        //TODO: Consider better logger; use injected logger service.
        log(api_1.generateMessage(messages_1.serverMessages.ON_START, [
            addr.address === '::' ? '' : addr.address,
            addr.port,
            basePath,
        ]));
        return httpServer;
    }
    async shutdown() {
        if (!this._httpServer) {
            return;
        }
        try {
            const serverClosed = new Promise(resolve => {
                this._httpServer.close(resolve);
            });
            const containerShutdown = this.container.shutdown();
            await serverClosed;
            await middleware_1.shutdownMiddleware();
            await containerShutdown;
            this.emit('shutdown');
            log(api_1.generateMessage(messages_1.serverMessages.ON_SHUTDOWN));
            // reset the Server
            this._httpServer = null;
        }
        catch (e) {
            error(api_1.generateMessage(messages_1.serverMessages.FAIL_SHUTDOWN, [e]));
        }
    }
    get port() {
        return this.config.server.port;
    }
    get httpServer() {
        return this._httpServer;
    }
    get app() {
        return this._app;
    }
}
__decorate([
    performance_1.Measure('server:initialize')
], Server.prototype, "initialize", null);
exports.Server = Server;
//# sourceMappingURL=server.js.map