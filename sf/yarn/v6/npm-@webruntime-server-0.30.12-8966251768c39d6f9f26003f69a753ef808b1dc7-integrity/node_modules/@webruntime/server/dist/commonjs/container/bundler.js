"use strict";
/** @hidden */
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const console_1 = require("console");
const glob_to_regexp_1 = __importDefault(require("glob-to-regexp"));
const api_1 = require("@webruntime/api");
const performance_1 = require("@webruntime/performance");
const messages_1 = require("../utils/messages");
const utils_1 = require("./utils");
function normalizeBaseCompilerConfig(config, mode) {
    const { projectDir: baseDir, externals = [], preloadModules, bundle: bundles = [] } = config;
    const { outputConfigs, lwcOptions: rootLwcOptions = {}, inlineConfig: inline = [], ...compilerConfigValues } = config.compilerConfig;
    // Get the outputConfig for the current mode
    const outputConfig = (outputConfigs && outputConfigs[mode]) || {};
    // Merge the lwcOptions from compilerConfig and the outputConfig (which takes precedence)
    const { lwcOptions: modeLwcOptions = {} } = outputConfig;
    const lwcOptions = { ...rootLwcOptions, ...modeLwcOptions };
    // Create the Rollup externals by merging the container externals and preloaded modules
    const external = [...externals, ...preloadModules];
    // Exclude bundled components from being inlined in ANY compilation
    const inlineConfig = [
        ...inline,
        {
            descriptor: '*/*',
            exclude: bundles.map((b) => {
                return typeof b === 'string' ? b : b.descriptor;
            }),
        },
    ];
    return { ...compilerConfigValues, baseDir, external, lwcOptions, inlineConfig, outputConfig };
}
async function bundle(specifier, params, container, config, disableBundling = false, results = [], visitedModules = []) {
    const measure = performance_1.startMeasure(`bundler:bundle:${specifier}`);
    const { metadata, services } = container;
    const { app: appConfig, preloadModules } = config;
    const normalizedBundledConfig = !disableBundling
        ? normalizeBundleConfig(specifier, config)
        : null;
    const external = container.isAppExternal(specifier);
    if (external) {
        // done
        performance_1.endMeasure(measure);
        return results;
    }
    const alreadyBundled = visitedModules.findIndex(o => o === specifier) >= 0;
    if (alreadyBundled) {
        /* In cases where a specifier is referenced more then once in the dependency graph,
            it should be floated to the top in order to for the dependency to be met
            prior to any module needing it.
        */
        const bundleIdx = results.findIndex(o => o.specifier === specifier);
        if (bundleIdx > 0) {
            const entry = results.splice(bundleIdx, 1);
            results.unshift(entry[0]);
        }
    }
    else {
        const service = container.find(specifier);
        try {
            api_1.invariant(service && api_1.supportsRequests(service), messages_1.containerMessages.INVALID_RESOURCE, [specifier]);
        }
        catch (err) {
            performance_1.endMeasure(measure);
            throw err;
        }
        // Mark the module as visited early, while bundling resolutions completes
        visitedModules.push(specifier);
        // Extract the proper output config settings from config using the request params mode.
        const baseConfig = normalizeBaseCompilerConfig(config, params.mode);
        // A service plugin allows contextual knowledge of the request to perform rollup bundle resolution
        // Generate a plugin list of services
        const plugins = [];
        services.forEach(instance => {
            if (api_1.supportsCompilation(instance)) {
                plugins.push(instance.getPlugin(params));
            }
        });
        // Append the list of plugins from compilerConfig to the CompileService plugins
        plugins.push(...(config.compilerConfig.plugins || []));
        const compilerConfig = { ...baseConfig, plugins };
        // Make the request and results insertion atomic
        const output = (await (async () => {
            const containerContext = {
                metadata,
                compilerConfig,
            };
            if (appConfig) {
                containerContext.app = appConfig;
            }
            const result = await service.request(specifier, params, containerContext);
            const { success, diagnostics } = result;
            if (!success && diagnostics) {
                diagnostics.forEach((d) => console_1.log(api_1.generateMessage(d)));
                // done, stop if there are errors encountered requesting a resource.
                results.unshift(result);
                return results;
            }
            // Generate uid for individual output
            if (api_1.containsComponentResource(result)) {
                result.uid = result.resource && utils_1.computeResourceId(result.resource.code);
            }
            // Add it to the collection
            results.unshift(result);
            return result;
        })());
        if (normalizedBundledConfig && api_1.containsComponentResource(output)) {
            // Bundle relevant dependencies
            const dependencies = output.metadata && output.metadata.dependencies;
            const exclusions = preloadModules.concat(normalizedBundledConfig.exclude ? normalizedBundledConfig.exclude : []);
            if (dependencies) {
                await Promise.all(dependencies
                    .filter(dependency => {
                    const excluded = utils_1.isMaskedBy(dependency, exclusions);
                    return !excluded;
                })
                    .map(dependency => {
                    return bundle(dependency, params, container, config, disableBundling, results, visitedModules);
                }));
            }
        }
    }
    performance_1.endMeasure(measure);
    return results;
}
exports.bundle = bundle;
function normalizeBundleConfig(specifier, config) {
    return config.bundle
        .map(entry => {
        if (typeof entry === 'string') {
            return {
                descriptor: entry,
            };
        }
        return entry;
    })
        .find(configEntry => {
        return glob_to_regexp_1.default(configEntry.descriptor).test(specifier);
    });
}
//# sourceMappingURL=bundler.js.map