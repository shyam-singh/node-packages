/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { generateUrl, navigate, subscribe } from 'webruntime/routingService';

jest.mock('@app/basePath', () => '/base', { virtual: true });
jest.mock('@salesforce/user/isGuest', () => ({ default: true }), { virtual: true });

jest.mock(
    '@app/routes',
    () => [
        {
            id: 'root',
            path: '/',
            view: 'view0',
            isRoot: true,
            isPublic: true,
        },
        {
            id: 'page1',
            path: '/page1',
            view: 'view1',
        },
        {
            id: 'page-with-params',
            path: '/users/:user/:action?/:display?',
            view: 'view2',
        },
        {
            id: 'default',
            path: '/default',
            view: 'view3',
            isDefault: true,
        },
        {
            id: 'page4',
            path: '/page4',
            view: 'view4',
        },
        {
            id: 'private',
            path: '/private',
            view: 'view4',
            isPublic: false,
        },
        {
            id: 'accounts-core',
            path: '/account/:objectApiName/:filterName',
            view: 'view5',
            page: {
                type: 'standard__objectPage',
                attributes: {
                    objectApiName: 'Account',
                    actionName: 'home',
                },
            },
        },
        {
            id: 'accounts',
            path: '/account/:objectApiName',
            view: 'view5',
            page: {
                type: 'standard__objectPage',
                attributes: {
                    objectApiName: 'Account',
                    actionName: 'home',
                },
            },
        },
        {
            id: 'accounts',
            path: '/account/:objectApiName',
            view: 'view5',
            page: {
                type: 'standard__objectPage',
                attributes: {
                    objectApiName: 'Account',
                    actionName: 'home',
                },
            },
        },
        {
            path: '/global-search/:term',
            view: 'view5',
            page: {
                type: 'standard__search',
            },
        },
    ],
    { virtual: true }
);
jest.mock(
    '@app/viewToThemeLayoutMap',
    () => ({
        view0: 'Inner',
        view1: 'default',
        view2: 'default',
    }),
    { virtual: true }
);

const waitForNavigation = () => {
    // eslint-disable-next-line @lwc/lwc/no-async-operation
    return new Promise(resolve => setTimeout(resolve));
};

beforeEach(() => {
    // clears the router and other mocks
    jest.clearAllMocks();
});

describe('webruntime/routingService', () => {
    it('returns known route URL with path base', async () => {
        const data = await generateUrl({ id: 'page1' });
        expect(data).toBe(`/base/page1`);
    });

    it('compiles route params', async () => {
        const routeParams = { user: 'Grima', action: 'banish' };
        const data = await generateUrl({ id: 'page-with-params', attributes: routeParams });
        expect(data).toBe(`/base/users/Grima/banish`);
    });

    it('compiles route params encoded', async () => {
        const routeParams = { user: 'Grima +' };
        const data = await generateUrl({ id: 'page-with-params', attributes: routeParams });
        expect(data).toBe(`/base/users/Grima+%2B`);
    });

    it('doesnt include unsupplied optional params', async () => {
        const data = await generateUrl({
            id: 'page-with-params',
            attributes: { user: 'Ted', display: 'compact' },
        });
        expect(data).toBe('/base/users/Ted/compact');
    });

    it('compiles query params', async () => {
        const queryParams = { you: 'shall', not: 'pass' };
        const data = await generateUrl({ id: 'page1', attributes: {}, state: queryParams });
        expect(data).toBe(`/base/page1?you=shall&not=pass`);
    });

    it('returns the default route for an unmatched URL', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        navigate('/does/not/exist');
        // Verify that the callback is triggered
        await waitForNavigation();
        expect(callback.mock.calls[1][0].type).toBe('standard__simpleRoute');
        expect(callback.mock.calls[1][1].id).toBe('default');
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('compiles a standard__search route with term into a URL with term', async () => {
        const data = await generateUrl({
            type: 'standard__search',
            state: { term: 'webruntime' },
        });
        expect(data).toBe(`/base/global-search/webruntime`);
    });

    it('compiles a standard__search route into a URL with the default term', async () => {
        const data = await generateUrl({
            type: 'standard__search',
        });
        expect(data).toBe(`/base/global-search/+`); // encoded space
    });

    it('compiles a URL with term into a standard__search route with term', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        navigate(`/base/global-search/bunnies`);
        // Verify that the callback is triggered
        await waitForNavigation();
        expect(callback).toHaveBeenCalledWith(
            {
                type: 'standard__search',
                attributes: {},
                state: { term: 'bunnies' },
            },
            expect.anything()
        );
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('compiles an on-core standard__objectPage route with a filterName into a URL', async () => {
        const data = await generateUrl({
            id: 'accounts-core',
            type: 'standard__objectPage',
            attributes: { objectApiName: 'Account', actionName: 'home' },
            state: { filterName: 'on' },
        });
        expect(data).toBe(`/base/account/Account/on`);
    });

    it('compiles an on-core standard__objectPage route with the default filterName into a URL', async () => {
        const data = await generateUrl({
            id: 'accounts-core',
            type: 'standard__objectPage',
            attributes: { objectApiName: 'Account', actionName: 'home' },
        });
        expect(data).toBe(`/base/account/Account/Default`);
    });

    it('compiles a URL into an on-core standard__objectPage route with filterName', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        navigate(`/base/account/Account/on`);
        // Verify that the callback is triggered
        await waitForNavigation();
        expect(callback).toHaveBeenCalledWith(
            {
                id: 'accounts-core',
                type: 'standard__objectPage',
                attributes: { objectApiName: 'Account', actionName: 'home' },
                state: { filterName: 'on' },
            },
            expect.anything()
        );
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('compiles an off-core standard__objectPage route with a filterName into a URL', async () => {
        const data = await generateUrl({
            id: 'accounts',
            type: 'accounts',
            attributes: { objectApiName: 'Account', actionName: 'home' },
            state: { filterName: 'off' },
        });
        expect(data).toBe(`/base/account/Account?filterName=off`);
    });

    it('compiles a URL into an off-core standard__objectPage route with filterName', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        navigate(`/base/account/Account?filterName=off`);
        // Verify that the callback is triggered
        await waitForNavigation();
        expect(callback).toHaveBeenCalledWith(
            {
                id: 'accounts',
                type: 'standard__objectPage',
                attributes: { objectApiName: 'Account', actionName: 'home' },
                state: { filterName: 'off' },
            },
            expect.anything()
        );
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('includes the mode param if currently present', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        // set current query parameters
        const state = { mode: 'compat' };
        navigate({ id: 'page4', attributes: {}, state });
        // Verify that the callback is triggered twice (on subscribe and when receiving this event)
        await waitForNavigation();
        expect(callback.mock.calls[1][0].state).toMatchObject(state);
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('compiles supplied query params over whitelisted params currently present', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        // set current query parameters
        const state = { 'webruntime.lwc.fallback': 'false', mode: 'compat' };
        navigate({
            id: 'page4',
            attributes: {},
            state,
        });
        // Verify that the callback is triggered twice (on subscribe and when receiving this event)
        await waitForNavigation();
        expect(callback.mock.calls[1][0].state).toMatchObject(state);
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('compiles an internal standard__webPage URL', async () => {
        const path = `/base/some/where`;
        const data = await generateUrl({
            attributes: { url: path },
            type: 'standard__webPage',
        });
        expect(data).toBe(path);
    });

    it('compiles an internal standard__webPage URL prefixed with a pseudo basePath', async () => {
        const path = `/basepathfaker/some/where`;
        const data = await generateUrl({
            attributes: { url: path },
            type: 'standard__webPage',
        });
        expect(data).toBe(`/base${path}`);
    });

    it('compiles an internal standard__webPage URL which is equal to the basePath', async () => {
        const path = `/base`;
        const data = await generateUrl({
            attributes: { url: path },
            type: 'standard__webPage',
        });
        expect(data).toBe(path);
    });

    it('compiles an external standard__webPage URL', async () => {
        const path = `https://www.google.com`;
        const data = await generateUrl({
            attributes: { url: path },
            type: 'standard__webPage',
        });
        expect(data).toBe(path);
    });

    it('returns an empty string as the URL for a malformed standard__webPage', async () => {
        const data = await generateUrl({ type: 'standard__webPage' });
        expect(data).toBe('');
    });

    it('opens external standard__webPage URLs in a new window', async () => {
        // hack to allow to use the window.open function, jsdom blocks you from using it
        const openMock = jest.fn();
        delete window.open;
        window.open = openMock;
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        navigate({ type: 'standard__webPage', attributes: { url: 'http://google.com' } });
        // Verify that the callback is only triggered once
        await waitForNavigation();
        expect(openMock).toHaveBeenCalledTimes(1);
        expect(callback).toHaveBeenCalledTimes(1);
    });

    it('allows relative standard__webPage URLs to propagate', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        navigate({
            type: 'standard__webPage',
            attributes: { url: `/base/page1` },
        });
        // Verify that the callback is triggered twice (on subscribe and when receiving this event)
        await waitForNavigation();
        expect(callback.mock.calls[1][1].id).toBe('page1');
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('allows relative standard__webPage URLs with no base path to propagate', async () => {
        // subscribe to route changes
        const callback = jest.fn();
        subscribe(callback);
        navigate({
            type: 'standard__webPage',
            attributes: { url: `/page1` },
        });
        // Verify that the callback is triggered twice (on subscribe and when receiving this event)
        await waitForNavigation();
        expect(callback.mock.calls[1][1].id).toBe('page1');
        expect(callback).toHaveBeenCalledTimes(2);
    });

    it('prevents guest users from navigating to private pages', async () => {
        jest.isolateModules(async () => {
            const routingService = require('webruntime/routingService');
            // hack to allow to set the window.location object, jsdom blocks you from setting it
            const newLocation = { ...window.location, href: '' };
            delete window.location; // this is needed so that the new location can be configurable
            window.location = newLocation;
            // subscribe to route changes
            const callback = jest.fn();
            routingService.subscribe(callback, false);
            routingService.navigate({ id: 'private' });
            await waitForNavigation();
            // should only have routed to the default route
            expect(callback).toHaveBeenCalledTimes(1);
            expect(callback.mock.calls[0][0].id).toBe('default');
            // Verify that window.location.href was set
            // since we want a full reload to let the server-side router kick in
            expect(window.location.href).toBe(`/base/private`);
        });
    });

    it('navigates to default route on error', async () => {
        jest.isolateModules(async () => {
            const routingService = require('webruntime/routingService');
            // subscribe to route changes
            const callback = jest.fn();
            routingService.subscribe(callback, false);

            const invalidPageReference = { bogus: 'stuff' };
            routingService.navigate(invalidPageReference);
            await waitForNavigation();

            // should only have routed to the default route
            expect(callback).toHaveBeenCalledTimes(1);
            expect(callback.mock.calls[0][0].id).toBe('default');
        });
    });
});
