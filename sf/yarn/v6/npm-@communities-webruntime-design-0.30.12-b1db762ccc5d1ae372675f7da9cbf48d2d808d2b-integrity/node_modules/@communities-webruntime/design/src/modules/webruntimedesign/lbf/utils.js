/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */


/* index.dev.js */


// *******************************************************************************************************************
// ATTENTION!
// THIS IS A GENERATED FILE FROM https://git.soma.salesforce.com/BuilderFramework/builder-framework
// If you would like to contribute, please follow the steps outlined in the git repo. Any changes made to this
// file in p4 will be automatically overwritten.
// *******************************************************************************************************************

var stringPropertyComparator = function stringPropertyComparator(field, reverse) {
  if (typeof field !== 'string' || field.length === 0) {
    throw new TypeError('field must be a non-empty string');
  }

  return function (a, b) {
    var result = a[field].localeCompare(b[field], undefined, {
      sensitivity: 'base'
    });
    return reverse ? -result : result;
  };
};
var labelComparator = stringPropertyComparator('label');
var nameComparator = stringPropertyComparator('name');
var multiComparatorGenerator = function multiComparatorGenerator(comparators) {
  if (!Array.isArray(comparators) || comparators.length === 0) {
    throw new TypeError('comparators must be a non-empty array');
  }

  return function (a, b) {
    var result = 0;
    comparators.some(function (comparator) {
      result = comparator(a, b);
      return result !== 0;
    });
    return result;
  };
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var isUndefinedOrNull = function isUndefinedOrNull(value) {
  return value === undefined || value === null;
};
var isUndefined = function isUndefined(value) {
  return value === undefined;
};
var isObject = function isObject(item) {
  return _typeof(item) === 'object' && !Array.isArray(item) && !isUndefinedOrNull(item);
};
var isValidNumber = function isValidNumber(value) {
  return value ? !isNaN(value) : false;
};
function isFunction(obj) {
  return typeof obj === 'function';
}
function isArray(arg) {
  return typeof Array.isArray === 'function' ? Array.isArray(arg) : Object.prototype.toString.call(arg) === '[object Array]';
}

var formatLabel = function formatLabel(formatString) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return formatString.replace(/\{(\d+)\}/gm, function (match, index) {
    var substitution = args[index];

    if (substitution === undefined) {
      return match;
    }

    return substitution + '';
  });
};
var escapeForRegExp = function escapeForRegExp(value) {
  if (typeof value !== 'string') {
    throw new TypeError('value must be a string');
  }

  return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

var validateMatcherArgs = function validateMatcherArgs(obj, key) {
  if (!isObject(obj)) {
    throw new TypeError('matcher obj must be defined and non-null');
  }

  if (typeof key !== 'string' || key.length === 0) {
    throw new TypeError('matcher key must be a non-empty string');
  }
};

var validateStringMatcherArgs = function validateStringMatcherArgs(obj, key, pattern) {
  validateMatcherArgs(obj, key);

  if (typeof pattern !== 'string' || pattern.length === 0) {
    throw new TypeError('string matcher pattern must be a non-empty pattern string');
  }
};

var containsMatcher = function containsMatcher(obj, key, pattern) {
  validateStringMatcherArgs(obj, key, pattern);
  var regex = new RegExp(escapeForRegExp(pattern), 'i');
  return regex.test(obj[key]);
};

var labelFilter = function labelFilter(pattern) {
  return function (obj) {
    return pattern ? containsMatcher(obj, 'label', pattern) : true;
  };
};

var CustomURLSearchParams = function () {
  function CustomURLSearchParams(init) {
    var _this = this;

    _classCallCheck(this, CustomURLSearchParams);

    this.map = new Map();

    if (!init) {
      return this;
    } else if (typeof init === 'string') {
      var searchParams = init;

      if (searchParams.charAt(0) === '?') {
        searchParams = searchParams.slice(1);
      }

      for (var pairs = searchParams.split('&'), i = 0, length = pairs.length; i < length; i++) {
        var value = pairs[i];
        var index = value.indexOf('=');

        if (index === -1) {
          this.append(value, '');
        } else {
          this.append(value.slice(0, index), value.slice(index + 1));
        }
      }
    } else if (init instanceof URLSearchParams || init instanceof CustomURLSearchParams) {
      init.forEach(function (value, name) {
        return _this.append(name, value);
      });
    } else if (Array.isArray(init)) {
      for (var _i = 0; _i < init.length; _i++) {
        this.append(init[_i][0], init[_i][1]);
      }
    } else if (_typeof(init) === 'object') {
      for (var name in init) {
        if (init.hasOwnProperty(name)) {
          this.append(name, init[name]);
        }
      }
    } else {
      throw new TypeError('Unsupported call to URLSearchParams constructor');
    }
  }

  _createClass(CustomURLSearchParams, [{
    key: "append",
    value: function append(name, value) {
      if (this.has(name)) {
        this.map.set(name, [].concat(_toConsumableArray(this.getAll(name)), [value]));
      } else {
        this.set(name, value);
      }
    }
  }, {
    key: "delete",
    value: function _delete(name) {
      this.map.delete(name);
    }
  }, {
    key: "get",
    value: function get(name) {
      return this.getAll(name)[0];
    }
  }, {
    key: "getAll",
    value: function getAll(name) {
      return this.map.get(name) || [];
    }
  }, {
    key: "has",
    value: function has(name) {
      return this.map.has(name);
    }
  }, {
    key: "set",
    value: function set(name, value) {
      this.map.set(name, [value]);
    }
  }, {
    key: "sort",
    value: function sort() {
      this.map = new Map(_toConsumableArray(this.map.entries()).sort());
    }
  }, {
    key: "forEach",
    value: function forEach(callbackfn, thisArg) {
      var _this2 = this;

      this.map.forEach(function (values, key, parent) {
        return values.forEach(function (value) {
          return callbackfn(value, key, _this2);
        });
      });
    }
  }, {
    key: "toString",
    value: function toString() {
      var array = [];
      this.forEach(function (value, key) {
        return array.push("".concat(key, "=").concat(value));
      });
      return array.join('&');
    }
  }]);

  return CustomURLSearchParams;
}();

if (!window.URLSearchParams) {
  window.URLSearchParams = CustomURLSearchParams;
}

function generateGuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}

function _apply(baseClass, members) {
  var forceCopy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (forceCopy) {
    for (var prop in members) {
      if (members.hasOwnProperty(prop)) {
        baseClass[prop] = members[prop];
      }
    }
  } else {
    for (var propEls in members) {
      if (!baseClass.hasOwnProperty(propEls)) {
        baseClass[propEls] = members[propEls];
      }
    }
  }

  return baseClass;
}

function clone(obj) {
  var deepCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!obj) {
    return obj;
  }

  var isArr = isArray(obj);
  var isObj = isObject(obj);

  if (!isArr && !isObj) {
    return obj;
  }

  if (deepCopy) {
    var ret;

    if (isArr) {
      ret = [];

      for (var iter = 0, len = obj.length; iter < len; iter++) {
        ret.push(clone(obj[iter], true));
      }
    } else {
      ret = Object.create(Object.getPrototypeOf(obj));

      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret[key] = clone(obj[key], true);
        }
      }
    }

    return ret;
  }

  if (isArr) {
    return obj.slice();
  }

  return _apply({}, obj);
}

var Connection = function () {
  function Connection(srcWindow, destWindow, destOrigin, hookShouldHandleMessage) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, Connection);

    this.listeners = {};
    this.open = false;

    if (!srcWindow) {
      throw new Error("PostMessage: Error creating connection! 'srcWindow' was not provided while creating the connection.");
    } else if (!destWindow && (!hookShouldHandleMessage || !hookShouldHandleMessage.constructor || !hookShouldHandleMessage.call || !hookShouldHandleMessage.apply)) {
      throw new Error("PostMessage: Error creating connection! Either 'destWindow' or 'hookShouldHandleMessage' should be provided while creating a connection.");
    }

    this.curWindow = srcWindow;
    this.otherWindow = destWindow;
    this.otherWindowOrigin = destOrigin;
    this.hookShouldHandleMessage = hookShouldHandleMessage;
    this.isParent = !!options.isParent;
  }

  _createClass(Connection, [{
    key: "messageHandler",
    value: function messageHandler(e) {
      if (!this.otherWindow && (!this.hookShouldHandleMessage || !this.hookShouldHandleMessage(e))) {
        return;
      } else if (!this.isMessageValid(e)) {
        return;
      }

      var data;

      try {
        data = JSON.parse(e.data);
      } catch (ex) {
        return;
      }

      var callbacks = this.listeners[data.mType];

      if (callbacks) {
        var callbacksLen = callbacks.length;

        for (var i = 0; i < callbacksLen; i++) {
          var callback = callbacks[i];

          if (callback && callback.constructor && callback.call && callback.apply) {
            callback(data.mBody);
          }
        }
      }
    }
  }, {
    key: "close",
    value: function close() {
      this.curWindow.removeEventListener('message', this.messageHandler, false);

      for (var prop in this) {
        if (this.hasOwnProperty(prop)) {
          delete this[prop];
        }
      }

      this.open = false;
    }
  }, {
    key: "listenFor",
    value: function listenFor(type, callback) {
      if (this.listeners.hasOwnProperty(type)) {
        this.listeners[type].push(callback);
      } else {
        this.listeners[type] = [callback];
      }

      return this;
    }
  }, {
    key: "stopListeningFor",
    value: function stopListeningFor(type, callback) {
      if (callback) {
        var listeners = this.listeners[type];
        var toRemoveIdx = listeners ? listeners.indexOf(callback) : -1;

        if (toRemoveIdx >= 0) {
          listeners.splice(toRemoveIdx, 1);

          if (listeners.length === 0) {
            delete this.listeners[type];
          } else {
            this.listeners[type] = listeners;
          }
        }
      } else {
        delete this.listeners[type];
      }

      return this;
    }
  }]);

  return Connection;
}();

var SETUP_INITIALIZE_PORT = 'setup:initialize-port';
var MessageChannelConnection = function (_Connection) {
  _inherits(MessageChannelConnection, _Connection);

  function MessageChannelConnection(srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options) {
    var _this;

    _classCallCheck(this, MessageChannelConnection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageChannelConnection).call(this, srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options));
    _this.messageQueue = [];

    _this.curWindow.addEventListener('message', _this.negotiatePort.bind(_assertThisInitialized(_this)), false);

    if (_this.isParent) {
      var channel = new MessageChannel();
      _this.port = channel.port1;
      _this.port.onmessage = _this.messageHandler.bind(_assertThisInitialized(_this));

      if (_this.otherWindow) {
        _this.otherWindow.postMessage(SETUP_INITIALIZE_PORT, destOrigin || '*', [channel.port2]);
      }

      _this.open = true;
    }

    return _this;
  }

  _createClass(MessageChannelConnection, [{
    key: "isMessageValid",
    value: function isMessageValid(e) {
      return true;
    }
  }, {
    key: "send",
    value: function send(type, message) {
      var data = {
        mType: type,
        mBody: message
      };

      if (!this.open || !this.port) {
        this.messageQueue.push(data);
        return this;
      }

      if (!this.otherWindow) {
        throw new Error("PostMessage: Cannot send messages using Connection connection since a 'destWindow' was not specified during creation.");
      }

      this.port.postMessage(JSON.stringify(data));
      return this;
    }
  }, {
    key: "negotiatePort",
    value: function negotiatePort(e) {
      if (e.data !== SETUP_INITIALIZE_PORT || this.isParent) {
        return;
      }

      this.port = e.ports[0];
      this.port.onmessage = this.messageHandler.bind(this);
      this.open = true;
      this.sendQueuedMessages();
    }
  }, {
    key: "sendQueuedMessages",
    value: function sendQueuedMessages() {
      var _this2 = this;

      var oldMessageQueue = _toConsumableArray(this.messageQueue);

      this.messageQueue = [];
      oldMessageQueue.forEach(function (message) {
        return _this2.send(message.mType, message.mBody);
      });
    }
  }]);

  return MessageChannelConnection;
}(Connection);

var PostMessageConnection = function (_Connection) {
  _inherits(PostMessageConnection, _Connection);

  function PostMessageConnection(srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options) {
    var _this;

    _classCallCheck(this, PostMessageConnection);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PostMessageConnection).call(this, srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options));

    _this.curWindow.addEventListener('message', _this.messageHandler.bind(_assertThisInitialized(_this)), false);

    _this.open = true;
    return _this;
  }

  _createClass(PostMessageConnection, [{
    key: "isMessageValid",
    value: function isMessageValid(e) {
      return e.source === this.otherWindow && !(this.otherWindowOrigin && e.origin.toLowerCase() !== this.otherWindowOrigin.toLowerCase());
    }
  }, {
    key: "send",
    value: function send(type, message) {
      if (!this.open) {
        throw new Error('PostMessage: Connection is not open. Cannot send messages if the connection is not open.');
      }

      if (!this.otherWindow) {
        throw new Error("PostMessage: Cannot send messages using Connection connection since a 'destWindow' was not specified during creation.");
      }

      var data = {
        mType: type,
        mBody: message
      };
      var origin = this.otherWindowOrigin || '*';
      this.otherWindow.postMessage(JSON.stringify(data), origin);
      return this;
    }
  }]);

  return PostMessageConnection;
}(Connection);

var ConnectionManager = function () {
  function ConnectionManager() {
    var connectionConstructor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PostMessageConnection;
    var connectionOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ConnectionManager);

    this.connections = [];
    this.connectionConstructor = connectionConstructor;
    this.connectionOptions = connectionOptions;
  }

  _createClass(ConnectionManager, [{
    key: "registerPostmessageHandler",
    value: function registerPostmessageHandler(sourceWindow, type, handler) {
      if (!!sourceWindow && !sourceWindow.location && !sourceWindow.document) {
        throw new Error('PostmessageManager: The source window supplied while registering the handler for "' + type + '" is not a valid window object.');
      }

      if (!isFunction(handler)) {
        throw new Error('PostmessageManager: The action supplied while registering the handler for "' + type + '" is not a valid function.');
      }

      var connection = sourceWindow ? this.getConnection(sourceWindow) : this.getListenOnlyConnection();
      connection.listenFor(type, handler);
    }
  }, {
    key: "unregisterPostmessageHandler",
    value: function unregisterPostmessageHandler(sourceWindow, type, handler) {
      if (!!sourceWindow && !sourceWindow.location && !sourceWindow.document) {
        throw new Error('PostmessageManager: The source window supplied while unregistering the handler for "' + type + '" is not a valid window object.');
      }

      var connection = sourceWindow ? this.getConnection(sourceWindow) : this.getListenOnlyConnection();
      connection.stopListeningFor(type, handler);
    }
  }, {
    key: "sendPostmessage",
    value: function sendPostmessage(destinationWindow, type, data) {
      if (!destinationWindow || !destinationWindow.location || !destinationWindow.postMessage) {
        throw new Error('PostmessageManager: The destination window supplied while sending the "' + type + '" message is not a valid window object.');
      }

      this.getConnection(destinationWindow).send(type, data);
    }
  }, {
    key: "getListenOnlyConnection",
    value: function getListenOnlyConnection() {
      var _this = this;

      if (!this.listenOnlyConnection) {
        this.listenOnlyConnection = new this.connectionConstructor(window, undefined, undefined, function (e) {
          return _this.findConnectionIndex(e.source) === -1;
        }, this.connectionOptions);
      }

      return this.listenOnlyConnection;
    }
  }, {
    key: "getConnection",
    value: function getConnection(sourceWindow) {
      var connection = this.findConnection(sourceWindow);

      if (!connection) {
        connection = new this.connectionConstructor(window, sourceWindow, undefined, undefined, this.connectionOptions);
        this.connections.push(connection);
      }

      return connection;
    }
  }, {
    key: "removeConnection",
    value: function removeConnection(sourceWindow) {
      var connectionToRemoveIdx = this.findConnectionIndex(sourceWindow);

      if (connectionToRemoveIdx === -1) {
        return;
      }

      var connectionToRemove = this.connections[connectionToRemoveIdx];

      if (connectionToRemove) {
        connectionToRemove.close();
      }

      this.connections.splice(connectionToRemoveIdx, 1);
    }
  }, {
    key: "findConnectionIndex",
    value: function findConnectionIndex(sourceWindow) {
      for (var i = 0; i < this.connections.length; i++) {
        if (this.connections[i].otherWindow === sourceWindow) {
          return i;
        }
      }

      return -1;
    }
  }, {
    key: "findConnection",
    value: function findConnection(sourceWindow) {
      var index = this.findConnectionIndex(sourceWindow);

      if (index >= 0) {
        return this.connections[index];
      }

      return undefined;
    }
  }]);

  return ConnectionManager;
}();

function _arrayEqual(a1, a2) {
  if (!a1 || !a2 || a1.length !== a2.length) {
    return false;
  }

  for (var i = 0; i < a1.length; i++) {
    if (!isEqual(a1[i], a2[i])) {
      return false;
    }
  }

  return true;
}

function _objectEqual(o1, o2) {
  if (!o1 || !o2) {
    return false;
  }

  var props1 = Object.getOwnPropertyNames(o1);
  var props2 = Object.getOwnPropertyNames(o2);

  if (props1.length !== props2.length) {
    return false;
  }

  for (var i = 0; i < props1.length; i++) {
    var propName = props1[i];

    if (!isEqual(o1[propName], o2[propName])) {
      return false;
    }
  }

  return true;
}

function isEqual(p1, p2) {
  if (isObject(p1) && isObject(p2)) {
    return _objectEqual(p1, p2);
  } else if (isArray(p1) && isArray(p2)) {
    return _arrayEqual(p1, p2);
  }

  return p1 === p2;
}

function scrubURLDomain(url) {
  if (typeof window !== 'undefined' && window.location && window.location.origin) {
    var domain = window.location.origin;
    var regExUrlProtocol = new RegExp('^.{0,}//');
    var urlPath = url.replace(regExUrlProtocol, '');

    if (regExUrlProtocol.test(url)) {
      if (urlPath.indexOf('/') >= 0) {
        return domain + urlPath.substr(urlPath.indexOf('/'));
      }
    } else if (urlPath.indexOf('/') === 0) {
      return domain + url;
    } else if (urlPath.indexOf('/') !== 0) {
      return domain + '/' + url;
    }
  }

  return '';
}

function shallowCopy(obj) {
  return _objectSpread({}, obj);
}

function invariant(value, msg) {
  if (!value) {
    throw new Error("Invariant Violation: ".concat(msg));
  }
}

function isTrue(value, msg) {
  if (!value) {
    throw new Error("Assert Violation: ".concat(msg));
  }
}

function isFalse(value, msg) {
  if (value) {
    throw new Error("Assert Violation: ".concat(msg));
  }
}

function fail(msg) {
  throw new Error(msg);
}

var assert = Object.freeze({
  __proto__: null,
  invariant: invariant,
  isTrue: isTrue,
  isFalse: isFalse,
  fail: fail
});

function isUndefined$1(obj) {
  return obj === undefined;
}

var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
var CONTEXT_ID = '@wire';
var CONTEXT_UPDATED = 'updated';
var CONTEXT_CONNECTED = 'connected';
var CONTEXT_DISCONNECTED = 'disconnected';
var CONNECT = 'connect';
var DISCONNECT = 'disconnect';
var CONFIG = 'config';

function invokeConfigListeners(configListenerMetadatas, paramValues) {
  configListenerMetadatas.forEach(function (metadata) {
    var listener = metadata.listener,
        statics = metadata.statics,
        reactives = metadata.reactives;
    var reactiveValues = Object.create(null);

    if (reactives) {
      var keys = Object.keys(reactives);

      for (var j = 0, jlen = keys.length; j < jlen; j++) {
        var key = keys[j];
        var value = paramValues[reactives[key]];
        reactiveValues[key] = value;
      }
    }

    var config = Object.assign({}, statics, reactiveValues);
    listener.call(undefined, config);
  });
}

function updated(cmp, reactiveParameters, configContext) {
  if (!configContext.mutated) {
    configContext.mutated = new Set(reactiveParameters);
    Promise.resolve().then(updatedFuture.bind(undefined, cmp, configContext));
  } else {
    for (var i = 0, n = reactiveParameters.length; i < n; i++) {
      configContext.mutated.add(reactiveParameters[i]);
    }
  }
}

function updatedFuture(cmp, configContext) {
  var uniqueListeners = new Set();
  var mutated = configContext.mutated;
  delete configContext.mutated;
  mutated.forEach(function (reactiveParameter) {
    var value = getReactiveParameterValue(cmp, reactiveParameter);

    if (configContext.values[reactiveParameter.reference] === value) {
      return;
    }

    configContext.values[reactiveParameter.reference] = value;
    var listeners = configContext.listeners[reactiveParameter.head];

    for (var i = 0, len = listeners.length; i < len; i++) {
      uniqueListeners.add(listeners[i]);
    }
  });
  invokeConfigListeners(uniqueListeners, configContext.values);
}

function getReactiveParameterValue(cmp, reactiveParameter) {
  var value = cmp[reactiveParameter.head];

  if (!reactiveParameter.tail) {
    return value;
  }

  var segments = reactiveParameter.tail;

  for (var i = 0, len = segments.length; i < len && value != null; i++) {
    var segment = segments[i];

    if (_typeof(value) !== 'object' || !(segment in value)) {
      return undefined;
    }

    value = value[segment];
  }

  return value;
}

function installTrap(cmp, reactiveParametersHead, reactiveParameters, configContext) {
  var callback = updated.bind(undefined, cmp, reactiveParameters, configContext);
  var newDescriptor = getOverrideDescriptor(cmp, reactiveParametersHead, callback);
  Object.defineProperty(cmp, reactiveParametersHead, newDescriptor);
}

function findDescriptor(target, propName, protoSet) {
  protoSet = protoSet || [];

  if (!target || protoSet.indexOf(target) > -1) {
    return null;
  }

  var descriptor = Object.getOwnPropertyDescriptor(target, propName);

  if (descriptor) {
    return descriptor;
  }

  var proto = Object.getPrototypeOf(target);

  if (!proto) {
    return null;
  }

  protoSet.push(target);
  return findDescriptor(proto, propName, protoSet);
}

function getOverrideDescriptor(cmp, prop, callback) {
  var descriptor = findDescriptor(cmp, prop);
  var enumerable;
  var get;
  var set;

  if (descriptor === null || descriptor.get === undefined && descriptor.set === undefined) {
    var value = cmp[prop];
    enumerable = true;

    get = function get() {
      return value;
    };

    set = function set(newValue) {
      value = newValue;
      callback();
    };
  } else {
    var originalSet = descriptor.set,
        originalGet = descriptor.get;
    enumerable = descriptor.enumerable;

    set = function set(newValue) {
      if (originalSet) {
        originalSet.call(cmp, newValue);
      }

      callback();
    };

    get = function get() {
      return originalGet ? originalGet.call(cmp) : undefined;
    };
  }

  return {
    set: set,
    get: get,
    enumerable: enumerable,
    configurable: true
  };
}

var ValueChangedEventType = 'ValueChangedEvent';

var ValueChangedEvent = function ValueChangedEvent(value) {
  _classCallCheck(this, ValueChangedEvent);

  this.type = ValueChangedEventType;
  this.value = value;
};

var LinkContextEventType = 'LinkContextEvent';

var LinkContextEvent = function LinkContextEvent(uid, callback) {
  _classCallCheck(this, LinkContextEvent);

  this.type = LinkContextEventType;
  this.uid = uid;
  this.callback = callback;
};

function removeListener(listeners, toRemove) {
  var idx = listeners.indexOf(toRemove);

  if (idx > -1) {
    listeners.splice(idx, 1);
  }
}

function removeConfigListener(configListenerMetadatas, toRemove) {
  for (var i = 0, len = configListenerMetadatas.length; i < len; i++) {
    if (configListenerMetadatas[i].listener === toRemove) {
      configListenerMetadatas.splice(i, 1);
      return;
    }
  }
}

function buildReactiveParameter(reference) {
  if (!reference.includes('.')) {
    return {
      reference: reference,
      head: reference
    };
  }

  var segments = reference.split('.');
  return {
    reference: reference,
    head: segments.shift(),
    tail: segments
  };
}

var WireEventTarget = function () {
  function WireEventTarget(cmp, def, context, wireDef, wireTarget) {
    _classCallCheck(this, WireEventTarget);

    this._cmp = cmp;
    this._def = def;
    this._context = context;
    this._wireDef = wireDef;
    this._wireTarget = wireTarget;
  }

  _createClass(WireEventTarget, [{
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      var _this = this;

      switch (type) {
        case CONNECT:
          {
            var connectedListeners = this._context[CONTEXT_ID][CONTEXT_CONNECTED];

            if (process.env.NODE_ENV !== 'production') {
              assert.isFalse(connectedListeners.includes(listener), 'must not call addEventListener("connect") with the same listener');
            }

            connectedListeners.push(listener);
            break;
          }

        case DISCONNECT:
          {
            var disconnectedListeners = this._context[CONTEXT_ID][CONTEXT_DISCONNECTED];

            if (process.env.NODE_ENV !== 'production') {
              assert.isFalse(disconnectedListeners.includes(listener), 'must not call addEventListener("disconnect") with the same listener');
            }

            disconnectedListeners.push(listener);
            break;
          }

        case CONFIG:
          {
            var reactives = this._wireDef.params;
            var statics = this._wireDef.static;
            var reactiveKeys;

            if (!reactives || (reactiveKeys = Object.keys(reactives)).length === 0) {
              var config = statics || Object.create(null);
              listener.call(undefined, config);
              return;
            }

            var configListenerMetadata = {
              listener: listener,
              statics: statics,
              reactives: reactives
            };
            var configContext = this._context[CONTEXT_ID][CONTEXT_UPDATED];
            var reactiveParametersGroupByHead = {};
            reactiveKeys.forEach(function (key) {
              var reactiveParameter = buildReactiveParameter(reactives[key]);
              var reactiveParameterHead = reactiveParameter.head;
              var configListenerMetadatas = configContext.listeners[reactiveParameterHead];
              var reactiveParametersWithSameHead = reactiveParametersGroupByHead[reactiveParameterHead];

              if (isUndefined$1(reactiveParametersWithSameHead)) {
                reactiveParametersWithSameHead = [];
                reactiveParametersGroupByHead[reactiveParameterHead] = reactiveParametersWithSameHead;
              }

              reactiveParametersWithSameHead.push(reactiveParameter);

              if (!configListenerMetadatas) {
                configListenerMetadatas = [configListenerMetadata];
                configContext.listeners[reactiveParameterHead] = configListenerMetadatas;
                installTrap(_this._cmp, reactiveParameterHead, reactiveParametersWithSameHead, configContext);
              } else {
                configListenerMetadatas.push(configListenerMetadata);
              }
            });
            Object.keys(reactiveParametersGroupByHead).forEach(function (head) {
              updated(_this._cmp, reactiveParametersGroupByHead[head], configContext);
            });
            break;
          }

        default:
          throw new Error("unsupported event type ".concat(type));
      }
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      switch (type) {
        case CONNECT:
          {
            var connectedListeners = this._context[CONTEXT_ID][CONTEXT_CONNECTED];
            removeListener(connectedListeners, listener);
            break;
          }

        case DISCONNECT:
          {
            var disconnectedListeners = this._context[CONTEXT_ID][CONTEXT_DISCONNECTED];
            removeListener(disconnectedListeners, listener);
            break;
          }

        case CONFIG:
          {
            var paramToConfigListenerMetadata = this._context[CONTEXT_ID][CONTEXT_UPDATED].listeners;
            var reactives = this._wireDef.params;

            if (reactives) {
              Object.keys(reactives).forEach(function (key) {
                var reactiveParameter = buildReactiveParameter(reactives[key]);
                var configListenerMetadatas = paramToConfigListenerMetadata[reactiveParameter.head];

                if (configListenerMetadatas) {
                  removeConfigListener(configListenerMetadatas, listener);
                }
              });
            }

            break;
          }

        default:
          throw new Error("unsupported event type ".concat(type));
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(evt) {
      if (evt instanceof ValueChangedEvent) {
        var value = evt.value;

        if (this._wireDef.method) {
          this._cmp[this._wireTarget](value);
        } else {
          this._cmp[this._wireTarget] = value;
        }

        return false;
      } else if (evt instanceof LinkContextEvent) {
        var uid = evt.uid,
            callback = evt.callback;
        var internalDomEvent = new CustomEvent(uid, {
          bubbles: true,
          composed: true,
          detail: function detail() {
            callback.apply(void 0, arguments);
          }
        });

        this._cmp.dispatchEvent(internalDomEvent);

        return false;
      } else if (evt.type === 'wirecontextevent') {
        return this._cmp.dispatchEvent(evt);
      } else {
        throw new Error("Invalid event ".concat(evt, "."));
      }
    }
  }]);

  return WireEventTarget;
}();

function getMethod(obj, key) {
  var value = obj[key];

  if (value == null) {
    return undefined;
  }

  if (typeof value !== 'function') {
    throw new TypeError(value + ' is not a function');
  }

  return value;
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;

  if (!cleanup) {
    return;
  }

  subscription._cleanup = undefined;
  cleanup();
}

function subscriptionClosed(subscription) {
  return subscription._observer === undefined;
}

function closeSubscription(subscription) {
  if (subscriptionClosed(subscription)) {
    return;
  }

  subscription._observer = undefined;
  cleanupSubscription(subscription);
}

function cleanupFromSubscription(subscription) {
  return function () {
    subscription.unsubscribe();
  };
}

var SubscriptionObserver = function () {
  function SubscriptionObserver(subscription) {
    _classCallCheck(this, SubscriptionObserver);

    this._subscription = subscription;
  }

  _createClass(SubscriptionObserver, [{
    key: "next",
    value: function next(value) {
      var subscription = this._subscription;

      if (subscriptionClosed(subscription)) {
        return;
      }

      var observer = subscription._observer;
      var m = getMethod(observer, 'next');

      if (!m) {
        return;
      }

      m.call(observer, value);
    }
  }, {
    key: "error",
    value: function error(value) {
      var subscription = this._subscription;

      if (subscriptionClosed(subscription)) {
        return;
      }

      var observer = subscription._observer;
      subscription._observer = undefined;
      var m = getMethod(observer, 'error');

      if (m) {
        m.call(observer, value);
      }

      cleanupSubscription(subscription);
    }
  }, {
    key: "complete",
    value: function complete() {
      var subscription = this._subscription;

      if (subscriptionClosed(subscription)) {
        return;
      }

      var observer = subscription._observer;
      subscription._observer = undefined;

      try {
        var m = getMethod(observer, 'complete');

        if (m) {
          m.call(observer);
        }
      } catch (e) {}

      cleanupSubscription(subscription);
    }
  }, {
    key: "closed",
    get: function get() {
      return subscriptionClosed(this._subscription);
    }
  }]);

  return SubscriptionObserver;
}();
var Subscription = function () {
  function Subscription(observer, subscriber) {
    _classCallCheck(this, Subscription);

    this._observer = observer;
    this._cleanup = undefined;
    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      var cleanup = subscriber.call(undefined, subscriptionObserver);

      if (cleanup != null) {
        if (typeof cleanup.unsubscribe === 'function') {
          cleanup = cleanupFromSubscription(cleanup);
        } else if (typeof cleanup !== 'function') {
          throw new TypeError(cleanup + ' is not a function');
        }

        this._cleanup = cleanup;
      }
    } catch (e) {
      subscriptionObserver.error(e);
      return;
    }

    if (subscriptionClosed(this)) {
      cleanupSubscription(this);
    }
  }

  _createClass(Subscription, [{
    key: "unsubscribe",
    value: function unsubscribe() {
      closeSubscription(this);
    }
  }, {
    key: "closed",
    get: function get() {
      return subscriptionClosed(this);
    }
  }]);

  return Subscription;
}();
var Observable = function () {
  function Observable(subscriber) {
    _classCallCheck(this, Observable);

    if (typeof subscriber !== 'function') {
      throw new TypeError('Observable initializer must be a function');
    }

    this._subscriber = subscriber;
  }

  _createClass(Observable, [{
    key: "subscribe",
    value: function subscribe(observer) {
      if (typeof observer === 'function') {
        observer = {
          next: observer,
          error: arguments.length <= 1 ? undefined : arguments[1],
          complete: arguments.length <= 2 ? undefined : arguments[2]
        };
      } else if (_typeof(observer) !== 'object') {
        observer = {};
      }

      return new Subscription(observer, this._subscriber);
    }
  }], [{
    key: "from",
    value: function from(x) {
      var C = typeof this === 'function' ? this : Observable;

      if (x == null) {
        throw new TypeError(x + ' is not an object');
      }

      var method = getMethod(x, Symbol.observable);

      if (method) {
        var observable = method.call(x);

        if (Object(observable) !== observable) {
          throw new TypeError(observable + ' is not an object');
        }

        if (observable.constructor === C) {
          return observable;
        }

        return new C(function (observer) {
          return observable.subscribe(observer);
        });
      }

      method = getMethod(x, Symbol.iterator);

      if (!method) {
        throw new TypeError(x + ' is not observable');
      }

      return new C(function (observer) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;
            observer.next(item);

            if (observer.closed) {
              return;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        observer.complete();
      });
    }
  }, {
    key: "of",
    value: function of() {
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      var C = typeof this === 'function' ? this : Observable;
      return new C(function (observer) {
        for (var i = 0; i < items.length; ++i) {
          observer.next(items[i]);

          if (observer.closed) {
            return;
          }
        }

        observer.complete();
      });
    }
  }]);

  return Observable;
}();

var WireValueChangeObservers = function () {
  function WireValueChangeObservers() {
    _classCallCheck(this, WireValueChangeObservers);

    this.observers = [];
  }

  _createClass(WireValueChangeObservers, [{
    key: "createObservable",
    value: function createObservable() {
      var _this = this;

      return new Observable(function (observer) {
        return _this.addObserver(observer);
      });
    }
  }, {
    key: "addObserver",
    value: function addObserver(observer) {
      var _this2 = this;

      this.observers.push(observer);
      return function () {
        var index = _this2.observers.indexOf(observer);

        if (index > -1) {
          _this2.observers.splice(index, 1);
        }
      };
    }
  }, {
    key: "emit",
    value: function emit(data, error) {
      this.observers.forEach(function (observer) {
        if (error) {
          observer.error(error);
        } else {
          observer.next(data);
        }
      });
    }
  }]);

  return WireValueChangeObservers;
}();
function configureObservers(getObservers) {
  return function (config) {
    var observers = getObservers(config);

    if (observers) {
      return observers.createObservable();
    }

    return undefined;
  };
}
function createWireAdapterFactory(getObservable, getInitialValue) {
  return function (wireEventTarget) {
    var connected = false;
    var config;
    var subscription;

    var unsubscribe = function unsubscribe() {
      if (subscription) {
        subscription.unsubscribe();
        subscription = undefined;
      }
    };

    var observer = {
      next: function next(data) {
        wireEventTarget.dispatchEvent(new ValueChangedEvent({
          data: data,
          error: undefined
        }));
      },
      error: function error(_error) {
        wireEventTarget.dispatchEvent(new ValueChangedEvent({
          data: undefined,
          error: _error
        }));
      },
      complete: unsubscribe
    };

    var subscribe = function subscribe() {
      var observable = getObservable(config);

      if (observable && !subscription) {
        if (getInitialValue) {
          observer.next(getInitialValue(config));
        }

        subscription = observable.subscribe(observer);
      }
    };

    wireEventTarget.addEventListener('config', function (configListenerArgument) {
      config = configListenerArgument;

      if (connected) {
        unsubscribe();
        subscribe();
      }
    });
    wireEventTarget.addEventListener('connect', function () {
      connected = true;

      if (config) {
        subscribe();
      }
    });
    wireEventTarget.addEventListener('disconnect', function () {
      connected = false;
      unsubscribe();
    });
  };
}

function leadingEdge(fn, delay) {
  var lastCall = 0;
  return function () {
    var now = new Date().getTime();

    if (now - lastCall < delay) {
      return undefined;
    }

    lastCall = now;
    return fn.apply(void 0, arguments);
  };
}

function trailingEdge(fn, delay) {
  var isWaiting = true;
  var lastInvokeTime = null;
  var timeout = null;

  var startTimer = function startTimer() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return window.setTimeout(function () {
      timeout = null;

      if (isWaiting) {
        isWaiting = false;
        lastInvokeTime = new Date().getTime();
        return fn.apply(void 0, args);
      }

      return undefined;
    }, delay);
  };

  return function () {
    if (timeout === null) {
      timeout = startTimer();
      var now = new Date().getTime();

      if (!lastInvokeTime || now - lastInvokeTime > delay) {
        lastInvokeTime = now;
        return fn.apply(void 0, arguments);
      }
    } else {
      isWaiting = true;
    }

    return undefined;
  };
}

function throttle(fn, delay, trailing) {
  if (trailing) {
    return trailingEdge(fn, delay);
  }

  return leadingEdge(fn, delay);
}

var ExpressionService = function () {
  function ExpressionService(contextProviders, expressionsAllowed) {
    _classCallCheck(this, ExpressionService);

    if (ExpressionService.staticInstantiator) {
      this.veExpressionService = ExpressionService.staticInstantiator(contextProviders, expressionsAllowed);
    }
  }

  _createClass(ExpressionService, [{
    key: "getVisualEditorExpressionService",
    value: function getVisualEditorExpressionService() {
      return this.veExpressionService;
    }
  }], [{
    key: "setExpressionServiceInstantiator",
    value: function setExpressionServiceInstantiator(instantiator) {
      ExpressionService.staticInstantiator = instantiator;
    }
  }]);

  return ExpressionService;
}();

var isArray$1 = Array.isArray;
var _getPrototypeOf$1 = Object.getPrototypeOf,
    ObjectCreate = Object.create,
    ObjectDefineProperty = Object.defineProperty,
    _isExtensible = Object.isExtensible,
    _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
    getOwnPropertyNames = Object.getOwnPropertyNames,
    getOwnPropertySymbols = Object.getOwnPropertySymbols,
    _preventExtensions = Object.preventExtensions,
    hasOwnProperty = Object.hasOwnProperty;
var _Array$prototype = Array.prototype,
    ArrayPush = _Array$prototype.push,
    ArrayConcat = _Array$prototype.concat;
var OtS = {}.toString;

function toString(obj) {
  if (obj && obj.toString) {
    return obj.toString();
  } else if (_typeof(obj) === 'object') {
    return OtS.call(obj);
  } else {
    return obj + '';
  }
}

function isUndefined$2(obj) {
  return obj === undefined;
}

function isFunction$1(obj) {
  return typeof obj === 'function';
}

function isObject$1(obj) {
  return _typeof(obj) === 'object';
}

var proxyToValueMap = new WeakMap();

function registerProxy(proxy, value) {
  proxyToValueMap.set(proxy, value);
}

var unwrap = function unwrap(replicaOrAny) {
  return proxyToValueMap.get(replicaOrAny) || replicaOrAny;
};

function wrapValue(membrane, value) {
  return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
}

function unwrapDescriptor(descriptor) {
  if (hasOwnProperty.call(descriptor, 'value')) {
    descriptor.value = unwrap(descriptor.value);
  }

  return descriptor;
}

function lockShadowTarget(membrane, shadowTarget, originalTarget) {
  var targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
  targetKeys.forEach(function (key) {
    var descriptor = _getOwnPropertyDescriptor(originalTarget, key);

    if (!descriptor.configurable) {
      descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
    }

    ObjectDefineProperty(shadowTarget, key, descriptor);
  });

  _preventExtensions(shadowTarget);
}

var ReactiveProxyHandler = function () {
  function ReactiveProxyHandler(membrane, value) {
    _classCallCheck(this, ReactiveProxyHandler);

    this.originalTarget = value;
    this.membrane = membrane;
  }

  _createClass(ReactiveProxyHandler, [{
    key: "get",
    value: function get(shadowTarget, key) {
      var originalTarget = this.originalTarget,
          membrane = this.membrane;
      var value = originalTarget[key];
      var valueObserved = membrane.valueObserved;
      valueObserved(originalTarget, key);
      return membrane.getProxy(value);
    }
  }, {
    key: "set",
    value: function set(shadowTarget, key, value) {
      var originalTarget = this.originalTarget,
          valueMutated = this.membrane.valueMutated;
      var oldValue = originalTarget[key];

      if (oldValue !== value) {
        originalTarget[key] = value;
        valueMutated(originalTarget, key);
      } else if (key === 'length' && isArray$1(originalTarget)) {
        valueMutated(originalTarget, key);
      }

      return true;
    }
  }, {
    key: "deleteProperty",
    value: function deleteProperty(shadowTarget, key) {
      var originalTarget = this.originalTarget,
          valueMutated = this.membrane.valueMutated;
      delete originalTarget[key];
      valueMutated(originalTarget, key);
      return true;
    }
  }, {
    key: "apply",
    value: function apply(shadowTarget, thisArg, argArray) {}
  }, {
    key: "construct",
    value: function construct(target, argArray, newTarget) {}
  }, {
    key: "has",
    value: function has(shadowTarget, key) {
      var originalTarget = this.originalTarget,
          valueObserved = this.membrane.valueObserved;
      valueObserved(originalTarget, key);
      return key in originalTarget;
    }
  }, {
    key: "ownKeys",
    value: function ownKeys(shadowTarget) {
      var originalTarget = this.originalTarget;
      return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    }
  }, {
    key: "isExtensible",
    value: function isExtensible(shadowTarget) {
      var shadowIsExtensible = _isExtensible(shadowTarget);

      if (!shadowIsExtensible) {
        return shadowIsExtensible;
      }

      var originalTarget = this.originalTarget,
          membrane = this.membrane;

      var targetIsExtensible = _isExtensible(originalTarget);

      if (!targetIsExtensible) {
        lockShadowTarget(membrane, shadowTarget, originalTarget);
      }

      return targetIsExtensible;
    }
  }, {
    key: "setPrototypeOf",
    value: function setPrototypeOf(shadowTarget, prototype) {
      if (process.env.NODE_ENV !== 'production') {
        throw new Error("Invalid setPrototypeOf invocation for reactive proxy ".concat(toString(this.originalTarget), ". Prototype of reactive objects cannot be changed."));
      }
    }
  }, {
    key: "getPrototypeOf",
    value: function getPrototypeOf(shadowTarget) {
      var originalTarget = this.originalTarget;
      return _getPrototypeOf$1(originalTarget);
    }
  }, {
    key: "getOwnPropertyDescriptor",
    value: function getOwnPropertyDescriptor(shadowTarget, key) {
      var originalTarget = this.originalTarget,
          membrane = this.membrane;
      var valueObserved = this.membrane.valueObserved;
      valueObserved(originalTarget, key);

      var desc = _getOwnPropertyDescriptor(originalTarget, key);

      if (isUndefined$2(desc)) {
        return desc;
      }

      var shadowDescriptor = _getOwnPropertyDescriptor(shadowTarget, key);

      if (!isUndefined$2(shadowDescriptor)) {
        return shadowDescriptor;
      }

      desc = wrapDescriptor(membrane, desc, wrapValue);

      if (!desc.configurable) {
        ObjectDefineProperty(shadowTarget, key, desc);
      }

      return desc;
    }
  }, {
    key: "preventExtensions",
    value: function preventExtensions(shadowTarget) {
      var originalTarget = this.originalTarget,
          membrane = this.membrane;
      lockShadowTarget(membrane, shadowTarget, originalTarget);

      _preventExtensions(originalTarget);

      return true;
    }
  }, {
    key: "defineProperty",
    value: function defineProperty(shadowTarget, key, descriptor) {
      var originalTarget = this.originalTarget,
          membrane = this.membrane;
      var valueMutated = membrane.valueMutated;
      var configurable = descriptor.configurable;

      if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {
        var originalDescriptor = _getOwnPropertyDescriptor(originalTarget, key);

        descriptor.value = originalDescriptor.value;
      }

      ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));

      if (configurable === false) {
        ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
      }

      valueMutated(originalTarget, key);
      return true;
    }
  }]);

  return ReactiveProxyHandler;
}();

function wrapReadOnlyValue(membrane, value) {
  return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
}

var ReadOnlyHandler = function () {
  function ReadOnlyHandler(membrane, value) {
    _classCallCheck(this, ReadOnlyHandler);

    this.originalTarget = value;
    this.membrane = membrane;
  }

  _createClass(ReadOnlyHandler, [{
    key: "get",
    value: function get(shadowTarget, key) {
      var membrane = this.membrane,
          originalTarget = this.originalTarget;
      var value = originalTarget[key];
      var valueObserved = membrane.valueObserved;
      valueObserved(originalTarget, key);
      return membrane.getReadOnlyProxy(value);
    }
  }, {
    key: "set",
    value: function set(shadowTarget, key, value) {
      if (process.env.NODE_ENV !== 'production') {
        var originalTarget = this.originalTarget;
        throw new Error("Invalid mutation: Cannot set \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
      }

      return false;
    }
  }, {
    key: "deleteProperty",
    value: function deleteProperty(shadowTarget, key) {
      if (process.env.NODE_ENV !== 'production') {
        var originalTarget = this.originalTarget;
        throw new Error("Invalid mutation: Cannot delete \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
      }

      return false;
    }
  }, {
    key: "apply",
    value: function apply(shadowTarget, thisArg, argArray) {}
  }, {
    key: "construct",
    value: function construct(target, argArray, newTarget) {}
  }, {
    key: "has",
    value: function has(shadowTarget, key) {
      var originalTarget = this.originalTarget,
          valueObserved = this.membrane.valueObserved;
      valueObserved(originalTarget, key);
      return key in originalTarget;
    }
  }, {
    key: "ownKeys",
    value: function ownKeys(shadowTarget) {
      var originalTarget = this.originalTarget;
      return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    }
  }, {
    key: "setPrototypeOf",
    value: function setPrototypeOf(shadowTarget, prototype) {
      if (process.env.NODE_ENV !== 'production') {
        var originalTarget = this.originalTarget;
        throw new Error("Invalid prototype mutation: Cannot set prototype on \"".concat(originalTarget, "\". \"").concat(originalTarget, "\" prototype is read-only."));
      }
    }
  }, {
    key: "getOwnPropertyDescriptor",
    value: function getOwnPropertyDescriptor(shadowTarget, key) {
      var originalTarget = this.originalTarget,
          membrane = this.membrane;
      var valueObserved = membrane.valueObserved;
      valueObserved(originalTarget, key);

      var desc = _getOwnPropertyDescriptor(originalTarget, key);

      if (isUndefined$2(desc)) {
        return desc;
      }

      var shadowDescriptor = _getOwnPropertyDescriptor(shadowTarget, key);

      if (!isUndefined$2(shadowDescriptor)) {
        return shadowDescriptor;
      }

      desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);

      if (hasOwnProperty.call(desc, 'set')) {
        desc.set = undefined;
      }

      if (!desc.configurable) {
        ObjectDefineProperty(shadowTarget, key, desc);
      }

      return desc;
    }
  }, {
    key: "preventExtensions",
    value: function preventExtensions(shadowTarget) {
      if (process.env.NODE_ENV !== 'production') {
        var originalTarget = this.originalTarget;
        throw new Error("Invalid mutation: Cannot preventExtensions on ".concat(originalTarget, "\". \"").concat(originalTarget, " is read-only."));
      }

      return false;
    }
  }, {
    key: "defineProperty",
    value: function defineProperty(shadowTarget, key, descriptor) {
      if (process.env.NODE_ENV !== 'production') {
        var originalTarget = this.originalTarget;
        throw new Error("Invalid mutation: Cannot defineProperty \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
      }

      return false;
    }
  }]);

  return ReadOnlyHandler;
}();

function extract(objectOrArray) {
  if (isArray$1(objectOrArray)) {
    return objectOrArray.map(function (item) {
      var original = unwrap(item);

      if (original !== item) {
        return extract(original);
      }

      return item;
    });
  }

  var obj = ObjectCreate(_getPrototypeOf$1(objectOrArray));
  var names = getOwnPropertyNames(objectOrArray);
  return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce(function (seed, key) {
    var item = objectOrArray[key];
    var original = unwrap(item);

    if (original !== item) {
      seed[key] = extract(original);
    } else {
      seed[key] = item;
    }

    return seed;
  }, obj);
}

var formatter = {
  header: function header(plainOrProxy) {
    var originalTarget = unwrap(plainOrProxy);

    if (!originalTarget || originalTarget === plainOrProxy) {
      return null;
    }

    var obj = extract(plainOrProxy);
    return ['object', {
      object: obj
    }];
  },
  hasBody: function hasBody() {
    return false;
  },
  body: function body() {
    return null;
  }
};

function getGlobal() {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  }

  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof global !== 'undefined') {
    return global;
  }

  return {};
}

function init() {
  if (process.env.NODE_ENV === 'production') {
    throw new ReferenceError();
  }

  var global = getGlobal();
  var devtoolsFormatters = global.devtoolsFormatters || [];
  ArrayPush.call(devtoolsFormatters, formatter);
  global.devtoolsFormatters = devtoolsFormatters;
}

if (process.env.NODE_ENV !== 'production') {
  init();
}

function createShadowTarget(value) {
  var shadowTarget = undefined;

  if (isArray$1(value)) {
    shadowTarget = [];
  } else if (isObject$1(value)) {
    shadowTarget = {};
  }

  return shadowTarget;
}

var ObjectDotPrototype = Object.prototype;

function defaultValueIsObservable(value) {
  if (value === null) {
    return false;
  }

  if (_typeof(value) !== 'object') {
    return false;
  }

  if (isArray$1(value)) {
    return true;
  }

  var proto = _getPrototypeOf$1(value);

  return proto === ObjectDotPrototype || proto === null || _getPrototypeOf$1(proto) === null;
}

var defaultValueObserved = function defaultValueObserved(obj, key) {};

var defaultValueMutated = function defaultValueMutated(obj, key) {};

var defaultValueDistortion = function defaultValueDistortion(value) {
  return value;
};

function wrapDescriptor(membrane, descriptor, getValue) {
  var set = descriptor.set,
      get = descriptor.get;

  if (hasOwnProperty.call(descriptor, 'value')) {
    descriptor.value = getValue(membrane, descriptor.value);
  } else {
    if (!isUndefined$2(get)) {
      descriptor.get = function () {
        return getValue(membrane, get.call(unwrap(this)));
      };
    }

    if (!isUndefined$2(set)) {
      descriptor.set = function (value) {
        set.call(unwrap(this), membrane.unwrapProxy(value));
      };
    }
  }

  return descriptor;
}

var ReactiveMembrane = function () {
  function ReactiveMembrane(options) {
    _classCallCheck(this, ReactiveMembrane);

    this.valueDistortion = defaultValueDistortion;
    this.valueMutated = defaultValueMutated;
    this.valueObserved = defaultValueObserved;
    this.valueIsObservable = defaultValueIsObservable;
    this.objectGraph = new WeakMap();

    if (!isUndefined$2(options)) {
      var valueDistortion = options.valueDistortion,
          valueMutated = options.valueMutated,
          valueObserved = options.valueObserved,
          valueIsObservable = options.valueIsObservable;
      this.valueDistortion = isFunction$1(valueDistortion) ? valueDistortion : defaultValueDistortion;
      this.valueMutated = isFunction$1(valueMutated) ? valueMutated : defaultValueMutated;
      this.valueObserved = isFunction$1(valueObserved) ? valueObserved : defaultValueObserved;
      this.valueIsObservable = isFunction$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
    }
  }

  _createClass(ReactiveMembrane, [{
    key: "getProxy",
    value: function getProxy(value) {
      var unwrappedValue = unwrap(value);
      var distorted = this.valueDistortion(unwrappedValue);

      if (this.valueIsObservable(distorted)) {
        var o = this.getReactiveState(unwrappedValue, distorted);
        return o.readOnly === value ? value : o.reactive;
      }

      return distorted;
    }
  }, {
    key: "getReadOnlyProxy",
    value: function getReadOnlyProxy(value) {
      value = unwrap(value);
      var distorted = this.valueDistortion(value);

      if (this.valueIsObservable(distorted)) {
        return this.getReactiveState(value, distorted).readOnly;
      }

      return distorted;
    }
  }, {
    key: "unwrapProxy",
    value: function unwrapProxy(p) {
      return unwrap(p);
    }
  }, {
    key: "getReactiveState",
    value: function getReactiveState(value, distortedValue) {
      var objectGraph = this.objectGraph;
      var reactiveState = objectGraph.get(distortedValue);

      if (reactiveState) {
        return reactiveState;
      }

      var membrane = this;
      reactiveState = {
        get reactive() {
          var reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);
          var proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
          registerProxy(proxy, value);
          ObjectDefineProperty(this, 'reactive', {
            value: proxy
          });
          return proxy;
        },

        get readOnly() {
          var readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);
          var proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
          registerProxy(proxy, value);
          ObjectDefineProperty(this, 'readOnly', {
            value: proxy
          });
          return proxy;
        }

      };
      objectGraph.set(distortedValue, reactiveState);
      return reactiveState;
    }
  }]);

  return ReactiveMembrane;
}();

export { Connection, ConnectionManager, CustomURLSearchParams, ExpressionService, MessageChannelConnection, Observable, PostMessageConnection, ReactiveMembrane, Subscription, WireValueChangeObservers, clone, configureObservers, createWireAdapterFactory, formatLabel, generateGuid, isArray, isEqual, isFunction, isObject, isUndefined, isUndefinedOrNull, isValidNumber, labelComparator, labelFilter, multiComparatorGenerator, nameComparator, scrubURLDomain, shallowCopy, stringPropertyComparator, throttle };
