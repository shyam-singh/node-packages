/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { utils as domUtil } from '../../lbf/interactions';
import { getElementSelector, toggleInteractionsProxies } from './utils';

const ESCAPE_KEY_NAME = 'Escape';

let inlineEditModeEnabled = false;
let activeRteItemId = null;

function enableInlineEditMode(postMessageManager) {
    // disable proxies
    toggleInteractionsProxies(false);
    inlineEditModeEnabled = true;

    postMessageManager.sendPostmessage(window.parent, 'enter-inline-editor-mode');
}

function disableInlineEditMode(postMessageManager) {
    // re-enable proxies
    toggleInteractionsProxies(true);
    inlineEditModeEnabled = false;

    activeRteItemId = null;
    // TODO - W-7346490
    // this event re-opens the prop editor but it immediately gets closed
    // due to unselect-element being fired (LWR only)
    postMessageManager.sendPostmessage(window.parent, 'exit-inline-editor-mode');
}

/**
 * Handler for interactinos state changes. This will be notified by the stateObserver
 * when a state change happens and when the selection changes, we exit inline edit mode (if needed)
 * @param  {object} property the property of the interaction state object that has changed
 */
function handleStateChange(property, postMessageManager) {
    if (property === 'current' && inlineEditModeEnabled) {
        disableEditorMode(postMessageManager);
    }
}

function getRteCmp(itemId) {
    let rteCmp;
    const cmpWrapper = domUtil.querySelector(document, getElementSelector(itemId));
    if (cmpWrapper) {
        const designCmp = cmpWrapper.querySelector('.actualNode').children[0];
        rteCmp = designCmp.shadowRoot.children[0];
    }
    return rteCmp;
}

function saveContent(itemId, value, postMessageManager) {
    postMessageManager.sendPostmessage(window.parent, 'save-contentblock', {
        guid: itemId,
        content: value,
    });
}

function enableEditorMode(itemId, postMessageManager) {
    enableInlineEditMode(postMessageManager);

    const rteCmp = getRteCmp(itemId);

    // exit on Escape
    rteCmp.addEventListener('keydown', evt => {
        if (ESCAPE_KEY_NAME === evt.key) {
            disableEditorMode(postMessageManager);
        }
    });

    // prevent RTE being un-selected when user clicks on a font
    // picker option that floats outside the RTE rendered area
    rteCmp.addEventListener('mousedown', evt => {
        evt.stopPropagation();
    });

    rteCmp.enterEditorMode();
    activeRteItemId = itemId;
}

function disableEditorMode(postMessageManager) {
    if (activeRteItemId) {
        const rteCmp = getRteCmp(activeRteItemId);
        if (rteCmp) {
            rteCmp.exitEditorMode();
            saveContent(activeRteItemId, rteCmp.richTextValue, postMessageManager);
        }

        disableInlineEditMode(postMessageManager);
    }
}

export { enableEditorMode, handleStateChange };
