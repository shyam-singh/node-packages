/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { generateUrl, subscribe } from 'webruntime/routingService';
import basePath from '@app/basePath';

/**
 * Starts an event handler for route change event.
 * Resets @lbf/interactions and sends route metadata to the builder.
 */
function startRouteListeners(postMessageManager, interactionsCore) {
    subscribe(async (currentRoute = {}, currentRouteDef) => {
        const { attributes = {}, state = {} } = currentRoute;
        const currentParams = { ...state, ...attributes };

        interactionsCore.invalidateAllElementCache();
        if (window.interactionsEnabled) {
            interactionsCore.enable();
        } else {
            interactionsCore.disable();
        }

        const resolvedRouteUrl = await getResolvedPath(currentRoute);
        postMessageManager.sendPostmessage(window.parent, 'route-change-success', {
            resolvedRouteUrl,
            routeId: currentRouteDef.id,
            routeParams: currentParams,
            routeUrl: currentRouteDef.path,
            viewId: currentRouteDef.viewId,
        });
    });
}

/**
 * Gets the resolved URL path by compiling parameters into the current route path, minus the basePath.
 * @param {route} currentRoute the current route
 */
async function getResolvedPath(currentRoute) {
    const { attributes = {}, state = {} } = currentRoute;
    let emptyState = {}; // we don't need any additional state params
    if (currentRoute.type === 'standard__search') { // ...unless it's the Search route
        emptyState = {
            term: state.term
        };
    }
    const resolvedRouteUrl = await generateUrl({ 
        type: currentRoute.type,
        attributes,
        state: emptyState
    });
    return resolvedRouteUrl ? resolvedRouteUrl.slice(basePath.length) : ''; // remove basePath
}

export { startRouteListeners };
