/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

/* eslint-disable */
(() => {
    window.cb_isChrome =
        !!window.chrome && !window.opera && window.navigator.userAgent.indexOf('Edge') === -1;

    // Only add the CSP violation listener for Chrome since it's the only browser that supports
    // the correct value for the 'disposition' attribute for CSP3 that indicates if the violation
    // is 'enforce' vs 'report'.  For communities with Grandfathered CSP security policy, CSP
    // violations will be for reporting purposes only which should not be surfaced in the builder.
    if (window.cb_isChrome) {
        window.cb_cspViolationListener = function(e) {
            if (e.disposition === 'enforce') {
                var violation = e.violatedDirective + '_' + e.blockedURI;
                window.cb_cspViolations = window.cb_cspViolations || {};
                if (!window.cb_cspViolations[violation]) {
                    window.cb_cspViolations[violation] = {
                        violatedDirective: e.violatedDirective,
                        blockedURI: e.blockedURI,
                    };
                }
            }
        };

        document.addEventListener('securitypolicyviolation', window.cb_cspViolationListener);
    }
})();

Webruntime.define('webruntimedesign', ['webruntime_loader/loader', 'lwc', 'webruntime/routingService', '@app/basePath'], function (loader, lwc, routingService, basePath) { 'use strict';

  var loader__default = 'default' in loader ? loader['default'] : loader;
  basePath = basePath && basePath.hasOwnProperty('default') ? basePath['default'] : basePath;

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var StateService = function () {
    function StateService() {
      var observers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, StateService);

      this.observers = observers;
      this.state = observable({
        dragging: false,
        x: 0,
        y: 0,
        current: null,
        originExternal: false,
        originX: null,
        originY: null,
        enabled: true,
        proxiesEnabled: true
      }, this.observers);
    }

    _createClass(StateService, [{
      key: "registerObserver",
      value: function registerObserver(observer) {
        this.observers.push(observer);
      }
    }, {
      key: "getState",
      value: function getState() {
        return this.state;
      }
    }]);

    return StateService;
  }();

  function observable(object, observers) {
    var proxyHandler = {
      set: function set(obj, prop, val) {
        observers.forEach(function (observer) {
          observer(obj, prop, val);
        });

        if (typeof Reflect !== 'undefined' && typeof Reflect.set === 'function') {
          return Reflect.set(obj, prop, val);
        } else {
          obj[prop] = val;
          return true;
        }
      }
    };
    return new Proxy(object, proxyHandler);
  }

  var HandledCache = function () {
    function HandledCache() {
      _classCallCheck(this, HandledCache);

      this.cache = {};
    }

    _createClass(HandledCache, [{
      key: "add",
      value: function add(key, item, handler) {
        if (!this.cache[key]) {
          this.cache[key] = item;
          handler(key, item);
        }
      }
    }, {
      key: "invalidate",
      value: function invalidate(key) {
        delete this.cache[key];
      }
    }, {
      key: "invalidateAll",
      value: function invalidateAll() {
        delete this.cache;
        this.cache = {};
      }
    }, {
      key: "getAll",
      value: function getAll() {
        return Object.values(this.cache);
      }
    }, {
      key: "get",
      value: function get(key) {
        return this.cache[key];
      }
    }]);

    return HandledCache;
  }();

  function closest(el, selector) {
    if (el.matches && el.matches(selector)) {
      return el;
    }

    if (el.assignedSlot) {
      return closest(el.assignedSlot, selector);
    }

    if (el.parentElement) {
      return closest(el.parentElement, selector);
    }

    if (el.parentNode && el.parentNode.nodeType === 1) {
      return closest(el.parentNode, selector);
    } else if (el.parentNode && el.parentNode.nodeType === 11 && el.parentNode.host) {
      return closest(el.parentNode.host, selector);
    }

    return null;
  }

  function querySelectorAll(node, selector) {
    var result = [];
    var selected = node.querySelectorAll && node.querySelectorAll(selector);

    if (selected) {
      result = [].concat(_toConsumableArray(result), _toConsumableArray(selected));
    }

    var walker = document.createTreeWalker(node, NodeFilter.SHOW_ALL, null, false);

    do {
      var currentNode = walker.currentNode;

      if (currentNode.shadowRoot) {
        result = result.concat(querySelectorAll(currentNode.shadowRoot, selector));
      }
    } while (walker.nextNode());

    return result;
  }

  function querySelector(node, selector) {
    var walker = document.createTreeWalker(node);
    var result = node.querySelector && node.querySelector(selector);

    if (result) {
      return result;
    }

    do {
      var currentNode = walker.currentNode;

      if (currentNode.shadowRoot) {
        result = querySelector(currentNode.shadowRoot, selector);

        if (result) {
          return result;
        }
      }

      if (currentNode instanceof HTMLSlotElement) {
        var slotNodes = currentNode.assignedNodes();

        for (var i = 0; i < slotNodes.length; i++) {
          result = querySelector(slotNodes[i], selector);

          if (result) {
            return result;
          }
        }
      }
    } while (walker.nextNode() && !result);

    return null;
  }

  function isCoordInElement(element, x, y) {
    function between(value, min, max) {
      return value >= min && value <= max;
    }

    var coord = getElementCoords(element);
    return between(x, coord.minX, coord.maxX) && between(y, coord.minY, coord.maxY);
  }

  function calculateDropPosition(components, x, y, getComponentKey) {
    var dimensions = components.map(function (component) {
      var rect = component.getBoundingClientRect();
      return {
        x: rect.left,
        y: rect.top,
        width: rect.width,
        height: rect.height,
        beforeId: getComponentKey(component)
      };
    });
    return calculateDropPositionFromDimensions(dimensions, x, y);
  }

  function calculateDropPositionFromDimensions(dimensions, x, y) {
    var closestSlot = null;
    dimensions.forEach(function (dimension, index, componentsArray) {
      var topSlot = {
        x: dimension.x,
        y: dimension.y,
        width: dimension.width,
        beforeId: dimension.beforeId,
        position: 'top',
        distance: 0
      };
      var bottomSlot = {
        x: dimension.x,
        y: dimension.y + dimension.height,
        width: dimension.width,
        beforeId: '',
        position: 'bottom',
        distance: 0
      };
      topSlot.distance = Math.abs(topSlot.x - x) + Math.abs(topSlot.y - y);
      bottomSlot.distance = Math.abs(bottomSlot.x - x) + Math.abs(bottomSlot.y - y);
      var closerSlot;

      if (index !== componentsArray.length - 1) {
        closerSlot = topSlot;
      } else {
        closerSlot = topSlot.distance < bottomSlot.distance ? topSlot : bottomSlot;
      }

      closestSlot = closestSlot && closestSlot.distance < closerSlot.distance ? closestSlot : closerSlot;
    });
    return closestSlot;
  }

  function getChildElementsInContainer(container, elementSelector, containerSelector) {
    if (container.parentNode) {
      var wrapper = container.parentNode.toString() === '[object ShadowRoot]' ? container.parentNode.host : container;
      return querySelectorAll(wrapper, elementSelector).filter(function (cmp) {
        return closest(cmp, containerSelector) === container;
      });
    }

    return [];
  }

  function deepCloneNode(node) {
    var clone = node.cloneNode(false);
    var childNodes;

    if (node.shadowRoot) {
      childNodes = node.shadowRoot.children;
    } else {
      childNodes = node.children;
    }

    for (var i = 0; i < childNodes.length; i++) {
      clone.appendChild(deepCloneNode(childNodes[i]));
    }

    return clone;
  }

  function getElementCoords(element) {
    var rect = element.getBoundingClientRect();
    var minX = rect.left;
    var minY = rect.top;
    var maxX = minX + rect.width;
    var maxY = minY + rect.height;
    return {
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  }

  function getClosestItemWithFilter(items, x, y, filter) {
    var found = items.filter(function (i) {
      return filter(i) && isCoordInElement(i.element, x, y);
    });

    if (found.length === 1) {
      return found[0];
    }

    if (found.length > 1) {
      return getInnerMostItem(found);
    }

    return null;
  }

  function getClosestItem(items, x, y) {
    return getClosestItemWithFilter(items, x, y, function (element) {
      return true;
    });
  }

  function getInnerMostItem(items) {
    var coordsArray = items.map(function (i) {
      return getElementCoords(i.element);
    });
    var idx = getInnerMostCoordsIdx(coordsArray);
    return items[idx];
  }

  function getInnerMostCoordsIdx(coordsArray) {
    var result = 0;
    var winner = coordsArray[result];

    for (var idx = 1; idx < coordsArray.length; ++idx) {
      var other = coordsArray[idx];

      if (isLeftInsideRightCoords(other, winner)) {
        winner = other;
        result = idx;
      }
    }

    return result;
  }

  function isLeftInsideRightCoords(left, right) {
    return left.minX >= right.minX && left.minY >= right.minY && left.maxX <= right.maxX && left.maxY <= right.maxY;
  }

  var InteractionsElement = function () {
    function InteractionsElement(element, config, domEventHandlers) {
      _classCallCheck(this, InteractionsElement);

      this.enabled = true;
      this.domEventHandlers = domEventHandlers;
      this.element = element;
      this.handlers = config.handlers;
      this.propertySelectors = config.propertySelectors;
      this.key = config.key(this.element);
      this.isContainer = false;
      this.isSelectable = false;
      this.isDeletable = false;
      this.isMovable = false;
      this.containsInteractionsElements = false;
      this.processProperties();
    }

    _createClass(InteractionsElement, [{
      key: "init",
      value: function init(enabled, elementState) {
        if (enabled) {
          this.enable(elementState);
        } else {
          this.disable();
        }
      }
    }, {
      key: "enable",
      value: function enable(elementState) {
        this.enabled = true;
        this.toggleDomEventHandlers();
        this.processHandlers('enable', {
          payload: elementState
        });
      }
    }, {
      key: "disable",
      value: function disable() {
        this.enabled = false;
        this.toggleDomEventHandlers();
        this.processHandlers('disable');
      }
    }, {
      key: "toggleDomEventHandlers",
      value: function toggleDomEventHandlers() {
        var _this = this;

        Object.keys(this.domEventHandlers).forEach(function (eventName) {
          if (_this.domEventHandlers[eventName]) {
            if (_this.enabled) {
              _this.element.addEventListener(eventName, _this.domEventHandlers[eventName]);
            } else {
              _this.element.removeEventListener(eventName, _this.domEventHandlers[eventName]);
            }
          }
        });
      }
    }, {
      key: "processProperties",
      value: function processProperties() {
        var _this2 = this;

        Object.keys(this.propertySelectors).forEach(function (propertyKey) {
          _this2[propertyKey] = _this2.element.matches(_this2.propertySelectors[propertyKey]);
        });

        if (querySelector(this.element, "".concat(this.propertySelectors.isSelectable, ",").concat(this.propertySelectors.isContainer))) {
          this.containsInteractionsElements = true;
        }
      }
    }, {
      key: "processHandlers",
      value: function processHandlers(method, params) {
        if (this.handlers && this.handlers[method]) {
          this.handlers[method]({
            context: this,
            params: params
          });
        }
      }
    }]);

    return InteractionsElement;
  }();

  var ElementService = function () {
    function ElementService(stateService, proxyService, config, selectHandler) {
      _classCallCheck(this, ElementService);

      this.selectHandler = selectHandler;
      this.selector = config.selector;
      this.cache = new HandledCache();
      this.stateService = stateService;
      this.proxyService = proxyService;
      this.config = config;
    }

    _createClass(ElementService, [{
      key: "scan",
      value: function scan(_ref) {
        var _this3 = this;

        var scope = _ref.scope;
        var cachedElements = this.cache.getAll();
        cachedElements.forEach(function (cachedElement) {
          if (!cachedElement.element.parentNode) {
            _this3.cache.invalidate(cachedElement.key);
          }
        });
        var elements = querySelectorAll(scope, this.selector);
        elements.forEach(function (element) {
          var interactionsElement = new InteractionsElement(element, _this3.config, {
            keypress: _this3.keypressHandler.bind(_this3),
            focus: _this3.focusHandler.bind(_this3)
          });

          _this3.cache.add(interactionsElement.key, interactionsElement, function (k, item) {
            interactionsElement.init(_this3.stateService.getState().enabled, {
              key: k,
              item: item
            });
          });
        });
      }
    }, {
      key: "getAll",
      value: function getAll() {
        return this.cache.getAll();
      }
    }, {
      key: "get",
      value: function get(key) {
        return this.cache.get(key);
      }
    }, {
      key: "invalidate",
      value: function invalidate(key) {
        this.cache.invalidate(key);
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        var _this4 = this;

        var found = this.cache.get(key);

        if (found) {
          var children = querySelectorAll(found.element, this.config.selector);
          children.map(function (el) {
            return _this4.config.key(el);
          }).forEach(function (innerKey) {
            if (innerKey) {
              _this4.invalidate(innerKey);
            }
          });
          found.element.remove();
          this.invalidate(key);
        }
      }
    }, {
      key: "invalidateAll",
      value: function invalidateAll() {
        return this.cache.invalidateAll();
      }
    }, {
      key: "enableAll",
      value: function enableAll(elementState) {
        this.cache.getAll().forEach(function (element) {
          return element.enable(elementState);
        });
      }
    }, {
      key: "disableAll",
      value: function disableAll() {
        this.cache.getAll().forEach(function (element) {
          return element.disable();
        });
      }
    }, {
      key: "findSelectableElementInCoord",
      value: function findSelectableElementInCoord(x, y) {
        return getClosestItemWithFilter(this.cache.getAll(), x, y, function (element) {
          return element.isSelectable;
        });
      }
    }, {
      key: "select",
      value: function select(key) {
        var interactionsElement = this.get(key);
        this.proxyService.select(interactionsElement);

        if (this.selectHandler) {
          this.selectHandler(interactionsElement);
        }
      }
    }, {
      key: "focusHandler",
      value: function focusHandler(event) {
        if (!event.target) return;
        var target = event.target;

        if (closest(target, this.proxyService.selector)) {
          return;
        }

        var el = closest(target, this.config.selector);

        if (el) {
          var interactionsElement = this.get(this.config.key(el));
          this.proxyService.focus(interactionsElement);
        }

        event.preventDefault();
        event.stopPropagation();
      }
    }, {
      key: "keypressHandler",
      value: function keypressHandler(event) {
        if (event.key === 'Enter' && event.target.matches(this.config.propertySelectors.isSelectable)) {
          this.select(this.config.key(event.target));
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }]);

    return ElementService;
  }();

  var PROXY_SELECTOR = 'interactions-proxy';

  var InteractionsProxy = function () {
    function InteractionsProxy(name, getProxyContainer, handlers) {
      _classCallCheck(this, InteractionsProxy);

      this.name = name;
      this.handlers = handlers;
      this.state = null;
      this.getProxyContainer = getProxyContainer;
      this.enabled = true;
      this.element = document.createElement('div');
      this.element.classList.add(PROXY_SELECTOR, "".concat(PROXY_SELECTOR, "-").concat(name));
      this.element.setAttribute('data-proxy-name', name);
      this.processHandlers('init');
    }

    _createClass(InteractionsProxy, [{
      key: "enable",
      value: function enable(proxyState) {
        this.enabled = true;
        this.state = proxyState;
        this.container = this.getProxyContainer(this.name, proxyState);

        if (this.container && !(this.element.parentNode === this.container)) {
          this.container.appendChild(this.element);
        }

        if (proxyState && proxyState.element && proxyState.element.containsInteractionsElements) {
          this.element.style.pointerEvents = 'none';
        }

        this.processHandlers('enable', {
          payload: proxyState,
          context: this
        });
      }
    }, {
      key: "disable",
      value: function disable() {
        if (this.container) {
          this.container.removeChild(this.element);
          this.container = undefined;
        }

        this.enabled = false;
        this.processHandlers('disable');
      }
    }, {
      key: "processHandlers",
      value: function processHandlers(method, params) {
        if (this.handlers && this.handlers[method]) {
          this.handlers[method]({
            key: this.name,
            element: this.element,
            params: params
          });
        }
      }
    }]);

    return InteractionsProxy;
  }();

  var ProxyService = function () {
    function ProxyService(key, config) {
      var _this = this;

      _classCallCheck(this, ProxyService);

      this.selector = PROXY_SELECTOR;
      this.key = key;
      this.proxies = {};
      Object.keys(config).forEach(function (proxyConfigKey) {
        _this.proxies[proxyConfigKey] = new InteractionsProxy(proxyConfigKey, config.getContainerOnEnable, config[proxyConfigKey]);
      });
    }

    _createClass(ProxyService, [{
      key: "enableAll",
      value: function enableAll(proxyState) {
        Object.values(this.proxies).forEach(function (proxy) {
          return proxy.enable(proxyState);
        });
      }
    }, {
      key: "disableAll",
      value: function disableAll() {
        Object.values(this.proxies).forEach(function (proxy) {
          return proxy.disable();
        });
      }
    }, {
      key: "focus",
      value: function focus(element) {
        this.proxies.hover.enable({
          element: element
        });
      }
    }, {
      key: "select",
      value: function select(element) {
        this.proxies.select.enable({
          element: element
        });
      }
    }]);

    return ProxyService;
  }();

  function updateHoverProxy(_ref) {
    var x = _ref.x,
        y = _ref.y,
        components = _ref.components,
        componentHoverProxy = _ref.componentHoverProxy,
        dragging = _ref.dragging,
        component = _ref.component,
        enabled = _ref.enabled;
    var found = getClosestItem(components, x, y);

    if (enabled && found && !dragging && component !== found) {
      componentHoverProxy.enable({
        element: found,
        x: x,
        y: y
      });
    } else {
      componentHoverProxy.disable();
    }
  }

  function updateSelectProxy(_ref2) {
    var component = _ref2.component,
        componentProxy = _ref2.componentProxy,
        enabled = _ref2.enabled;

    if (component && enabled) {
      componentProxy.enable({
        element: component
      });
    } else {
      componentProxy.disable();
    }
  }

  function updateDropTargetProxy(_ref3) {
    var x = _ref3.x,
        y = _ref3.y,
        regions = _ref3.regions,
        dropTargetProxy = _ref3.dropTargetProxy,
        dragging = _ref3.dragging,
        component = _ref3.component,
        enabled = _ref3.enabled,
        getComponentKey = _ref3.getComponentKey,
        elementSelector = _ref3.elementSelector,
        containerSelector = _ref3.containerSelector;

    if (enabled && dragging) {
      var foundRegion = getClosestItem(regions, x, y);

      if (foundRegion) {
        var components = getChildElementsInContainer(foundRegion.element, elementSelector, containerSelector);
        var position;

        if (components && components.length > 0) {
          position = calculateDropPosition(components, x, y, getComponentKey) || undefined;
        }

        dropTargetProxy.enable({
          position: position,
          x: x,
          y: y,
          container: foundRegion,
          element: component
        });
      } else {
        dropTargetProxy.disable();
      }
    } else {
      dropTargetProxy.disable();
    }
  }

  function updateDragProxy(_ref4) {
    var x = _ref4.x,
        y = _ref4.y,
        component = _ref4.component,
        dragging = _ref4.dragging,
        originExternal = _ref4.originExternal,
        componentCloneProxy = _ref4.componentCloneProxy,
        enabled = _ref4.enabled;

    if (enabled && dragging && !originExternal && component) {
      componentCloneProxy.enable({
        x: x,
        y: y,
        element: component
      });
    } else {
      componentCloneProxy.disable();
    }
  }

  function attachDocumentListeners(_ref) {
    var stateService = _ref.stateService,
        findElement = _ref.findElement,
        clickHandler = _ref.clickHandler,
        dropHandler = _ref.dropHandler,
        dragConfiguration = _ref.dragConfiguration;
    var dragStartDistance = dragConfiguration ? dragConfiguration.dragStartDistance : 20;
    document.addEventListener('mousemove', function (event) {
      var state = stateService.getState();

      if (!state.enabled) {
        return;
      }

      state.x = event.clientX;
      state.y = event.clientY;

      if (!isUndefinedOrNull(state.originX) && !isUndefinedOrNull(state.originY) && !state.dragging && state.current) {
        if (Math.abs(state.originX - state.x) + Math.abs(state.originY - state.y) > dragStartDistance) {
          state.dragging = true;
        }
      }

      if (state.dragging) {
        event.preventDefault();
      }
    });
    document.addEventListener('mouseup', function (event) {
      var state = stateService.getState();

      if (!state.enabled || !(event.button === 0)) {
        return;
      }

      state.x = event.clientX;
      state.y = event.clientY;

      if (state.current) {
        if (state.dragging) {
          dropHandler(state);
          state.current = null;
        } else {
          clickHandler(state);
        }
      }

      state.originX = null;
      state.originY = null;
      state.dragging = false;
    });
    document.addEventListener('mousedown', function (event) {
      var state = stateService.getState();

      if (!state.enabled || !(event.button === 0)) {
        return;
      }

      state.x = event.clientX;
      state.y = event.clientY;
      var found = findElement(state);

      if (found) {
        event.preventDefault();
        state.originX = state.x;
        state.originY = state.y;

        if (found !== state.current) {
          state.current = found;
        }
      } else {
        state.current = null;
      }
    });
  }

  function isUndefinedOrNull(object) {
    return typeof object === 'undefined' || object === null;
  }

  function attachWindowListeners(_ref) {
    var stateService = _ref.stateService;
    window.addEventListener('blur', function () {
      var state = stateService.getState();
      state.originX = null;
      state.originY = null;
    });
  }

  var Interactions = function () {
    function Interactions(_ref) {
      var _this = this;

      var key = _ref.key,
          scope = _ref.scope,
          configuration = _ref.configuration;

      _classCallCheck(this, Interactions);

      this.scope = scope;
      this.configuration = configuration;
      var _this$configuration = this.configuration,
          _dropHandler = _this$configuration.dropHandler,
          selectHandler = _this$configuration.selectHandler,
          stateObserver = _this$configuration.stateObserver;
      var observers = [function (obj, prop, val) {
        if (prop === 'x' || prop === 'y' || prop === 'dragging') {
          obj[prop] = val;

          _this.render(obj.x, obj.y);
        }
      }];

      if (stateObserver) {
        observers = [stateObserver.bind(this)].concat(_toConsumableArray(observers));
      }

      this.stateService = new StateService(observers);
      this.proxyService = new ProxyService(key, configuration.proxy);
      this.elementService = new ElementService(this.stateService, this.proxyService, this.configuration.element, selectHandler);
      this.scan();
      attachDocumentListeners({
        stateService: this.stateService,
        findElement: function findElement(state) {
          return _this.elementService.findSelectableElementInCoord(state.x, state.y);
        },
        dropHandler: function dropHandler() {
          if (_dropHandler) {
            _dropHandler(_this.proxyService.proxies.dropTarget ? _this.proxyService.proxies.dropTarget.state : null);
          }
        },
        clickHandler: function clickHandler(state) {
          if (selectHandler) {
            selectHandler(state.current);
          }
        },
        dragConfiguration: this.configuration.drag
      });
      attachWindowListeners({
        stateService: this.stateService
      });
    }

    _createClass(Interactions, [{
      key: "enable",
      value: function enable() {
        this.stateService.getState().enabled = true;
        this.elementService.enableAll();
      }
    }, {
      key: "disable",
      value: function disable() {
        this.stateService.getState().enabled = false;
        this.elementService.disableAll();
        this.proxyService.disableAll();
      }
    }, {
      key: "enableProxies",
      value: function enableProxies() {
        this.stateService.getState().proxiesEnabled = true;
      }
    }, {
      key: "disableProxies",
      value: function disableProxies() {
        this.stateService.getState().proxiesEnabled = false;
        this.proxyService.disableAll();
      }
    }, {
      key: "scan",
      value: function scan() {
        this.elementService.scan({
          scope: this.scope
        });
      }
    }, {
      key: "poll",
      value: function poll(interval) {
        var _this2 = this;

        setInterval(this.scan.bind(this), interval);
        setInterval(function () {
          var _this2$stateService$g = _this2.stateService.getState(),
              x = _this2$stateService$g.x,
              y = _this2$stateService$g.y;

          _this2.render(x, y);
        }, interval);
      }
    }, {
      key: "render",
      value: function render(x, y) {
        var _this$stateService$ge = this.stateService.getState(),
            current = _this$stateService$ge.current,
            dragging = _this$stateService$ge.dragging,
            enabled = _this$stateService$ge.enabled,
            proxiesEnabled = _this$stateService$ge.proxiesEnabled;

        var elements = this.elementService.getAll();

        if (proxiesEnabled) {
          updateHoverProxy({
            x: x,
            y: y,
            components: elements.filter(function (element) {
              return element.isSelectable;
            }),
            componentHoverProxy: this.proxyService.proxies.hover,
            dragging: dragging,
            component: current,
            enabled: enabled
          });
          updateSelectProxy({
            component: current,
            componentProxy: this.proxyService.proxies.select,
            enabled: enabled
          });
          updateDragProxy({
            x: x,
            y: y,
            component: current,
            dragging: this.stateService.getState().dragging,
            originExternal: this.stateService.getState().originExternal,
            componentCloneProxy: this.proxyService.proxies.drag,
            enabled: enabled
          });

          if (this.proxyService.proxies.dropTarget) {
            updateDropTargetProxy({
              x: x,
              y: y,
              regions: elements.filter(function (element) {
                return element.isContainer;
              }),
              dropTargetProxy: this.proxyService.proxies.dropTarget,
              dragging: this.stateService.getState().dragging,
              component: current,
              enabled: enabled,
              getComponentKey: this.configuration.element.key,
              elementSelector: this.configuration.element.propertySelectors.isSelectable,
              containerSelector: this.configuration.element.propertySelectors.isContainer
            });
          }
        }
      }
    }, {
      key: "dragStart",
      value: function dragStart(_ref2) {
        var mouseX = _ref2.mouseX,
            mouseY = _ref2.mouseY;
        var state = this.stateService.getState();
        state.x = mouseX;
        state.y = mouseY;
        state.dragging = true;
        state.originExternal = true;
      }
    }, {
      key: "dragUpdate",
      value: function dragUpdate(_ref3) {
        var mouseX = _ref3.mouseX,
            mouseY = _ref3.mouseY;
        var state = this.stateService.getState();
        state.x = mouseX;
        state.y = mouseY;
      }
    }, {
      key: "dragEnd",
      value: function dragEnd(_ref4) {
        var mouseX = _ref4.mouseX,
            mouseY = _ref4.mouseY;
        var state = this.stateService.getState();
        state.x = mouseX;
        state.y = mouseY;
        state.dragging = false;
        state.originExternal = false;
        return this.proxyService.proxies.dropTarget ? this.proxyService.proxies.dropTarget.state : null;
      }
    }, {
      key: "selectComponent",
      value: function selectComponent(key) {
        var state = this.stateService.getState();
        state.current = this.elementService.get(key);
      }
    }, {
      key: "getSelectedComponent",
      value: function getSelectedComponent() {
        return this.stateService.getState().current;
      }
    }, {
      key: "invalidateComponentCache",
      value: function invalidateComponentCache(key) {
        var state = this.stateService.getState();
        this.elementService.invalidate(key);
        state.current = null;
      }
    }, {
      key: "invalidateAllElementCache",
      value: function invalidateAllElementCache() {
        var state = this.stateService.getState();
        this.elementService.invalidateAll();
        state.current = null;
      }
    }, {
      key: "deleteComponent",
      value: function deleteComponent(key) {
        var keepSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var state = this.stateService.getState();
        this.elementService.delete(key);

        if (state.current && state.current.key === key && !keepSelected) {
          state.current = null;
        }
      }
    }]);

    return Interactions;
  }();

  var BASE_Z_INDEX = 999;
  var elementHandlerMap = {
    enable: function enable(_ref) {
      var context = _ref.context;

      if (context.isContainer) {
        Object.assign(context.element.style, {
          border: '1px dashed #bbbbbb',
          margin: '15px',
          padding: '15px',
          'padding-bottom': 0,
          'min-height': '50px'
        });
      } else {
        Object.assign(context.element.style, {
          'margin-bottom': '15px'
        });
      }
    },
    disable: function disable(_ref2) {
      var context = _ref2.context;

      if (context.isContainer) {
        Object.assign(context.element.style, {
          border: '',
          margin: '',
          padding: '',
          'min-height': ''
        });
      } else {
        Object.assign(context.element.style, {
          'margin-bottom': ''
        });
      }
    }
  };
  var proxyConfiguration = {
    getContainerOnEnable: function getContainerOnEnable(key, proxyState) {
      if (key === 'dropTarget' && proxyState.container) {
        return querySelector(proxyState.container.element, '.proxy-container');
      } else if (proxyState.element) {
        return querySelector(proxyState.element.element, '.proxy-container');
      }

      return null;
    },
    dropTarget: {
      enable: function enable(_ref3) {
        var element = _ref3.element,
            params = _ref3.params;
        var position = params.payload.position;

        if (!position && params.payload.container) {
          var rect = params.payload.container.element.getBoundingClientRect();
          position = {
            x: rect.left,
            y: rect.top + rect.height / 2,
            width: rect.width,
            distance: 0,
            beforeId: '',
            position: 'middle'
          };
        }

        if (position) {
          var _position = position,
              x = _position.x,
              y = _position.y,
              width = _position.width;
          var style = {
            left: "".concat(window.scrollX + x, "px"),
            top: "".concat(window.scrollY + y, "px"),
            width: "".concat(width, "px"),
            position: 'absolute',
            height: "0px",
            borderTop: '2px solid red',
            backgroundColor: 'red',
            zIndex: BASE_Z_INDEX + 2,
            display: ''
          };
          Object.assign(element.style, style);
        } else {
          element.style.display = 'none';
        }
      },
      disable: function disable(_ref4) {
        var element = _ref4.element;
        element.style.display = 'none';
      }
    },
    select: {
      enable: function enable(_ref5) {
        var element = _ref5.element,
            params = _ref5.params;
        var component = params.payload.element;
        if (!component) return;
        var rect = component.element.getBoundingClientRect();
        var style = {
          display: 'block',
          width: "".concat(rect.width, "px"),
          height: "".concat(rect.height, "px"),
          outline: '2px solid #0059A7',
          position: 'absolute',
          top: "".concat(window.scrollY + rect.top, "px"),
          left: "".concat(window.scrollX + rect.left, "px"),
          zIndex: BASE_Z_INDEX + 1,
          cursor: 'grab'
        };
        Object.assign(element.style, style);
      },
      disable: function disable(_ref6) {
        var element = _ref6.element;
        element.style.display = 'none';
      }
    },
    drag: {
      enable: function enable(_ref7) {
        var element = _ref7.element,
            params = _ref7.params;
        var component = params.payload.element;
        if (!component) return;
        var rect = component.element.getBoundingClientRect();

        if (params.payload.x && params.payload.y) {
          var style = {
            display: 'block',
            position: 'fixed',
            left: "".concat(params.payload.x - rect.width / 2, "px"),
            top: "".concat(params.payload.y - rect.height / 2, "px"),
            height: "".concat(rect.height, "px"),
            width: "".concat(rect.width, "px"),
            border: '2px solid purple',
            backgroundColor: 'purple',
            opacity: 0.5,
            zIndex: BASE_Z_INDEX + 3
          };
          Object.assign(element.style, style);
        }
      },
      disable: function disable(_ref8) {
        var element = _ref8.element;
        element.style.display = 'none';
      }
    },
    hover: {
      enable: function enable(_ref9) {
        var element = _ref9.element,
            params = _ref9.params;
        var component = params.payload.element;
        if (!component) return;
        var rect = component.element.getBoundingClientRect();
        var style = {
          display: "block",
          width: "".concat(rect.width, "px"),
          height: "".concat(rect.height, "px"),
          outline: '2px solid rgb(65, 166, 255)',
          position: 'absolute',
          top: "".concat(window.scrollY + rect.top, "px"),
          left: "".concat(window.scrollX + rect.left, "px"),
          zIndex: BASE_Z_INDEX,
          cursor: 'pointer'
        };
        Object.assign(element.style, style);
      },
      disable: function disable(_ref10) {
        var element = _ref10.element;
        element.style.display = 'none';
      }
    }
  };
  var defaultConfig = {
    dropHandler: function dropHandler(state) {
      return console.log("Elem Dropped ".concat(state));
    },
    selectHandler: function selectHandler(obj) {
      return console.log("Elem selected ".concat(obj));
    },
    drag: {
      dragStartDistance: 20
    },
    springLoading: {
      delay: 30,
      validator: function validator(el) {
        return el.tagName === 'a' || el.tagName === 'button';
      }
    },
    element: {
      selector: '[data-item-id][data-interactions-item="true"]',
      handlers: elementHandlerMap,
      key: function key(el) {
        return el.getAttribute('data-item-id');
      },
      propertySelectors: {
        isContainer: '[data-allow-drop="true"]',
        isSelectable: '[data-allow-select="true"]',
        isDeletable: '[data-allow-delete="true"]',
        isMovable: '[data-allow-move="true"]'
      }
    },
    proxy: proxyConfiguration
  };

  if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector;
  }

  var utils = {
    querySelectorAll: querySelectorAll,
    querySelector: querySelector,
    isCoordInElement: isCoordInElement,
    deepCloneNode: deepCloneNode,
    closest: closest
  };

  function stylesheet(hostSelector, shadowSelector, nativeShadow) {
    return ".interactions-component" + shadowSelector + " {min-height: 40px;}\n";
  }
  var _implicitStylesheets = [stylesheet];

  function tmpl($api, $cmp, $slotset, $ctx) {
    return [];
  }

  var _tmpl = lwc.registerTemplate(tmpl);
  tmpl.stylesheets = [];
  tmpl.stylesheetTokens = {
    hostAttribute: "webruntimedesign-designComponent_designComponent-host",
    shadowAttribute: "webruntimedesign-designComponent_designComponent"
  };

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  class GeneratedComponent extends lwc.LightningElement {
    constructor(...args) {
      super(...args);
      this.generated = void 0;
      this.routeParams = {};
      this.attributes = void 0;
    }

    /**
     * Subscribe to route changes
     */
    async connectedCallback() {
      this.subscription = await routingService.subscribe(this.setRoute.bind(this));
    }
    /**
     * Sets route params attribute so attributes depending on it can resolve properly
     * Re-evaluates the component attributes on route change.
     */


    async setRoute({
      attributes,
      state
    }, routeParams = {}, queryParams = {}) {
      this.routeParams = _objectSpread({}, attributes, state, queryParams, routeParams); // When route is set, re-evaluate the cmp attributes so that some may resolve

      this.evaluateAttributes();
    }

    get generatedTemplate() {
      return this.generated;
    }

    set generatedTemplate(generated) {
      this.generated = generated;
      this.html = generated.html;
      this.evaluateAttributes();
    }
    /**
     * If the generated attributes are available, we will bind them to this component
     * Otherwise, use an empty object
     */


    evaluateAttributes() {
      this.attributes = this.generated && this.generated.attributes ? this.generated.attributes(this) : {};
    }

    render() {
      return this.html;
    }

    disconnectedCallback() {
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
    }

  }

  lwc.registerDecorators(GeneratedComponent, {
    publicProps: {
      generatedTemplate: {
        config: 3
      }
    },
    track: {
      attributes: 1
    },
    fields: ["generated", "routeParams"]
  });

  var designComponent = lwc.registerComponent(GeneratedComponent, {
    tmpl: _tmpl
  });

  function tmpl$1($api, $cmp, $slotset, $ctx) {
    const {
      c: api_custom_element,
      h: api_element
    } = $api;
    return [api_element("div", {
      classMap: {
        "interactions-component": true,
        "interactions-element": true
      },
      attrs: {
        "data-allow-select": "true",
        "data-allow-move": "true",
        "data-allow-delete": "true",
        "data-item-id": $cmp.componentId,
        "data-fqn": $cmp.componentName,
        "data-component-label": $cmp.label,
        "data-component-locked": $cmp.isLocked
      },
      key: 3
    }, [api_element("div", {
      classMap: {
        "actualNode": true
      },
      key: 1
    }, [$cmp.generatedTemplate ? api_custom_element("webruntimedesign-design-component", designComponent, {
      props: {
        "generatedTemplate": $cmp.generatedTemplate
      },
      key: 0
    }, []) : null]), api_element("div", {
      classMap: {
        "proxy-container": true
      },
      context: {
        lwc: {
          dom: "manual"
        }
      },
      key: 2
    }, [])])];
  }

  var _tmpl$1 = lwc.registerTemplate(tmpl$1);
  tmpl$1.stylesheets = [];

  if (_implicitStylesheets) {
    tmpl$1.stylesheets.push.apply(tmpl$1.stylesheets, _implicitStylesheets);
  }
  tmpl$1.stylesheetTokens = {
    hostAttribute: "webruntimedesign-componentWrapper_componentWrapper-host",
    shadowAttribute: "webruntimedesign-componentWrapper_componentWrapper"
  };

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /**
   * Namespaces used for design components
   */
  const DESIGN_COMPONENT_NAMESPACE = '@design';
  /**
   * Returns a module specifier for the design component with the given name
   */

  function getDesignComponentModuleSpecifier(name) {
    return `${DESIGN_COMPONENT_NAMESPACE}/${name}`;
  }

  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  async function generateComponent(id) {
    // resolve the module specifier, this will return either return the module URL
    // or the specifier itself depending or whether the module has alrerady been loaded
    const designSpecifier = getDesignComponentModuleSpecifier(id);
    const resolvedId = loader__default.resolve(designSpecifier); // delete the module from the registry to make sure we get a fresh copy

    loader__default.delete(designSpecifier); // get and return the fresh copy

    const module = await loader__default.load(resolvedId);
    return module.default;
  }

  var componentService = {
    generateComponent
  };

  class ComponentWrapper extends lwc.LightningElement {
    constructor(...args) {
      super(...args);
      this.componentId = void 0;
      this.label = void 0;
      this.componentName = void 0;
      this.isLocked = false;
      this.componentAttributes = void 0;
      this.generatedTemplate = void 0;
      this.childComponentAttached = false;
    }

    async renderedCallback() {
      await this.createChildComponentIfNotPresent();
    }

    async createChildComponentIfNotPresent() {
      if (this.childComponentAttached) {
        return;
      } // Fetch the generated component


      const generated = await componentService.generateComponent(this.componentId);
      this.generatedTemplate = generated;
      this.childComponentAttached = true;
    }

    async disconnectedCallback() {
      await this.destroyChildComponentIfPresent();
    }

    async destroyChildComponentIfPresent() {
      if (!this.childComponentAttached) {
        return;
      } // re-render without attached generated component


      this.generatedTemplate = null;
      this.childComponentAttached = false;
    }

  }

  lwc.registerDecorators(ComponentWrapper, {
    publicProps: {
      componentId: {
        config: 0
      },
      label: {
        config: 0
      },
      componentName: {
        config: 0
      },
      isLocked: {
        config: 0
      },
      componentAttributes: {
        config: 0
      }
    },
    track: {
      generatedTemplate: 1
    },
    fields: ["childComponentAttached"]
  });

  var componentWrapper = lwc.registerComponent(ComponentWrapper, {
    tmpl: _tmpl$1
  });

  let interactions = null;

  function setInteractions(instance) {
    interactions = instance;
  }

  function getInteractions() {
    return interactions;
  }

  var interactionsManager = {
    getInteractions,
    setInteractions
  };

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const BASE_Z_INDEX$1 = 99999;
  const POLLING_INTERVAL = 100;
  const ELEMENT_ID_ATTRIBUTE_NAME = 'data-item-id';
  const ELEMENT_FQN_ATTRIBUTE_NAME = 'data-fqn';
  const COMPONENT_LABEL_ATTRIBUTE_NAME = 'data-component-label';
  const ELEMENT_WRAPPER_CLASS = 'interactions-element';
  const COMPONENT_WRAPPER_CLASS = 'interactions-component';
  const REGION_LABEL_ATTRIBUTE_NAME = 'data-region-label';
  const REGION_NAME_ATTRIBUTE_NAME = 'data-region-name';
  const REGION_WRAPPER_CLASS = 'interactions-region';
  const REGION_WRAPPER_MANUAL_CLASS = 'manual';
  const REGION_WRAPPER_DROPZONE_CLASS = 'dropzone';
  const COMPONENT_WRAPPER_ELEMENT_NAME = 'webruntimedesign-component-wrapper';
  const SECTION_FQN = 'community_layout/section';
  const PROXY_LABEL_CLASS = 'proxy-select-label';
  const CONTENT_REGION_NAME = 'content';

  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  function getElementSelector(id) {
    return `.${ELEMENT_WRAPPER_CLASS}[${ELEMENT_ID_ATTRIBUTE_NAME}="${id}"]`;
  }

  function getContainingRegion(element) {
    return closestAncestor(`.${REGION_WRAPPER_CLASS}`, element);
  }

  function closestAncestor(selector, base = this) {
    function getClosestFrom(el) {
      if (!el || el === document || el === window) {
        return null;
      }

      const found = el.closest(selector);
      return found ? found : getClosestFrom(el.getRootNode().host);
    }

    return getClosestFrom(base);
  }

  function isOrIsDescendantOfType(typeSelector, baseElement) {
    return baseElement.matches(typeSelector) || !!closestAncestor(typeSelector, baseElement);
  }
  /**
   * Inserts a component into the container in a dropzone corresponding to the position of the component in the container.
   */


  function insertComponent({
    beforeId,
    containerId,
    component
  }) {
    const regionWrapperEl = utils.querySelector(document, getElementSelector(containerId)).parentNode.host;
    const beforeComponentWrapperEl = beforeId ? utils.querySelector(document, getElementSelector(beforeId)).parentNode.host : null;
    const dropzoneEl = findDropzoneEl({
      beforeId,
      regionWrapperEl,
      beforeComponentWrapperEl
    });
    insertItemToDropzoneEl({
      dropzoneEl,
      itemEl: component,
      beforeComponentWrapperEl
    });
  }

  function getValidLastRegion(dropzoneEls) {
    const current = dropzoneEls.pop(); // this implementation of closest checks the node passed in for equality before moving up
    // the tree, so we need to pass the parent of current here to find a true ancestor

    const closest = utils.closest(current.parentNode.host, `.${REGION_WRAPPER_DROPZONE_CLASS}`);

    if (dropzoneEls.some(el => el === closest)) {
      return getValidLastRegion(dropzoneEls);
    }

    return current;
  }
  /**
   * Find the correct lwc:dom="manual" dropzone element to insert the component into.
   * Due to the DOM manipulation limitation of LWC, all dynamic component CRUD is done in a dropzone.
   */


  function findDropzoneEl({
    beforeId,
    regionWrapperEl,
    beforeComponentWrapperEl
  }) {
    let dropzoneEl = null;

    if (beforeId) {
      // find if any of container's dropzone contains the beforeItem
      dropzoneEl = utils.querySelectorAll(regionWrapperEl, `.${REGION_WRAPPER_DROPZONE_CLASS}`).find(el => {
        return utils.querySelectorAll(el, getElementSelector(beforeId)).length > 0;
      }); // if found, we have our dropzone. If not, beforeItem is not in a dropzone and we grab it by index

      if (!dropzoneEl) {
        const indexOfBeforeComponentWrapperEl = Array.from(regionWrapperEl.children).indexOf(beforeComponentWrapperEl);
        const dropzoneWrapper = regionWrapperEl.children[indexOfBeforeComponentWrapperEl - 1];
        const dropzone = dropzoneWrapper.shadowRoot.querySelector(`.${REGION_WRAPPER_DROPZONE_CLASS}`);

        if (dropzone && dropzone.classList.contains(REGION_WRAPPER_DROPZONE_CLASS)) {
          dropzoneEl = dropzone;
        }
      }
    } else {
      // if beforeId is missing, we are inserting to the last of the dropzone in the region in the last position
      const dropzoneEls = utils.querySelectorAll(regionWrapperEl, `.${REGION_WRAPPER_DROPZONE_CLASS}`);

      if (dropzoneEls.length) {
        return getValidLastRegion(dropzoneEls);
      }

      return null;
    }

    return dropzoneEl;
  }
  /**
   * Inserts the item to the dropzone.
   */


  function insertItemToDropzoneEl({
    dropzoneEl,
    itemEl,
    beforeComponentWrapperEl
  }) {
    // checks whether the component is the first in the region.
    if (beforeComponentWrapperEl) {
      // checks whether the component prior to the current has already been moved to the dropzone.
      if (Array.from(dropzoneEl.children).includes(beforeComponentWrapperEl.shadowRoot.host)) {
        dropzoneEl.insertBefore(itemEl, beforeComponentWrapperEl);
      } else {
        dropzoneEl.appendChild(itemEl);
      }
    } else {
      dropzoneEl.appendChild(itemEl);
    }
  }
  /**
   * Wrapper for creating webruntimedesign/componentWrapper.
   */


  async function createComponent(properties) {
    return Object.assign(lwc.createElement(COMPONENT_WRAPPER_ELEMENT_NAME, {
      is: componentWrapper
    }), properties);
  }
  /**
   * Helper for checking whether the element is visible in the viewable page.
   */


  function isElementVisible(element) {
    return element.offsetWidth > 0 && element.offsetHeight > 0;
  }
  /**
   * Helper for fetching all region elements and updating their visibility, including their "manual" DOM.
   */


  function updateRegionsVisibility() {
    const regions = utils.querySelectorAll(document, `.${REGION_WRAPPER_CLASS}`);
    regions.forEach(region => updateRegionVisibility(region));
  }
  /**
   * Helper for updating region element's visibility, including its "manual" DOM.
   */


  function updateRegionVisibility(region) {
    const manual = utils.querySelector(region, `.${REGION_WRAPPER_MANUAL_CLASS}`);
    const isEmpty = utils.querySelector(region, `.${COMPONENT_WRAPPER_CLASS}`) === null;
    manual.style.display = isEmpty ? '' : 'none';
  }
  /**
   * Helper for toggling @lbf/interactions.
   * State is kept in `window.interactionsEnabled` for global access during design mode.
   */


  function toggleInteractions(isEnabled, interactionsCore) {
    window.interactionsEnabled = isEnabled;

    if (isEnabled) {
      interactionsCore.enable();
    } else {
      interactionsCore.disable();
    }
  }

  function toggleInteractionsProxies(isEnabled) {
    const interactions = interactionsManager.getInteractions();

    if (isEnabled) {
      interactions.enableProxies();
    } else {
      interactions.disableProxies();
    }
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const ESCAPE_KEY_NAME = 'Escape';
  let inlineEditModeEnabled = false;
  let activeRteItemId = null;

  function enableInlineEditMode(postMessageManager) {
    // disable proxies
    toggleInteractionsProxies(false);
    inlineEditModeEnabled = true;
    postMessageManager.sendPostmessage(window.parent, 'enter-inline-editor-mode');
  }

  function disableInlineEditMode(postMessageManager) {
    // re-enable proxies
    toggleInteractionsProxies(true);
    inlineEditModeEnabled = false;
    activeRteItemId = null; // TODO - W-7346490
    // this event re-opens the prop editor but it immediately gets closed
    // due to unselect-element being fired (LWR only)

    postMessageManager.sendPostmessage(window.parent, 'exit-inline-editor-mode');
  }
  /**
   * Handler for interactinos state changes. This will be notified by the stateObserver
   * when a state change happens and when the selection changes, we exit inline edit mode (if needed)
   * @param  {object} property the property of the interaction state object that has changed
   */


  function handleStateChange(property, postMessageManager) {
    if (property === 'current' && inlineEditModeEnabled) {
      disableEditorMode(postMessageManager);
    }
  }

  function getRteCmp(itemId) {
    let rteCmp;
    const cmpWrapper = utils.querySelector(document, getElementSelector(itemId));

    if (cmpWrapper) {
      const designCmp = cmpWrapper.querySelector('.actualNode').children[0];
      rteCmp = designCmp.shadowRoot.children[0];
    }

    return rteCmp;
  }

  function saveContent(itemId, value, postMessageManager) {
    postMessageManager.sendPostmessage(window.parent, 'save-contentblock', {
      guid: itemId,
      content: value
    });
  }

  function enableEditorMode(itemId, postMessageManager) {
    enableInlineEditMode(postMessageManager);
    const rteCmp = getRteCmp(itemId); // exit on Escape

    rteCmp.addEventListener('keydown', evt => {
      if (ESCAPE_KEY_NAME === evt.key) {
        disableEditorMode(postMessageManager);
      }
    }); // prevent RTE being un-selected when user clicks on a font
    // picker option that floats outside the RTE rendered area

    rteCmp.addEventListener('mousedown', evt => {
      evt.stopPropagation();
    });
    rteCmp.enterEditorMode();
    activeRteItemId = itemId;
  }

  function disableEditorMode(postMessageManager) {
    if (activeRteItemId) {
      const rteCmp = getRteCmp(activeRteItemId);

      if (rteCmp) {
        rteCmp.exitEditorMode();
        saveContent(activeRteItemId, rteCmp.richTextValue, postMessageManager);
      }

      disableInlineEditMode(postMessageManager);
    }
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const SECURITY_POLICY_VIOLATION_EVENT = 'securitypolicyviolation';
  let cspViolationHandler;
  /**
   * Displays the CSP violations that were caught before webruntimedesign module was loaded
   * and removes the violations and the violation listener from the window object.
   */

  function displayCspErrorsCaughtBeforeDesignModeInitialized(postMessageManager) {
    const cspViolations = window.cb_cspViolations;

    if (cspViolations) {
      Object.values(cspViolations).forEach(violation => {
        sendCSPErrorMessage(postMessageManager, violation.violatedDirective, violation.blockedURI);
      });
      document.removeEventListener(SECURITY_POLICY_VIOLATION_EVENT, window.cb_cspViolationListener);
      delete window.cb_cspViolations;
      delete window.cb_cspViolationListener;
    }
  }
  /**
   * Starts an event listener for securitypolicyviolation.  When the event
   * occurs, a postMessage is sent to display the CSP error in a popup
   * error dialog if it has not been displayed previously.
   */


  function addCSPErrorHandler(postMessageManager) {
    const cspViolations = {};
    cspViolationHandler = getCSPViolationHandler.bind(this, cspViolations, postMessageManager);
    document.addEventListener(SECURITY_POLICY_VIOLATION_EVENT, cspViolationHandler);
  }

  function getCSPViolationHandler(cspViolations, postMessageManager, event) {
    const {
      disposition,
      violatedDirective,
      blockedURI
    } = event;

    if (disposition === 'enforce') {
      const violation = `${violatedDirective}_${blockedURI}_${window.location.pathname}`;

      if (!cspViolations[violation]) {
        cspViolations[violation] = true;
        sendCSPErrorMessage(postMessageManager, violatedDirective, blockedURI);
      }
    }
  }

  function sendCSPErrorMessage(postMessageManager, violatedDirective, blockedURI) {
    violatedDirective = unifyGranularElemAttrDirectives(violatedDirective);
    postMessageManager.sendPostmessage(window.parent, 'show-csp-error-dialog', {
      violatedDirective,
      blockedURI
    });
  }
  /**
   * Version 3 of CSP added more granular elem/attrib directives for
   * script-src and style-src. Since we don't support those, replace
   * those violations with the more general script-src/style-src
   * directives which we do support.
   */


  function unifyGranularElemAttrDirectives(directive) {
    switch (directive) {
      case 'script-src-elem':
      case 'script-src-attr':
        return 'script-src';

      case 'style-src-elem':
      case 'style-src-attr':
        return 'style-src';

      default:
        return directive;
    }
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
   * Starts an event listener for securitypolicyviolation event
   */

  function startDocumentListeners(postMessageManager) {
    // Only add the CSP violation listener for Chrome since it's the only browser that supports
    // the correct value for the 'disposition' attribute for CSP3 that indicates if the violation
    // is 'enforce' vs 'report'.  For communities with Grandfathered CSP security policy, CSP
    // violations will be for reporting purposes only which should not be surfaced in the builder.
    if (window.cb_isChrome) {
      displayCspErrorsCaughtBeforeDesignModeInitialized(postMessageManager);
      addCSPErrorHandler(postMessageManager);
    }
  }

  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  /* index.dev.js */
  // *******************************************************************************************************************
  // ATTENTION!
  // THIS IS A GENERATED FILE FROM https://git.soma.salesforce.com/BuilderFramework/builder-framework
  // If you would like to contribute, please follow the steps outlined in the git repo. Any changes made to this
  // file in p4 will be automatically overwritten.
  // *******************************************************************************************************************
  var stringPropertyComparator = function stringPropertyComparator(field, reverse) {
    if (typeof field !== 'string' || field.length === 0) {
      throw new TypeError('field must be a non-empty string');
    }

    return function (a, b) {
      var result = a[field].localeCompare(b[field], undefined, {
        sensitivity: 'base'
      });
      return reverse ? -result : result;
    };
  };

  var labelComparator = stringPropertyComparator('label');
  var nameComparator = stringPropertyComparator('name');

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray$1(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  var CustomURLSearchParams = function () {
    function CustomURLSearchParams(init) {
      var _this = this;

      _classCallCheck$1(this, CustomURLSearchParams);

      this.map = new Map();

      if (!init) {
        return this;
      } else if (typeof init === 'string') {
        var searchParams = init;

        if (searchParams.charAt(0) === '?') {
          searchParams = searchParams.slice(1);
        }

        for (var pairs = searchParams.split('&'), i = 0, length = pairs.length; i < length; i++) {
          var value = pairs[i];
          var index = value.indexOf('=');

          if (index === -1) {
            this.append(value, '');
          } else {
            this.append(value.slice(0, index), value.slice(index + 1));
          }
        }
      } else if (init instanceof URLSearchParams || init instanceof CustomURLSearchParams) {
        init.forEach(function (value, name) {
          return _this.append(name, value);
        });
      } else if (Array.isArray(init)) {
        for (var _i = 0; _i < init.length; _i++) {
          this.append(init[_i][0], init[_i][1]);
        }
      } else if (_typeof(init) === 'object') {
        for (var name in init) {
          if (init.hasOwnProperty(name)) {
            this.append(name, init[name]);
          }
        }
      } else {
        throw new TypeError('Unsupported call to URLSearchParams constructor');
      }
    }

    _createClass$1(CustomURLSearchParams, [{
      key: "append",
      value: function append(name, value) {
        if (this.has(name)) {
          this.map.set(name, [].concat(_toConsumableArray$1(this.getAll(name)), [value]));
        } else {
          this.set(name, value);
        }
      }
    }, {
      key: "delete",
      value: function _delete(name) {
        this.map.delete(name);
      }
    }, {
      key: "get",
      value: function get(name) {
        return this.getAll(name)[0];
      }
    }, {
      key: "getAll",
      value: function getAll(name) {
        return this.map.get(name) || [];
      }
    }, {
      key: "has",
      value: function has(name) {
        return this.map.has(name);
      }
    }, {
      key: "set",
      value: function set(name, value) {
        this.map.set(name, [value]);
      }
    }, {
      key: "sort",
      value: function sort() {
        this.map = new Map(_toConsumableArray$1(this.map.entries()).sort());
      }
    }, {
      key: "forEach",
      value: function forEach(callbackfn, thisArg) {
        var _this2 = this;

        this.map.forEach(function (values, key, parent) {
          return values.forEach(function (value) {
            return callbackfn(value, key, _this2);
          });
        });
      }
    }, {
      key: "toString",
      value: function toString() {
        var array = [];
        this.forEach(function (value, key) {
          return array.push("".concat(key, "=").concat(value));
        });
        return array.join('&');
      }
    }]);

    return CustomURLSearchParams;
  }();

  if (!window.URLSearchParams) {
    window.URLSearchParams = CustomURLSearchParams;
  }

  var Connection = function () {
    function Connection(srcWindow, destWindow, destOrigin, hookShouldHandleMessage) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      _classCallCheck$1(this, Connection);

      this.listeners = {};
      this.open = false;

      if (!srcWindow) {
        throw new Error("PostMessage: Error creating connection! 'srcWindow' was not provided while creating the connection.");
      } else if (!destWindow && (!hookShouldHandleMessage || !hookShouldHandleMessage.constructor || !hookShouldHandleMessage.call || !hookShouldHandleMessage.apply)) {
        throw new Error("PostMessage: Error creating connection! Either 'destWindow' or 'hookShouldHandleMessage' should be provided while creating a connection.");
      }

      this.curWindow = srcWindow;
      this.otherWindow = destWindow;
      this.otherWindowOrigin = destOrigin;
      this.hookShouldHandleMessage = hookShouldHandleMessage;
      this.isParent = !!options.isParent;
    }

    _createClass$1(Connection, [{
      key: "messageHandler",
      value: function messageHandler(e) {
        if (!this.otherWindow && (!this.hookShouldHandleMessage || !this.hookShouldHandleMessage(e))) {
          return;
        } else if (!this.isMessageValid(e)) {
          return;
        }

        var data;

        try {
          data = JSON.parse(e.data);
        } catch (ex) {
          return;
        }

        var callbacks = this.listeners[data.mType];

        if (callbacks) {
          var callbacksLen = callbacks.length;

          for (var i = 0; i < callbacksLen; i++) {
            var callback = callbacks[i];

            if (callback && callback.constructor && callback.call && callback.apply) {
              callback(data.mBody);
            }
          }
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.curWindow.removeEventListener('message', this.messageHandler, false);

        for (var prop in this) {
          if (this.hasOwnProperty(prop)) {
            delete this[prop];
          }
        }

        this.open = false;
      }
    }, {
      key: "listenFor",
      value: function listenFor(type, callback) {
        if (this.listeners.hasOwnProperty(type)) {
          this.listeners[type].push(callback);
        } else {
          this.listeners[type] = [callback];
        }

        return this;
      }
    }, {
      key: "stopListeningFor",
      value: function stopListeningFor(type, callback) {
        if (callback) {
          var listeners = this.listeners[type];
          var toRemoveIdx = listeners ? listeners.indexOf(callback) : -1;

          if (toRemoveIdx >= 0) {
            listeners.splice(toRemoveIdx, 1);

            if (listeners.length === 0) {
              delete this.listeners[type];
            } else {
              this.listeners[type] = listeners;
            }
          }
        } else {
          delete this.listeners[type];
        }

        return this;
      }
    }]);

    return Connection;
  }();

  var SETUP_INITIALIZE_PORT = 'setup:initialize-port';

  var MessageChannelConnection = function (_Connection) {
    _inherits(MessageChannelConnection, _Connection);

    function MessageChannelConnection(srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options) {
      var _this;

      _classCallCheck$1(this, MessageChannelConnection);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageChannelConnection).call(this, srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options));
      _this.messageQueue = [];

      _this.curWindow.addEventListener('message', _this.negotiatePort.bind(_assertThisInitialized(_this)), false);

      if (_this.isParent) {
        var channel = new MessageChannel();
        _this.port = channel.port1;
        _this.port.onmessage = _this.messageHandler.bind(_assertThisInitialized(_this));

        if (_this.otherWindow) {
          _this.otherWindow.postMessage(SETUP_INITIALIZE_PORT, destOrigin || '*', [channel.port2]);
        }

        _this.open = true;
      }

      return _this;
    }

    _createClass$1(MessageChannelConnection, [{
      key: "isMessageValid",
      value: function isMessageValid(e) {
        return true;
      }
    }, {
      key: "send",
      value: function send(type, message) {
        var data = {
          mType: type,
          mBody: message
        };

        if (!this.open || !this.port) {
          this.messageQueue.push(data);
          return this;
        }

        if (!this.otherWindow) {
          throw new Error("PostMessage: Cannot send messages using Connection connection since a 'destWindow' was not specified during creation.");
        }

        this.port.postMessage(JSON.stringify(data));
        return this;
      }
    }, {
      key: "negotiatePort",
      value: function negotiatePort(e) {
        if (e.data !== SETUP_INITIALIZE_PORT || this.isParent) {
          return;
        }

        this.port = e.ports[0];
        this.port.onmessage = this.messageHandler.bind(this);
        this.open = true;
        this.sendQueuedMessages();
      }
    }, {
      key: "sendQueuedMessages",
      value: function sendQueuedMessages() {
        var _this2 = this;

        var oldMessageQueue = _toConsumableArray$1(this.messageQueue);

        this.messageQueue = [];
        oldMessageQueue.forEach(function (message) {
          return _this2.send(message.mType, message.mBody);
        });
      }
    }]);

    return MessageChannelConnection;
  }(Connection);

  var PostMessageConnection = function (_Connection) {
    _inherits(PostMessageConnection, _Connection);

    function PostMessageConnection(srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options) {
      var _this;

      _classCallCheck$1(this, PostMessageConnection);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PostMessageConnection).call(this, srcWindow, destWindow, destOrigin, hookShouldHandleMessage, options));

      _this.curWindow.addEventListener('message', _this.messageHandler.bind(_assertThisInitialized(_this)), false);

      _this.open = true;
      return _this;
    }

    _createClass$1(PostMessageConnection, [{
      key: "isMessageValid",
      value: function isMessageValid(e) {
        return e.source === this.otherWindow && !(this.otherWindowOrigin && e.origin.toLowerCase() !== this.otherWindowOrigin.toLowerCase());
      }
    }, {
      key: "send",
      value: function send(type, message) {
        if (!this.open) {
          throw new Error('PostMessage: Connection is not open. Cannot send messages if the connection is not open.');
        }

        if (!this.otherWindow) {
          throw new Error("PostMessage: Cannot send messages using Connection connection since a 'destWindow' was not specified during creation.");
        }

        var data = {
          mType: type,
          mBody: message
        };
        var origin = this.otherWindowOrigin || '*';
        this.otherWindow.postMessage(JSON.stringify(data), origin);
        return this;
      }
    }]);

    return PostMessageConnection;
  }(Connection);

  var ConnectionManager = function () {
    function ConnectionManager() {
      var connectionConstructor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PostMessageConnection;
      var connectionOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck$1(this, ConnectionManager);

      this.connections = [];
      this.connectionConstructor = connectionConstructor;
      this.connectionOptions = connectionOptions;
    }

    _createClass$1(ConnectionManager, [{
      key: "registerPostmessageHandler",
      value: function registerPostmessageHandler(sourceWindow, type, handler) {
        if (!!sourceWindow && !sourceWindow.location && !sourceWindow.document) {
          throw new Error('PostmessageManager: The source window supplied while registering the handler for "' + type + '" is not a valid window object.');
        }

        if (!isFunction(handler)) {
          throw new Error('PostmessageManager: The action supplied while registering the handler for "' + type + '" is not a valid function.');
        }

        var connection = sourceWindow ? this.getConnection(sourceWindow) : this.getListenOnlyConnection();
        connection.listenFor(type, handler);
      }
    }, {
      key: "unregisterPostmessageHandler",
      value: function unregisterPostmessageHandler(sourceWindow, type, handler) {
        if (!!sourceWindow && !sourceWindow.location && !sourceWindow.document) {
          throw new Error('PostmessageManager: The source window supplied while unregistering the handler for "' + type + '" is not a valid window object.');
        }

        var connection = sourceWindow ? this.getConnection(sourceWindow) : this.getListenOnlyConnection();
        connection.stopListeningFor(type, handler);
      }
    }, {
      key: "sendPostmessage",
      value: function sendPostmessage(destinationWindow, type, data) {
        if (!destinationWindow || !destinationWindow.location || !destinationWindow.postMessage) {
          throw new Error('PostmessageManager: The destination window supplied while sending the "' + type + '" message is not a valid window object.');
        }

        this.getConnection(destinationWindow).send(type, data);
      }
    }, {
      key: "getListenOnlyConnection",
      value: function getListenOnlyConnection() {
        var _this = this;

        if (!this.listenOnlyConnection) {
          this.listenOnlyConnection = new this.connectionConstructor(window, undefined, undefined, function (e) {
            return _this.findConnectionIndex(e.source) === -1;
          }, this.connectionOptions);
        }

        return this.listenOnlyConnection;
      }
    }, {
      key: "getConnection",
      value: function getConnection(sourceWindow) {
        var connection = this.findConnection(sourceWindow);

        if (!connection) {
          connection = new this.connectionConstructor(window, sourceWindow, undefined, undefined, this.connectionOptions);
          this.connections.push(connection);
        }

        return connection;
      }
    }, {
      key: "removeConnection",
      value: function removeConnection(sourceWindow) {
        var connectionToRemoveIdx = this.findConnectionIndex(sourceWindow);

        if (connectionToRemoveIdx === -1) {
          return;
        }

        var connectionToRemove = this.connections[connectionToRemoveIdx];

        if (connectionToRemove) {
          connectionToRemove.close();
        }

        this.connections.splice(connectionToRemoveIdx, 1);
      }
    }, {
      key: "findConnectionIndex",
      value: function findConnectionIndex(sourceWindow) {
        for (var i = 0; i < this.connections.length; i++) {
          if (this.connections[i].otherWindow === sourceWindow) {
            return i;
          }
        }

        return -1;
      }
    }, {
      key: "findConnection",
      value: function findConnection(sourceWindow) {
        var index = this.findConnectionIndex(sourceWindow);

        if (index >= 0) {
          return this.connections[index];
        }

        return undefined;
      }
    }]);

    return ConnectionManager;
  }();

  function invariant(value, msg) {
    if (!value) {
      throw new Error("Invariant Violation: ".concat(msg));
    }
  }

  function isTrue(value, msg) {
    if (!value) {
      throw new Error("Assert Violation: ".concat(msg));
    }
  }

  function isFalse(value, msg) {
    if (value) {
      throw new Error("Assert Violation: ".concat(msg));
    }
  }

  function fail(msg) {
    throw new Error(msg);
  }

  var assert = Object.freeze({
    __proto__: null,
    invariant: invariant,
    isTrue: isTrue,
    isFalse: isFalse,
    fail: fail
  });

  function isUndefined$1(obj) {
    return obj === undefined;
  }

  var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
  var CONTEXT_ID = '@wire';
  var CONTEXT_UPDATED = 'updated';
  var CONTEXT_CONNECTED = 'connected';
  var CONTEXT_DISCONNECTED = 'disconnected';
  var CONNECT = 'connect';
  var DISCONNECT = 'disconnect';
  var CONFIG = 'config';

  function invokeConfigListeners(configListenerMetadatas, paramValues) {
    configListenerMetadatas.forEach(function (metadata) {
      var listener = metadata.listener,
          statics = metadata.statics,
          reactives = metadata.reactives;
      var reactiveValues = Object.create(null);

      if (reactives) {
        var keys = Object.keys(reactives);

        for (var j = 0, jlen = keys.length; j < jlen; j++) {
          var key = keys[j];
          var value = paramValues[reactives[key]];
          reactiveValues[key] = value;
        }
      }

      var config = Object.assign({}, statics, reactiveValues);
      listener.call(undefined, config);
    });
  }

  function updated(cmp, reactiveParameters, configContext) {
    if (!configContext.mutated) {
      configContext.mutated = new Set(reactiveParameters);
      Promise.resolve().then(updatedFuture.bind(undefined, cmp, configContext));
    } else {
      for (var i = 0, n = reactiveParameters.length; i < n; i++) {
        configContext.mutated.add(reactiveParameters[i]);
      }
    }
  }

  function updatedFuture(cmp, configContext) {
    var uniqueListeners = new Set();
    var mutated = configContext.mutated;
    delete configContext.mutated;
    mutated.forEach(function (reactiveParameter) {
      var value = getReactiveParameterValue(cmp, reactiveParameter);

      if (configContext.values[reactiveParameter.reference] === value) {
        return;
      }

      configContext.values[reactiveParameter.reference] = value;
      var listeners = configContext.listeners[reactiveParameter.head];

      for (var i = 0, len = listeners.length; i < len; i++) {
        uniqueListeners.add(listeners[i]);
      }
    });
    invokeConfigListeners(uniqueListeners, configContext.values);
  }

  function getReactiveParameterValue(cmp, reactiveParameter) {
    var value = cmp[reactiveParameter.head];

    if (!reactiveParameter.tail) {
      return value;
    }

    var segments = reactiveParameter.tail;

    for (var i = 0, len = segments.length; i < len && value != null; i++) {
      var segment = segments[i];

      if (_typeof(value) !== 'object' || !(segment in value)) {
        return undefined;
      }

      value = value[segment];
    }

    return value;
  }

  function installTrap(cmp, reactiveParametersHead, reactiveParameters, configContext) {
    var callback = updated.bind(undefined, cmp, reactiveParameters, configContext);
    var newDescriptor = getOverrideDescriptor(cmp, reactiveParametersHead, callback);
    Object.defineProperty(cmp, reactiveParametersHead, newDescriptor);
  }

  function findDescriptor(target, propName, protoSet) {
    protoSet = protoSet || [];

    if (!target || protoSet.indexOf(target) > -1) {
      return null;
    }

    var descriptor = Object.getOwnPropertyDescriptor(target, propName);

    if (descriptor) {
      return descriptor;
    }

    var proto = Object.getPrototypeOf(target);

    if (!proto) {
      return null;
    }

    protoSet.push(target);
    return findDescriptor(proto, propName, protoSet);
  }

  function getOverrideDescriptor(cmp, prop, callback) {
    var descriptor = findDescriptor(cmp, prop);
    var enumerable;
    var get;
    var set;

    if (descriptor === null || descriptor.get === undefined && descriptor.set === undefined) {
      var value = cmp[prop];
      enumerable = true;

      get = function get() {
        return value;
      };

      set = function set(newValue) {
        value = newValue;
        callback();
      };
    } else {
      var originalSet = descriptor.set,
          originalGet = descriptor.get;
      enumerable = descriptor.enumerable;

      set = function set(newValue) {
        if (originalSet) {
          originalSet.call(cmp, newValue);
        }

        callback();
      };

      get = function get() {
        return originalGet ? originalGet.call(cmp) : undefined;
      };
    }

    return {
      set: set,
      get: get,
      enumerable: enumerable,
      configurable: true
    };
  }

  var ValueChangedEventType = 'ValueChangedEvent';

  var ValueChangedEvent = function ValueChangedEvent(value) {
    _classCallCheck$1(this, ValueChangedEvent);

    this.type = ValueChangedEventType;
    this.value = value;
  };

  var LinkContextEventType = 'LinkContextEvent';

  var LinkContextEvent = function LinkContextEvent(uid, callback) {
    _classCallCheck$1(this, LinkContextEvent);

    this.type = LinkContextEventType;
    this.uid = uid;
    this.callback = callback;
  };

  function removeListener(listeners, toRemove) {
    var idx = listeners.indexOf(toRemove);

    if (idx > -1) {
      listeners.splice(idx, 1);
    }
  }

  function removeConfigListener(configListenerMetadatas, toRemove) {
    for (var i = 0, len = configListenerMetadatas.length; i < len; i++) {
      if (configListenerMetadatas[i].listener === toRemove) {
        configListenerMetadatas.splice(i, 1);
        return;
      }
    }
  }

  function buildReactiveParameter(reference) {
    if (!reference.includes('.')) {
      return {
        reference: reference,
        head: reference
      };
    }

    var segments = reference.split('.');
    return {
      reference: reference,
      head: segments.shift(),
      tail: segments
    };
  }

  var WireEventTarget = function () {
    function WireEventTarget(cmp, def, context, wireDef, wireTarget) {
      _classCallCheck$1(this, WireEventTarget);

      this._cmp = cmp;
      this._def = def;
      this._context = context;
      this._wireDef = wireDef;
      this._wireTarget = wireTarget;
    }

    _createClass$1(WireEventTarget, [{
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        var _this = this;

        switch (type) {
          case CONNECT:
            {
              var connectedListeners = this._context[CONTEXT_ID][CONTEXT_CONNECTED];

              {
                assert.isFalse(connectedListeners.includes(listener), 'must not call addEventListener("connect") with the same listener');
              }

              connectedListeners.push(listener);
              break;
            }

          case DISCONNECT:
            {
              var disconnectedListeners = this._context[CONTEXT_ID][CONTEXT_DISCONNECTED];

              {
                assert.isFalse(disconnectedListeners.includes(listener), 'must not call addEventListener("disconnect") with the same listener');
              }

              disconnectedListeners.push(listener);
              break;
            }

          case CONFIG:
            {
              var reactives = this._wireDef.params;
              var statics = this._wireDef.static;
              var reactiveKeys;

              if (!reactives || (reactiveKeys = Object.keys(reactives)).length === 0) {
                var config = statics || Object.create(null);
                listener.call(undefined, config);
                return;
              }

              var configListenerMetadata = {
                listener: listener,
                statics: statics,
                reactives: reactives
              };
              var configContext = this._context[CONTEXT_ID][CONTEXT_UPDATED];
              var reactiveParametersGroupByHead = {};
              reactiveKeys.forEach(function (key) {
                var reactiveParameter = buildReactiveParameter(reactives[key]);
                var reactiveParameterHead = reactiveParameter.head;
                var configListenerMetadatas = configContext.listeners[reactiveParameterHead];
                var reactiveParametersWithSameHead = reactiveParametersGroupByHead[reactiveParameterHead];

                if (isUndefined$1(reactiveParametersWithSameHead)) {
                  reactiveParametersWithSameHead = [];
                  reactiveParametersGroupByHead[reactiveParameterHead] = reactiveParametersWithSameHead;
                }

                reactiveParametersWithSameHead.push(reactiveParameter);

                if (!configListenerMetadatas) {
                  configListenerMetadatas = [configListenerMetadata];
                  configContext.listeners[reactiveParameterHead] = configListenerMetadatas;
                  installTrap(_this._cmp, reactiveParameterHead, reactiveParametersWithSameHead, configContext);
                } else {
                  configListenerMetadatas.push(configListenerMetadata);
                }
              });
              Object.keys(reactiveParametersGroupByHead).forEach(function (head) {
                updated(_this._cmp, reactiveParametersGroupByHead[head], configContext);
              });
              break;
            }

          default:
            throw new Error("unsupported event type ".concat(type));
        }
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        switch (type) {
          case CONNECT:
            {
              var connectedListeners = this._context[CONTEXT_ID][CONTEXT_CONNECTED];
              removeListener(connectedListeners, listener);
              break;
            }

          case DISCONNECT:
            {
              var disconnectedListeners = this._context[CONTEXT_ID][CONTEXT_DISCONNECTED];
              removeListener(disconnectedListeners, listener);
              break;
            }

          case CONFIG:
            {
              var paramToConfigListenerMetadata = this._context[CONTEXT_ID][CONTEXT_UPDATED].listeners;
              var reactives = this._wireDef.params;

              if (reactives) {
                Object.keys(reactives).forEach(function (key) {
                  var reactiveParameter = buildReactiveParameter(reactives[key]);
                  var configListenerMetadatas = paramToConfigListenerMetadata[reactiveParameter.head];

                  if (configListenerMetadatas) {
                    removeConfigListener(configListenerMetadatas, listener);
                  }
                });
              }

              break;
            }

          default:
            throw new Error("unsupported event type ".concat(type));
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(evt) {
        if (evt instanceof ValueChangedEvent) {
          var value = evt.value;

          if (this._wireDef.method) {
            this._cmp[this._wireTarget](value);
          } else {
            this._cmp[this._wireTarget] = value;
          }

          return false;
        } else if (evt instanceof LinkContextEvent) {
          var uid = evt.uid,
              callback = evt.callback;
          var internalDomEvent = new CustomEvent(uid, {
            bubbles: true,
            composed: true,
            detail: function detail() {
              callback.apply(void 0, arguments);
            }
          });

          this._cmp.dispatchEvent(internalDomEvent);

          return false;
        } else if (evt.type === 'wirecontextevent') {
          return this._cmp.dispatchEvent(evt);
        } else {
          throw new Error("Invalid event ".concat(evt, "."));
        }
      }
    }]);

    return WireEventTarget;
  }();

  function getMethod(obj, key) {
    var value = obj[key];

    if (value == null) {
      return undefined;
    }

    if (typeof value !== 'function') {
      throw new TypeError(value + ' is not a function');
    }

    return value;
  }

  function cleanupSubscription(subscription) {
    var cleanup = subscription._cleanup;

    if (!cleanup) {
      return;
    }

    subscription._cleanup = undefined;
    cleanup();
  }

  function subscriptionClosed(subscription) {
    return subscription._observer === undefined;
  }

  function closeSubscription(subscription) {
    if (subscriptionClosed(subscription)) {
      return;
    }

    subscription._observer = undefined;
    cleanupSubscription(subscription);
  }

  function cleanupFromSubscription(subscription) {
    return function () {
      subscription.unsubscribe();
    };
  }

  var SubscriptionObserver = function () {
    function SubscriptionObserver(subscription) {
      _classCallCheck$1(this, SubscriptionObserver);

      this._subscription = subscription;
    }

    _createClass$1(SubscriptionObserver, [{
      key: "next",
      value: function next(value) {
        var subscription = this._subscription;

        if (subscriptionClosed(subscription)) {
          return;
        }

        var observer = subscription._observer;
        var m = getMethod(observer, 'next');

        if (!m) {
          return;
        }

        m.call(observer, value);
      }
    }, {
      key: "error",
      value: function error(value) {
        var subscription = this._subscription;

        if (subscriptionClosed(subscription)) {
          return;
        }

        var observer = subscription._observer;
        subscription._observer = undefined;
        var m = getMethod(observer, 'error');

        if (m) {
          m.call(observer, value);
        }

        cleanupSubscription(subscription);
      }
    }, {
      key: "complete",
      value: function complete() {
        var subscription = this._subscription;

        if (subscriptionClosed(subscription)) {
          return;
        }

        var observer = subscription._observer;
        subscription._observer = undefined;

        try {
          var m = getMethod(observer, 'complete');

          if (m) {
            m.call(observer);
          }
        } catch (e) {}

        cleanupSubscription(subscription);
      }
    }, {
      key: "closed",
      get: function get() {
        return subscriptionClosed(this._subscription);
      }
    }]);

    return SubscriptionObserver;
  }();

  var Subscription = function () {
    function Subscription(observer, subscriber) {
      _classCallCheck$1(this, Subscription);

      this._observer = observer;
      this._cleanup = undefined;
      var subscriptionObserver = new SubscriptionObserver(this);

      try {
        var cleanup = subscriber.call(undefined, subscriptionObserver);

        if (cleanup != null) {
          if (typeof cleanup.unsubscribe === 'function') {
            cleanup = cleanupFromSubscription(cleanup);
          } else if (typeof cleanup !== 'function') {
            throw new TypeError(cleanup + ' is not a function');
          }

          this._cleanup = cleanup;
        }
      } catch (e) {
        subscriptionObserver.error(e);
        return;
      }

      if (subscriptionClosed(this)) {
        cleanupSubscription(this);
      }
    }

    _createClass$1(Subscription, [{
      key: "unsubscribe",
      value: function unsubscribe() {
        closeSubscription(this);
      }
    }, {
      key: "closed",
      get: function get() {
        return subscriptionClosed(this);
      }
    }]);

    return Subscription;
  }();

  var Observable = function () {
    function Observable(subscriber) {
      _classCallCheck$1(this, Observable);

      if (typeof subscriber !== 'function') {
        throw new TypeError('Observable initializer must be a function');
      }

      this._subscriber = subscriber;
    }

    _createClass$1(Observable, [{
      key: "subscribe",
      value: function subscribe(observer) {
        if (typeof observer === 'function') {
          observer = {
            next: observer,
            error: arguments.length <= 1 ? undefined : arguments[1],
            complete: arguments.length <= 2 ? undefined : arguments[2]
          };
        } else if (_typeof(observer) !== 'object') {
          observer = {};
        }

        return new Subscription(observer, this._subscriber);
      }
    }], [{
      key: "from",
      value: function from(x) {
        var C = typeof this === 'function' ? this : Observable;

        if (x == null) {
          throw new TypeError(x + ' is not an object');
        }

        var method = getMethod(x, Symbol.observable);

        if (method) {
          var observable = method.call(x);

          if (Object(observable) !== observable) {
            throw new TypeError(observable + ' is not an object');
          }

          if (observable.constructor === C) {
            return observable;
          }

          return new C(function (observer) {
            return observable.subscribe(observer);
          });
        }

        method = getMethod(x, Symbol.iterator);

        if (!method) {
          throw new TypeError(x + ' is not observable');
        }

        return new C(function (observer) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var item = _step.value;
              observer.next(item);

              if (observer.closed) {
                return;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          observer.complete();
        });
      }
    }, {
      key: "of",
      value: function of() {
        for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
          items[_key] = arguments[_key];
        }

        var C = typeof this === 'function' ? this : Observable;
        return new C(function (observer) {
          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);

            if (observer.closed) {
              return;
            }
          }

          observer.complete();
        });
      }
    }]);

    return Observable;
  }();

  var WireValueChangeObservers = function () {
    function WireValueChangeObservers() {
      _classCallCheck$1(this, WireValueChangeObservers);

      this.observers = [];
    }

    _createClass$1(WireValueChangeObservers, [{
      key: "createObservable",
      value: function createObservable() {
        var _this = this;

        return new Observable(function (observer) {
          return _this.addObserver(observer);
        });
      }
    }, {
      key: "addObserver",
      value: function addObserver(observer) {
        var _this2 = this;

        this.observers.push(observer);
        return function () {
          var index = _this2.observers.indexOf(observer);

          if (index > -1) {
            _this2.observers.splice(index, 1);
          }
        };
      }
    }, {
      key: "emit",
      value: function emit(data, error) {
        this.observers.forEach(function (observer) {
          if (error) {
            observer.error(error);
          } else {
            observer.next(data);
          }
        });
      }
    }]);

    return WireValueChangeObservers;
  }();

  var ExpressionService = function () {
    function ExpressionService(contextProviders, expressionsAllowed) {
      _classCallCheck$1(this, ExpressionService);

      if (ExpressionService.staticInstantiator) {
        this.veExpressionService = ExpressionService.staticInstantiator(contextProviders, expressionsAllowed);
      }
    }

    _createClass$1(ExpressionService, [{
      key: "getVisualEditorExpressionService",
      value: function getVisualEditorExpressionService() {
        return this.veExpressionService;
      }
    }], [{
      key: "setExpressionServiceInstantiator",
      value: function setExpressionServiceInstantiator(instantiator) {
        ExpressionService.staticInstantiator = instantiator;
      }
    }]);

    return ExpressionService;
  }();

  var isArray$1 = Array.isArray;
  var _getPrototypeOf$1 = Object.getPrototypeOf,
      ObjectCreate = Object.create,
      ObjectDefineProperty = Object.defineProperty,
      _isExtensible = Object.isExtensible,
      _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
      getOwnPropertyNames = Object.getOwnPropertyNames,
      getOwnPropertySymbols = Object.getOwnPropertySymbols,
      _preventExtensions = Object.preventExtensions,
      hasOwnProperty = Object.hasOwnProperty;
  var _Array$prototype = Array.prototype,
      ArrayPush = _Array$prototype.push,
      ArrayConcat = _Array$prototype.concat;
  var OtS = {}.toString;

  function toString(obj) {
    if (obj && obj.toString) {
      return obj.toString();
    } else if (_typeof(obj) === 'object') {
      return OtS.call(obj);
    } else {
      return obj + '';
    }
  }

  function isUndefined$2(obj) {
    return obj === undefined;
  }

  function isFunction$1(obj) {
    return typeof obj === 'function';
  }

  function isObject$1(obj) {
    return _typeof(obj) === 'object';
  }

  var proxyToValueMap = new WeakMap();

  function registerProxy(proxy, value) {
    proxyToValueMap.set(proxy, value);
  }

  var unwrap = function unwrap(replicaOrAny) {
    return proxyToValueMap.get(replicaOrAny) || replicaOrAny;
  };

  function wrapValue(membrane, value) {
    return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
  }

  function unwrapDescriptor(descriptor) {
    if (hasOwnProperty.call(descriptor, 'value')) {
      descriptor.value = unwrap(descriptor.value);
    }

    return descriptor;
  }

  function lockShadowTarget(membrane, shadowTarget, originalTarget) {
    var targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
    targetKeys.forEach(function (key) {
      var descriptor = _getOwnPropertyDescriptor(originalTarget, key);

      if (!descriptor.configurable) {
        descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
      }

      ObjectDefineProperty(shadowTarget, key, descriptor);
    });

    _preventExtensions(shadowTarget);
  }

  var ReactiveProxyHandler = function () {
    function ReactiveProxyHandler(membrane, value) {
      _classCallCheck$1(this, ReactiveProxyHandler);

      this.originalTarget = value;
      this.membrane = membrane;
    }

    _createClass$1(ReactiveProxyHandler, [{
      key: "get",
      value: function get(shadowTarget, key) {
        var originalTarget = this.originalTarget,
            membrane = this.membrane;
        var value = originalTarget[key];
        var valueObserved = membrane.valueObserved;
        valueObserved(originalTarget, key);
        return membrane.getProxy(value);
      }
    }, {
      key: "set",
      value: function set(shadowTarget, key, value) {
        var originalTarget = this.originalTarget,
            valueMutated = this.membrane.valueMutated;
        var oldValue = originalTarget[key];

        if (oldValue !== value) {
          originalTarget[key] = value;
          valueMutated(originalTarget, key);
        } else if (key === 'length' && isArray$1(originalTarget)) {
          valueMutated(originalTarget, key);
        }

        return true;
      }
    }, {
      key: "deleteProperty",
      value: function deleteProperty(shadowTarget, key) {
        var originalTarget = this.originalTarget,
            valueMutated = this.membrane.valueMutated;
        delete originalTarget[key];
        valueMutated(originalTarget, key);
        return true;
      }
    }, {
      key: "apply",
      value: function apply(shadowTarget, thisArg, argArray) {}
    }, {
      key: "construct",
      value: function construct(target, argArray, newTarget) {}
    }, {
      key: "has",
      value: function has(shadowTarget, key) {
        var originalTarget = this.originalTarget,
            valueObserved = this.membrane.valueObserved;
        valueObserved(originalTarget, key);
        return key in originalTarget;
      }
    }, {
      key: "ownKeys",
      value: function ownKeys(shadowTarget) {
        var originalTarget = this.originalTarget;
        return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
      }
    }, {
      key: "isExtensible",
      value: function isExtensible(shadowTarget) {
        var shadowIsExtensible = _isExtensible(shadowTarget);

        if (!shadowIsExtensible) {
          return shadowIsExtensible;
        }

        var originalTarget = this.originalTarget,
            membrane = this.membrane;

        var targetIsExtensible = _isExtensible(originalTarget);

        if (!targetIsExtensible) {
          lockShadowTarget(membrane, shadowTarget, originalTarget);
        }

        return targetIsExtensible;
      }
    }, {
      key: "setPrototypeOf",
      value: function setPrototypeOf(shadowTarget, prototype) {
        {
          throw new Error("Invalid setPrototypeOf invocation for reactive proxy ".concat(toString(this.originalTarget), ". Prototype of reactive objects cannot be changed."));
        }
      }
    }, {
      key: "getPrototypeOf",
      value: function getPrototypeOf(shadowTarget) {
        var originalTarget = this.originalTarget;
        return _getPrototypeOf$1(originalTarget);
      }
    }, {
      key: "getOwnPropertyDescriptor",
      value: function getOwnPropertyDescriptor(shadowTarget, key) {
        var originalTarget = this.originalTarget,
            membrane = this.membrane;
        var valueObserved = this.membrane.valueObserved;
        valueObserved(originalTarget, key);

        var desc = _getOwnPropertyDescriptor(originalTarget, key);

        if (isUndefined$2(desc)) {
          return desc;
        }

        var shadowDescriptor = _getOwnPropertyDescriptor(shadowTarget, key);

        if (!isUndefined$2(shadowDescriptor)) {
          return shadowDescriptor;
        }

        desc = wrapDescriptor(membrane, desc, wrapValue);

        if (!desc.configurable) {
          ObjectDefineProperty(shadowTarget, key, desc);
        }

        return desc;
      }
    }, {
      key: "preventExtensions",
      value: function preventExtensions(shadowTarget) {
        var originalTarget = this.originalTarget,
            membrane = this.membrane;
        lockShadowTarget(membrane, shadowTarget, originalTarget);

        _preventExtensions(originalTarget);

        return true;
      }
    }, {
      key: "defineProperty",
      value: function defineProperty(shadowTarget, key, descriptor) {
        var originalTarget = this.originalTarget,
            membrane = this.membrane;
        var valueMutated = membrane.valueMutated;
        var configurable = descriptor.configurable;

        if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {
          var originalDescriptor = _getOwnPropertyDescriptor(originalTarget, key);

          descriptor.value = originalDescriptor.value;
        }

        ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));

        if (configurable === false) {
          ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
        }

        valueMutated(originalTarget, key);
        return true;
      }
    }]);

    return ReactiveProxyHandler;
  }();

  function wrapReadOnlyValue(membrane, value) {
    return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
  }

  var ReadOnlyHandler = function () {
    function ReadOnlyHandler(membrane, value) {
      _classCallCheck$1(this, ReadOnlyHandler);

      this.originalTarget = value;
      this.membrane = membrane;
    }

    _createClass$1(ReadOnlyHandler, [{
      key: "get",
      value: function get(shadowTarget, key) {
        var membrane = this.membrane,
            originalTarget = this.originalTarget;
        var value = originalTarget[key];
        var valueObserved = membrane.valueObserved;
        valueObserved(originalTarget, key);
        return membrane.getReadOnlyProxy(value);
      }
    }, {
      key: "set",
      value: function set(shadowTarget, key, value) {
        {
          var originalTarget = this.originalTarget;
          throw new Error("Invalid mutation: Cannot set \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
        }
      }
    }, {
      key: "deleteProperty",
      value: function deleteProperty(shadowTarget, key) {
        {
          var originalTarget = this.originalTarget;
          throw new Error("Invalid mutation: Cannot delete \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
        }
      }
    }, {
      key: "apply",
      value: function apply(shadowTarget, thisArg, argArray) {}
    }, {
      key: "construct",
      value: function construct(target, argArray, newTarget) {}
    }, {
      key: "has",
      value: function has(shadowTarget, key) {
        var originalTarget = this.originalTarget,
            valueObserved = this.membrane.valueObserved;
        valueObserved(originalTarget, key);
        return key in originalTarget;
      }
    }, {
      key: "ownKeys",
      value: function ownKeys(shadowTarget) {
        var originalTarget = this.originalTarget;
        return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
      }
    }, {
      key: "setPrototypeOf",
      value: function setPrototypeOf(shadowTarget, prototype) {
        {
          var originalTarget = this.originalTarget;
          throw new Error("Invalid prototype mutation: Cannot set prototype on \"".concat(originalTarget, "\". \"").concat(originalTarget, "\" prototype is read-only."));
        }
      }
    }, {
      key: "getOwnPropertyDescriptor",
      value: function getOwnPropertyDescriptor(shadowTarget, key) {
        var originalTarget = this.originalTarget,
            membrane = this.membrane;
        var valueObserved = membrane.valueObserved;
        valueObserved(originalTarget, key);

        var desc = _getOwnPropertyDescriptor(originalTarget, key);

        if (isUndefined$2(desc)) {
          return desc;
        }

        var shadowDescriptor = _getOwnPropertyDescriptor(shadowTarget, key);

        if (!isUndefined$2(shadowDescriptor)) {
          return shadowDescriptor;
        }

        desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);

        if (hasOwnProperty.call(desc, 'set')) {
          desc.set = undefined;
        }

        if (!desc.configurable) {
          ObjectDefineProperty(shadowTarget, key, desc);
        }

        return desc;
      }
    }, {
      key: "preventExtensions",
      value: function preventExtensions(shadowTarget) {
        {
          var originalTarget = this.originalTarget;
          throw new Error("Invalid mutation: Cannot preventExtensions on ".concat(originalTarget, "\". \"").concat(originalTarget, " is read-only."));
        }
      }
    }, {
      key: "defineProperty",
      value: function defineProperty(shadowTarget, key, descriptor) {
        {
          var originalTarget = this.originalTarget;
          throw new Error("Invalid mutation: Cannot defineProperty \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
        }
      }
    }]);

    return ReadOnlyHandler;
  }();

  function extract(objectOrArray) {
    if (isArray$1(objectOrArray)) {
      return objectOrArray.map(function (item) {
        var original = unwrap(item);

        if (original !== item) {
          return extract(original);
        }

        return item;
      });
    }

    var obj = ObjectCreate(_getPrototypeOf$1(objectOrArray));
    var names = getOwnPropertyNames(objectOrArray);
    return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce(function (seed, key) {
      var item = objectOrArray[key];
      var original = unwrap(item);

      if (original !== item) {
        seed[key] = extract(original);
      } else {
        seed[key] = item;
      }

      return seed;
    }, obj);
  }

  var formatter = {
    header: function header(plainOrProxy) {
      var originalTarget = unwrap(plainOrProxy);

      if (!originalTarget || originalTarget === plainOrProxy) {
        return null;
      }

      var obj = extract(plainOrProxy);
      return ['object', {
        object: obj
      }];
    },
    hasBody: function hasBody() {
      return false;
    },
    body: function body() {
      return null;
    }
  };

  function getGlobal() {
    if (typeof globalThis !== 'undefined') {
      return globalThis;
    }

    if (typeof self !== 'undefined') {
      return self;
    }

    if (typeof window !== 'undefined') {
      return window;
    }

    if (typeof global !== 'undefined') {
      return global;
    }

    return {};
  }

  function init() {

    var global = getGlobal();
    var devtoolsFormatters = global.devtoolsFormatters || [];
    ArrayPush.call(devtoolsFormatters, formatter);
    global.devtoolsFormatters = devtoolsFormatters;
  }

  {
    init();
  }

  function createShadowTarget(value) {
    var shadowTarget = undefined;

    if (isArray$1(value)) {
      shadowTarget = [];
    } else if (isObject$1(value)) {
      shadowTarget = {};
    }

    return shadowTarget;
  }

  var ObjectDotPrototype = Object.prototype;

  function defaultValueIsObservable(value) {
    if (value === null) {
      return false;
    }

    if (_typeof(value) !== 'object') {
      return false;
    }

    if (isArray$1(value)) {
      return true;
    }

    var proto = _getPrototypeOf$1(value);

    return proto === ObjectDotPrototype || proto === null || _getPrototypeOf$1(proto) === null;
  }

  var defaultValueObserved = function defaultValueObserved(obj, key) {};

  var defaultValueMutated = function defaultValueMutated(obj, key) {};

  var defaultValueDistortion = function defaultValueDistortion(value) {
    return value;
  };

  function wrapDescriptor(membrane, descriptor, getValue) {
    var set = descriptor.set,
        get = descriptor.get;

    if (hasOwnProperty.call(descriptor, 'value')) {
      descriptor.value = getValue(membrane, descriptor.value);
    } else {
      if (!isUndefined$2(get)) {
        descriptor.get = function () {
          return getValue(membrane, get.call(unwrap(this)));
        };
      }

      if (!isUndefined$2(set)) {
        descriptor.set = function (value) {
          set.call(unwrap(this), membrane.unwrapProxy(value));
        };
      }
    }

    return descriptor;
  }

  var ReactiveMembrane = function () {
    function ReactiveMembrane(options) {
      _classCallCheck$1(this, ReactiveMembrane);

      this.valueDistortion = defaultValueDistortion;
      this.valueMutated = defaultValueMutated;
      this.valueObserved = defaultValueObserved;
      this.valueIsObservable = defaultValueIsObservable;
      this.objectGraph = new WeakMap();

      if (!isUndefined$2(options)) {
        var valueDistortion = options.valueDistortion,
            valueMutated = options.valueMutated,
            valueObserved = options.valueObserved,
            valueIsObservable = options.valueIsObservable;
        this.valueDistortion = isFunction$1(valueDistortion) ? valueDistortion : defaultValueDistortion;
        this.valueMutated = isFunction$1(valueMutated) ? valueMutated : defaultValueMutated;
        this.valueObserved = isFunction$1(valueObserved) ? valueObserved : defaultValueObserved;
        this.valueIsObservable = isFunction$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
      }
    }

    _createClass$1(ReactiveMembrane, [{
      key: "getProxy",
      value: function getProxy(value) {
        var unwrappedValue = unwrap(value);
        var distorted = this.valueDistortion(unwrappedValue);

        if (this.valueIsObservable(distorted)) {
          var o = this.getReactiveState(unwrappedValue, distorted);
          return o.readOnly === value ? value : o.reactive;
        }

        return distorted;
      }
    }, {
      key: "getReadOnlyProxy",
      value: function getReadOnlyProxy(value) {
        value = unwrap(value);
        var distorted = this.valueDistortion(value);

        if (this.valueIsObservable(distorted)) {
          return this.getReactiveState(value, distorted).readOnly;
        }

        return distorted;
      }
    }, {
      key: "unwrapProxy",
      value: function unwrapProxy(p) {
        return unwrap(p);
      }
    }, {
      key: "getReactiveState",
      value: function getReactiveState(value, distortedValue) {
        var objectGraph = this.objectGraph;
        var reactiveState = objectGraph.get(distortedValue);

        if (reactiveState) {
          return reactiveState;
        }

        var membrane = this;
        reactiveState = {
          get reactive() {
            var reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);
            var proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
            registerProxy(proxy, value);
            ObjectDefineProperty(this, 'reactive', {
              value: proxy
            });
            return proxy;
          },

          get readOnly() {
            var readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);
            var proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
            registerProxy(proxy, value);
            ObjectDefineProperty(this, 'readOnly', {
              value: proxy
            });
            return proxy;
          }

        };
        objectGraph.set(distortedValue, reactiveState);
        return reactiveState;
      }
    }]);

    return ReactiveMembrane;
  }();

  /**
   * Takes the brandingSet and brandingDef, and updates the CSS variables accordingly
   *
   * @param {*} brandingSet
   * @param {*} brandingDef
   */
  function updateCSSVars({
    brandingSet,
    brandingDef
  }) {
    const {
      values
    } = brandingSet;
    Object.entries(values).forEach(([key, value]) => {
      const foundDef = brandingDef.find(def => {
        return def.name === key;
      }); // skip updating image because image need a canvas reload
      // reload will be triggered by the builder

      if (foundDef && foundDef.type !== 'Image') {
        foundDef.tokens.forEach(tokenName => {
          window.document.documentElement.style.setProperty(tokenName, value);
        });
      }
    });
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const FLEXIBLE_LAYOUT_SELECTOR = 'community_layout-slds-flexible-layout';
  const COLUMN_NAME = 'column';
  const COLUMN_SELECTOR = `[data-region-name='${COLUMN_NAME}']`;
  const THEME_REGION_TYPE = 'theme';
  const THEME_REGION_SELECTOR = `[data-region-type='${THEME_REGION_TYPE}']`;
  const ADD_SECTION_BUTTON_SELECTOR = '.add-section';
  const ADD_SECTION_BUTTON_POSITION_OFFSET = -12;

  function clearSectionProxyChangesIfNeeded(element) {
    // label is hidden for sections, so restore here
    const label = element.querySelector(`.${PROXY_LABEL_CLASS}`);
    label.style.display = 'flex';
    getSectionButtons(element).forEach(button => {
      button.remove();
    });
  }

  function getSectionButtons(element) {
    return element.querySelectorAll(ADD_SECTION_BUTTON_SELECTOR);
  }

  function isSection(element) {
    return element.dataset && SECTION_FQN === element.dataset.fqn;
  }

  function isValidDropTarget(dragElement, targetElement) {
    if (dragElement) {
      // if the element is not a section, we're dragging an existing component in the canvas
      // otherwise, confirm we're dragging a section and we can only drop those in the content region
      return !isSection(dragElement) && isValidDropTargetForComponent(targetElement) || isSection(dragElement) && isValidDropTargetForSection(targetElement);
    } // if dragElement is null, then we're dragging a component from the palette


    return isValidDropTargetForComponent(targetElement);
  }

  function isValidDropTargetForSection(targetElement) {
    return targetElement.dataset.regionName && targetElement.dataset.regionName === CONTENT_REGION_NAME;
  }

  function isValidDropTargetForComponent(targetElement) {
    // if the page has a flex layout, restrict drops to the theme and column regions
    // otherwise, don't restrict drops
    return utils.querySelector(document, FLEXIBLE_LAYOUT_SELECTOR) ? isOrIsDescendantOfType(COLUMN_SELECTOR, targetElement) || isOrIsDescendantOfType(THEME_REGION_SELECTOR, targetElement) : true;
  }

  function updateProxyForSection(proxyElement, componentElement, postMessageManager) {
    // remove the label
    const label = proxyElement.querySelector(`.${PROXY_LABEL_CLASS}`);
    label.style.display = 'none'; // add the click-to-add section buttons on the top and bottom of the proxy

    proxyElement.appendChild(createAddSectionButton(true, componentElement, postMessageManager));
    proxyElement.appendChild(createAddSectionButton(false, componentElement, postMessageManager));
  }

  function getSectionSiblings(regionEl) {
    return Array.from(utils.querySelectorAll(regionEl, `.${COMPONENT_WRAPPER_CLASS}`)).filter(element => isSection(element));
  }

  function getAddSectionClickHandler(sectionElement, isBottomButton, postMessageManager) {
    return () => {
      const sectionId = sectionElement.dataset.itemId;
      const container = getContainingRegion(sectionElement); // beforeId is sectionId if the top add button is pressed

      let beforeId = sectionId;

      if (isBottomButton) {
        // filter out the dropzone children
        const siblingList = getSectionSiblings(container);
        const sectionIndex = siblingList.findIndex(el => el.dataset.itemId === sectionId); // if the current section is not the last, then beforeId is the ID of the following section
        // null indicates the section will be appended to the end of the list, since there is no next sibling

        beforeId = sectionIndex < siblingList.length - 1 ? siblingList[sectionIndex + 1].dataset.itemId : null;
      }

      const params = {
        container: container.dataset.itemId,
        beforeId
      };
      postMessageManager.sendPostmessage(window.parent, 'cb-add-section', params);
    };
  }

  function createAddSectionButton(isTopButton, element, postMessageManager) {
    const addButton = document.createElement('button');
    addButton.classList.add('slds-button', 'slds-button_icon', 'add-section');

    if (isTopButton) {
      addButton.classList.add('add-section-top');
    } else {
      addButton.classList.add('add-section-bottom');
    }

    const buttonStyle = {
      position: 'absolute',
      left: '49.3%',
      height: '24px',
      width: '24px',
      borderRadius: '50%',
      pointerEvents: 'auto',
      backgroundColor: '#0059A7',
      border: '1px solid #0059A7',
      margin: 0,
      paddingBottom: '1px'
    };

    if (isTopButton) {
      buttonStyle.top = `${ADD_SECTION_BUTTON_POSITION_OFFSET}px`;
    } else {
      buttonStyle.bottom = `${ADD_SECTION_BUTTON_POSITION_OFFSET}px`;
    }

    Object.assign(addButton.style, buttonStyle);
    addButton.onmouseup = getAddSectionClickHandler(element, !isTopButton, postMessageManager); // prevent the mousemove event from passing through the button, since half of the button is outside of
    // the proxy rectangle, and the proxy will disappear if you hover over the 'outside' portion

    addButton.onmousemove = event => {
      event.stopPropagation();
    }; // prevent the mousedown event from passing through the button, which could cause the element to be deselected
    // when clicking on the area of the button that is outside of the proxy rectangle


    addButton.onmousedown = event => {
      event.stopPropagation();
    };

    const span = document.createElement('span');
    span.classList.add('icon-utility-add');
    const spanStyle = {
      backgroundSize: '9px',
      backgroundRepeat: 'no-repeat',
      backgroundPosition: 'center center',
      width: '9px',
      height: '9px',
      display: 'inline-block',
      backgroundImage: 'url(\'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" id="new"%3E%3Cpath d="M13.8 13.4h7.7c.3 0 .7-.3.7-.7v-1.4c0-.4-.4-.7-.7-.7h-7.7c-.2 0-.4-.2-.4-.4V2.5c0-.3-.3-.7-.7-.7h-1.4c-.4 0-.7.4-.7.7v7.7c0 .2-.2.4-.4.4H2.5c-.3 0-.7.3-.7.7v1.4c0 .4.4.7.7.7h7.7c.2 0 .4.2.4.4v7.7c0 .3.3.7.7.7h1.4c.4 0 .7-.4.7-.7v-7.7c0-.2.2-.4.4-.4z"%3E%3C/path%3E%3C/svg%3E\')'
    };
    Object.assign(span.style, spanStyle);
    addButton.appendChild(span);
    return addButton;
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
   * Starts ConnectionManager
   */

  function startPostMessageManager() {
    return new ConnectionManager();
  }
  /**
   * Starts listeners that listens to events from the parent window, i.e., builder.
   * These postMessages are contracts between the canvas and the builder.
   */


  function startPostMessageListeners({
    postMessageManager,
    interactions
  }) {
    /**
     * Toggles @lbf/interactions. Originates from Builder's preview mode toggle.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'set-interactions', enabled => {
      toggleInteractions(enabled, interactions);
    });
    /**
     * Handler for starting inline edit mode for the Rich Content Editor in the design environment.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'open-current-inline-editor', params => {
      const {
        itemId
      } = params;
      enableEditorMode(itemId, postMessageManager);
    });
    /**
     * Handler for event denoting successful reposition of a component in siteDotCom region.
     * Grabs the component element from the DOM and moves it to the dropzone corresponding to its new position.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'cb-dnd-move-item', data => {
      const {
        beforeId,
        container,
        item
      } = data.data;
      const componentWrapperEl = utils.querySelector(document, getElementSelector(item)).parentNode.host;
      insertComponent({
        beforeId,
        containerId: container,
        component: componentWrapperEl
      });
      interactions.selectComponent(item);
      updateRegionsVisibility();
    });
    /**
     * Handler for event denoting successful deletion of a component in siteDotCom region.
     * Deletes the corresponding component element from the DOM.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'cb-dnd-delete-item', data => {
      const {
        results
      } = data;
      interactions.deleteComponent(results.DeletedItemID);
      updateRegionsVisibility();
    });
    /**
     * Handler for event denoting starting of component dragging from builder (e.g., component palette) to the canvas.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'drag-start', data => {
      interactions.dragStart({
        mouseX: data.x,
        mouseY: data.y
      });
    });
    /**
     * Handler for event denoting external positional change of component dragging from builder (e.g., component palette) to the canvas.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'drag-mouse-position', data => {
      interactions.dragUpdate({
        mouseX: data.x,
        mouseY: data.y
      });
    });
    /**
     * Handler for event denoting external drop of component dragging from builder (e.g., component palette) to the canvas.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'drag-end', data => {
      const result = interactions.dragEnd({
        mouseX: data.x,
        mouseY: data.y
      });

      if (!isValidDropTargetForComponent(result.container.element)) {
        return;
      }

      const beforeId = result.position && result.position.beforeId;
      const containerId = result.container.key;
      /**
       * After we calculate the container and position, we postMessage back to the builder to create the component in the SiteDotCom region.
       */

      postMessageManager.sendPostmessage(window.parent, 'drop-item', {
        argument: data.argument,
        type: data.argument.properties.connectorType,
        container: containerId,
        beforeId: beforeId
      });
    });
    /**
     * Handler for event denoting successful creation of a new component in siteDotCom region.
     * Creates a new LWC component wrapper dynamically and insert the component to the dropzone corresponding to its new position.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'cb-dnd-drop-item', data => {
      const {
        argument,
        beforeId,
        container
      } = data.data;
      const {
        CurrentItemID
      } = data.results;
      const {
        fqn
      } = argument.properties; // namespace:fqn

      createComponent({
        componentName: fqn.replace(':', '/'),
        label: argument.label || fqn,
        componentAttributes: data.results.PropertiesJSON.Value,
        componentId: CurrentItemID,
        isLocked: false
      }).then(componentWrapperEl => {
        insertComponent({
          beforeId,
          containerId: container,
          component: componentWrapperEl
        });
        interactions.selectComponent(CurrentItemID);
        updateRegionsVisibility();
      });
    });
    /**
     * Handler for event denoting successful property update of a siteDotCom component.
     * Creates a new LWC component wrapper dynamically, insert the component to the dropzone corresponding to its new position and deletes the old component.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'cb-prop-changed', data => {
      const {
        id,
        props = {}
      } = data;
      const origComponentWrapperEl = utils.querySelector(document, getElementSelector(id)).parentNode.host;
      createComponent({
        componentAttributes: props,
        componentId: origComponentWrapperEl.componentId,
        componentName: origComponentWrapperEl.componentName,
        label: origComponentWrapperEl.label,
        isLocked: origComponentWrapperEl.isLocked
      }).then(componentWrapperEl => {
        // check if component is already inside a dropzone
        if (origComponentWrapperEl.parentNode && !origComponentWrapperEl.parentNode.classList.contains(REGION_WRAPPER_DROPZONE_CLASS)) {
          // if component is not in a dropzone already, find the correct dropzone
          const origComponentWrapperSiblings = origComponentWrapperEl.parentNode.children;
          const indexOfOrig = Array.from(origComponentWrapperSiblings).indexOf(origComponentWrapperEl);
          const dropzoneWrapper = Array.from(origComponentWrapperSiblings)[indexOfOrig - 1];
          const dropzoneEl = utils.querySelector(dropzoneWrapper, `.${REGION_WRAPPER_DROPZONE_CLASS}`); // delete the old component from the DOM and interaction's cache
          // since the old and new components have the same id, we need to manually invalidate the cache

          interactions.deleteComponent(id, true); // insert the new component into the dropzone

          dropzoneEl.appendChild(componentWrapperEl); // register the new component into interactions

          interactions.scan(); // select the component

          interactions.selectComponent(id);
        } else {
          // get the closest dropZone element from original componentWrapper
          const dropzoneEl = utils.closest(origComponentWrapperEl, `.${REGION_WRAPPER_DROPZONE_CLASS}`); // cache the component list and position before we delete the old component

          const childEls = Array.from(dropzoneEl.childNodes);
          const indexOfOrig = childEls.indexOf(origComponentWrapperEl); // delete the old component from the DOM and interaction's cache
          // we can't simply do replaceChild since old and new component shares the id

          interactions.deleteComponent(id, true); // insert the new component where the old one was positioned

          dropzoneEl.insertBefore(componentWrapperEl, childEls[indexOfOrig + 1]); // register the new component into interactions

          interactions.scan(); // select the component

          interactions.selectComponent(id);
        }
      });
    });
    /**
     * Handler for event that requests for the current scroll position of th canvas.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'get-scroll-position', () => {
      const yOffset = window.pageYOffset;
      const xOffset = window.pageXOffset;
      const result = {
        top: yOffset,
        left: xOffset,
        bottom: document.documentElement.scrollHeight - yOffset - window.innerHeight,
        right: document.documentElement.scrollWidth - xOffset - window.innerWidth
      };
      postMessageManager.sendPostmessage(window.parent, 'scroll-positions', result);
    });
    /**
     * Handler for event that requests metadata about a component on the canvas.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'cb-request-element-attributes', itemId => {
      const itemEl = utils.querySelector(document, getElementSelector(itemId));

      if (itemEl) {
        postMessageManager.sendPostmessage(window.parent, 'cb-response-element-attributes', {
          allowDelete: false,
          fqn: itemEl.getAttribute(ELEMENT_FQN_ATTRIBUTE_NAME),
          id: itemEl.getAttribute(ELEMENT_ID_ATTRIBUTE_NAME),
          isInTabset: false,
          isInThemeRegion: false,
          label: itemEl.getAttribute(COMPONENT_LABEL_ATTRIBUTE_NAME)
        });
      }
    });
    /**
     * Handler for event that requests that a component be selected on the canvas.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'select-element', itemId => {
      interactions.selectComponent(itemId);
    });
    /**
     * Handler for event that requests the id of the currently selected component
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'get-selected-element', () => {
      const selectedComponent = interactions.getSelectedComponent();
      let itemId;

      if (selectedComponent) {
        itemId = selectedComponent.element.dataset.itemId;
      }

      postMessageManager.sendPostmessage(window.parent, 'selected-element', itemId);
    });
    /**
     * Handler for event that notifies the canvas of branding property changes.
     */

    postMessageManager.registerPostmessageHandler(window.parent, 'reload-styles', ({
      brandingSet,
      brandingDef
    }) => {
      updateCSSVars({
        brandingSet,
        brandingDef
      });
    });
  }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }

  function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  /**
   * Starts an event handler for route change event.
   * Resets @lbf/interactions and sends route metadata to the builder.
   */

  function startRouteListeners(postMessageManager, interactionsCore) {
    routingService.subscribe(async (currentRoute = {}, currentRouteDef) => {
      const {
        attributes = {},
        state = {}
      } = currentRoute;

      const currentParams = _objectSpread$1({}, state, attributes);

      interactionsCore.invalidateAllElementCache();

      if (window.interactionsEnabled) {
        interactionsCore.enable();
      } else {
        interactionsCore.disable();
      }

      const resolvedRouteUrl = await getResolvedPath(currentRoute);
      postMessageManager.sendPostmessage(window.parent, 'route-change-success', {
        resolvedRouteUrl,
        routeId: currentRouteDef.id,
        routeParams: currentParams,
        routeUrl: currentRouteDef.path,
        viewId: currentRouteDef.viewId
      });
    });
  }
  /**
   * Gets the resolved URL path by compiling parameters into the current route path, minus the basePath.
   * @param {route} currentRoute the current route
   */


  async function getResolvedPath(currentRoute) {
    const {
      attributes = {},
      state = {}
    } = currentRoute;
    let emptyState = {}; // we don't need any additional state params

    if (currentRoute.type === 'standard__search') {
      // ...unless it's the Search route
      emptyState = {
        term: state.term
      };
    }

    const resolvedRouteUrl = await routingService.generateUrl({
      type: currentRoute.type,
      attributes,
      state: emptyState
    });
    return resolvedRouteUrl ? resolvedRouteUrl.slice(basePath.length) : ''; // remove basePath
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /**
   * Starts an event handler for toggling interactions through a custom event on the window object.
   */

  function startWindowListeners(interactionsCore) {
    window.addEventListener('set-interactions', event => {
      toggleInteractions(event.detail && event.detail.interactionsEnabled, interactionsCore);
    });
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  function regionEnableHandler({
    element
  }) {
    // style region
    Object.assign(element.style, {
      border: '1px dashed #bbbbbb',
      margin: '20px',
      padding: '20px',
      'padding-bottom': '0',
      'min-height': '60px'
    }); // clear manual DOM

    const manual = element.querySelector('.manual');

    while (manual.firstChild) {
      manual.removeChild(manual.firstChild);
    } // create region label element inside the manual DOM


    const label = document.createElement('div');
    Object.assign(label.style, {
      'text-align': 'center',
      'font-style': 'italic',
      color: '#667889'
    }); // fallback to region name when region label is not available

    label.textContent = element.getAttribute(REGION_LABEL_ATTRIBUTE_NAME) || element.getAttribute(REGION_NAME_ATTRIBUTE_NAME);
    manual.appendChild(label); // Update visibility based on children

    updateRegionVisibility(element);
  }

  function regionDisableHandler({
    element
  }) {
    Object.assign(element.style, {
      border: '',
      margin: '',
      padding: '',
      'min-height': ''
    }); // clear manual DOM

    const manual = element.querySelector(`.${REGION_WRAPPER_MANUAL_CLASS}`);

    while (manual.firstChild) {
      manual.removeChild(manual.firstChild);
    }
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function componentEnableHandler({
    element
  }) {
    Object.assign(element.style, {
      'margin-bottom': '15px'
    });
  }

  function componentDisableHandler({
    element
  }) {
    Object.assign(element.style, {
      'margin-bottom': ''
    });
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  function configureLabel(labelElement, textContent) {
    labelElement.style.visibility = '';
    labelElement.textContent = textContent;
    const labelRect = labelElement.getBoundingClientRect();
    labelElement.style.top = `-${labelRect.height}px`;
    labelElement.style.left = `calc(50% - ${labelRect.width / 2}px)`;
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const PROXY_TOOLBOX_CLASS = 'proxy-select-toolbox';
  const PROXY_TOOLBOX_ITEM_CLASS = 'proxy-select-toolbox-item';
  const PROXY_TOOLBOX_DELETE_CLASS = 'proxy-select-toolbox-delete';

  function selectProxyInitHandler({
    element,
    postMessageManager
  }) {
    const label = document.createElement('div');
    label.classList.add(PROXY_LABEL_CLASS);
    Object.assign(label.style, {
      position: 'absolute',
      padding: '0 10px',
      'background-color': '#0059A7',
      color: 'white',
      height: '26px',
      'user-select': 'none',
      'border-radius': '3px 3px 0 0',
      display: 'flex',
      'align-items': 'center',
      'justify-content': 'center'
    });
    element.appendChild(label); // create a re-usable component proxy toolbox

    const toolbox = document.createElement('div');
    toolbox.classList.add(PROXY_TOOLBOX_CLASS);
    Object.assign(toolbox.style, {
      position: 'absolute',
      top: '0',
      right: '0',
      display: 'flex',
      'user-select': 'none'
    });
    element.appendChild(toolbox); // toolbox - delete

    const toolboxDelete = document.createElement('div');
    toolboxDelete.classList.add(PROXY_TOOLBOX_ITEM_CLASS, PROXY_TOOLBOX_DELETE_CLASS);
    toolboxDelete.textContent = 'x';
    Object.assign(toolboxDelete.style, {
      height: '20px',
      width: '20px',
      'background-color': '#0059A7',
      color: 'white',
      display: 'flex',
      'align-items': 'center',
      'justify-content': 'center',
      'line-height': '20px'
    });
    toolbox.appendChild(toolboxDelete);
    toolboxDelete.addEventListener('mouseup', () => {
      const itemId = element.getAttribute(ELEMENT_ID_ATTRIBUTE_NAME);
      postMessageManager.sendPostmessage(window.parent, 'delete-item', {
        itemid: itemId
      });
    });
    return element;
  }

  function selectProxyEnableHandler({
    element,
    params,
    postMessageManager
  }) {
    const component = params.payload.element;
    element.setAttribute(ELEMENT_ID_ATTRIBUTE_NAME, component.element.getAttribute(ELEMENT_ID_ATTRIBUTE_NAME));
    const rect = component.element.getBoundingClientRect();
    const style = {
      display: '',
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      'box-shadow': '0 0 0 2px #0059A7',
      position: 'absolute',
      top: `${window.scrollY + rect.top}px`,
      left: `${window.scrollX + rect.left}px`,
      zIndex: BASE_Z_INDEX$1,
      cursor: 'pointer'
    };
    Object.assign(element.style, style); // set data-item-id with key from component element

    element.setAttribute(ELEMENT_ID_ATTRIBUTE_NAME, component.key);

    if (isElementVisible(element) && isElementVisible(component.element)) {
      const label = element.querySelector(`.${PROXY_LABEL_CLASS}`); // for sections, we hide the label and add the click-to-add buttons

      if (isSection(component.element)) {
        updateProxyForSection(element, component.element, postMessageManager);
      } else {
        configureLabel(label, component.element.getAttribute(COMPONENT_LABEL_ATTRIBUTE_NAME));
        clearSectionProxyChangesIfNeeded(element);
      }
    }
  }

  function selectProxyDisableHandler({
    element
  }) {
    element.style.display = 'none';
    clearSectionProxyChangesIfNeeded(element);
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  function hoverProxyInitHandler({
    element
  }) {
    // create a reusable hover proxy label element
    const label = document.createElement('div');
    label.classList.add(PROXY_LABEL_CLASS);
    Object.assign(label.style, {
      position: 'absolute',
      padding: '0 10px',
      'background-color': '#0069c6',
      color: 'white',
      height: '26px',
      'user-select': 'none',
      'border-radius': '3px 3px 0 0',
      display: 'flex',
      'align-items': 'center',
      'justify-content': 'center'
    });
    element.appendChild(label);
  }

  function hoverProxyEnableHandler({
    element,
    params,
    postMessageManager
  }) {
    const component = params.payload.element;
    const rect = component.element.getBoundingClientRect();
    const style = {
      display: '',
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      'box-shadow': '0 0 0 2px #0069c6',
      position: 'absolute',
      top: `${window.scrollY + rect.top}px`,
      left: `${window.scrollX + rect.left}px`,
      zIndex: BASE_Z_INDEX$1 + 1
    };
    Object.assign(element.style, style);

    if (isElementVisible(element) && isElementVisible(component.element)) {
      const label = element.querySelector(`.${PROXY_LABEL_CLASS}`); // for sections, we hide the label and add the click-to-add buttons

      if (isSection(component.element)) {
        updateProxyForSection(element, component.element, postMessageManager);
      } else {
        configureLabel(label, component.element.getAttribute(COMPONENT_LABEL_ATTRIBUTE_NAME));
        clearSectionProxyChangesIfNeeded(element);
      }
    }
  }

  function hoverProxyDisableHandler({
    element
  }) {
    element.style.display = 'none';
    clearSectionProxyChangesIfNeeded(element);
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  function dragProxyEnableHandler({
    element,
    params
  }) {
    const component = params.payload.element;
    const rect = component.element.getBoundingClientRect();
    const style = {
      display: 'block',
      position: 'fixed',
      left: `${params.payload.x - rect.width / 2}px`,
      top: `${params.payload.y - rect.height / 2}px`,
      height: `${rect.height}px`,
      width: `${rect.width}px`,
      border: '2px solid #d4d4d4',
      backgroundColor: '#f3f3f3',
      opacity: 0.5,
      zIndex: BASE_Z_INDEX$1 + 3
    };
    Object.assign(element.style, style);
  }

  function dragProxyDisableHandler({
    element
  }) {
    if (element && element.style) {
      element.style.display = 'none';
    }
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  const PROXY_BAR_CONTAINER_CLASS = 'proxy-drop-target-bar-container';
  const PROXY_BAR_LEFT_CLASS = 'proxy-drop-target-bar-left';
  const PROXY_BAR_RIGHT_CLASS = 'proxy-drop-target-bar-right';
  const PROXY_REGION_LABEL_CLASS = 'proxy-drop-target-region-label';
  const PROXY_REGION_LABEL_CONTAINER_CLASS = 'proxy-drop-target-region-label-container';
  const PROXY_REGION_LABEL_BADGE_CLASS = 'proxy-drop-target-region-label-badge';
  const PROXY_PAGE_COLOR = '#04844b';
  const PROXY_THEME_COLOR = '#cf368c';

  function createBarEl(element) {
    const barContainerEl = document.createElement('div');
    barContainerEl.classList.add(PROXY_BAR_CONTAINER_CLASS);
    element.appendChild(barContainerEl);
    const barLeftEl = document.createElement('div');
    barLeftEl.classList.add(PROXY_BAR_LEFT_CLASS);
    barContainerEl.appendChild(barLeftEl);
    const barRightEl = document.createElement('div');
    barRightEl.classList.add(PROXY_BAR_RIGHT_CLASS);
    barContainerEl.appendChild(barRightEl);
  }

  function createRegionEl(element) {
    const labelContainerEl = document.createElement('div');
    labelContainerEl.classList.add(PROXY_REGION_LABEL_CONTAINER_CLASS);
    Object.assign(labelContainerEl.style, {
      position: 'absolute',
      padding: '0 10px',
      color: 'white',
      height: '26px',
      'user-select': 'none',
      'border-radius': '3px 3px 0 0',
      display: 'flex',
      'align-items': 'center',
      'justify-content': 'center',
      top: '-26px'
    });
    element.appendChild(labelContainerEl);
    const labelEl = document.createElement('div');
    labelEl.classList.add(PROXY_REGION_LABEL_CLASS);
    Object.assign(labelEl.style, {
      color: '#fff'
    });
    labelContainerEl.appendChild(labelEl);
    const badgeEl = document.createElement('div');
    badgeEl.classList.add(PROXY_REGION_LABEL_BADGE_CLASS);
    Object.assign(badgeEl.style, {
      color: '#fff',
      'font-size': '9px',
      'text-transform': 'inherit',
      'background-color': 'rgba(0, 0, 0, 0.2)',
      padding: '2px 10px',
      'margin-left': '7px',
      'border-radius': '7px'
    });
    labelContainerEl.appendChild(badgeEl);
  }

  function dropTargetProxyInitHandler({
    element
  }) {
    createBarEl(element);
    createRegionEl(element);
  }

  function getRegionProxyColor(type) {
    if (type === 'theme') {
      return PROXY_THEME_COLOR;
    }

    return PROXY_PAGE_COLOR;
  }

  function styleRegionProxyBadge(element, containerElement) {
    const badgeLabel = containerElement.getAttribute('data-region-badge-label');
    const badgeEl = element.querySelector(`.${PROXY_REGION_LABEL_BADGE_CLASS}`);

    if (badgeLabel) {
      badgeEl.style.display = '';
      badgeEl.textContent = badgeLabel;
    } else {
      badgeEl.style.display = 'none';
    }
  }

  function styleRegionProxyLabel(element, containerElement) {
    const containerType = containerElement.getAttribute('data-region-type');
    const regionLabelContainerEl = element.querySelector(`.${PROXY_REGION_LABEL_CONTAINER_CLASS}`);
    const regionLabelEl = element.querySelector(`.${PROXY_REGION_LABEL_CLASS}`);
    regionLabelEl.textContent = containerElement.getAttribute(REGION_LABEL_ATTRIBUTE_NAME);
    const regionLabelElRect = regionLabelContainerEl.getBoundingClientRect();
    regionLabelContainerEl.style.left = `calc(50% - ${regionLabelElRect.width / 2}px)`;
    regionLabelContainerEl.style.backgroundColor = getRegionProxyColor(containerType);
  }

  function styleRegionProxy({
    element,
    rect,
    container
  }) {
    const containerElement = container.element;
    const containerType = containerElement.getAttribute('data-region-type');
    const style = {
      display: '',
      width: `${rect.width}px`,
      height: `${rect.height}px`,
      outline: `2px solid ${getRegionProxyColor(containerType)}`,
      position: 'absolute',
      left: `${window.scrollX + rect.left}px`,
      top: `${window.scrollY + rect.top}px`,
      zIndex: BASE_Z_INDEX$1 - 1
    };
    Object.assign(element.style, style); // show label when proxy and component proxy is visible

    if (isElementVisible(element)) {
      styleRegionProxyLabel(element, containerElement);
      styleRegionProxyBadge(element, containerElement);
    }
  }

  function styleDropBarProxy({
    element,
    position,
    rect
  }) {
    const barEl = element.querySelector(`.${PROXY_BAR_CONTAINER_CLASS}`);
    const barStyle = {
      position: 'absolute',
      height: `0px`,
      borderTop: '1px solid #0059A7',
      backgroundColor: '#0059A7',
      zIndex: BASE_Z_INDEX$1 + 2,
      display: ''
    };

    if (position) {
      const {
        x,
        y,
        width
      } = position;
      barStyle.width = `${width}px`;
      barStyle.left = `${window.scrollX + x - (window.scrollX + rect.left)}px`;
      barStyle.top = `${window.scrollY + y - (window.scrollY + rect.top)}px`;
    } else {
      barStyle.left = `${window.scrollX + rect.left}px`;
      barStyle.top = `${rect.height / 2}px`;
      barStyle.width = `${rect.width - 30}px`;
    }

    Object.assign(barEl.style, barStyle);
    const barLeftRightStyle = {
      height: '11px',
      'background-color': '#0059A7',
      position: 'absolute',
      width: '1px',
      top: '-6px'
    };
    const barLeftEl = element.querySelector(`.${PROXY_BAR_LEFT_CLASS}`);
    Object.assign(barLeftEl.style, barLeftRightStyle);
    const barRightEl = element.querySelector(`.${PROXY_BAR_RIGHT_CLASS}`);
    Object.assign(barRightEl.style, barLeftRightStyle);
    barRightEl.style.right = '0';
  }

  function dropTargetProxyEnableHandler({
    element,
    params
  }) {
    const {
      payload
    } = params;
    const {
      position,
      container
    } = payload;

    if (container && isValidDropTarget(payload.element && payload.element.element, container.element)) {
      const rect = container.element.getBoundingClientRect();
      styleRegionProxy({
        element,
        rect,
        container
      });
      styleDropBarProxy({
        element,
        position,
        rect
      });
    } else {
      element.style.display = 'none';
    }
  }

  function dropTargetProxyDisableHandler({
    element
  }) {
    element.style.display = 'none';
  }

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  function dropEventHandler({
    element,
    position,
    container,
    postMessageManager
  }) {
    if (element && isValidDropTarget(element.element, container.element)) {
      const beforeId = position && position.beforeId;
      const containerId = container.key;
      const itemId = element.key;
      postMessageManager.sendPostmessage(window.parent, 'move-item', {
        beforeId,
        container: containerId,
        item: itemId
      });
    }
  }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

  function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  /**
   * Observer for state
   * Gets triggered everytime there is a state change within @lbf/interactions
   */

  function stateObserver({
    prop,
    val,
    postMessageManager
  }) {
    handleStateChange(prop, postMessageManager); // when prop === 'current', this indicates a change to the currently selected interactions element
    // that is, either a new element has been selected, or the current element has been deselected

    if (prop === 'current') {
      if (val) {
        postMessageManager.sendPostmessage(window.parent, 'select-item', {
          id: val.key
        });
      } else {
        postMessageManager.sendPostmessage(window.parent, 'unselect-element');
      }
    }
  }
  /**
   * Start the designmode
   */


  function start() {
    const postMessageManager = startPostMessageManager(); // inform the builder that the canvas has loaded

    postMessageManager.sendPostmessage(window.parent, 'live-loaded');

    const configuration = _objectSpread$2({}, defaultConfig, {
      selectHandler: () => {},
      // override to remove default behavior
      element: _objectSpread$2({}, defaultConfig.element, {
        selector: `.${ELEMENT_WRAPPER_CLASS}`,
        key: el => el.getAttribute(ELEMENT_ID_ATTRIBUTE_NAME),
        handlers: {
          enable: ({
            context
          }) => {
            if (context.isContainer) {
              regionEnableHandler(context);
            } else {
              componentEnableHandler(context);
            }
          },
          disable: ({
            context
          }) => {
            if (context.isContainer) {
              regionDisableHandler(context);
            } else {
              componentDisableHandler(context);
            }
          }
        }
      }),
      proxy: _objectSpread$2({}, defaultConfig.proxy, {
        select: {
          init: ({
            element
          }) => {
            selectProxyInitHandler({
              element,
              postMessageManager
            });
          },
          enable: ({
            element,
            params
          }) => {
            selectProxyEnableHandler({
              element,
              params,
              postMessageManager
            });
          },
          disable: selectProxyDisableHandler
        },
        drag: {
          enable: dragProxyEnableHandler,
          disable: dragProxyDisableHandler
        },
        hover: {
          init: hoverProxyInitHandler,
          enable: ({
            element,
            params
          }) => {
            hoverProxyEnableHandler({
              element,
              params,
              postMessageManager
            });
          },
          disable: hoverProxyDisableHandler
        },
        dropTarget: {
          init: dropTargetProxyInitHandler,
          enable: dropTargetProxyEnableHandler,
          disable: dropTargetProxyDisableHandler
        }
      }),
      dropHandler: ({
        element,
        position,
        container
      }) => {
        dropEventHandler({
          element,
          position,
          container,
          postMessageManager
        });
      },
      stateObserver: (obj, prop, val) => {
        stateObserver({
          prop,
          val,
          postMessageManager
        });
      }
    }); // initialize @lbf/interactions


    const instance = new Interactions({
      key: 'webruntime',
      scope: document,
      selector: `.${ELEMENT_WRAPPER_CLASS}`,
      configuration: configuration
    });
    interactionsManager.setInteractions(instance); // start polling

    instance.poll(POLLING_INTERVAL); // start all the listeners

    startRouteListeners(postMessageManager, instance);
    startWindowListeners(instance);
    startDocumentListeners(postMessageManager);
    startPostMessageListeners({
      postMessageManager,
      interactions: instance
    });
  }

  function tmpl$2($api, $cmp, $slotset, $ctx) {
    const {
      s: api_slot,
      h: api_element
    } = $api;
    return [api_element("div", {
      classMap: {
        "interactions-region": true,
        "interactions-element": true
      },
      attrs: {
        "data-allow-drop": "true",
        "data-item-id": $cmp.regionId,
        "data-region-name": $cmp.regionName,
        "data-region-label": $cmp.label,
        "data-region-type": $cmp.type,
        "data-region-locked": $cmp.isLocked,
        "data-region-badge-label": $cmp.badgeLabel
      },
      key: 3
    }, [api_slot("", {
      key: 0
    }, [], $slotset), api_element("div", {
      classMap: {
        "manual": true
      },
      context: {
        lwc: {
          dom: "manual"
        }
      },
      key: 1
    }, []), api_element("div", {
      classMap: {
        "proxy-container": true
      },
      context: {
        lwc: {
          dom: "manual"
        }
      },
      key: 2
    }, [])])];
  }

  var _tmpl$2 = lwc.registerTemplate(tmpl$2);
  tmpl$2.slots = [""];
  tmpl$2.stylesheets = [];
  tmpl$2.stylesheetTokens = {
    hostAttribute: "webruntimedesign-regionWrapper_regionWrapper-host",
    shadowAttribute: "webruntimedesign-regionWrapper_regionWrapper"
  };

  class RegionWrapper extends lwc.LightningElement {
    constructor(...args) {
      super(...args);
      this.regionId = void 0;
      this.label = void 0;
      this.regionName = void 0;
      this.type = 'page';
      this.badgeLabel = '';
      this.isLocked = false;
    }

  }

  lwc.registerDecorators(RegionWrapper, {
    publicProps: {
      regionId: {
        config: 0
      },
      label: {
        config: 0
      },
      regionName: {
        config: 0
      },
      type: {
        config: 0
      },
      badgeLabel: {
        config: 0
      },
      isLocked: {
        config: 0
      }
    }
  });

  var regionWrapper = lwc.registerComponent(RegionWrapper, {
    tmpl: _tmpl$2
  });

  function tmpl$3($api, $cmp, $slotset, $ctx) {
    const {
      h: api_element
    } = $api;
    return [api_element("div", {
      classMap: {
        "dropzone": true
      },
      attrs: {
        "data-item-id": $cmp.regionId
      },
      context: {
        lwc: {
          dom: "manual"
        }
      },
      key: 0
    }, [])];
  }

  var _tmpl$3 = lwc.registerTemplate(tmpl$3);
  tmpl$3.stylesheets = [];
  tmpl$3.stylesheetTokens = {
    hostAttribute: "webruntimedesign-dropRegion_dropRegion-host",
    shadowAttribute: "webruntimedesign-dropRegion_dropRegion"
  };

  class DropRegion extends lwc.LightningElement {
    constructor(...args) {
      super(...args);
      this.regionId = void 0;
    }

  }

  lwc.registerDecorators(DropRegion, {
    publicProps: {
      regionId: {
        config: 0
      }
    }
  });

  var dropRegion = lwc.registerComponent(DropRegion, {
    tmpl: _tmpl$3
  });

  /**
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */
  /*
   * Register framework modules available to templates modules.
   */

  loader.defineModules({
    'webruntimedesign/componentWrapper': componentWrapper,
    'webruntimedesign/regionWrapper': regionWrapper,
    'webruntimedesign/dropRegion': dropRegion,
    'webruntimedesign/componentService': componentService,
    'webruntimedesign/designComponent': designComponent
  }); // Initialize designmode when DOM is ready.

  if (/interactive|complete/.test(document.readyState)) {
    // DOMContentLoaded has already been fired
    start();
  } else {
    document.addEventListener('DOMContentLoaded', start, false);
  }

});
