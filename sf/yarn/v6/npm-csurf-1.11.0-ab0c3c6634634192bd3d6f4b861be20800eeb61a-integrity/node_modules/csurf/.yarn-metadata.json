{
  "manifest": {
    "name": "csurf",
    "description": "CSRF token middleware",
    "version": "1.11.0",
    "author": {
      "name": "Jonathan Ong",
      "email": "me@jongleberry.com",
      "url": "http://jongleberry.com"
    },
    "contributors": [
      {
        "name": "Douglas Christopher Wilson",
        "email": "doug@somethingdoug.com"
      }
    ],
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/expressjs/csurf.git"
    },
    "dependencies": {
      "cookie": "0.4.0",
      "cookie-signature": "1.0.6",
      "csrf": "3.1.0",
      "http-errors": "~1.7.3"
    },
    "devDependencies": {
      "body-parser": "1.19.0",
      "connect": "3.7.0",
      "cookie-parser": "1.4.4",
      "cookie-session": "1.4.0",
      "eslint": "6.8.0",
      "eslint-config-standard": "14.1.0",
      "eslint-plugin-import": "2.20.0",
      "eslint-plugin-markdown": "1.0.1",
      "eslint-plugin-node": "11.0.0",
      "eslint-plugin-promise": "4.2.1",
      "eslint-plugin-standard": "4.0.1",
      "mocha": "7.0.0",
      "nyc": "15.0.0",
      "supertest": "4.0.2"
    },
    "engines": {
      "node": ">= 0.8.0"
    },
    "scripts": {
      "lint": "eslint --plugin markdown --ext js,md .",
      "test": "mocha --check-leaks --reporter spec --bail test/",
      "test-cov": "nyc --reporter=html --reporter=text npm test",
      "test-travis": "nyc --reporter=text npm test"
    },
    "files": [
      "HISTORY.md",
      "LICENSE",
      "index.js"
    ],
    "keywords": [
      "csrf",
      "tokens",
      "middleware",
      "express"
    ],
    "_registry": "npm",
    "_loc": "C:\\Users\\csmku\\AppData\\Local\\sf\\yarn\\v6\\npm-csurf-1.11.0-ab0c3c6634634192bd3d6f4b861be20800eeb61a-integrity\\node_modules\\csurf\\package.json",
    "readmeFilename": "README.md",
    "readme": "# csurf\n\n[![NPM Version][npm-version-image]][npm-url]\n[![NPM Downloads][npm-downloads-image]][node-url]\n[![Build status][travis-image]][travis-url]\n[![Test coverage][coveralls-image]][coveralls-url]\n\nNode.js [CSRF][wikipedia-csrf] protection middleware.\n\nRequires either a session middleware or [cookie-parser](https://www.npmjs.com/package/cookie-parser) to be initialized first.\n\n  * If you are setting the [\"cookie\" option](#cookie) to a non-`false` value,\n    then you must use [cookie-parser](https://www.npmjs.com/package/cookie-parser)\n    before this module.\n  * Otherwise, you must use a session middleware before this module. For example:\n    - [express-session](https://www.npmjs.com/package/express-session)\n    - [cookie-session](https://www.npmjs.com/package/cookie-session)\n\nIf you have questions on how this module is implemented, please read\n[Understanding CSRF](https://github.com/pillarjs/understanding-csrf).\n\n## Installation\n\nThis is a [Node.js](https://nodejs.org/en/) module available through the\n[npm registry](https://www.npmjs.com/). Installation is done using the\n[`npm install` command](https://docs.npmjs.com/getting-started/installing-npm-packages-locally):\n\n```sh\n$ npm install csurf\n```\n\n## API\n\n<!-- eslint-disable no-unused-vars -->\n\n```js\nvar csurf = require('csurf')\n```\n\n### csurf([options])\n\nCreate a middleware for CSRF token creation and validation. This middleware\nadds a `req.csrfToken()` function to make a token which should be added to\nrequests which mutate state, within a hidden form field, query-string etc.\nThis token is validated against the visitor's session or csrf cookie.\n\n#### Options\n\nThe `csurf` function takes an optional `options` object that may contain\nany of the following keys:\n\n##### cookie\n\nDetermines if the token secret for the user should be stored in a cookie\nor in `req.session`. Storing the token secret in a cookie implements\nthe [double submit cookie pattern][owsap-csrf-double-submit].\nDefaults to `false`.\n\nWhen set to `true` (or an object of options for the cookie), then the module\nchanges behavior and no longer uses `req.session`. This means you _are no\nlonger required to use a session middleware_. Instead, you do need to use the\n[cookie-parser](https://www.npmjs.com/package/cookie-parser) middleware in\nyour app before this middleware.\n\nWhen set to an object, cookie storage of the secret is enabled and the\nobject contains options for this functionality (when set to `true`, the\ndefaults for the options are used). The options may contain any of the\nfollowing keys:\n\n  - `key` - the name of the cookie to use to store the token secret\n    (defaults to `'_csrf'`).\n  - `path` - the path of the cookie (defaults to `'/'`).\n  - `signed` - indicates if the cookie should be signed (defaults to `false`).\n  - `secure` - marks the cookie to be used with HTTPS only (defaults to\n    `false`).\n  - `maxAge` - the number of seconds after which the cookie will expire\n    (defaults to session length).\n  - `httpOnly` - flags the cookie to be accessible only by the web server\n    (defaults to `false`).\n  - `sameSite` - sets the same site policy for the cookie(defaults to\n    `false`). This can be set to `'strict'`, `'lax'`, `'none'`, or `true`\n    (which maps to `'strict'`).\n  - `domain` - sets the domain the cookie is valid on(defaults to current\n    domain).\n\n##### ignoreMethods\n\nAn array of the methods for which CSRF token checking will disabled.\nDefaults to `['GET', 'HEAD', 'OPTIONS']`.\n\n##### sessionKey\n\nDetermines what property (\"key\") on `req` the session object is located.\nDefaults to `'session'` (i.e. looks at `req.session`). The CSRF secret\nfrom this library is stored and read as `req[sessionKey].csrfSecret`.\n\nIf the [\"cookie\" option](#cookie) is not `false`, then this option does\nnothing.\n\n##### value\n\nProvide a function that the middleware will invoke to read the token from\nthe request for validation. The function is called as `value(req)` and is\nexpected to return the token as a string.\n\nThe default value is a function that reads the token from the following\nlocations, in order:\n\n  - `req.body._csrf` - typically generated by the `body-parser` module.\n  - `req.query._csrf` - a built-in from Express.js to read from the URL\n    query string.\n  - `req.headers['csrf-token']` - the `CSRF-Token` HTTP request header.\n  - `req.headers['xsrf-token']` - the `XSRF-Token` HTTP request header.\n  - `req.headers['x-csrf-token']` - the `X-CSRF-Token` HTTP request header.\n  - `req.headers['x-xsrf-token']` - the `X-XSRF-Token` HTTP request header.\n\n## Example\n\n### Simple express example\n\nThe following is an example of some server-side code that generates a form\nthat requires a CSRF token to post back.\n\n```js\nvar cookieParser = require('cookie-parser')\nvar csrf = require('csurf')\nvar bodyParser = require('body-parser')\nvar express = require('express')\n\n// setup route middlewares\nvar csrfProtection = csrf({ cookie: true })\nvar parseForm = bodyParser.urlencoded({ extended: false })\n\n// create express app\nvar app = express()\n\n// parse cookies\n// we need this because \"cookie\" is true in csrfProtection\napp.use(cookieParser())\n\napp.get('/form', csrfProtection, function (req, res) {\n  // pass the csrfToken to the view\n  res.render('send', { csrfToken: req.csrfToken() })\n})\n\napp.post('/process', parseForm, csrfProtection, function (req, res) {\n  res.send('data is being processed')\n})\n```\n\nInside the view (depending on your template language; handlebars-style\nis demonstrated here), set the `csrfToken` value as the value of a hidden\ninput field named `_csrf`:\n\n```html\n<form action=\"/process\" method=\"POST\">\n  <input type=\"hidden\" name=\"_csrf\" value=\"{{csrfToken}}\">\n  \n  Favorite color: <input type=\"text\" name=\"favoriteColor\">\n  <button type=\"submit\">Submit</button>\n</form>\n```\n\n#### Using AJAX\n\nWhen accessing protected routes via ajax both the csrf token will need to be\npassed in the request. Typically this is done using a request header, as adding\na request header can typically be done at a central location easily without\npayload modification.\n\nThe CSRF token is obtained from the `req.csrfToken()` call on the server-side.\nThis token needs to be exposed to the client-side, typically by including it in\nthe initial page content. One possibility is to store it in an HTML `<meta>` tag,\nwhere value can then be retrieved at the time of the request by JavaScript.\n\nThe following can be included in your view (handlebar example below), where the\n`csrfToken` value came from `req.csrfToken()`:\n\n```html\n<meta name=\"csrf-token\" content=\"{{csrfToken}}\">\n```\n\nThe following is an example of using the\n[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to post\nto the `/process` route with the CSRF token from the `<meta>` tag on the page:\n\n<!-- eslint-env browser -->\n\n```js\n// Read the CSRF token from the <meta> tag\nvar token = document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content')\n\n// Make a request using the Fetch API\nfetch('/process', {\n  credentials: 'same-origin', // <-- includes cookies in the request\n  headers: {\n    'CSRF-Token': token // <-- is the csrf token as a header\n  },\n  method: 'POST',\n  body: {\n    favoriteColor: 'blue'\n  }\n})\n```\n\n#### Single Page Application (SPA)\n\nMany SPA frameworks like Angular have CSRF support built in automatically.\nTypically they will reflect the value from a specific cookie, like\n`XSRF-TOKEN` (which is the case for Angular).\n\nTo take advantage of this, set the value from `req.csrfToken()` in the cookie\nused by the SPA framework. This is only necessary to do on the route that\nrenders the page (where `res.render` or `res.sendFile` is called in Express,\nfor example).\n\nThe following is an example for Express of a typical SPA response:\n\n<!-- eslint-disable no-undef -->\n\n```js\napp.all('*', function (req, res) {\n  res.cookie('XSRF-TOKEN', req.csrfToken())\n  res.render('index')\n})\n```\n\n### Ignoring Routes\n\n**Note** CSRF checks should only be disabled for requests that you expect to\ncome from outside of your website. Do not disable CSRF checks for requests\nthat you expect to only come from your website. An existing session, even if\nit belongs to an authenticated user, is not enough to protect against CSRF\nattacks.\n\nThe following is an example of how to order your routes so that certain endpoints\ndo not check for a valid CSRF token.\n\n```js\nvar cookieParser = require('cookie-parser')\nvar csrf = require('csurf')\nvar bodyParser = require('body-parser')\nvar express = require('express')\n\n// create express app\nvar app = express()\n\n// create api router\nvar api = createApiRouter()\n\n// mount api before csrf is appended to the app stack\napp.use('/api', api)\n\n// now add csrf and other middlewares, after the \"/api\" was mounted\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(cookieParser())\napp.use(csrf({ cookie: true }))\n\napp.get('/form', function (req, res) {\n  // pass the csrfToken to the view\n  res.render('send', { csrfToken: req.csrfToken() })\n})\n\napp.post('/process', function (req, res) {\n  res.send('csrf was required to get here')\n})\n\nfunction createApiRouter () {\n  var router = new express.Router()\n\n  router.post('/getProfile', function (req, res) {\n    res.send('no csrf to get here')\n  })\n\n  return router\n}\n```\n\n### Custom error handling\n\nWhen the CSRF token validation fails, an error is thrown that has\n`err.code === 'EBADCSRFTOKEN'`. This can be used to display custom\nerror messages.\n\n```js\nvar bodyParser = require('body-parser')\nvar cookieParser = require('cookie-parser')\nvar csrf = require('csurf')\nvar express = require('express')\n\nvar app = express()\napp.use(bodyParser.urlencoded({ extended: false }))\napp.use(cookieParser())\napp.use(csrf({ cookie: true }))\n\n// error handler\napp.use(function (err, req, res, next) {\n  if (err.code !== 'EBADCSRFTOKEN') return next(err)\n\n  // handle CSRF token errors here\n  res.status(403)\n  res.send('form tampered with')\n})\n```\n\n## References\n\n- [Cross-side request forgery on Wikipedia][wikipedia-csrf]\n- [OWASP Cross-Site Request Forgery Prevention Cheat Sheet][owsap-csrf]\n\n[owsap-csrf]: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\n[owsap-csrf-double-submit]: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie\n[wikipedia-csrf]: https://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n## License\n\n[MIT](LICENSE)\n\n[coveralls-image]: https://badgen.net/coveralls/c/github/expressjs/csurf/master\n[coveralls-url]: https://coveralls.io/r/expressjs/csurf?branch=master\n[node-url]: https://nodejs.org/en/download\n[npm-downloads-image]: https://badgen.net/npm/dm/csurf\n[npm-url]: https://npmjs.org/package/csurf\n[npm-version-image]: https://badgen.net/npm/v/csurf\n[travis-image]: https://badgen.net/travis/expressjs/csurf/master\n[travis-url]: https://travis-ci.org/expressjs/csurf\n",
    "licenseText": "(The MIT License)\n\nCopyright (c) 2014 Jonathan Ong <me@jongleberry.com>\nCopyright (c) 2014-2016 Douglas Christopher Wilson <doug@somethingdoug.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/csurf/-/csurf-1.11.0.tgz#ab0c3c6634634192bd3d6f4b861be20800eeb61a",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/csurf/-/csurf-1.11.0.tgz",
    "hash": "ab0c3c6634634192bd3d6f4b861be20800eeb61a",
    "integrity": "sha512-UCtehyEExKTxgiu8UHdGvHj4tnpE/Qctue03Giq5gPgMQ9cg/ciod5blZQ5a4uCEenNQjxyGuzygLdKUmee/bQ==",
    "registry": "npm",
    "packageName": "csurf",
    "cacheIntegrity": "sha512-UCtehyEExKTxgiu8UHdGvHj4tnpE/Qctue03Giq5gPgMQ9cg/ciod5blZQ5a4uCEenNQjxyGuzygLdKUmee/bQ== sha1-qww8ZjRjQZK9PW9LhhviCADutho="
  },
  "registry": "npm",
  "hash": "ab0c3c6634634192bd3d6f4b861be20800eeb61a"
}