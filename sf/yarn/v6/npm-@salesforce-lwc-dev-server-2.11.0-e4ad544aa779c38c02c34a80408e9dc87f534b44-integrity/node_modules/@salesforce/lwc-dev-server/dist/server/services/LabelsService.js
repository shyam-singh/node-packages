"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const fast_xml_parser_1 = __importDefault(require("fast-xml-parser"));
const debug_1 = __importDefault(require("debug"));
const api_1 = require("@webruntime/api");
const compiler_1 = require("@webruntime/compiler");
const chokidar_1 = require("chokidar");
const errors_1 = require("@lwc/errors");
const module_resolver_1 = require("@lwc/module-resolver");
const NAMESPACE = '@salesforce/label';
const URI_PREFIX = `/label/:mode/:locale/:name`;
const PACKAGE_MAPPING = `${NAMESPACE}/`;
const debug = debug_1.default('localdevserver:labelsservice');
function getLabelService(customLabelsPath) {
    return class LabelService extends api_1.AddressableService {
        constructor(publicConfig) {
            super(URI_PREFIX);
            this.customLabels = {};
            this.moduleLabels = {};
            this.mappings = {
                [NAMESPACE]: URI_PREFIX
            };
            this.moduleCache = new Map();
            this.publicConfig = publicConfig;
            this.moduleLabelsCache = new compiler_1.LoadingCache(this.loadModuleLabel.bind(this));
        }
        async initialize() {
            this.customLabels = this.loadCustomLabels(customLabelsPath);
            this.moduleLabels = await this.loadModuleLabels();
            if (customLabelsPath) {
                this.watcher = chokidar_1.watch(customLabelsPath).on('change', () => {
                    this.moduleCache.clear();
                    this.customLabels = this.loadCustomLabels(customLabelsPath);
                });
            }
            debug('Labels loaded', this.customLabels);
        }
        async shutdown() {
            if (this.watcher) {
                await this.watcher.close();
            }
        }
        toSpecifier(url) {
            const { name } = this.parseUrl(url);
            return `${NAMESPACE}/${name}`;
        }
        loadCustomLabels(labelsPath) {
            if (!labelsPath) {
                debug('custom labels file not specified');
                return {};
            }
            if (!fs_extra_1.default.existsSync(labelsPath)) {
                console.warn(`Warning: Labels file '${labelsPath}' does not exist.`);
                return {};
            }
            const xmlContent = fs_extra_1.default.readFileSync(labelsPath, 'utf8');
            const parsedXml = fast_xml_parser_1.default.parse(xmlContent);
            if (!parsedXml.CustomLabels || !parsedXml.CustomLabels.labels) {
                console.warn(`custom labels file '${labelsPath}' did not have expected format or was empty, ignoring.`);
                return {};
            }
            let labels = parsedXml.CustomLabels.labels;
            if (!Array.isArray(labels)) {
                labels = [labels];
            }
            const processed = labels.reduce((obj, label) => {
                if (label.fullName && label.value) {
                    obj['c.' + label.fullName] = label.value;
                }
                return obj;
            }, {});
            debug(`found custom labels: ${JSON.stringify(processed, null, 2)}`);
            return processed;
        }
        resolveAllModules(projectDir, moduleDir, customModuleDirs = []) {
            if (projectDir === undefined) {
                return [];
            }
            return module_resolver_1.resolveModules({
                rootDir: projectDir,
                modules: moduleDir
                    ? [moduleDir, ...customModuleDirs]
                    : customModuleDirs
            });
        }
        async loadModuleLabels() {
            if (!this.publicConfig) {
                return {};
            }
            const lwcOptions = this.publicConfig.compilerConfig.lwcOptions || {
                modules: []
            };
            const modules = this.resolveAllModules(this.publicConfig.projectDir, this.publicConfig.moduleDir, lwcOptions.modules);
            const labelResolutions = {};
            modules.forEach((mapping) => {
                if (mapping.specifier.startsWith(PACKAGE_MAPPING)) {
                    labelResolutions[specifierToCacheKey(mapping.specifier)] =
                        mapping.entry;
                }
            });
            return labelResolutions;
        }
        loadModuleLabel(specifier) {
            return fs_extra_1.default.readFileSync(this.moduleLabels[specifierToCacheKey(specifier)], 'utf-8');
        }
        async compileLabel(specifier, params, context) {
            debug(`compile label: ${specifier}`);
            const { mode, locale } = params;
            const descriptor = `${mode}/${NAMESPACE}/${specifier}@${locale}`;
            let moduleDef = this.moduleCache.get(descriptor);
            if (!moduleDef) {
                debug(`No cached module for label ${specifier}. Compiling now.`);
                const label = this.customLabels[specifier];
                if (label) {
                    const files = {
                        [`${NAMESPACE}/${specifier}.js`]: `export default "${label}"`
                    };
                    moduleDef = await compiler_1.compile({
                        ...context,
                        name: specifier,
                        namespace: NAMESPACE,
                        files
                    });
                    if (moduleDef && moduleDef.success) {
                        this.moduleCache.set(`${descriptor}`, moduleDef);
                        debug(`Compiling label ${specifier} succeeded.`);
                    }
                    else {
                        debug(`Compiling label ${specifier} failed.`);
                    }
                }
            }
            return moduleDef;
        }
        async request(specifier, params, context) {
            const parts = specifier.split('/');
            const id = parts[2];
            const compilerOutput = await this.compileLabel(id, params, context);
            if (!compilerOutput) {
                debug(`Attempting to load label ${id} failed.`);
                return {
                    type: api_1.RequestOutputTypes.COMPONENT,
                    specifier,
                    success: false,
                    diagnostics: [
                        {
                            code: -1,
                            message: 'Compiler output undefined or null',
                            level: errors_1.DiagnosticLevel.Fatal
                        }
                    ]
                };
            }
            const { result, metadata, success, diagnostics } = compilerOutput;
            return {
                type: api_1.RequestOutputTypes.COMPONENT,
                specifier,
                resource: result,
                metadata,
                success,
                diagnostics
            };
        }
        getPlugin() {
            const customlabels = this.customLabels;
            const moduleLabels = this.moduleLabels;
            const moduleLabelsCache = this.moduleLabelsCache;
            return {
                name: 'labels-addressable-service',
                resolveId(specifier) {
                    if (specifier.startsWith(PACKAGE_MAPPING)) {
                        return `${specifier}.js`;
                    }
                    return null;
                },
                load(specifier) {
                    if (specifier.startsWith(PACKAGE_MAPPING)) {
                        const key = specifierToCacheKey(specifier);
                        if (moduleLabels.hasOwnProperty(key)) {
                            return moduleLabelsCache.get(key);
                        }
                        if (customlabels.hasOwnProperty(key)) {
                            return `export default "${customlabels[key]}"`;
                        }
                        return `export default "[${key}]"`;
                    }
                    return null;
                }
            };
        }
    };
}
exports.getLabelService = getLabelService;
function specifierToCacheKey(specifier) {
    return specifier
        .replace(PACKAGE_MAPPING, '')
        .replace('.js', '')
        .replace('/', '.');
}
//# sourceMappingURL=LabelsService.js.map