/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import perfHooks from 'perf_hooks';
import { Measure, endMeasure, startMeasure } from '../performance-timing';

jest.mock('perf_hooks');

describe('@webruntime/performance > performance-timing', () => {
    let measure;
    const measureName = 'test-measure';
    const measureNameRegex = new RegExp(`^${measureName}-\\d{6}`);

    afterEach(() => {
        jest.clearAllMocks();
    });

    it('calls performance.mark on startMeasure', () => {
        measure = startMeasure(measureName);
        expect(perfHooks.performance.mark).toHaveBeenCalled();
    });

    it('should return the given measure name with uniqueness added', () => {
        expect(measureNameRegex.test(measure)).toBe(true);
    });

    it('calls performance.mark on endMeasure', () => {
        endMeasure(measure);
        expect(perfHooks.performance.mark).toHaveBeenCalled();
    });

    it('calls performance.measure on endMeasure', () => {
        endMeasure(measure);
        expect(perfHooks.performance.measure).toHaveBeenCalled();
    });

    it('calls performance.clearMarks on endMeasure', () => {
        endMeasure(measure);
        expect(perfHooks.performance.clearMarks).toHaveBeenCalled();
    });

    describe('@Measure decorator', () => {
        const measureNameFunc = jest.fn().mockReturnValue('just-a-test');
        class TestClass {
            @Measure('just-a-test')
            stringMethod() {
                return 'string-method';
            }

            @Measure(measureNameFunc)
            functionMethod() {
                return 'function-method';
            }

            @Measure('just-a-promise-resolution')
            resolvedPromiseMethod() {
                return Promise.resolve('resolved-promise');
            }

            @Measure(measureNameFunc)
            rejectedPromiseMethod() {
                return Promise.reject('rejected-promise');
            }
        }

        describe('with string passed in', () => {
            let returnValue;

            afterEach(() => {
                jest.clearAllMocks();
            });

            beforeEach(() => {
                returnValue = new TestClass().stringMethod();
            });

            it('calls performance.mark', () => {
                // Check for two calls - one to set the starting mark and one to set the ending mark
                expect(perfHooks.performance.mark).toHaveBeenCalledTimes(2);
            });

            it('calls performance.measure', () => {
                expect(perfHooks.performance.measure).toHaveBeenCalled();
            });

            it('calls performance.clearMarks', () => {
                // Called twice to clear starting and ending marks
                expect(perfHooks.performance.clearMarks).toHaveBeenCalledTimes(2);
            });

            it('calls the original function and returns the correct value', () => {
                expect(returnValue).toEqual('string-method');
            });
        });

        describe('with function passed in', () => {
            let returnValue;

            afterEach(() => {
                jest.clearAllMocks();
            });

            beforeEach(() => {
                returnValue = new TestClass().functionMethod();
            });

            it('calls the function passed as a parameter to get the measure name', () => {
                expect(measureNameFunc).toHaveBeenCalled();
            });

            it('calls performance.mark', () => {
                // Check for two calls - one to set the starting mark and one to set the ending mark
                expect(perfHooks.performance.mark).toHaveBeenCalledTimes(2);
            });

            it('calls performance.measure', () => {
                expect(perfHooks.performance.measure).toHaveBeenCalled();
            });

            it('calls performance.clearMarks', () => {
                // Called twice to clear starting and ending marks
                expect(perfHooks.performance.clearMarks).toHaveBeenCalledTimes(2);
            });

            it('calls the original function and returns the correct value', () => {
                expect(returnValue).toEqual('function-method');
            });
        });

        describe('with promises returned', () => {
            let returnValue;

            afterEach(() => {
                jest.clearAllMocks();
            });

            it('handles the function passed in returning a resolved promise', async () => {
                returnValue = await new TestClass().resolvedPromiseMethod();
                expect(returnValue).toEqual('resolved-promise');
            });

            it('handles the function passed in returning a rejected promise', async () => {
                return new TestClass().rejectedPromiseMethod().catch(e => {
                    expect(e).toEqual('rejected-promise');
                });
            });
        });
    });
});
