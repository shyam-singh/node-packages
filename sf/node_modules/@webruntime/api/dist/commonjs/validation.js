"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const console_1 = require("console");
const config_1 = require("./config");
const default_webruntime_app_1 = require("./default-webruntime-app");
const errors_1 = require("./errors");
const messages_1 = require("./messages");
/**
 * Return true if a thing is a string
 *
 * @param thing - thing to test
 */
function isString(thing) {
    return typeof thing === 'string';
}
/**
 * Return true if a thing is an array
 *
 * @param thing - thing to test
 */
function isArray(thing) {
    return Array.isArray(thing);
}
/**
 * Return true if a thing is an array of strings
 *
 * @param thing - thing to test
 */
function isArrayOfStrings(thing) {
    return Array.isArray(thing) && thing.every(p => isString(p));
}
/**
 * Return true if a thing is undefined or a string
 *
 * @param thing - thing to test
 */
function isUndefinedOrString(thing) {
    return thing === undefined || isString(thing);
}
/**
 * Return true if a string is empty OR if it matches the given regular expression
 *
 * @param thing - potential string to test
 * @param regexp - regular express with which to test string
 */
function isEmptyOrMatching(thing, regexp) {
    return typeof thing === 'string' && (thing === '' || regexp.test(thing));
}
/**
 * Transform {@link Config} object values which are incorrect
 *
 * @param config
 * @param DEFAULT_CONFIG
 */
function transformConfig(config, DEFAULT_CONFIG) {
    // Default app definition if not given
    if (config.app && !config.app.definition) {
        config.app.definition = default_webruntime_app_1.DefaultWebruntimeApp;
    }
    // Ensure we have all absolute paths
    config.projectDir = path.resolve(config.projectDir);
    if (typeof config.buildDir === 'string') {
        config.buildDir = path.resolve(config.projectDir, config.buildDir);
    }
    if (typeof config.moduleDir === 'string') {
        config.moduleDir = path.resolve(config.projectDir, config.moduleDir);
    }
    if (config.app && typeof config.app.defaultTemplate === 'string') {
        config.app.defaultTemplate = path.resolve(config.projectDir, config.app.defaultTemplate);
    }
    // Validate server.port is a number, otherwise fall back
    if (typeof config.server.port !== 'number') {
        console_1.warn(errors_1.generateMessage(messages_1.configMessages.INVALID_PORT, [DEFAULT_CONFIG.server.port]));
        config.server.port = DEFAULT_CONFIG.server.port;
    }
    // Validate buildDir is a string, otherwise fall back
    if (typeof config.buildDir !== 'string') {
        console_1.warn(errors_1.generateMessage(messages_1.configMessages.INVALID_BUILD_DIR, [config.buildDir, DEFAULT_CONFIG.buildDir]));
        config.buildDir = path.resolve(config.projectDir, DEFAULT_CONFIG.buildDir);
    }
    // Validate supported Compile Modes, otherwise fall back
    const compileMode = config.defaultMode;
    if (!Object.values(config_1.CompileMode).includes(compileMode)) {
        console_1.warn(errors_1.generateMessage(messages_1.configMessages.INVALID_COMPILE_MODE, [
            compileMode,
            DEFAULT_CONFIG.defaultMode,
        ]));
        config.defaultMode = DEFAULT_CONFIG.defaultMode;
    }
    // Validate that defaultLocale is a string, if it exists, otherwise fall back
    if (!isUndefinedOrString(config.defaultLocale)) {
        console_1.warn(errors_1.generateMessage(messages_1.configMessages.INVALID_LOCALE, [
            config.defaultLocale,
            DEFAULT_CONFIG.defaultLocale,
        ]));
        config.defaultLocale = DEFAULT_CONFIG.defaultLocale;
    }
    return config;
}
exports.transformConfig = transformConfig;
/**
 * Validate a {@link Config} object
 *
 * @param projectDir : (optional) The path to the base directory of the app project. Defaults to process.cwd().
 * @param configFiles : (optional) A list of paths to {@link Config} files.
 *
 */
function validateConfig(config) {
    var _a;
    // Ensure the resource root and base path start with a slash.
    const { basePath, resourceRoot } = config.server;
    // A path which starts with a slash, has sections of [-_.a-zA-Z0-9], and no groups of slashes.
    const pathWithStartingSlash = /^\/[-_.\w\d]+(\/[-_.\w\d]+)*$/;
    errors_1.invariant(isEmptyOrMatching(resourceRoot, pathWithStartingSlash), messages_1.configMessages.INVALID_RESOURCE_ROOT, [resourceRoot]);
    errors_1.invariant(isEmptyOrMatching(basePath, pathWithStartingSlash), messages_1.configMessages.INVALID_BASE_PATH, [
        basePath,
    ]);
    // Validate that moduleDir is a string, if it exists
    errors_1.invariant(isUndefinedOrString(config.moduleDir), messages_1.configMessages.INVALID_MODULE_DIR, [
        config.moduleDir,
    ]);
    // Validate that default component and template are strings, if config.app exists
    if (config.app) {
        const { defaultComponent, defaultTemplate } = config.app;
        errors_1.invariant(isUndefinedOrString(defaultComponent), messages_1.configMessages.INVALID_DEFAULT_CMP, [
            defaultComponent,
        ]);
        errors_1.invariant(isUndefinedOrString(defaultTemplate), messages_1.configMessages.INVALID_DEFAULT_TEMPLATE, [
            defaultTemplate,
        ]);
    }
    // Validate Compiler supported module formats
    const moduleFormat = (_a = config.compilerConfig.format) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    errors_1.invariant(Object.values(config_1.SupportedModuleFormat).includes(moduleFormat), messages_1.configMessages.INVALID_MODULE_FORMAT, [moduleFormat]);
    // Validate ES format is only used in 'dev' mode
    errors_1.invariant(moduleFormat !== config_1.SupportedModuleFormat.ExperimentalESM ||
        config.defaultMode === config_1.CompileMode.dev, messages_1.configMessages.INVALID_MODULE_FORMAT_ESM);
    // Validate that preloadModules and externals are arrays of strings, if they exist
    errors_1.invariant(isArrayOfStrings(config.preloadModules), messages_1.configMessages.INVALID_PRELOAD_MODULES, [
        config.preloadModules,
    ]);
    if (config.externals) {
        errors_1.invariant(isArrayOfStrings(config.externals), messages_1.configMessages.INVALID_EXTERNALS, [
            config.externals,
        ]);
    }
    // Validate bundle format
    errors_1.invariant(isArray(config.bundle) &&
        config.bundle.every((b) => isString(b) || isString(b.descriptor)), messages_1.configMessages.INVALID_BUNDLE, [config.bundle]);
}
exports.validateConfig = validateConfig;
//# sourceMappingURL=validation.js.map