"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const errors_1 = require("./errors");
const messages_1 = require("./messages");
const utils_1 = require("./utils");
const validation_1 = require("./validation");
exports.WEBRUNTIME_APP_CONFIG_JS_FILENAME = 'webruntime-app.config.js';
// TODO these are the same compile modes from Talon (compiler-service.ts)
/** The compilation modes available to be configured for LWR */
var CompileMode;
(function (CompileMode) {
    CompileMode["dev"] = "dev";
    CompileMode["prod"] = "prod";
    CompileMode["compat"] = "compat";
    CompileMode["prod_compat"] = "prod_compat";
})(CompileMode = exports.CompileMode || (exports.CompileMode = {}));
/** The compiler module formats available to be configured for LWR. Note, native ESM format is experimental only. */
var SupportedModuleFormat;
(function (SupportedModuleFormat) {
    SupportedModuleFormat["AMD"] = "amd";
    SupportedModuleFormat["ExperimentalESM"] = "esm";
})(SupportedModuleFormat = exports.SupportedModuleFormat || (exports.SupportedModuleFormat = {}));
exports.DEFAULT_CONFIG = {
    projectDir: process.cwd(),
    buildDir: 'dist',
    server: {
        port: 3000,
        extensions: [],
        resourceRoot: '/webruntime',
        basePath: '',
    },
    defaultMode: CompileMode.dev,
    defaultLocale: 'en_US',
    bundle: [],
    preloadModules: [],
    services: [],
    compilerConfig: {
        format: SupportedModuleFormat.AMD,
        formatConfig: {
            amd: {
                define: 'define',
            },
        },
        inlineConfig: [],
        outputConfigs: {
            dev: {
                compat: false,
                minify: false,
                sourcemap: false,
                env: {
                    NODE_ENV: 'development',
                },
            },
        },
        plugins: [],
    },
};
/**
 * Build a {@link Config} object from the webruntime configurations provided in
 * the **projectDir** and merged with the webruntime configurations referenced
 * in the  **configFiles**.
 * The merged configuration follows the order --
 *  1. default configuration {@link DEFAULT_CONFIG}
 *  2. configuration provided by the **configFiles** using array ordering
 *  3. project configuration found in the projectDir.
 *  4. Dynamic config (optionally provided in ServerOptions.config)
 *
 * @param dynamicConfig : (optional) Partial<Config> representing dynamic configuration options
 * @param configFiles : (optional) A list of paths to {@link Config} files.
 *
 */
function buildConfig(options = {}) {
    var _a;
    const { dynamicConfig = {}, configFiles = [] } = options;
    const projectDir = (_a = dynamicConfig.projectDir, (_a !== null && _a !== void 0 ? _a : exports.DEFAULT_CONFIG.projectDir));
    const projectConfigPath = path.resolve(projectDir, exports.WEBRUNTIME_APP_CONFIG_JS_FILENAME);
    // Verify preconditions for merge
    errors_1.invariant(fs.existsSync(projectDir), messages_1.configMessages.MISSING_PROJECTDIR, [projectDir]);
    errors_1.invariant(Array.isArray(configFiles) && configFiles.every(c => typeof c === 'string'), messages_1.configMessages.INVALID_CONFIG_FILES, [configFiles]);
    // Merge each of the configFiles followed by the project-level webruntime-app.config.js
    let mergedConfig = { ...exports.DEFAULT_CONFIG };
    const pConfigExists = fs.existsSync(projectConfigPath);
    configFiles.concat(pConfigExists ? [projectConfigPath] : []).forEach((configFile) => {
        const configValues = require(configFile);
        mergedConfig = deepmerge_1.default(mergedConfig, configValues);
    });
    // Dynamic Config takes final precedence, merge it in
    mergedConfig = deepmerge_1.default(mergedConfig, dynamicConfig);
    // Quality of life transformations and fallbacks
    const finalConfig = validation_1.transformConfig(mergedConfig, exports.DEFAULT_CONFIG);
    validation_1.validateConfig(finalConfig);
    return utils_1.deepFreeze(finalConfig);
}
exports.buildConfig = buildConfig;
//# sourceMappingURL=config.js.map