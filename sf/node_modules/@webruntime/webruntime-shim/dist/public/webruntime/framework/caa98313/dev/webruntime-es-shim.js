(function () {
  'use strict';

  /* ES Module Shims 0.4.5 */
  (function () {

    const resolvedPromise = Promise.resolve();

    let baseUrl;

    function createBlob (source) {
      return URL.createObjectURL(new Blob([source], { type: 'application/javascript' }));
    }

    const hasDocument = typeof document !== 'undefined';

    // support browsers without dynamic import support (eg Firefox 6x)
    let dynamicImport;
    try {
      dynamicImport = (0, eval)('u=>import(u)');
    }
    catch (e) {
      if (hasDocument) {
        self.addEventListener('error', e => importShim.e = e.error);
        dynamicImport = blobUrl => {
          const topLevelBlobUrl = createBlob(
            `import*as m from'${blobUrl}';self.importShim.l=m;self.importShim.e=null`
          );
          const s = document.createElement('script');
          s.type = 'module';
          s.src = topLevelBlobUrl;
          document.head.appendChild(s);
          return new Promise((resolve, reject) => {
            s.addEventListener('load', () => {
              document.head.removeChild(s);
              importShim.e ? reject(importShim.e) : resolve(importShim.l, baseUrl);
            });
          });
        };
      }
    }

    if (hasDocument) {
      const baseEl = document.querySelector('base[href]');
      if (baseEl)
        baseUrl = baseEl.href;
    }

    if (!baseUrl && typeof location !== 'undefined') {
      baseUrl = location.href.split('#')[0].split('?')[0];
      const lastSepIndex = baseUrl.lastIndexOf('/');
      if (lastSepIndex !== -1)
        baseUrl = baseUrl.slice(0, lastSepIndex + 1);
    }

    let esModuleShimsSrc;
    if (hasDocument) {
      esModuleShimsSrc = document.currentScript && document.currentScript.src;
    }

    const backslashRegEx = /\\/g;
    function resolveIfNotPlainOrUrl (relUrl, parentUrl) {
      // strip off any trailing query params or hashes
      parentUrl = parentUrl && parentUrl.split('#')[0].split('?')[0];
      if (relUrl.indexOf('\\') !== -1)
        relUrl = relUrl.replace(backslashRegEx, '/');
      // protocol-relative
      if (relUrl[0] === '/' && relUrl[1] === '/') {
        return parentUrl.slice(0, parentUrl.indexOf(':') + 1) + relUrl;
      }
      // relative-url
      else if (relUrl[0] === '.' && (relUrl[1] === '/' || relUrl[1] === '.' && (relUrl[2] === '/' || relUrl.length === 2 && (relUrl += '/')) ||
          relUrl.length === 1  && (relUrl += '/')) ||
          relUrl[0] === '/') {
        const parentProtocol = parentUrl.slice(0, parentUrl.indexOf(':') + 1);
        // Disabled, but these cases will give inconsistent results for deep backtracking
        //if (parentUrl[parentProtocol.length] !== '/')
        //  throw new Error('Cannot resolve');
        // read pathname from parent URL
        // pathname taken to be part after leading "/"
        let pathname;
        if (parentUrl[parentProtocol.length + 1] === '/') {
          // resolving to a :// so we need to read out the auth and host
          if (parentProtocol !== 'file:') {
            pathname = parentUrl.slice(parentProtocol.length + 2);
            pathname = pathname.slice(pathname.indexOf('/') + 1);
          }
          else {
            pathname = parentUrl.slice(8);
          }
        }
        else {
          // resolving to :/ so pathname is the /... part
          pathname = parentUrl.slice(parentProtocol.length + (parentUrl[parentProtocol.length] === '/'));
        }

        if (relUrl[0] === '/')
          return parentUrl.slice(0, parentUrl.length - pathname.length - 1) + relUrl;

        // join together and split for removal of .. and . segments
        // looping the string instead of anything fancy for perf reasons
        // '../../../../../z' resolved to 'x/y' is just 'z'
        const segmented = pathname.slice(0, pathname.lastIndexOf('/') + 1) + relUrl;

        const output = [];
        let segmentIndex = -1;
        for (let i = 0; i < segmented.length; i++) {
          // busy reading a segment - only terminate on '/'
          if (segmentIndex !== -1) {
            if (segmented[i] === '/') {
              output.push(segmented.slice(segmentIndex, i + 1));
              segmentIndex = -1;
            }
          }

          // new segment - check if it is relative
          else if (segmented[i] === '.') {
            // ../ segment
            if (segmented[i + 1] === '.' && (segmented[i + 2] === '/' || i + 2 === segmented.length)) {
              output.pop();
              i += 2;
            }
            // ./ segment
            else if (segmented[i + 1] === '/' || i + 1 === segmented.length) {
              i += 1;
            }
            else {
              // the start of a new segment as below
              segmentIndex = i;
            }
          }
          // it is the start of a new segment
          else {
            segmentIndex = i;
          }
        }
        // finish reading out the last segment
        if (segmentIndex !== -1)
          output.push(segmented.slice(segmentIndex));
        return parentUrl.slice(0, parentUrl.length - pathname.length) + output.join('');
      }
    }

    /*
     * Import maps implementation
     *
     * To make lookups fast we pre-resolve the entire import map
     * and then match based on backtracked hash lookups
     *
     */
    const emptyImportMap = { imports: {}, scopes: {} };

    function resolveUrl (relUrl, parentUrl) {
      return resolveIfNotPlainOrUrl(relUrl, parentUrl) || (relUrl.indexOf(':') !== -1 ? relUrl : resolveIfNotPlainOrUrl('./' + relUrl, parentUrl));
    }

    async function hasStdModule (name) {
      try {
        await dynamicImport(name);
        return true;
      }
      catch (e) {
        return false;
      }
    }

    async function resolveAndComposePackages (packages, outPackages, baseUrl, parentMap, parentUrl) {
      outer: for (let p in packages) {
        const resolvedLhs = resolveIfNotPlainOrUrl(p, baseUrl) || p;
        let target = packages[p];
        if (typeof target === 'string')
          target = [target];
        else if (!Array.isArray(target))
          continue;

        for (const rhs of target) {
          if (typeof rhs !== 'string')
            continue;
          const mapped = resolveImportMap(parentMap, resolveIfNotPlainOrUrl(rhs, baseUrl) || rhs, parentUrl);
          if (mapped && (!mapped.startsWith('std:') || await hasStdModule(mapped))) {
            outPackages[resolvedLhs] = mapped;
            continue outer;
          }
        }
        targetWarning(p, packages[p], 'bare specifier did not resolve');
      }
    }

    async function resolveAndComposeImportMap (json, baseUrl, parentMap) {
      const outMap = { imports: Object.assign({}, parentMap.imports), scopes: Object.assign({}, parentMap.scopes) };

      if (json.imports)
        await resolveAndComposePackages(json.imports, outMap.imports, baseUrl, parentMap, null);

      if (json.scopes)
        for (let s in json.scopes) {
          const resolvedScope = resolveUrl(s, baseUrl);
          await resolveAndComposePackages(json.scopes[s], outMap.scopes[resolvedScope] || (outMap.scopes[resolvedScope] = {}), baseUrl, parentMap, resolvedScope);
        }

      return outMap;
    }

    function getMatch (path, matchObj) {
      if (matchObj[path])
        return path;
      let sepIndex = path.length;
      do {
        const segment = path.slice(0, sepIndex + 1);
        if (segment in matchObj)
          return segment;
      } while ((sepIndex = path.lastIndexOf('/', sepIndex - 1)) !== -1)
    }

    function applyPackages (id, packages) {
      const pkgName = getMatch(id, packages);
      if (pkgName) {
        const pkg = packages[pkgName];
        if (pkg === null) return;
        if (id.length > pkgName.length && pkg[pkg.length - 1] !== '/')
          targetWarning(pkgName, pkg, "should have a trailing '/'");
        else
          return pkg + id.slice(pkgName.length);
      }
    }

    function targetWarning (match, target, msg) {
      console.warn("Package target " + msg + ", resolving target '" + target + "' for " + match);
    }

    function resolveImportMap (importMap, resolvedOrPlain, parentUrl) {
      let scopeUrl = parentUrl && getMatch(parentUrl, importMap.scopes);
      while (scopeUrl) {
        const packageResolution = applyPackages(resolvedOrPlain, importMap.scopes[scopeUrl]);
        if (packageResolution)
          return packageResolution;
        scopeUrl = getMatch(scopeUrl.slice(0, scopeUrl.lastIndexOf('/')), importMap.scopes);
      }
      return applyPackages(resolvedOrPlain, importMap.imports) || resolvedOrPlain.indexOf(':') !== -1 && resolvedOrPlain;
    }

    /* es-module-lexer 0.3.13 */
    function parse(Q,B="@"){if(!A)return init.then(()=>parse(Q));const C=(A.__heap_base.value||A.__heap_base)+4*Q.length+-A.memory.buffer.byteLength;if(C>0&&A.memory.grow(Math.ceil(C/65536)),function(A,Q){const B=A.length;let C=0;for(;C<B;)Q[C]=A.charCodeAt(C++);}(Q,new Uint16Array(A.memory.buffer,A.sa(Q.length),Q.length+1)),!A.parse())throw Object.assign(new Error(`Parse error ${B}:${Q.slice(0,A.e()).split("\n").length}:${A.e()-Q.lastIndexOf("\n",A.e()-1)}`),{idx:A.e()});const E=[],g=[];for(;A.ri();)E.push({s:A.is(),e:A.ie(),d:A.id()});for(;A.re();)g.push(Q.slice(A.es(),A.ee()));return [E,g]}let A;const init=WebAssembly.compile((A=>"function"==typeof atob?Uint8Array.from(atob(A),A=>A.charCodeAt(0)):Buffer.from(A,"base64"))("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")).then(WebAssembly.instantiate).then(({exports:Q})=>{A=Q;});

    class WorkerShim {
      constructor(aURL, options = {}) {
        if (options.type !== 'module')
          return new Worker(aURL, options);

        if (!esModuleShimsSrc)
          throw new Error('es-module-shims.js must be loaded with a script tag for WorkerShim support.');

        options.importMap = options.importMap || emptyImportMap;

        const workerScriptUrl = createBlob(
          `importScripts('${esModuleShimsSrc}');importShim.map=${JSON.stringify(options.importMap)};importShim('${new URL(aURL, baseUrl).href}').catch(e=>setTimeout(()=>{throw e}))`
        );

        return new Worker(workerScriptUrl, Object.assign({}, options, { type: undefined }));
      }
    }

    let id = 0;
    const registry = {};

    async function loadAll (load, seen) {
      if (load.b || seen[load.u])
        return;
      seen[load.u] = 1;
      await load.L;
      return Promise.all(load.d.map(dep => loadAll(dep, seen)));
    }

    async function topLevelLoad (url, source) {
      await init;
      const load = getOrCreateLoad(url, source);
      const seen = {};
      await loadAll(load, seen);
      lastLoad = undefined;
      resolveDeps(load, seen);
      const module = await dynamicImport(load.b);
      // if the top-level load is a shell, run its update function
      if (load.s)
        (await dynamicImport(load.s)).u$_(module);
      return module;
    }

    async function importShim$1 (id, parentUrl) {
      return topLevelLoad(await resolve(id, parentUrl || baseUrl));
    }

    self.importShim = importShim$1;

    const meta = {};
    const wasmModules = {};

    const edge = navigator.userAgent.match(/Edge\/\d\d\.\d+$/);

    Object.defineProperties(importShim$1, {
      map: { value: emptyImportMap, writable: true },
      m: { value: meta },
      w: { value: wasmModules },
      l: { value: undefined, writable: true },
      e: { value: undefined, writable: true }
    });
    importShim$1.fetch = url => fetch(url);

    let lastLoad;
    function resolveDeps (load, seen) {
      if (load.b || !seen[load.u])
        return;
      seen[load.u] = 0;

      for (const dep of load.d)
        resolveDeps(dep, seen);

      // "execution"
      const source = load.S;
      // edge doesnt execute sibling in order, so we fix this up by ensuring all previous executions are explicit dependencies
      let resolvedSource = edge && lastLoad ? `import '${lastLoad}';` : '';

      const [imports] = load.a;

      if (!imports.length) {
        resolvedSource += source;
      }
      else {
        // once all deps have loaded we can inline the dependency resolution blobs
        // and define this blob
        let lastIndex = 0, depIndex = 0;
        for (const { s: start, e: end, d: dynamicImportIndex } of imports) {
          // dependency source replacements
          if (dynamicImportIndex === -1) {
            const depLoad = load.d[depIndex++];
            let blobUrl = depLoad.b;
            if (!blobUrl) {
              // circular shell creation
              if (!(blobUrl = depLoad.s)) {
                blobUrl = depLoad.s = createBlob(`export function u$_(m){${
                depLoad.a[1].map(
                  name => name === 'default' ? `$_default=m.default` : `${name}=m.${name}`
                ).join(',')
              }}${
                depLoad.a[1].map(name =>
                  name === 'default' ? `let $_default;export{$_default as default}` : `export let ${name}`
                ).join(';')
              }\n//# sourceURL=${depLoad.r}?cycle`);
              }
            }
            // circular shell execution
            else if (depLoad.s) {
              resolvedSource += source.slice(lastIndex, start - 1) + '/*' + source.slice(start - 1, end + 1) + '*/' + source.slice(start - 1, start) + blobUrl + source[end] + `;import*as m$_${depIndex} from'${depLoad.b}';import{u$_ as u$_${depIndex}}from'${depLoad.s}';u$_${depIndex}(m$_${depIndex})`;
              lastIndex = end + 1;
              depLoad.s = undefined;
              continue;
            }
            resolvedSource += source.slice(lastIndex, start - 1) + '/*' + source.slice(start - 1, end + 1) + '*/' + source.slice(start - 1, start) + blobUrl;
            lastIndex = end;
          }
          // import.meta
          else if (dynamicImportIndex === -2) {
            meta[load.r] = { url: load.r };
            resolvedSource += source.slice(lastIndex, start) + 'importShim.m[' + JSON.stringify(load.r) + ']';
            lastIndex = end;
          }
          // dynamic import
          else {
            resolvedSource += source.slice(lastIndex, dynamicImportIndex + 6) + 'Shim(' + source.slice(start, end) + ', ' + JSON.stringify(load.r);
            lastIndex = end;
          }
        }

        resolvedSource += source.slice(lastIndex);
      }

      let sourceMappingResolved = '';
      const sourceMappingIndex = resolvedSource.lastIndexOf('//# sourceMappingURL=');
      if (sourceMappingIndex > -1) {
        const sourceMappingEnd = resolvedSource.indexOf('\n',sourceMappingIndex);
        const sourceMapping = resolvedSource.slice(sourceMappingIndex, sourceMappingEnd > -1 ? sourceMappingEnd : undefined);
        sourceMappingResolved = `\n//# sourceMappingURL=` + resolveUrl(sourceMapping.slice(21), load.r);
      }
      load.b = lastLoad = createBlob(resolvedSource + sourceMappingResolved + '\n//# sourceURL=' + load.r);
      load.S = undefined;
    }

    function getOrCreateLoad (url, source) {
      let load = registry[url];
      if (load)
        return load;

      load = registry[url] = {
        // url
        u: url,
        // response url
        r: undefined,
        // fetchPromise
        f: undefined,
        // source
        S: undefined,
        // linkPromise
        L: undefined,
        // analysis
        a: undefined,
        // deps
        d: undefined,
        // blobUrl
        b: undefined,
        // shellUrl
        s: undefined,
      };

      if (url.startsWith('std:'))
        return Object.assign(load, {
          r: url,
          f: resolvedPromise,
          L: resolvedPromise,
          b: url
        });

      load.f = (async () => {
        if (!source) {
          const res = await importShim$1.fetch(url);
          if (!res.ok)
            throw new Error(`${res.status} ${res.statusText} ${res.url}`);

          load.r = res.url;

          const contentType = res.headers.get('content-type');
          if (contentType.match(/^(text|application)\/(x-)?javascript(;|$)/)) {
            source = await res.text();
          }
          else if (contentType.match(/^application\/json(;|$)/)) {
            source = `export default JSON.parse(${JSON.stringify(await res.text())})`;
          }
          else if (contentType.match(/^text\/css(;|$)/)) {
            source = `const s=new CSSStyleSheet();s.replaceSync(${JSON.stringify(await res.text())});export default s`;
          }
          else if (contentType.match(/^application\/wasm(;|$)/)) {
            const module = wasmModules[url] = await WebAssembly.compile(await res.arrayBuffer());
            let deps = WebAssembly.Module.imports ? WebAssembly.Module.imports(module).map(impt => impt.module) : [];

            const aDeps = [];
            load.a = [aDeps, WebAssembly.Module.exports(module).map(expt => expt.name)];

            const depStrs = deps.map(dep => JSON.stringify(dep));

            let curIndex = 0;
            load.S = depStrs.map((depStr, idx) => {
                const index = idx.toString();
                const strStart = curIndex + 17 + index.length;
                const strEnd = strStart + depStr.length - 2;
                aDeps.push({
                  s: strStart,
                  e: strEnd,
                  d: -1
                });
                curIndex += strEnd + 3;
                return `import*as m${index} from${depStr};`
              }).join('') +
              `const module=importShim.w[${JSON.stringify(url)}],exports=new WebAssembly.Instance(module,{` +
              depStrs.map((depStr, idx) => `${depStr}:m${idx},`).join('') +
              `}).exports;` +
              load.a[1].map(name => name === 'default' ? `export default exports.${name}` : `export const ${name}=exports.${name}`).join(';');
            return deps;
          }
          else {
            throw new Error(`Unknown Content-Type "${contentType}"`);
          }
        }
        try {
          load.a = parse(source, load.u);
        }
        catch (e) {
          console.warn(e);
          load.a = [[], []];
        }
        load.S = source;
        return load.a[0].filter(d => d.d === -1).map(d => source.slice(d.s, d.e));
      })();

      load.L = load.f.then(async deps => {
        load.d = await Promise.all(deps.map(async depId => {
          const depLoad = getOrCreateLoad(await resolve(depId, load.r || load.u));
          await depLoad.f;
          return depLoad;
        }));
      });

      return load;
    }

    let importMapPromise;

    if (hasDocument) {
      // preload import maps
      for (const script of document.querySelectorAll('script[type="webruntime-importmap"][src]'))
        script._f = fetch(script.src);
      // load any module scripts
      for (const script of document.querySelectorAll('script[type="webruntime-module"]'))
        topLevelLoad(script.src || `${baseUrl}?${id++}`, script.src ? null : script.innerHTML);
    }

    async function resolve (id, parentUrl) {
      if (!importMapPromise) {
        importMapPromise = resolvedPromise;
        if (hasDocument)
          for (const script of document.querySelectorAll('script[type="webruntime-importmap"]')) {
            importMapPromise = importMapPromise.then(async () => {
              importShim$1.map = await resolveAndComposeImportMap(script.src ? await (await (script._f || fetch(script.src))).json() : JSON.parse(script.innerHTML), script.src || baseUrl, importShim$1.map);
            });
          }
      }
      await importMapPromise;
      return resolveImportMap(importShim$1.map, resolveIfNotPlainOrUrl(id, parentUrl) || id, parentUrl) || throwUnresolved(id, parentUrl);
    }

    function throwUnresolved (id, parentUrl) {
      throw Error("Unable to resolve specifier '" + id + (parentUrl ? "' from " + parentUrl : "'"));
    }

    self.WorkerShim = WorkerShim;

  }());

  /* proxy-compat-disable */
  function invariant(value, msg) {
    if (!value) {
      throw new Error(`Invariant Violation: ${msg}`);
    }
  }

  function isTrue(value, msg) {
    if (!value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }

  function isFalse(value, msg) {
    if (value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }

  function fail(msg) {
    throw new Error(msg);
  }

  var assert = Object.freeze({
    __proto__: null,
    invariant: invariant,
    isTrue: isTrue,
    isFalse: isFalse,
    fail: fail
  });
  const {
    assign,
    create,
    defineProperties,
    defineProperty,
    freeze,
    getOwnPropertyDescriptor,
    getOwnPropertyNames,
    getPrototypeOf,
    hasOwnProperty,
    keys,
    seal,
    setPrototypeOf
  } = Object;
  const {
    isArray
  } = Array;
  const {
    filter: ArrayFilter,
    find: ArrayFind,
    forEach,
    indexOf: ArrayIndexOf,
    join: ArrayJoin,
    map: ArrayMap,
    push: ArrayPush,
    reduce: ArrayReduce,
    reverse: ArrayReverse,
    slice: ArraySlice,
    splice: ArraySplice,
    unshift: ArrayUnshift
  } = Array.prototype;
  const {
    charCodeAt: StringCharCodeAt,
    replace: StringReplace,
    slice: StringSlice,
    toLowerCase: StringToLowerCase
  } = String.prototype;

  function isUndefined(obj) {
    return obj === undefined;
  }

  function isNull(obj) {
    return obj === null;
  }

  function isTrue$1(obj) {
    return obj === true;
  }

  function isFalse$1(obj) {
    return obj === false;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function isObject(obj) {
    return typeof obj === 'object';
  }

  const OtS = {}.toString;

  function toString(obj) {
    if (obj && obj.toString) {
      if (isArray(obj)) {
        return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
      }

      return obj.toString();
    } else if (typeof obj === 'object') {
      return OtS.call(obj);
    } else {
      return obj + emptyString;
    }
  }

  function getPropertyDescriptor(o, p) {
    do {
      const d = getOwnPropertyDescriptor(o, p);

      if (!isUndefined(d)) {
        return d;
      }

      o = getPrototypeOf(o);
    } while (o !== null);
  }

  const emptyString = '';
  const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';

  function createHiddenField(key, namespace) {
    return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`;
  }

  const hiddenFieldsMap = new WeakMap();

  function setHiddenField(o, field, value) {
    let valuesByField = hiddenFieldsMap.get(o);

    if (isUndefined(valuesByField)) {
      valuesByField = create(null);
      hiddenFieldsMap.set(o, valuesByField);
    }

    valuesByField[field] = value;
  }

  function getHiddenField(o, field) {
    const valuesByField = hiddenFieldsMap.get(o);

    if (!isUndefined(valuesByField)) {
      return valuesByField[field];
    }
  }

  const {
    DOCUMENT_POSITION_CONTAINED_BY,
    DOCUMENT_POSITION_CONTAINS,
    DOCUMENT_POSITION_PRECEDING,
    DOCUMENT_POSITION_FOLLOWING,
    ELEMENT_NODE,
    TEXT_NODE,
    CDATA_SECTION_NODE,
    PROCESSING_INSTRUCTION_NODE,
    COMMENT_NODE,
    DOCUMENT_FRAGMENT_NODE
  } = Node;
  const {
    appendChild,
    cloneNode,
    compareDocumentPosition,
    insertBefore,
    removeChild,
    replaceChild,
    hasChildNodes
  } = Node.prototype;
  const {
    contains
  } = HTMLElement.prototype;
  const firstChildGetter = getOwnPropertyDescriptor(Node.prototype, 'firstChild').get;
  const lastChildGetter = getOwnPropertyDescriptor(Node.prototype, 'lastChild').get;
  const textContentGetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
  const parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
  const ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
  const parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement') ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
  const textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
  const childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes') ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
  const isConnected = hasOwnProperty.call(Node.prototype, 'isConnected') ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get : function () {
    const doc = ownerDocumentGetter.call(this);
    return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  };

  const {
    addEventListener,
    getAttribute,
    getBoundingClientRect,
    getElementsByTagName,
    getElementsByTagNameNS,
    hasAttribute,
    querySelectorAll,
    removeAttribute,
    removeEventListener,
    setAttribute
  } = Element.prototype;
  const attachShadow = hasOwnProperty.call(Element.prototype, 'attachShadow') ? Element.prototype.attachShadow : () => {
    throw new TypeError('attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components');
  };
  const childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;
  const firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
  const lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;
  const innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'innerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');
  const innerHTMLGetter = innerHTMLDescriptor.get;
  const innerHTMLSetter = innerHTMLDescriptor.set;
  const outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'outerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML');
  const outerHTMLGetter = outerHTMLDescriptor.get;
  const outerHTMLSetter = outerHTMLDescriptor.set;
  const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
  const tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');
  const tabIndexGetter = tabIndexDescriptor.get;
  const tabIndexSetter = tabIndexDescriptor.set;
  const matches = hasOwnProperty.call(Element.prototype, 'matches') ? Element.prototype.matches : Element.prototype.msMatchesSelector;
  const childrenGetter = hasOwnProperty.call(Element.prototype, 'children') ? getOwnPropertyDescriptor(Element.prototype, 'children').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
  const {
    getElementsByClassName
  } = HTMLElement.prototype;
  const shadowRootGetter = hasOwnProperty.call(Element.prototype, 'shadowRoot') ? getOwnPropertyDescriptor(Element.prototype, 'shadowRoot').get : () => null;

  let assignedNodes, assignedElements;

  if (typeof HTMLSlotElement !== 'undefined') {
    assignedNodes = HTMLSlotElement.prototype.assignedNodes;
    assignedElements = HTMLSlotElement.prototype.assignedElements;
  } else {
    assignedNodes = () => {
      throw new TypeError("assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };

    assignedElements = () => {
      throw new TypeError("assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
  }

  const dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
  const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
  const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
  const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;

  const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
  const elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint') ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
  const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
  const {
    createComment,
    querySelectorAll: querySelectorAll$1,
    getElementById,
    getElementsByClassName: getElementsByClassName$1,
    getElementsByTagName: getElementsByTagName$1,
    getElementsByTagNameNS: getElementsByTagNameNS$1
  } = Document.prototype;
  const {
    getElementsByName
  } = HTMLDocument.prototype;

  const {
    addEventListener: windowAddEventListener,
    removeEventListener: windowRemoveEventListener
  } = window;

  const MO = MutationObserver;
  const MutationObserverObserve = MO.prototype.observe;

  function detect () {
    return typeof HTMLSlotElement === 'undefined';
  }

  const {
    createElement
  } = Document.prototype;
  const CHAR_S = 115;
  const CHAR_L = 108;
  const CHAR_O = 111;
  const CHAR_T = 116;
  function apply() {
    class HTMLSlotElement {}

    setPrototypeOf(HTMLSlotElement, HTMLElement.constructor);
    setPrototypeOf(HTMLSlotElement.prototype, HTMLElement.prototype);
    Window.prototype.HTMLSlotElement = HTMLSlotElement;
    defineProperty(Document.prototype, 'createElement', {
      value: function (tagName, _options) {
        const elm = createElement.apply(this, ArraySlice.call(arguments));

        if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
          setPrototypeOf(elm, HTMLSlotElement.prototype);
        }

        return elm;
      }
    });
  }

  if (detect()) {
    apply();
  }

  const {
    assign: assign$1,
    create: create$1,
    defineProperties: defineProperties$1,
    defineProperty: defineProperty$1,
    freeze: freeze$1,
    getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,
    getOwnPropertyNames: getOwnPropertyNames$1,
    getPrototypeOf: getPrototypeOf$1,
    hasOwnProperty: hasOwnProperty$1,
    keys: keys$1,
    seal: seal$1,
    setPrototypeOf: setPrototypeOf$1
  } = Object;

  const hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';

  let _globalThis;

  if (typeof globalThis === 'object') {
    _globalThis = globalThis;
  }

  function getGlobalThis() {
    if (typeof _globalThis === 'object') {
      return _globalThis;
    }

    try {
      Object.defineProperty(Object.prototype, '__magic__', {
        get: function () {
          return this;
        },
        configurable: true
      });
      _globalThis = __magic__;
      delete Object.prototype.__magic__;
    } catch (ex) {} finally {
      if (typeof _globalThis === 'undefined') {
        _globalThis = window;
      }
    }

    return _globalThis;
  }

  const _globalThis$1 = getGlobalThis();

  if (!_globalThis$1.lwcRuntimeFlags) {
    Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {
      value: create$1(null)
    });
  }

  const runtimeFlags = _globalThis$1.lwcRuntimeFlags;

  function getOwnerDocument(node) {
    const doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
  }
  function getOwnerWindow(node) {
    const doc = getOwnerDocument(node);
    const win = defaultViewGetter.call(doc);

    if (win === null) {
      throw new TypeError();
    }

    return win;
  }
  let skipGlobalPatching;
  function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
      const ownerDocument = getOwnerDocument(node);
      skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') === 'temporary-bypass';
    }

    return isTrue$1(skipGlobalPatching);
  }
  function arrayFromCollection(collection) {
    const size = collection.length;
    const cloned = [];

    if (size > 0) {
      for (let i = 0; i < size; i++) {
        cloned[i] = collection[i];
      }
    }

    return cloned;
  }

  function pathComposer(startNode, composed) {
    const composedPath = [];
    let current = startNode;
    const startRoot = startNode instanceof Window ? startNode : startNode.getRootNode();

    while (!isNull(current)) {
      composedPath.push(current);
      let assignedSlot = null;

      if (current instanceof Element) {
        assignedSlot = current.assignedSlot;
      }

      if (!isNull(assignedSlot)) {
        current = assignedSlot;
      } else if (current instanceof ShadowRoot && (composed || current !== startRoot)) {
        current = current.host;
      } else {
        current = current.parentNode;
      }
    }

    let doc;

    if (startNode instanceof Window) {
      doc = startNode.document;
    } else {
      doc = getOwnerDocument(startNode);
    }

    if (composedPath[composedPath.length - 1] === doc) {
      composedPath.push(window);
    }

    return composedPath;
  }

  function retarget(refNode, path) {
    if (isNull(refNode)) {
      return null;
    }

    const refNodePath = pathComposer(refNode, true);
    const p$ = path;

    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
      ancestor = p$[i];
      root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();

      if (root !== lastRoot) {
        rootIdx = refNodePath.indexOf(root);
        lastRoot = root;
      }

      if (!(root instanceof SyntheticShadowRoot) || !isUndefined(rootIdx) && rootIdx > -1) {
        return ancestor;
      }
    }

    return null;
  }

  var EventListenerContext;

  (function (EventListenerContext) {
    EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
    EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
  })(EventListenerContext || (EventListenerContext = {}));

  const eventToContextMap = new WeakMap();

  function isChildNode(root, node) {
    return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
  }

  const GET_ROOT_NODE_CONFIG_FALSE = {
    composed: false
  };

  function getRootNodeHost(node, options) {
    let rootNode = node.getRootNode(options);

    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
      rootNode = getHost(rootNode);
    }

    return rootNode;
  }

  function targetGetter() {
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    const originalTarget = eventTargetGetter.call(this);
    const composedPath = pathComposer(originalTarget, this.composed);
    const doc = getOwnerDocument(originalTarget);

    if (!(originalCurrentTarget instanceof Node)) {
      if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    } else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
      if (isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    }

    const eventContext = eventToContextMap.get(this);
    const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
    return retarget(currentTarget, composedPath);
  }

  function composedPathValue() {
    const originalTarget = eventTargetGetter.call(this);
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    return isNull(originalCurrentTarget) ? [] : pathComposer(originalTarget, this.composed);
  }

  function patchEvent(event) {
    if (eventToContextMap.has(event)) {
      return;
    }

    defineProperties(event, {
      target: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      composedPath: {
        value: composedPathValue,
        writable: true,
        enumerable: true,
        configurable: true
      },
      srcElement: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      path: {
        get: composedPathValue,
        enumerable: true,
        configurable: true
      }
    });
    const originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');

    if (!isUndefined(originalRelatedTargetDescriptor)) {
      const relatedTargetGetter = originalRelatedTargetDescriptor.get;
      defineProperty(event, 'relatedTarget', {
        get() {
          const eventContext = eventToContextMap.get(this);
          const originalCurrentTarget = eventCurrentTargetGetter.call(this);
          const relatedTarget = relatedTargetGetter.call(this);

          if (isNull(relatedTarget)) {
            return null;
          }

          const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
          return retarget(currentTarget, pathComposer(relatedTarget, true));
        },

        enumerable: true,
        configurable: true
      });
    }

    eventToContextMap.set(event, 0);
  }
  const customElementToWrappedListeners = new WeakMap();

  function getEventMap(elm) {
    let listenerInfo = customElementToWrappedListeners.get(elm);

    if (isUndefined(listenerInfo)) {
      listenerInfo = create(null);
      customElementToWrappedListeners.set(elm, listenerInfo);
    }

    return listenerInfo;
  }

  const shadowRootEventListenerMap = new WeakMap();

  function getWrappedShadowRootListener(sr, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);

    if (isUndefined(shadowRootWrappedListener)) {
      shadowRootWrappedListener = function (event) {
        const {
          composed
        } = event;
        const target = eventTargetGetter.call(event);
        const currentTarget = eventCurrentTargetGetter.call(event);

        if (target !== currentTarget) {
          const rootNode = getRootNodeHost(target, {
            composed
          });

          if (isChildNode(rootNode, currentTarget) || composed === false && rootNode === currentTarget) {
            listener.call(sr, event);
          }
        }
      };

      shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;

      {
        shadowRootWrappedListener.original = listener;
      }

      shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }

    return shadowRootWrappedListener;
  }

  const customElementEventListenerMap = new WeakMap();

  function getWrappedCustomElementListener(elm, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    let customElementWrappedListener = customElementEventListenerMap.get(listener);

    if (isUndefined(customElementWrappedListener)) {
      customElementWrappedListener = function (event) {
        if (isValidEventForCustomElement(event)) {
          listener.call(elm, event);
        }
      };

      customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;

      {
        customElementWrappedListener.original = listener;
      }

      customElementEventListenerMap.set(listener, customElementWrappedListener);
    }

    return customElementWrappedListener;
  }

  function domListener(evt) {
    patchEvent(evt);
    let immediatePropagationStopped = false;
    let propagationStopped = false;
    const {
      type,
      stopImmediatePropagation,
      stopPropagation
    } = evt;
    const currentTarget = eventCurrentTargetGetter.call(evt);
    const listenerMap = getEventMap(currentTarget);
    const listeners = listenerMap[type];
    defineProperty(evt, 'stopImmediatePropagation', {
      value() {
        immediatePropagationStopped = true;
        stopImmediatePropagation.call(evt);
      },

      writable: true,
      enumerable: true,
      configurable: true
    });
    defineProperty(evt, 'stopPropagation', {
      value() {
        propagationStopped = true;
        stopPropagation.call(evt);
      },

      writable: true,
      enumerable: true,
      configurable: true
    });
    const bookkeeping = ArraySlice.call(listeners);

    function invokeListenersByPlacement(placement) {
      forEach.call(bookkeeping, listener => {
        if (isFalse$1(immediatePropagationStopped) && listener.placement === placement) {
          if (ArrayIndexOf.call(listeners, listener) !== -1) {
            listener.call(undefined, evt);
          }
        }
      });
    }

    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);

    if (isFalse$1(immediatePropagationStopped) && isFalse$1(propagationStopped)) {
      eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
      invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    }

    eventToContextMap.set(evt, 0);
  }

  function attachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let cmpEventHandlers = listenerMap[type];

    if (isUndefined(cmpEventHandlers)) {
      cmpEventHandlers = listenerMap[type] = [];
    }

    if (cmpEventHandlers.length === 0) {
      addEventListener.call(elm, type, domListener);
    }

    ArrayPush.call(cmpEventHandlers, wrappedListener);
  }

  function detachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let p;
    let listeners;

    if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
      ArraySplice.call(listeners, p, 1);

      if (listeners.length === 0) {
        removeEventListener.call(elm, type, domListener);
      }
    }
  }

  function isValidEventForCustomElement(event) {
    const target = eventTargetGetter.call(event);
    const currentTarget = eventCurrentTargetGetter.call(event);
    const {
      composed
    } = event;
    return composed === true || target === currentTarget || isChildNode(getRootNodeHost(target, GET_ROOT_NODE_CONFIG_FALSE), currentTarget);
  }

  function addCustomElementEventListener(elm, type, listener, _options) {
    {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for Element.addEventListener() in ${toString(elm)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }

    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    attachDOMListener(elm, type, wrappedListener);
  }
  function removeCustomElementEventListener(elm, type, listener, _options) {
    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    detachDOMListener(elm, type, wrappedListener);
  }
  function addShadowRootEventListener(sr, type, listener, _options) {
    {
      if (!isFunction(listener)) {
        throw new TypeError(`Invalid second argument for ShadowRoot.addEventListener() in ${toString(sr)} for event "${type}". Expected an EventListener but received ${listener}.`);
      }
    }

    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    attachDOMListener(elm, type, wrappedListener);
  }
  function removeShadowRootEventListener(sr, type, listener, _options) {
    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    detachDOMListener(elm, type, wrappedListener);
  }

  function getTextContent(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          const childNodes = getFilteredChildNodes(node);
          let content = '';

          for (let i = 0, len = childNodes.length; i < len; i += 1) {
            const currentNode = childNodes[i];

            if (currentNode.nodeType !== COMMENT_NODE) {
              content += getTextContent(currentNode);
            }
          }

          return content;
        }

      default:
        return node.nodeValue;
    }
  }

  const Items = createHiddenField('StaticNodeListItems', 'synthetic-shadow');

  function StaticNodeList() {
    throw new TypeError('Illegal constructor');
  }

  StaticNodeList.prototype = create(NodeList.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticNodeList
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(index) {
        return this[index];
      }

    },
    length: {
      enumerable: true,
      configurable: true,

      get() {
        return getHiddenField(this, Items).length;
      }

    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items), cb, thisArg);
      }

    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items), (v, i) => [i, v]);
      }

    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items), (_v, i) => i);
      }

    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return getHiddenField(this, Items);
      }

    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,

      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = getHiddenField(this, Items);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }

    },
    [Symbol.toStringTag]: {
      configurable: true,

      get() {
        return 'NodeList';
      }

    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return '[object NodeList]';
      }

    }
  });
  setPrototypeOf(StaticNodeList, NodeList);
  function createStaticNodeList(items) {
    const nodeList = create(StaticNodeList.prototype);
    setHiddenField(nodeList, Items, items);
    forEach.call(items, (item, index) => {
      defineProperty(nodeList, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return nodeList;
  }

  const Items$1 = createHiddenField('StaticHTMLCollectionItems', 'synthetic-shadow');

  function StaticHTMLCollection() {
    throw new TypeError('Illegal constructor');
  }

  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticHTMLCollection
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(index) {
        return this[index];
      }

    },
    length: {
      enumerable: true,
      configurable: true,

      get() {
        return getHiddenField(this, Items$1).length;
      }

    },
    namedItem: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(name) {
        if (name === '') {
          return null;
        }

        const items = getHiddenField(this, Items$1);

        for (let i = 0, len = items.length; i < len; i++) {
          const item = items[len];

          if (name === getAttribute.call(item, 'id') || name === getAttribute.call(item, 'name')) {
            return item;
          }
        }

        return null;
      }

    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items$1), cb, thisArg);
      }

    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items$1), (v, i) => [i, v]);
      }

    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items$1), (v, i) => i);
      }

    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return getHiddenField(this, Items$1);
      }

    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,

      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = getHiddenField(this, Items$1);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }

    },
    [Symbol.toStringTag]: {
      configurable: true,

      get() {
        return 'HTMLCollection';
      }

    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return '[object HTMLCollection]';
      }

    }
  });
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);
  function createStaticHTMLCollection(items) {
    const collection = create(StaticHTMLCollection.prototype);
    setHiddenField(collection, Items$1, items);
    forEach.call(items, (item, index) => {
      defineProperty(collection, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return collection;
  }

  function getInnerHTML(node) {
    let s = '';
    const childNodes = getFilteredChildNodes(node);

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      s += getOuterHTML(childNodes[i]);
    }

    return s;
  }

  const escapeAttrRegExp = /[&\u00A0"]/g;
  const escapeDataRegExp = /[&\u00A0<>]/g;
  const {
    replace,
    toLowerCase
  } = String.prototype;

  function escapeReplace(c) {
    switch (c) {
      case '&':
        return '&amp;';

      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '"':
        return '&quot;';

      case '\u00A0':
        return '&nbsp;';

      default:
        return '';
    }
  }

  function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
  }

  function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
  }

  const voidElements = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);
  const plaintextParents = new Set(['STYLE', 'SCRIPT', 'XMP', 'IFRAME', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT', 'NOSCRIPT']);
  function getOuterHTML(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          const {
            attributes: attrs
          } = node;
          const tagName = tagNameGetter.call(node);
          let s = '<' + toLowerCase.call(tagName);

          for (let i = 0, attr; attr = attrs[i]; i++) {
            s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
          }

          s += '>';

          if (voidElements.has(tagName)) {
            return s;
          }

          return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
        }

      case TEXT_NODE:
        {
          const {
            data,
            parentNode
          } = node;

          if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {
            return data;
          }

          return escapeData(data);
        }

      case CDATA_SECTION_NODE:
        {
          return `<!CDATA[[${node.data}]]>`;
        }

      case PROCESSING_INSTRUCTION_NODE:
        {
          return `<?${node.target} ${node.data}?>`;
        }

      case COMMENT_NODE:
        {
          return `<!--${node.data}-->`;
        }

      default:
        {
          return '';
        }
    }
  }

  const InternalSlot = createHiddenField('shadowRecord', 'synthetic-shadow');
  const {
    createDocumentFragment
  } = document;

  function getInternalSlot(root) {
    const record = getHiddenField(root, InternalSlot);

    if (isUndefined(record)) {
      throw new TypeError();
    }

    return record;
  }

  const ShadowRootResolverKey = '$shadowResolver$';
  const ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
  defineProperty(Node.prototype, ShadowRootResolverKey, {
    set(fn) {
      this[ShadowResolverPrivateKey] = fn;
      setNodeOwnerKey(this, fn.nodeKey);
    },

    get() {
      return this[ShadowResolverPrivateKey];
    },

    configurable: true,
    enumerable: true
  });
  function getShadowRootResolver(node) {
    return node[ShadowRootResolverKey];
  }
  function setShadowRootResolver(node, fn) {
    node[ShadowRootResolverKey] = fn;
  }
  function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
  }
  function getHost(root) {
    return getInternalSlot(root).host;
  }
  function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
  }
  function isHostElement(elm) {
    return !isUndefined(getHiddenField(elm, InternalSlot));
  }
  let uid = 0;
  function attachShadow$1(elm, options) {
    if (!isUndefined(getHiddenField(elm, InternalSlot))) {
      throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }

    const {
      mode,
      delegatesFocus
    } = options;
    const doc = getOwnerDocument(elm);
    const sr = createDocumentFragment.call(doc);
    const record = {
      mode,
      delegatesFocus: !!delegatesFocus,
      host: elm,
      shadowRoot: sr
    };
    setHiddenField(sr, InternalSlot, record);
    setHiddenField(elm, InternalSlot, record);

    const shadowResolver = () => sr;

    const x = shadowResolver.nodeKey = uid++;
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
  }
  const SyntheticShadowRootDescriptors = {
    constructor: {
      writable: true,
      configurable: true,
      value: SyntheticShadowRoot
    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return `[object ShadowRoot]`;
      }

    }
  };
  const ShadowRootDescriptors = {
    activeElement: {
      enumerable: true,
      configurable: true,

      get() {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const activeElement = DocumentPrototypeActiveElement.call(doc);

        if (isNull(activeElement)) {
          return activeElement;
        }

        if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
          return null;
        }

        let node = activeElement;

        while (!isNodeOwnedBy(host, node)) {
          node = parentElementGetter.call(node);
        }

        if (isSlotElement(node)) {
          return null;
        }

        return node;
      }

    },
    delegatesFocus: {
      configurable: true,

      get() {
        return getInternalSlot(this).delegatesFocus;
      }

    },
    elementFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(left, top) {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const element = elementFromPoint.call(doc, left, top);

        if (isNull(element)) {
          return element;
        }

        return retarget(this, pathComposer(element, true));
      }

    },
    elementsFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(_left, _top) {
        throw new Error();
      }

    },
    getSelection: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        throw new Error();
      }

    },
    host: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this);
      }

    },
    mode: {
      configurable: true,

      get() {
        return getInternalSlot(this).mode;
      }

    },
    styleSheets: {
      enumerable: true,
      configurable: true,

      get() {
        throw new Error();
      }

    }
  };
  const NodePatchDescriptors = {
    insertBefore: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild, refChild) {
        insertBefore.call(getHost(this), newChild, refChild);
        return newChild;
      }

    },
    removeChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(oldChild) {
        removeChild.call(getHost(this), oldChild);
        return oldChild;
      }

    },
    appendChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild) {
        appendChild.call(getHost(this), newChild);
        return newChild;
      }

    },
    replaceChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild, oldChild) {
        replaceChild.call(getHost(this), newChild, oldChild);
        return oldChild;
      }

    },
    addEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(type, listener, options) {
        addShadowRootEventListener(this, type, listener);
      }

    },
    removeEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(type, listener, options) {
        removeShadowRootEventListener(this, type, listener);
      }

    },
    baseURI: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this).baseURI;
      }

    },
    childNodes: {
      enumerable: true,
      configurable: true,

      get() {
        return createStaticNodeList(shadowRootChildNodes(this));
      }

    },
    compareDocumentPosition: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(otherNode) {
        const host = getHost(this);

        if (this === otherNode) {
          return 0;
        } else if (this.contains(otherNode)) {
          return 20;
        } else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
          return 37;
        } else {
          return 35;
        }
      }

    },
    contains: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(otherNode) {
        if (this === otherNode) {
          return true;
        }

        const host = getHost(this);
        return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
      }

    },
    firstChild: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[0] || null;
      }

    },
    lastChild: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[childNodes.length - 1] || null;
      }

    },
    hasChildNodes: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        const childNodes = getInternalChildNodes(this);
        return childNodes.length > 0;
      }

    },
    isConnected: {
      enumerable: true,
      configurable: true,

      get() {
        return isConnected.call(getHost(this));
      }

    },
    nextSibling: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    previousSibling: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    nodeName: {
      enumerable: true,
      configurable: true,

      get() {
        return '#document-fragment';
      }

    },
    nodeType: {
      enumerable: true,
      configurable: true,

      get() {
        return 11;
      }

    },
    nodeValue: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    ownerDocument: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this).ownerDocument;
      }

    },
    parentElement: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    parentNode: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    textContent: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        let textContent = '';

        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];

          if (currentNode.nodeType !== COMMENT_NODE) {
            textContent += getTextContent(currentNode);
          }
        }

        return textContent;
      },

      set(v) {
        const host = getHost(this);
        textContextSetter.call(host, v);
      }

    },
    getRootNode: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(options) {
        return !isUndefined(options) && isTrue$1(options.composed) ? getHost(this).getRootNode(options) : this;
      }

    }
  };
  const ElementPatchDescriptors = {
    innerHTML: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        let innerHTML = '';

        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
        }

        return innerHTML;
      },

      set(v) {
        const host = getHost(this);
        innerHTMLSetter.call(host, v);
      }

    }
  };
  const ParentNodePatchDescriptors = {
    childElementCount: {
      enumerable: true,
      configurable: true,

      get() {
        return this.children.length;
      }

    },
    children: {
      enumerable: true,
      configurable: true,

      get() {
        return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), elm => elm instanceof Element));
      }

    },
    firstElementChild: {
      enumerable: true,
      configurable: true,

      get() {
        return this.children[0] || null;
      }

    },
    lastElementChild: {
      enumerable: true,
      configurable: true,

      get() {
        const {
          children
        } = this;
        return children.item(children.length - 1) || null;
      }

    },
    querySelector: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(selectors) {
        return shadowRootQuerySelector(this, selectors);
      }

    },
    querySelectorAll: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(selectors) {
        return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
      }

    }
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
  function SyntheticShadowRoot() {
    throw new TypeError('Illegal constructor');
  }
  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
  function getIE11FakeShadowRootPlaceholder(host) {
    const shadowRoot = getShadowRoot(host);
    let c = shadowRoot.$$placeholder$$;

    if (!isUndefined(c)) {
      return c;
    }

    const doc = getOwnerDocument(host);
    c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');
    defineProperties(c, {
      childNodes: {
        get() {
          return shadowRoot.childNodes;
        },

        enumerable: true,
        configurable: true
      },
      tagName: {
        get() {
          return `#shadow-root (${shadowRoot.mode})`;
        },

        enumerable: true,
        configurable: true
      }
    });
    return c;
  }

  function foldSlotElement(slot) {
    let parent = parentElementGetter.call(slot);

    while (!isNull(parent) && isSlotElement(parent)) {
      slot = parent;
      parent = parentElementGetter.call(slot);
    }

    return slot;
  }

  function isNodeSlotted(host, node) {
    {
      assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);
      assert.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);
    }

    const hostKey = getNodeKey(host);
    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);

    while (!isNull(currentElement) && currentElement !== host) {
      const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
      const parent = parentElementGetter.call(currentElement);

      if (elmOwnerKey === hostKey) {
        return isSlotElement(currentElement);
      } else if (parent === host) {
        return false;
      } else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
        if (isSlotElement(parent)) {
          currentElement = getNodeOwner(foldSlotElement(parent));

          if (!isNull(currentElement)) {
            if (currentElement === host) {
              return true;
            } else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        currentElement = parent;
      }
    }

    return false;
  }

  function getNodeOwner(node) {
    if (!(node instanceof Node)) {
      return null;
    }

    const ownerKey = getNodeNearestOwnerKey(node);

    if (isUndefined(ownerKey)) {
      return null;
    }

    let nodeOwner = node;

    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
      nodeOwner = parentNodeGetter.call(nodeOwner);
    }

    if (isNull(nodeOwner)) {
      return null;
    }

    return nodeOwner;
  }
  function isSlotElement(node) {
    return node instanceof HTMLSlotElement;
  }
  function isNodeOwnedBy(owner, node) {
    {
      assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);
      assert.invariant(node instanceof Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);
      assert.invariant(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);
    }

    const ownerKey = getNodeNearestOwnerKey(node);
    return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
  }
  function shadowRootChildNodes(root) {
    const elm = getHost(root);
    return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }
  function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];

    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }
  function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        return node;
      }
    }

    return null;
  }
  function getAllMatches(owner, nodeList) {
    const filteredAndPatched = [];

    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      const isOwned = isNodeOwnedBy(owner, node);

      if (isOwned) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }
  function getFirstMatch(owner, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      if (isNodeOwnedBy(owner, nodeList[i])) {
        return nodeList[i];
      }
    }

    return null;
  }
  function shadowRootQuerySelector(root, selector) {
    const elm = getHost(root);
    const nodeList = arrayFromCollection(querySelectorAll.call(elm, selector));
    return getFirstMatch(elm, nodeList);
  }
  function shadowRootQuerySelectorAll(root, selector) {
    const elm = getHost(root);
    const nodeList = querySelectorAll.call(elm, selector);
    return getAllMatches(elm, arrayFromCollection(nodeList));
  }
  function getFilteredChildNodes(node) {
    let children;

    if (!isHostElement(node) && !isSlotElement(node)) {
      children = childNodesGetter.call(node);
      return arrayFromCollection(children);
    }

    if (isHostElement(node)) {
      const slots = arrayFromCollection(querySelectorAll.call(node, 'slot'));
      const resolver = getShadowRootResolver(getShadowRoot(node));
      return ArrayReduce.call(slots, (seed, slot) => {
        if (resolver === getShadowRootResolver(slot)) {
          ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
        }

        return seed;
      }, []);
    } else {
      children = arrayFromCollection(childNodesGetter.call(node));
      const resolver = getShadowRootResolver(node);
      return ArrayReduce.call(children, (seed, child) => {
        if (resolver === getShadowRootResolver(child)) {
          ArrayPush.call(seed, child);
        }

        return seed;
      }, []);
    }
  }
  function getFilteredSlotAssignedNodes(slot) {
    const owner = getNodeOwner(slot);

    if (isNull(owner)) {
      return [];
    }

    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (!isNodeOwnedBy(owner, child)) {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  const OwnKey = '$$OwnKey$$';
  const OwnerKey = '$$OwnerKey$$';
  const hasNativeSymbolsSupport$2 = Symbol('x').toString() === 'Symbol(x)';
  function getNodeOwnerKey(node) {
    return node[OwnerKey];
  }
  function setNodeOwnerKey(node, value) {
    {
      defineProperty(node, OwnerKey, {
        value,
        configurable: true
      });
    }
  }
  function getNodeKey(node) {
    return node[OwnKey];
  }
  function setNodeKey(node, value) {
    {
      defineProperty(node, OwnKey, {
        value
      });
    }
  }
  function getNodeNearestOwnerKey(node) {
    let ownerNode = node;
    let ownerKey;

    while (!isNull(ownerNode)) {
      ownerKey = getNodeOwnerKey(ownerNode);

      if (!isUndefined(ownerKey)) {
        return ownerKey;
      }

      ownerNode = parentNodeGetter.call(ownerNode);
    }
  }
  function isNodeShadowed(node) {
    return !isUndefined(getNodeOwnerKey(node));
  }
  function isNodeDeepShadowed(node) {
    return !isUndefined(getNodeNearestOwnerKey(node));
  }
  function hasMountedChildren(node) {
    return isSlotElement(node) || isHostElement(node);
  }

  function getShadowParent(node, value) {
    const owner = getNodeOwner(node);

    if (value === owner) {
      return getShadowRoot(owner);
    } else if (value instanceof Element) {
      if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
        return value;
      } else if (!isNull(owner) && isSlotElement(value)) {
        const slotOwner = getNodeOwner(value);

        if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
          return slotOwner;
        }
      }
    }

    return null;
  }

  function hasChildNodesPatched() {
    return getInternalChildNodes(this).length > 0;
  }

  function firstChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[0] || null;
  }

  function lastChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[childNodes.length - 1] || null;
  }

  function textContentGetterPatched() {
    return getTextContent(this);
  }

  function textContentSetterPatched(value) {
    textContextSetter.call(this, value);
  }

  function parentNodeGetterPatched() {
    const value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return value;
    }

    return getShadowParent(this, value);
  }

  function parentElementGetterPatched() {
    const value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return null;
    }

    const parentNode = getShadowParent(this, value);
    return parentNode instanceof Element ? parentNode : null;
  }

  function compareDocumentPositionPatched(otherNode) {
    if (this.getRootNode() === otherNode) {
      return 10;
    } else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return 35;
    }

    return compareDocumentPosition.call(this, otherNode);
  }

  function containsPatched(otherNode) {
    if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return false;
    }

    return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }

  function cloneNodePatched(deep) {
    const clone = cloneNode.call(this, false);

    if (!deep) {
      return clone;
    }

    const childNodes = getInternalChildNodes(this);

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      clone.appendChild(childNodes[i].cloneNode(true));
    }

    return clone;
  }

  function childNodesGetterPatched() {
    if (this instanceof Element && isHostElement(this)) {
      const owner = getNodeOwner(this);
      const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));

      if ( isFalse$1(hasNativeSymbolsSupport$2) && isExternalChildNodeAccessorFlagOn()) {
        ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));
      }

      return createStaticNodeList(childNodes);
    }

    return childNodesGetter.call(this);
  }

  const nativeGetRootNode = Node.prototype.getRootNode;
  const getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function () {
    let node = this;
    let nodeParent;

    while (!isNull(nodeParent = parentNodeGetter.call(node))) {
      node = nodeParent;
    }

    return node;
  };

  function getNearestRoot(node) {
    const ownerNode = getNodeOwner(node);

    if (isNull(ownerNode)) {
      return getDocumentOrRootNode.call(node);
    }

    return getShadowRoot(ownerNode);
  }

  function getRootNodePatched(options) {
    const composed = isUndefined(options) ? false : !!options.composed;
    return isTrue$1(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }

  defineProperties(Node.prototype, {
    firstChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstChildGetterPatched.call(this);
        }

        return firstChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    lastChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastChildGetterPatched.call(this);
        }

        return lastChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    textContent: {
      get() {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return textContentGetterPatched.call(this);
          }

          return textContentGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return textContentGetter.call(this);
        }

        return textContentGetterPatched.call(this);
      },

      set: textContentSetterPatched,
      enumerable: true,
      configurable: true
    },
    parentNode: {
      get() {
        if (isNodeShadowed(this)) {
          return parentNodeGetterPatched.call(this);
        }

        return parentNodeGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    parentElement: {
      get() {
        if (isNodeShadowed(this)) {
          return parentElementGetterPatched.call(this);
        }

        return parentElementGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (hasMountedChildren(this)) {
          return childNodesGetterPatched.call(this);
        }

        return childNodesGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    hasChildNodes: {
      value() {
        if (hasMountedChildren(this)) {
          return hasChildNodesPatched.call(this);
        }

        return hasChildNodes.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    compareDocumentPosition: {
      value(otherNode) {
        if (isGlobalPatchingSkipped(this)) {
          return compareDocumentPosition.call(this, otherNode);
        }

        return compareDocumentPositionPatched.call(this, otherNode);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    contains: {
      value(otherNode) {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (otherNode == null) {
            return false;
          }

          if (isNodeShadowed(this) || isHostElement(this)) {
            return containsPatched.call(this, otherNode);
          }

          return contains.call(this, otherNode);
        }

        if (isGlobalPatchingSkipped(this)) {
          return contains.call(this, otherNode);
        }

        return containsPatched.call(this, otherNode);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    cloneNode: {
      value(deep) {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return cloneNodePatched.call(this, deep);
          }

          return cloneNode.call(this, deep);
        }

        if (isTrue$1(deep)) {
          if (isGlobalPatchingSkipped(this)) {
            return cloneNode.call(this, deep);
          }

          return cloneNodePatched.call(this, deep);
        }

        return cloneNode.call(this, deep);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    getRootNode: {
      value: getRootNodePatched,
      enumerable: true,
      configurable: true,
      writable: true
    },
    isConnected: {
      enumerable: true,
      configurable: true,

      get() {
        return isConnected.call(this);
      }

    }
  });
  let internalChildNodeAccessorFlag = false;
  function isExternalChildNodeAccessorFlagOn() {
    return !internalChildNodeAccessorFlag;
  }
  const getInternalChildNodes =  isFalse$1(hasNativeSymbolsSupport$2) ? function (node) {
    internalChildNodeAccessorFlag = true;
    let childNodes;
    let error = null;

    try {
      childNodes = node.childNodes;
    } catch (e) {
      error = e;
    } finally {
      internalChildNodeAccessorFlag = false;

      if (!isNull(error)) {
        throw error;
      }
    }

    return childNodes;
  } : function (node) {
    return node.childNodes;
  };

  if (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {
    defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(Node.prototype, 'contains'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {
    defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(Node.prototype, 'parentElement'));
  }

  function elemFromPoint(left, top) {
    const element = elementFromPoint.call(this, left, top);

    if (isNull(element)) {
      return element;
    }

    return retarget(this, pathComposer(element, true));
  }

  Document.prototype.elementFromPoint = elemFromPoint;
  defineProperty(Document.prototype, 'activeElement', {
    get() {
      let node = DocumentPrototypeActiveElement.call(this);

      if (isNull(node)) {
        return node;
      }

      while (!isUndefined(getNodeOwnerKey(node))) {
        node = parentElementGetter.call(node);

        if (isNull(node)) {
          return null;
        }
      }

      if (node.tagName === 'HTML') {
        node = this.body;
      }

      return node;
    },

    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementById', {
    value() {
      const elm = getElementById.apply(this, ArraySlice.call(arguments));

      if (isNull(elm)) {
        return null;
      }

      return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelector', {
    value() {
      const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFind.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return !isUndefined(filtered) ? filtered : null;
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelectorAll', {
    value() {
      const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByClassName', {
    value() {
      const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagName', {
    value() {
      const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagNameNS', {
    value() {
      const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName') ? HTMLDocument.prototype : Document.prototype, 'getElementsByName', {
    value() {
      const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });

  Object.defineProperty(window, 'ShadowRoot', {
    value: SyntheticShadowRoot,
    configurable: true,
    writable: true
  });

  function doesEventNeedsPatch(e) {
    const originalTarget = eventTargetGetter.call(e);
    return originalTarget instanceof Node && isNodeDeepShadowed(originalTarget);
  }

  function isValidEventListener(listener) {
    return isFunction(listener) || !isNull(listener) && isObject(listener) && isFunction(listener.handleEvent);
  }

  function getEventListenerWrapper(listener) {
    if ('$$lwcEventWrapper$$' in listener) {
      return listener.$$lwcEventWrapper$$;
    }

    const isHandlerFunction = isFunction(listener);

    const wrapperFn = listener.$$lwcEventWrapper$$ = function (e) {
      if (doesEventNeedsPatch(e)) {
        patchEvent(e);
      }

      return isHandlerFunction ? listener.call(this, e) : listener.handleEvent && listener.handleEvent(e);
    };

    return wrapperFn;
  }

  function windowAddEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function windowRemoveEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    windowRemoveEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  function addEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    addEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function removeEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    removeEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  window.addEventListener = windowAddEventListener$1;
  window.removeEventListener = windowRemoveEventListener$1;
  const protoToBePatched = typeof EventTarget !== 'undefined' ? EventTarget.prototype : Node.prototype;
  defineProperties(protoToBePatched, {
    addEventListener: {
      value: addEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: removeEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });

  const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
  function detect$1() {
    if (!composedDescriptor) {
      return false;
    }

    let clickEvent = new Event('click');
    const button = document.createElement('button');
    button.addEventListener('click', event => clickEvent = event);
    button.click();
    return !composedDescriptor.get.call(clickEvent);
  }

  const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');

  function handleClick(event) {
    Object.defineProperty(event, 'composed', {
      configurable: true,
      enumerable: true,

      get() {
        return true;
      }

    });
  }

  function apply$1() {
    HTMLElement.prototype.click = function () {
      addEventListener.call(this, 'click', handleClick);

      try {
        originalClickDescriptor.value.call(this);
      } finally {
        removeEventListener.call(this, 'click', handleClick);
      }
    };
  }

  if (detect$1()) {
    apply$1();
  }

  function detect$2() {
    return new Event('test', {
      composed: true
    }).composed !== true;
  }

  function apply$2() {
    const composedEvents = assign(create(null), {
      blur: 1,
      focus: 1,
      focusin: 1,
      focusout: 1,
      click: 1,
      dblclick: 1,
      mousedown: 1,
      mouseenter: 1,
      mouseleave: 1,
      mousemove: 1,
      mouseout: 1,
      mouseover: 1,
      mouseup: 1,
      wheel: 1,
      beforeinput: 1,
      input: 1,
      keydown: 1,
      keyup: 1,
      compositionstart: 1,
      compositionupdate: 1,
      compositionend: 1,
      touchstart: 1,
      touchend: 1,
      touchmove: 1,
      touchcancel: 1,
      pointerover: 1,
      pointerenter: 1,
      pointerdown: 1,
      pointermove: 1,
      pointerup: 1,
      pointercancel: 1,
      pointerout: 1,
      pointerleave: 1,
      gotpointercapture: 1,
      lostpointercapture: 1,
      dragstart: 1,
      drag: 1,
      dragenter: 1,
      dragleave: 1,
      dragover: 1,
      drop: 1,
      dragend: 1,
      DOMActivate: 1,
      DOMFocusIn: 1,
      DOMFocusOut: 1,
      keypress: 1
    });
    const EventConstructor = Event;

    function PatchedEvent(type, eventInitDict) {
      const event = new EventConstructor(type, eventInitDict);
      const isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
        composed: {
          get() {
            return isComposed;
          },

          configurable: true,
          enumerable: true
        }
      });
      return event;
    }

    PatchedEvent.prototype = EventConstructor.prototype;
    PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;
    PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;
    PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;
    PatchedEvent.NONE = EventConstructor.NONE;
    window.Event = PatchedEvent;
    Object.defineProperties(Event.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return composedEvents[type] === 1;
        },

        configurable: true,
        enumerable: true
      }
    });
  }

  if (detect$2()) {
    apply$2();
  }

  const CustomEventConstructor = CustomEvent;

  function PatchedCustomEvent(type, eventInitDict) {
    const event = new CustomEventConstructor(type, eventInitDict);
    const isComposed = !!(eventInitDict && eventInitDict.composed);
    Object.defineProperties(event, {
      composed: {
        get() {
          return isComposed;
        },

        configurable: true,
        enumerable: true
      }
    });
    return event;
  }

  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;

  const originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed').get;
  Object.defineProperties(FocusEvent.prototype, {
    composed: {
      get() {
        const {
          isTrusted
        } = this;
        const composed = originalComposedGetter.call(this);

        if (isTrusted && composed === false) {
          return true;
        }

        return composed;
      },

      enumerable: true,
      configurable: true
    }
  });

  function detect$3() {
    return typeof HTMLIFrameElement !== 'undefined';
  }

  function apply$3() {
    const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
    const {
      get: originalGetter
    } = desc;

    desc.get = function () {
      const original = originalGetter.call(this);

      if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
        return original;
      }

      return wrapIframeWindow(original);
    };

    defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
  }

  function wrapIframeWindow(win) {
    return {
      addEventListener() {
        return win.addEventListener.apply(win, arguments);
      },

      blur() {
        return win.blur.apply(win, arguments);
      },

      close() {
        return win.close.apply(win, arguments);
      },

      focus() {
        return win.focus.apply(win, arguments);
      },

      postMessage() {
        return win.postMessage.apply(win, arguments);
      },

      removeEventListener() {
        return win.removeEventListener.apply(win, arguments);
      },

      get closed() {
        return win.closed;
      },

      get frames() {
        return win.frames;
      },

      get length() {
        return win.length;
      },

      get location() {
        return win.location;
      },

      set location(value) {
        win.location = value;
      },

      get opener() {
        return win.opener;
      },

      get parent() {
        return win.parent;
      },

      get self() {
        return win.self;
      },

      get top() {
        return win.top;
      },

      get window() {
        return win.window;
      }

    };
  }

  if (detect$3()) {
    apply$3();
  }

  const OriginalMutationObserver = MutationObserver;
  const {
    disconnect: originalDisconnect,
    observe: originalObserve,
    takeRecords: originalTakeRecords
  } = OriginalMutationObserver.prototype;
  const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
  const observerLookupField = '$$lwcNodeObservers$$';
  const observerToNodesMap = new WeakMap();

  function getNodeObservers(node) {
    return node[observerLookupField];
  }

  function setNodeObservers(node, observers) {
    node[observerLookupField] = observers;
  }

  function retargetMutationRecord(originalRecord) {
    const {
      addedNodes,
      removedNodes,
      target,
      type
    } = originalRecord;
    const retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
      addedNodes: {
        get() {
          return addedNodes;
        },

        enumerable: true,
        configurable: true
      },
      removedNodes: {
        get() {
          return removedNodes;
        },

        enumerable: true,
        configurable: true
      },
      type: {
        get() {
          return type;
        },

        enumerable: true,
        configurable: true
      },
      target: {
        get() {
          return target.shadowRoot;
        },

        enumerable: true,
        configurable: true
      }
    });
    return retargetedRecord;
  }

  function isQualifiedObserver(observer, target) {
    let parentNode = target;

    while (!isNull(parentNode)) {
      const parentNodeObservers = getNodeObservers(parentNode);

      if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer || ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
        return true;
      }

      parentNode = parentNode.parentNode;
    }

    return false;
  }

  function filterMutationRecords(mutations, observer) {
    return ArrayReduce.call(mutations, (filteredSet, record) => {
      const {
        target,
        addedNodes,
        removedNodes,
        type
      } = record;

      if (type === 'childList' && !isUndefined(getNodeKey(target))) {
        if (addedNodes.length > 0) {
          const sampleNode = addedNodes[0];

          if (isQualifiedObserver(observer, sampleNode)) {
            const nodeObservers = getNodeObservers(target);

            if (nodeObservers && (nodeObservers[0] === observer || ArrayIndexOf.call(nodeObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, record);
            } else {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        } else {
          const shadowRoot = target.shadowRoot;
          const sampleNode = removedNodes[0];

          if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && isQualifiedObserver(observer, target)) {
            ArrayPush.call(filteredSet, record);
          } else if (shadowRoot) {
            const shadowRootObservers = getNodeObservers(shadowRoot);

            if (shadowRootObservers && (shadowRootObservers[0] === observer || ArrayIndexOf.call(shadowRootObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        }
      } else {
        if (isQualifiedObserver(observer, target)) {
          ArrayPush.call(filteredSet, record);
        }
      }

      return filteredSet;
    }, []);
  }

  function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];

    if (isUndefined(wrappedCallback)) {
      wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
        const filteredRecords = filterMutationRecords(mutations, observer);

        if (filteredRecords.length === 0) {
          return;
        }

        callback.call(observer, filteredRecords, observer);
      };
    }

    return wrappedCallback;
  }

  function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer = new OriginalMutationObserver(wrappedCallback);
    return observer;
  }

  function patchedDisconnect() {
    originalDisconnect.call(this);
    const observedNodes = observerToNodesMap.get(this);

    if (!isUndefined(observedNodes)) {
      forEach.call(observedNodes, observedNode => {
        const observers = observedNode[observerLookupField];

        if (!isUndefined(observers)) {
          const index = ArrayIndexOf.call(observers, this);

          if (index !== -1) {
            ArraySplice.call(observers, index, 1);
          }
        }
      });
      observedNodes.length = 0;
    }
  }

  function patchedObserve(target, options) {
    let targetObservers = getNodeObservers(target);

    if (isUndefined(targetObservers)) {
      targetObservers = [];
      setNodeObservers(target, targetObservers);
    }

    if (ArrayIndexOf.call(targetObservers, this) === -1) {
      ArrayPush.call(targetObservers, this);
    }

    if (target instanceof SyntheticShadowRoot) {
      target = target.host;
    }

    if (observerToNodesMap.has(this)) {
      const observedNodes = observerToNodesMap.get(this);

      if (ArrayIndexOf.call(observedNodes, target) === -1) {
        ArrayPush.call(observedNodes, target);
      }
    } else {
      observerToNodesMap.set(this, [target]);
    }

    return originalObserve.call(this, target, options);
  }

  function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
  }

  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, 'MutationObserver', {
    value: PatchedMutationObserver,
    configurable: true,
    writable: true
  });

  let observer;
  const observerConfig = {
    childList: true
  };
  const SlotChangeKey = createHiddenField('slotchange', 'synthetic-shadow');

  function initSlotObserver() {
    return new MO(mutations => {
      const slots = [];
      forEach.call(mutations, mutation => {
        {
          assert.invariant(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle "childList" mutations.`);
        }

        const {
          target: slot
        } = mutation;

        if (ArrayIndexOf.call(slots, slot) === -1) {
          ArrayPush.call(slots, slot);
          dispatchEvent.call(slot, new CustomEvent('slotchange'));
        }
      });
    });
  }

  function getFilteredSlotFlattenNodes(slot) {
    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (child instanceof Element && isSlotElement(child)) {
        ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
      } else {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  function assignedSlotGetterPatched() {
    const parentNode = parentNodeGetter.call(this);

    if (isNull(parentNode) || !isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
      return null;
    }

    return parentNode;
  }
  defineProperties(HTMLSlotElement.prototype, {
    addEventListener: {
      value(type, listener, options) {
        HTMLElement.prototype.addEventListener.call(this, type, listener, options);

        if (type === 'slotchange' && !getHiddenField(this, SlotChangeKey)) {
          setHiddenField(this, SlotChangeKey, true);

          if (!observer) {
            observer = initSlotObserver();
          }

          MutationObserverObserve.call(observer, this, observerConfig);
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedElements: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue$1(options.flatten);
          const nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
          return ArrayFilter.call(nodes, node => node instanceof Element);
        } else {
          return assignedElements.apply(this, ArraySlice.call(arguments));
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedNodes: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue$1(options.flatten);
          return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        } else {
          return assignedNodes.apply(this, ArraySlice.call(arguments));
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    name: {
      get() {
        const name = getAttribute.call(this, 'name');
        return isNull(name) ? '' : name;
      },

      set(value) {
        setAttribute.call(this, 'name', value);
      },

      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (isNodeShadowed(this)) {
          const owner = getNodeOwner(this);
          const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
          return createStaticNodeList(childNodes);
        }

        return childNodesGetter.call(this);
      },

      enumerable: true,
      configurable: true
    }
  });

  defineProperties(Text.prototype, {
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
    let filtered;
    const ownerKey = getNodeOwnerKey(context);

    if (!isUndefined(ownerKey)) {
      if (isHostElement(context)) {
        const owner = getNodeOwner(context);

        if (isNull(owner)) {
          filtered = [];
        } else if (getNodeKey(context)) {
          filtered = getAllSlottedMatches(context, unfilteredNodes);
        } else {
          filtered = getAllMatches(owner, unfilteredNodes);
        }
      } else {
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
      }
    } else if (context instanceof HTMLBodyElement) {
      filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }

    return filtered;
  }

  var ShadowDomSemantic;

  (function (ShadowDomSemantic) {
    ShadowDomSemantic[ShadowDomSemantic["Disabled"] = 0] = "Disabled";
    ShadowDomSemantic[ShadowDomSemantic["Enabled"] = 1] = "Enabled";
  })(ShadowDomSemantic || (ShadowDomSemantic = {}));

  function innerHTMLGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    let innerHTML = '';

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      innerHTML += getOuterHTML(childNodes[i]);
    }

    return innerHTML;
  }

  function outerHTMLGetterPatched() {
    return getOuterHTML(this);
  }

  function attachShadowPatched(options) {
    if (isTrue$1(options['$$lwc-synthetic-mode$$'])) {
      return attachShadow$1(this, options);
    } else {
      return attachShadow.call(this, options);
    }
  }

  function shadowRootGetterPatched() {
    if (isHostElement(this)) {
      const shadow = getShadowRoot(this);

      if (shadow.mode === 'open') {
        return shadow;
      }
    }

    return shadowRootGetter.call(this);
  }

  function childrenGetterPatched() {
    const owner = getNodeOwner(this);
    const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
    return createStaticHTMLCollection(ArrayFilter.call(childNodes, node => node instanceof Element));
  }

  function childElementCountGetterPatched() {
    return this.children.length;
  }

  function firstElementChildGetterPatched() {
    return this.children[0] || null;
  }

  function lastElementChildGetterPatched() {
    const {
      children
    } = this;
    return children.item(children.length - 1) || null;
  }

  defineProperties(Element.prototype, {
    innerHTML: {
      get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return innerHTMLGetterPatched.call(this);
          }

          return innerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return innerHTMLGetter.call(this);
        }

        return innerHTMLGetterPatched.call(this);
      },

      set(v) {
        innerHTMLSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    outerHTML: {
      get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return outerHTMLGetterPatched.call(this);
          }

          return outerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return outerHTMLGetter.call(this);
        }

        return outerHTMLGetterPatched.call(this);
      },

      set(v) {
        outerHTMLSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    attachShadow: {
      value: attachShadowPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    shadowRoot: {
      get: shadowRootGetterPatched,
      enumerable: true,
      configurable: true
    },
    children: {
      get() {
        if (hasMountedChildren(this)) {
          return childrenGetterPatched.call(this);
        }

        return childrenGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    childElementCount: {
      get() {
        if (hasMountedChildren(this)) {
          return childElementCountGetterPatched.call(this);
        }

        return childElementCountGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    firstElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstElementChildGetterPatched.call(this);
        }

        return firstElementChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    lastElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastElementChildGetterPatched.call(this);
        }

        return lastElementChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  if (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {
    defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {
    defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'children')) {
    defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));
  }

  function querySelectorPatched() {
    const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

    if (isHostElement(this)) {
      const owner = getNodeOwner(this);

      if (isNull(owner)) {
        return null;
      } else if (getNodeKey(this)) {
        return getFirstSlottedMatch(this, nodeList);
      } else {
        return getFirstMatch(owner, nodeList);
      }
    } else if (isNodeShadowed(this)) {
      const ownerKey = getNodeOwnerKey(this);

      if (!isUndefined(ownerKey)) {
        const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === ownerKey);
        return isUndefined(elm) ? null : elm;
      } else {
        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          return nodeList.length === 0 ? null : nodeList[0];
        }

        const contextNearestOwnerKey = getNodeNearestOwnerKey(this);
        const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
        return isUndefined(elm) ? null : elm;
      }
    } else {
      if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
        if (!(this instanceof HTMLBodyElement)) {
          const elm = nodeList[0];
          return isUndefined(elm) ? null : elm;
        }
      }

      const elm = ArrayFind.call(nodeList, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(this));
      return isUndefined(elm) ? null : elm;
    }
  }

  function getFilteredArrayOfNodes(context, unfilteredNodes, shadowDomSemantic) {
    let filtered;

    if (isHostElement(context)) {
      const owner = getNodeOwner(context);

      if (isNull(owner)) {
        filtered = [];
      } else if (getNodeKey(context)) {
        filtered = getAllSlottedMatches(context, unfilteredNodes);
      } else {
        filtered = getAllMatches(owner, unfilteredNodes);
      }
    } else if (isNodeShadowed(context)) {
      const ownerKey = getNodeOwnerKey(context);

      if (!isUndefined(ownerKey)) {
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
      } else if (shadowDomSemantic === ShadowDomSemantic.Enabled) {
        const contextNearestOwnerKey = getNodeNearestOwnerKey(context);
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    } else {
      if (context instanceof HTMLBodyElement || shadowDomSemantic === ShadowDomSemantic.Enabled) {
        filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    }

    return filtered;
  }

  defineProperties(Element.prototype, {
    querySelector: {
      value: querySelectorPatched,
      writable: true,
      enumerable: true,
      configurable: true
    },
    querySelectorAll: {
      value() {
        const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          const filteredResults = getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Disabled);
          return createStaticNodeList(filteredResults);
        }

        return createStaticNodeList(getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Enabled));
      },

      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  {
    defineProperties(Element.prototype, {
      getElementsByClassName: {
        value() {
          const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagName: {
        value() {
          const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagNameNS: {
        value() {
          const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      }
    });
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {
    defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));
  }

  const TabbableElementsQuery = `
    button:not([tabindex="-1"]):not([disabled]),
    [contenteditable]:not([tabindex="-1"]),
    video[controls]:not([tabindex="-1"]),
    audio[controls]:not([tabindex="-1"]),
    [href]:not([tabindex="-1"]),
    input:not([tabindex="-1"]):not([disabled]),
    select:not([tabindex="-1"]):not([disabled]),
    textarea:not([tabindex="-1"]):not([disabled]),
    [tabindex="0"]
`;
  const DidAddMouseDownListener = createHiddenField('DidAddMouseDownListener', 'synthetic-shadow');

  function isVisible(element) {
    const {
      width,
      height
    } = getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    return noZeroSize && getComputedStyle(element).visibility !== 'hidden';
  }

  function isTabbable(element) {
    return matches.call(element, TabbableElementsQuery) && isVisible(element);
  }

  function getTabbableSegments(host) {
    const doc = getOwnerDocument(host);
    const all = arrayFromCollection(querySelectorAll$1.call(doc, TabbableElementsQuery));
    const inner = arrayFromCollection(querySelectorAll.call(host, TabbableElementsQuery));

    {
      assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);
    }

    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = ArrayIndexOf.call(all, host);
    const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
    const prev = ArraySlice.call(all, 0, firstChildIndex);
    const next = ArraySlice.call(all, lastChildIndex);
    return {
      prev,
      inner,
      next
    };
  }

  function getActiveElement(host) {
    const doc = getOwnerDocument(host);
    const activeElement = DocumentPrototypeActiveElement.call(doc);

    if (isNull(activeElement)) {
      return activeElement;
    }

    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
  }

  function relatedTargetPosition(host, relatedTarget) {
    const pos = compareDocumentPosition.call(host, relatedTarget);

    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
      return 0;
    } else if (pos & DOCUMENT_POSITION_PRECEDING) {
      return 1;
    } else if (pos & DOCUMENT_POSITION_FOLLOWING) {
      return 2;
    }

    return -1;
  }

  function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, 'focusin', muteEvent, true);
    windowAddEventListener.call(win, 'focusout', muteEvent, true);
    func();
    windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
    windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
  }

  function focusOnNextOrBlur(segment, target, relatedTarget) {
    const win = getOwnerWindow(relatedTarget);
    const next = getNextTabbable(segment, relatedTarget);

    if (isNull(next)) {
      muteFocusEventsDuringExecution(win, () => {
        target.blur();
      });
    } else {
      muteFocusEventsDuringExecution(win, () => {
        next.focus();
      });
    }
  }

  let letBrowserHandleFocus = false;
  function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
  }
  function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
  }

  function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    const host = eventCurrentTargetGetter.call(event);
    const target = eventTargetGetter.call(event);

    if (host !== target) {
      return;
    }

    const relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
      const first = ArrayFind.call(segments.inner, findTabbableElms);

      if (!isUndefined(first)) {
        const win = getOwnerWindow(first);
        muteFocusEventsDuringExecution(win, () => {
          first.focus();
        });
      } else {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
    } else if (host === target) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    const relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    const host = eventCurrentTargetGetter.call(event);
    const segments = getTabbableSegments(host);

    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
      return;
    }

    const target = eventTargetGetter.call(event);
    const position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      focusOnNextOrBlur(segments.next, target, relatedTarget);
    }

    if (position === 2) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
      return false;
    }

    const ownerDocument = getOwnerDocument(toElm);
    let root = toElm.getRootNode();

    while (root !== ownerDocument && root !== fromRoot) {
      const sr = root;
      const host = sr.host;

      if (getAttribute.call(host, 'tabindex') === '-1') {
        return false;
      }

      root = host && host.getRootNode();
    }

    return true;
  }

  function getNextTabbable(tabbables, relatedTarget) {
    const len = tabbables.length;

    if (len > 0) {
      for (let i = 0; i < len; i += 1) {
        const next = tabbables[i];

        if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
          return next;
        }
      }
    }

    return null;
  }

  function handleFocus(elm) {
    {
      assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);
    }

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener.call(elm, 'focusin', skipHostHandler, true);
  }
  function ignoreFocus(elm) {
    removeEventListener.call(elm, 'focusin', skipHostHandler, true);
  }

  function bindDocumentMousedownMouseupHandlers(elm) {
    const ownerDocument = getOwnerDocument(elm);

    if (!getHiddenField(ownerDocument, DidAddMouseDownListener)) {
      setHiddenField(ownerDocument, DidAddMouseDownListener, true);
      addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
      addEventListener.call(ownerDocument, 'mouseup', () => {
        setTimeout(enableKeyboardFocusNavigationRoutines);
      }, true);
    }
  }

  function handleFocusIn(elm) {
    {
      assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);
    }

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }
  function ignoreFocusIn(elm) {
    removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  const {
    blur,
    focus
  } = HTMLElement.prototype;

  function tabIndexGetterPatched() {
    if (isDelegatingFocus(this) && isFalse$1(hasAttribute.call(this, 'tabindex'))) {
      return 0;
    }

    return tabIndexGetter.call(this);
  }

  function tabIndexSetterPatched(value) {
    const delegatesFocus = isDelegatingFocus(this);
    const prevValue = tabIndexGetter.call(this);
    const prevHasAttr = hasAttribute.call(this, 'tabindex');
    tabIndexSetter.call(this, value);
    const currValue = tabIndexGetter.call(this);
    const currHasAttr = hasAttribute.call(this, 'tabindex');
    const didValueChange = prevValue !== currValue;

    if (prevHasAttr && (didValueChange || isFalse$1(currHasAttr))) {
      if (prevValue === -1) {
        ignoreFocusIn(this);
      }

      if (prevValue === 0 && delegatesFocus) {
        ignoreFocus(this);
      }
    }

    if (isFalse$1(currHasAttr)) {
      return;
    }

    if (prevHasAttr && currHasAttr && isFalse$1(didValueChange)) {
      return;
    }

    if (currValue === -1) {
      handleFocusIn(this);
    }

    if (currValue === 0 && delegatesFocus) {
      handleFocus(this);
    }
  }

  function blurPatched() {
    if (isDelegatingFocus(this)) {
      const currentActiveElement = getActiveElement(this);

      if (!isNull(currentActiveElement)) {
        currentActiveElement.blur();
        return;
      }
    }

    return blur.call(this);
  }

  function focusPatched() {
    disableKeyboardFocusNavigationRoutines();
    focus.call(this);
    enableKeyboardFocusNavigationRoutines();
  }

  defineProperties(HTMLElement.prototype, {
    tabIndex: {
      get() {
        if (isHostElement(this)) {
          return tabIndexGetterPatched.call(this);
        }

        return tabIndexGetter.call(this);
      },

      set(v) {
        if (isHostElement(this)) {
          return tabIndexSetterPatched.call(this, v);
        }

        return tabIndexSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    blur: {
      value() {
        if (isHostElement(this)) {
          return blurPatched.call(this);
        }

        blur.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    focus: {
      value() {
        focusPatched.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    }
  });

  const {
    addEventListener: superAddEventListener,
    removeEventListener: superRemoveEventListener
  } = Node.prototype;

  function addEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      addCustomElementEventListener(this, type, listener);
    } else {
      superAddEventListener.call(this, type, listener, options);
    }
  }

  function removeEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      removeCustomElementEventListener(this, type, listener);
    } else {
      superRemoveEventListener.call(this, type, listener, options);
    }
  }

  if (typeof EventTarget !== 'undefined') {
    defineProperties(EventTarget.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  } else {
    defineProperties(Node.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  }

  const ShadowTokenKey = '$shadowToken$';
  const ShadowTokenPrivateKey = '$$ShadowTokenKey$$';
  function getShadowToken(node) {
    return node[ShadowTokenKey];
  }
  function setShadowToken(node, shadowToken) {
    node[ShadowTokenKey] = shadowToken;
  }
  defineProperty(Element.prototype, '$shadowToken$', {
    set(shadowToken) {
      const oldShadowToken = this[ShadowTokenPrivateKey];

      if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
        removeAttribute.call(this, oldShadowToken);
      }

      if (!isUndefined(shadowToken)) {
        setAttribute.call(this, shadowToken, '');
      }

      this[ShadowTokenPrivateKey] = shadowToken;
    },

    get() {
      return this[ShadowTokenPrivateKey];
    },

    configurable: true
  });

  const DomManualPrivateKey = '$$DomManualKey$$';

  const DocumentResolverFn = function () {};

  let portalObserver;
  const portalObserverConfig = {
    childList: true
  };

  function adoptChildNode(node, fn, shadowToken) {
    const previousNodeShadowResolver = getShadowRootResolver(node);

    if (previousNodeShadowResolver === fn) {
      return;
    }

    setShadowRootResolver(node, fn);

    if (node instanceof Element) {
      setShadowToken(node, shadowToken);

      if (isHostElement(node)) {
        return;
      }

      if (isUndefined(previousNodeShadowResolver)) {
        MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
      }

      const childNodes = childNodesGetter.call(node);

      for (let i = 0, len = childNodes.length; i < len; i += 1) {
        adoptChildNode(childNodes[i], fn, shadowToken);
      }
    }
  }

  function initPortalObserver() {
    return new MO(mutations => {
      forEach.call(mutations, mutation => {
        const {
          target: elm,
          addedNodes,
          removedNodes
        } = mutation;
        const fn = getShadowRootResolver(elm);
        const shadowToken = getShadowToken(elm);

        for (let i = 0, len = removedNodes.length; i < len; i += 1) {
          const node = removedNodes[i];

          if (!(compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            adoptChildNode(node, DocumentResolverFn, undefined);
          }
        }

        for (let i = 0, len = addedNodes.length; i < len; i += 1) {
          const node = addedNodes[i];

          if (compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            adoptChildNode(node, fn, shadowToken);
          }
        }
      });
    });
  }

  function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
      portalObserver = initPortalObserver();
    }

    if (isUndefined(getShadowRootResolver(elm))) {
      throw new Error(`Invalid Element`);
    }

    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
  }

  defineProperty(Element.prototype, '$domManual$', {
    set(v) {
      this[DomManualPrivateKey] = v;

      if (isTrue$1(v)) {
        markElementAsPortal(this);
      }
    },

    get() {
      return this[DomManualPrivateKey];
    },

    configurable: true
  });
  /** version: 1.1.13-224.5 */

  /**
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */

  const LOADER_SPECIFIER = 'webruntime_loader/loader';

  // Create a dynamic loader "module" that re-exports the dynamic import shim
  //  <script type="webruntime-module" src="<blob url>"></script>
  const loader = `
    const load = window.importShim;
    delete window.importShim;
    export { load };
`;
  const blob = new Blob([loader], { type: 'application/javascript' });
  const loaderScript = document.createElement('script');
  const blobURL = URL.createObjectURL(blob);
  loaderScript.src = blobURL;
  loaderScript.type = 'webruntime-module';
  document.head.prepend(loaderScript);

  // Create a import map that points to the loader blob
  const importMap = {
      imports: {
          [LOADER_SPECIFIER]: blobURL,
      },
  };
  const importMapScript = document.createElement('script');
  importMapScript.type = 'webruntime-importmap';
  importMapScript.innerText = JSON.stringify(importMap);
  document.head.prepend(importMapScript);

}());
