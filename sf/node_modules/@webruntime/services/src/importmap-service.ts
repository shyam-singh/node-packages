/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import {
    AddressableService,
    RequestOutput,
    RequestOutputTypes,
    RequestParams,
    RequestService,
    invariant,
} from '@webruntime/api';
import { Measure } from '@webruntime/performance';
import { importMapMessages as messages } from './messages';
import { closeWatchers, getLatestCachedResourceMap, initWatchers } from './utils';

const IMPORTMAP_SVC_SPECIFIER = 'importmap';
const URI = `/imports/:mode/:locale/importmap.json`;
const DEFAULT_UID = 'latest';

interface ImportMap {
    imports: object;
}

/**
 * The core Importmap Service is responsible for providing an addressable
 * importmap resource (compliant with WICG import-map specification) in
 * the format expected by the client loader.
 */
export class ImportMapService extends AddressableService implements RequestService {
    mappings = {
        [IMPORTMAP_SVC_SPECIFIER]: URI,
    };

    private buildDir: string;
    private basePath: string;
    private uidMap: any = {};
    private uidMapChanged: boolean = false;
    private importMapCache: any = {};

    private updateUIDMap = () => {
        this.uidMap = getLatestCachedResourceMap(this.buildDir);
        this.uidMapChanged = true;
    };

    /**
     * Create an {@link ImportMapService}
     *
     * @param {object} options Constructor options
     * @param {string} options.buildDir Configured build directory
     * @param {string} options.server.baseDir Configured base path
     */
    constructor({ buildDir, server: { basePath } }) {
        super(URI);
        this.buildDir = buildDir;
        this.basePath = basePath;
    }

    /**
     * Initializes the {@link ImportMapService}
     */
    async initialize() {
        initWatchers(this.buildDir, this.updateUIDMap);
        this.updateUIDMap();
    }

    /**
     * Ties into container shutdown lifecycle to perform cleanup.
     * Close watchers that were started via initialize().
     */
    shutdown() {
        closeWatchers();
    }

    /**
     * Implementation of {@link RequestService} `request` API which enables {@link ImportMapService}
     * to handle requests for supported resources as defined by its service `mappings`.
     *
     * @param {string} specifier Specifier for an importmap resource
     * @param {object} options a {@link RequestParams} object
     * @param {object} context a context object provided by the container
     * @param {object} context.metadata metadata provided by the container that includes the current importmap
     *
     * @returns {Promise<RequestOutput>} a promise which resolves to a RequestOutput object including an importmap resource
     */
    @Measure(specifier => `importmap-service:request:${specifier}`)
    async request(specifier: string, options: RequestParams, { metadata }): Promise<RequestOutput> {
        const { mode, locale } = options;
        if (!mode || !locale) {
            return {
                type: RequestOutputTypes.JSON,
                specifier,
                success: false,
                diagnostics: [messages.MISSING_PARAMS],
            };
        }

        // Create new importMap anytime the uid map changes or the cacheKey changes
        const cacheKey = mode + locale;
        if (this.uidMapChanged || !this.importMapCache[cacheKey]) {
            const mapInstance: { [key: string]: any } = {};
            for (const property in metadata.importMap.imports) {
                if ({}.hasOwnProperty.call(metadata.importMap.imports, property)) {
                    // Do not need to create mappings for importmap resources since they are not imported on the client
                    if (property === IMPORTMAP_SVC_SPECIFIER) {
                        continue;
                    }

                    let uid: string;
                    const descriptor = `component://${property}@${locale}`; //TODO consider other resource types
                    if (property.endsWith('/')) {
                        uid = DEFAULT_UID;
                    } else if (this.uidMap[descriptor]) {
                        uid = this.uidMap[descriptor][mode] || DEFAULT_UID;
                    } else {
                        uid = DEFAULT_UID;
                    }
                    // Each URI entry should be prefixed by the server base path
                    mapInstance[property] = `${this.basePath}${replaceAll(
                        metadata.importMap.imports[property],
                        {
                            mode,
                            locale,
                            uid,
                        }
                    )}`;
                }
            }
            const importMap: ImportMap = { imports: packageImportMap(mapInstance) };
            this.importMapCache[cacheKey] = importMap;

            this.uidMapChanged = false;
        }

        return {
            type: RequestOutputTypes.JSON,
            specifier,
            resource: {
                json: this.importMapCache[cacheKey],
            },
            success: true,
            diagnostics: [],
        };
    }

    /**
     * Implementation of {@link AddressableService} `toSpecifier` API which returns the
     * `specifier` for an importmap resource.
     *
     * @returns {string} importmap specifier
     */
    toSpecifier(): string {
        return IMPORTMAP_SVC_SPECIFIER;
    }
}

function replaceAll(str: string, mapObj: any) {
    const re = new RegExp(`:${Object.keys(mapObj).join('|:')}`, 'gi');

    return str.replace(re, function(matched) {
        const name = matched.slice(1);
        return mapObj[name.toLowerCase()];
    });
}

/**
 * Optimize the import map by converting entries into import map packages.
 *
 * @example
 * mapInstance = {
 *  'foo/bar': '/js/123/dev/en_us/foo/bar',
 *  'foo/baz': '/js/latest/dev/en_us/foo/bar',
 *  'foo/bat': '/js/latest/dev/en_us/foo/bat',
 *  'test/': '/some/url/alreadyPackaged/test/',
 *  'test/foo': '/some/other/url/test/foo',
 *  '@salesforce/error/labels/': '/js/en_US/labels',
 *  'wire-service': '/js/components/wire-service'
 * }
 *
 * // foo/baz && foo/bat are "packaged"
 * packagedMapInstance = {
 *  'foo/bar': '/js/123/dev/en_us/foo/bar'
 *  'foo/': '/js/latest/dev/en_us/foo/',
 *  'test/': '/some/url/alreadyPackaged/test/',
 *  'test/foo': '/some/other/url/test/foo',
 *  '@salesforce/error/labels/': '/js/en_US/labels',
 *  'wire-service': '/js/components/wire-service'
 * }
 *
 */
function packageImportMap(mapInstance) {
    const packagedMapInstance = {};
    const namespaceMap = {};
    Object.keys(mapInstance).forEach(specifier => {
        // TODO can namespace have multiple '/'? eg @salesforce/error/labels
        const { namespace, name } = parseNameAndNamespace(specifier);

        invariant(namespace || name, messages.MISSING_NAMES, [specifier]);

        const url = mapInstance[specifier];
        if (!namespace && name) {
            // support non-namespaced like 'wire-service'
            packagedMapInstance[name] = url;
        } else if (!name && namespace.endsWith('/')) {
            invariant(url.endsWith('/'), messages.INVALID_PACKAGE, [specifier]);

            // already a package
            packagedMapInstance[namespace] = url;
        } else if (!url.endsWith(specifier)) {
            // If both name && namespace, but URL does not end with specifier, don't try to package
            packagedMapInstance[specifier] = url;
        } else if (packagedMapInstance[namespace]) {
            // namespace already taken
            packagedMapInstance[specifier] = url;
        } else if (!packagedMapInstance[specifier]) {
            // Count the occurrences of the package URL, grouping them under namespace
            //
            // namespace - 'foo/'
            // packageUrls - '/js/latest/dev/en_us/foo/bar' --> '/js/latest/dev/en_us/foo/'
            const packageUrl = url.slice(0, url.lastIndexOf(name));
            namespaceMap[namespace] = namespaceMap[namespace] || {
                packageUrls: {},
                highCount: { count: 0, packageUrl },
            };
            const currentHighCount = namespaceMap[namespace].highCount.count;

            if (namespaceMap[namespace].packageUrls[packageUrl]) {
                const packageUrlArray = namespaceMap[namespace].packageUrls[packageUrl];
                packageUrlArray.push(name);
                if (packageUrlArray.length > currentHighCount) {
                    namespaceMap[namespace].highCount = {
                        count: packageUrlArray.length,
                        packageUrl,
                    };
                }
            } else {
                namespaceMap[namespace].packageUrls[packageUrl] = [name];
                if (currentHighCount === 0) {
                    namespaceMap[namespace].highCount = {
                        count: 1,
                        packageUrl,
                    };
                }
            }
        }
    });

    Object.keys(namespaceMap).forEach(qualifiedNamespace => {
        const urlMap = namespaceMap[qualifiedNamespace];

        let highCountPackaged = false;
        let { packageUrl: highCountUrl } = urlMap.highCount;

        // Only package the entry if more than one
        if (urlMap.highCount.count > 1) {
            const existingPackageUrl = packagedMapInstance[qualifiedNamespace];
            // Package the high count if there isn't an existing package
            if (!existingPackageUrl || highCountUrl === existingPackageUrl) {
                packagedMapInstance[qualifiedNamespace] = highCountUrl;
                highCountPackaged = true;
            }
        } else {
            highCountPackaged = true;
            highCountUrl = null;
        }

        // Map the rest with the full specifier + full url
        Object.keys(urlMap.packageUrls).forEach(packageUrl => {
            if (!highCountPackaged || packageUrl !== highCountUrl) {
                const names = urlMap.packageUrls[packageUrl];
                names.forEach(name => {
                    packagedMapInstance[`${qualifiedNamespace}${name}`] = packageUrl + name;
                });
            }
        });
    });

    return packagedMapInstance;
}

function parseNameAndNamespace(specifier) {
    const idx = specifier.lastIndexOf('/');
    return {
        namespace: specifier.slice(0, idx + 1),
        name: specifier.slice(idx + 1),
    };
}
