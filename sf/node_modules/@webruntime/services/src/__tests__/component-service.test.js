/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import * as path from 'path';
import { ComponentService } from '../component-service';

jest.mock('@webruntime/compiler', () => {
    const compilerOutput = {
        result: {
            code: 'console.log("hello world");',
            map: {},
            outputConfig: {},
        },
        metadata: {
            dependencies: ['mock/component', 'something/else'],
            dynamicImports: [],
        },
        success: true,
        diagnostics: [
            {
                message: 'foo',
                code: '123',
                filename: 'bar',
                location: 'baz',
                level: 'bae',
            },
        ],
    };
    return {
        compile: jest.fn().mockReturnValue(Promise.resolve(compilerOutput)),
        CompilerResourceMetadata: function(metadata) {
            Object.assign(this, metadata);
        },
        __setDependenciesForTest: value => {
            compilerOutput.metadata.dependencies = value;
        },
    };
});

describe('component-service', () => {
    afterEach(() => {
        jest.clearAllMocks();
    });

    describe('initialize', () => {
        it('should attempt module resolution for installed lwc npm modules', async () => {
            const projectDir = path.join(__dirname, './fixtures/project-deps');
            const componentService = new ComponentService({
                projectDir,
                compilerConfig: {},
            });

            await componentService.initialize();
            expect(componentService.mappings).toMatchSnapshot();
        });

        it('should attempt module resolution for local modules when moduleDir is provided', async () => {
            const projectDir = path.join(__dirname, './fixtures/simple-app');
            const componentService = new ComponentService({
                projectDir,
                moduleDir: 'src/modules',
                compilerConfig: {},
            });

            await componentService.initialize();
            expect(componentService.mappings).toMatchSnapshot();
        });

        it('should not attempt module resolution for local modules if no moduleDir provided', async () => {
            const projectDir = path.join(__dirname, './fixtures/simple-app');
            const componentService = new ComponentService({
                projectDir,
                compilerConfig: {},
            });

            await componentService.initialize();
            expect(componentService.mappings).toMatchSnapshot();
        });
    });

    describe('request', () => {
        let componentService;

        beforeEach(async () => {
            const projectDir = path.join(__dirname, './fixtures/simple-app');
            componentService = new ComponentService({
                projectDir,
                moduleDir: 'src/modules',
                compilerConfig: {},
            });
        });

        const namespace = 'x';
        const name = 'cmp';
        const compilerConfig = {
            files: ['file1', 'file2'],
            baseDir: '/foo',
            format: 'amd',
            //...
        };
        const requestConfig = [
            `${namespace}/${name}`,
            {
                mode: 'dev',
                locale: 'en_US',
            },
            {
                metadata: {
                    /*...*/
                },
                compilerConfig: compilerConfig,
            },
        ];

        it('should compile a resource', async () => {
            const compilerSpy = require('@webruntime/compiler');
            await componentService.initialize();
            await componentService.request(...requestConfig);
            expect(compilerSpy.compile).toHaveBeenCalledTimes(1);
        });

        it('should pass through compilerConfig, namespace, name parameters to compiler', async () => {
            const compilerSpy = require('@webruntime/compiler');
            await componentService.initialize();
            await componentService.request(...requestConfig);
            expect(compilerSpy.compile).toHaveBeenCalledWith({
                ...compilerConfig,
                namespace,
                name,
            });
        });

        it('should obey API contract', async () => {
            await componentService.initialize();
            const result = await componentService.request(...requestConfig);
            expect(result).toMatchSnapshot();
        });

        it('should obey API contract when no dependencies are returned', async () => {
            const compilerSpy = require('@webruntime/compiler');
            compilerSpy.__setDependenciesForTest(undefined);
            await componentService.initialize();
            const result = await componentService.request(...requestConfig);
            expect(result).toMatchSnapshot();
        });

        it('should handle non-namespaced modules', async () => {
            const compilerSpy = require('@webruntime/compiler');
            const requestConfigNonNamespaced = [
                'lwc',
                {
                    mode: 'dev',
                    locale: 'en_US',
                },
                {
                    metadata: {
                        /*...*/
                    },
                    compilerConfig: compilerConfig,
                },
            ];
            await componentService.initialize();
            await componentService.request(...requestConfigNonNamespaced);
            expect(compilerSpy.compile).toHaveBeenCalledWith({
                name: 'lwc',
                namespace: '',
                ...compilerConfig,
            });
        });
    });

    describe('toSpecifier', () => {
        let componentService;

        beforeEach(async () => {
            const projectDir = path.join(__dirname, './fixtures/simple-app');
            componentService = new ComponentService({
                projectDir,
                moduleDir: 'src/modules',
                compilerConfig: {},
            });
            componentService.initialize();
        });

        it('should return specifier from url: 1', () => {
            const specifier = componentService.toSpecifier(
                '/webruntime/component/latest/dev/en_US/mock/component'
            );
            expect(specifier).toBe('mock/component');
        });

        it('should return specifier from url: 2', () => {
            const specifier = componentService.toSpecifier(
                '/webruntime/component/1231231231/dev/en_US/lightning/component'
            );
            expect(specifier).toBe('lightning/component');
        });

        it('should return specifier from url: 3', () => {
            const specifier = componentService.toSpecifier(
                '/webruntime/component/latest/prod/en_ES/mock/component'
            );
            expect(specifier).toBe('mock/component');
        });

        it('should return specifier from url: 4', () => {
            const specifier = componentService.toSpecifier(
                '/webruntime/component/9999999999/compat/en_ES/namespace/name'
            );
            expect(specifier).toBe('namespace/name');
        });

        it('should return specifier from url without namespace', () => {
            const specifier = componentService.toSpecifier(
                '/webruntime/component/8080808080/compat/en_US/name'
            );
            expect(specifier).toBe('name');
        });
    });
});
