"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @hidden */
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const api_1 = require("@webruntime/api");
const performance_1 = require("@webruntime/performance");
const framework_resources_1 = __importDefault(require("../container/framework-resources"));
const messages_1 = require("../utils/messages");
const utils_1 = require("../utils/utils");
const resourceSetCache = {};
/**
 * Generates an ordered list of bootstrap resources required to bootstrap the given specifier:
 *
 * eg: BootstrapResourceList = {
 *  specifier: "webruntime/app",
 *  resources: [
 *  {
 *      .. header styles ..
 *  },
 *  {
 *      specifier: "framework://webruntime"
 *      type: "text/javascript",
 *      path: "/js/webruntime/dev/uid/webruntime.js"
 *  },
 *  {
 *      specifier: "importmap",
 *      type: "webruntime-importmap",
 *      path: "/js/webruntime/dev/",
 *      code: "{
 *          imports: {
 *              "webruntime/app": "/path/to/service"
 *          }
 *      }"
 *  },
 *  {
 *      .. scripts ..
 *  },
 *  {
 *      specifier: "force/lds",
 *      type: "webruntime-module",
 *      path: "/js/components/dev/latest/en_US/force/lds"
 *  },
 *  {
 *      specifier: "@webruntime/bootstrap",
 *      type: "webruntime-module",
 *      path: "/js/components/dev/latest/en_US/webruntime/appinjector"
 *   }
 *  ]
 * }
 *
 */
async function generate(specifier, pivots, container, config, page) {
    const measure = performance_1.startMeasure(`bootstrap-resource-generator:generate:${specifier}`);
    const baseResources = await getBaseBootstrapResourceSet(specifier, pivots, container, config);
    const styleResources = page && page.experimental_styles ? getStyleResources(page) : [];
    const scriptResources = page && page.experimental_scripts ? getScriptResources(page) : [];
    /**
     * Resource Order Matters!
     *
     */
    const bootstrapResources = {
        specifier: baseResources.specifier,
        resources: 
        // Phase 0: Custom Page Styles
        styleResources
            // Phase 1: Framework Resources (eg: webruntime-shim)
            .concat(baseResources.frameworkResources)
            // Phase 2: Custom Page Scripts (from experimental_scripts)
            .concat(scriptResources)
            // Phase 3: Import Map Resource
            .concat(baseResources.importMapsResources)
            // Phase 4: Get resource list of app config preloadModules
            .concat(baseResources.configExternalResources)
            // Phase 5: Get resource list for the given app specifier
            .concat(baseResources.componentResources),
    };
    performance_1.endMeasure(measure);
    return bootstrapResources;
}
exports.generate = generate;
async function getBaseBootstrapResourceSet(specifier, pivots, container, config) {
    const { buildDir, server: { basePath }, } = config;
    const versionKey = utils_1.getLatestVersion(buildDir);
    const cacheKey = JSON.stringify({ pivots, specifier, versionKey });
    const importMap = await getImportMaps(pivots, container);
    const importMapsResource = getImportMapsResource(importMap);
    const usingNativeModules = container.isUsingExperimentalModules();
    if (!resourceSetCache[cacheKey]) {
        const frameworkResource = getFrameworkResources(basePath, pivots.mode, usingNativeModules);
        const configExternalResources = await getConfigExternalResources(pivots, container, config, usingNativeModules);
        const componentResources = await getComponentResources(specifier, pivots, container, config, usingNativeModules);
        const resourceSet = {
            specifier: specifier,
            frameworkResources: frameworkResource,
            importMapsResources: importMapsResource,
            configExternalResources: configExternalResources,
            componentResources: componentResources,
        };
        // eslint-disable-next-line require-atomic-updates
        resourceSetCache[cacheKey] = resourceSet;
    }
    else {
        resourceSetCache[cacheKey].importMapsResources = importMapsResource;
    }
    // add paths to each preloaded and component resource
    const resources = resourceSetCache[cacheKey];
    const createUrlPath = resource => {
        const useImportURL = !usingNativeModules && resource.type === 'webruntime-module';
        // es-modules-shim doesn't support import:urls yet, so use the actual url
        resource.path = useImportURL
            ? `import:${resource.specifier}`
            : getSpecifierUrl(resource.specifier, importMap);
    };
    resources.configExternalResources.forEach(createUrlPath);
    resources.componentResources.forEach(createUrlPath);
    return resourceSetCache[cacheKey];
}
function getSpecifierUrl(specifier, importMap) {
    if (importMap.imports[specifier]) {
        return importMap.imports[specifier];
    }
    const [namespace, name] = specifier.split('/');
    const packagedPath = importMap.imports[`${namespace}/`];
    if (packagedPath) {
        return packagedPath + name;
    }
    throw new Error(api_1.generateMessage(messages_1.bootstrapMessages.UNMAPPED_SPECIFIER, [specifier]));
}
function normalizeResourceType(resource) {
    if (Object.prototype.toString.call(resource) === '[object String]') {
        return [resource];
    }
    return resource;
}
function getStyleResources(page) {
    const styles = normalizeResourceType(page.experimental_styles);
    return styles.map(style => {
        const styleType = Object.prototype.toString.call(style);
        if (styleType === '[object Object]') {
            const href = style.href;
            const code = style.code;
            // href XOR code
            api_1.invariant(!href !== !code, messages_1.bootstrapMessages.INVALID_STYLE_PROPS, [JSON.stringify(style)]);
            const styleResource = {
                type: 'text/css',
                specifier: 'style',
            };
            const media = style.media;
            if (media) {
                styleResource.media = media;
            }
            if (href) {
                // Generate import style
                styleResource.path = href;
                return styleResource;
            }
            if (code) {
                // Generate inline style
                styleResource.code = code;
                return styleResource;
            }
        }
        if (styleType === '[object String]') {
            // Generate inline script
            return {
                type: 'text/css',
                specifier: 'style',
                media: style.media,
                code: style,
            };
        }
        throw new Error(api_1.generateMessage(messages_1.bootstrapMessages.INVALID_STYLE));
    });
}
/**
 * Retrieve static framework resources
 */
function getFrameworkResources(basePath, mode, usingNativeModules) {
    const descriptor = usingNativeModules
        ? 'framework://webruntime-es-shim'
        : 'framework://webruntime-amd-shim';
    const staticResource = framework_resources_1.default(descriptor);
    const uri = staticResource.modes[mode];
    const resources = [
        {
            type: 'text/javascript',
            path: basePath + uri,
            attributes: usingNativeModules ? ['defer'] : undefined,
            specifier: staticResource.descriptor,
        },
    ];
    return resources;
}
async function getImportMaps(pivots, container) {
    const { results } = await container.build('importmap', pivots);
    const importMapResult = results && results[0];
    api_1.invariant(importMapResult && importMapResult.resource, messages_1.bootstrapMessages.COMPILE_FAILED);
    const { json } = importMapResult.resource;
    return json;
}
function getImportMapsResource(importMap) {
    const importMapResource = {
        specifier: 'importmap',
        type: 'webruntime-importmap',
    };
    importMapResource.code = JSON.stringify(importMap);
    return [importMapResource];
}
function getScriptResources(page) {
    const scripts = normalizeResourceType(page.experimental_scripts);
    return scripts.map(script => {
        const scriptType = Object.prototype.toString.call(script);
        if (scriptType === '[object Object]') {
            const href = script.href;
            const code = script.code;
            // href XOR code
            api_1.invariant(!href !== !code, messages_1.bootstrapMessages.INVALID_SCRIPT_PROPS, [JSON.stringify(script)]);
            if (href) {
                // Generate import script
                return {
                    type: 'text/javascript',
                    path: href,
                    specifier: 'script',
                };
            }
            if (code) {
                // Generate inline script
                return {
                    type: 'text/javascript',
                    code: code,
                    specifier: 'script',
                };
            }
        }
        if (scriptType === '[object String]') {
            // Generate inline script
            return {
                type: 'text/javascript',
                code: script,
                specifier: 'script',
            };
        }
        throw new Error(api_1.generateMessage(messages_1.bootstrapMessages.INVALID_SCRIPT));
    });
}
async function getConfigExternalResources(pivots, container, config, usingNativeModules) {
    // eg ['force/lds', 'some/lwc']
    const { preloadModules } = config;
    const externalsResources = await Promise.all(preloadModules.map(externalSpecifier => getComponentResources(externalSpecifier, pivots, container, config, usingNativeModules)));
    // flatten
    return externalsResources.reduce((accumulator, value) => accumulator.concat(value), []);
}
/**
 * Given an entry module, generate the list of bootstrap dependencies
 *
 * @param entrySpecifier
 * @param pivots
 * @param container
 * @param config
 */
async function getComponentResources(entrySpecifier, pivots, container, config, usingNativeModules) {
    const bootstrapDependencies = await getBootstrapDependencies(entrySpecifier, container, config, pivots, {});
    bootstrapDependencies.push(entrySpecifier);
    // add entry specifier and its dependencies as regular script tags
    // this preloads and parses the code achieving parallel downloads
    const bootstrapResources = bootstrapDependencies.map(specifier => {
        return {
            specifier,
            type: 'text/javascript',
            useLinkPreload: usingNativeModules,
        };
    });
    // entry module (eg: @webruntime/app) is executed with type="module"
    bootstrapResources.push({
        specifier: entrySpecifier,
        type: 'webruntime-module',
        useLinkPreload: false,
    });
    return bootstrapResources;
}
async function getBootstrapDependencies(entrySpecifier, container, config, pivots, alreadyIncluded) {
    const resourceBundle = await container.build(entrySpecifier, pivots);
    // Loop on the resource bundle, collecting external dependencies.
    // External dependencies are dependencies that are NOT inlined OR bundled.
    const externalDeps = new Map();
    for (let i = resourceBundle.results.length - 1; i >= 0; i--) {
        const { specifier, metadata } = resourceBundle.results[i];
        // All resource bundle specifiers are already included
        alreadyIncluded[specifier] = true;
        // Remove resource specifiers from the external dependency list
        if (externalDeps.get(specifier)) {
            externalDeps.delete(specifier);
        }
        // Add all resource dependencies as possibly external
        if (metadata) {
            metadata.dependencies.forEach(dep => {
                externalDeps.set(dep, true);
            });
        }
        // TODO do something with metadata.dynamicImports,
    }
    const deps = [];
    for (const specifier of externalDeps.keys()) {
        if (!alreadyIncluded[specifier] && !isExternal(specifier, container, config)) {
            alreadyIncluded[specifier] = true;
            deps.push({
                specifier,
                depsPromise: getBootstrapDependencies(specifier, container, config, pivots, alreadyIncluded),
            });
        }
    }
    const nestedDeps = await Promise.all(deps.map(o => o.depsPromise));
    let dependencies = [];
    for (let i = 0; i < nestedDeps.length; i++) {
        dependencies.push(deps[i].specifier);
        if (nestedDeps[i].length) {
            dependencies = dependencies.concat(nestedDeps[i]);
        }
    }
    return dependencies;
}
function isExternal(specifier, container, config) {
    if (container.isAppExternal(specifier)) {
        return true;
    }
    const { preloadModules } = config;
    return preloadModules && preloadModules.length && preloadModules.indexOf(specifier) >= 0
        ? true
        : false;
}
//# sourceMappingURL=bootstrap-resource-generator.js.map