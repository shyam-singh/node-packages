"use strict";
/** @hidden */
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const stream_1 = __importDefault(require("stream"));
const util_1 = require("util");
const path = __importStar(require("path"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const folder_hash_1 = require("folder-hash");
const chokidar_1 = __importDefault(require("chokidar"));
const api_1 = require("@webruntime/api");
const messages_1 = require("./messages");
const { log } = console;
const RESOURCES_FILE = 'resources.json';
const METADATA_FILE = 'metadata.json';
let latestVersion;
let versionWatcher;
function loadUids(outputDir) {
    const file = `${outputDir}/${RESOURCES_FILE}`;
    return fs_1.default.existsSync(file) ? JSON.parse(fs_1.default.readFileSync(file, 'utf8')) : {};
}
function appendUids(outputDir, { versionKey, descriptor, mode, uid }) {
    const resources = loadUids(outputDir);
    resources[versionKey] = resources[versionKey] || {};
    //TODO consider merge here
    resources[versionKey][descriptor] = resources[versionKey][descriptor] || {};
    resources[versionKey][descriptor][mode] = uid;
    const file = `${outputDir}/${RESOURCES_FILE}`;
    fs_1.default.writeFileSync(file, JSON.stringify(resources, null, 4));
}
async function createVersionHash(sourcePath, buildDir, projectDir) {
    const sourceHashResult = await folder_hash_1.hashElement(sourcePath, { algo: 'md5', encoding: 'hex' });
    const configHashResult = await folder_hash_1.hashElement(projectDir, {
        algo: 'md5',
        encoding: 'hex',
        files: { include: [api_1.WEBRUNTIME_APP_CONFIG_JS_FILENAME] },
    });
    const version = crypto_1.default
        .createHash('md5')
        .update(sourceHashResult.hash + configHashResult.hash)
        .digest('hex')
        .substring(0, 10);
    log(api_1.generateMessage(messages_1.versionMessages.CREATE_HASH, [version]));
    const outputFile = path.resolve(buildDir, METADATA_FILE);
    mkdirp_1.default.sync(path.dirname(outputFile));
    fs_1.default.writeFileSync(outputFile, JSON.stringify({ latest: version }), { encoding: 'utf8' });
    return version;
}
function getLatestVersion(buildDir) {
    if (latestVersion) {
        return latestVersion;
    }
    const file = path.join(buildDir, METADATA_FILE);
    const contents = fs_1.default.existsSync(file) ? JSON.parse(fs_1.default.readFileSync(file, 'utf8')) : {};
    return contents.latest || undefined;
}
exports.getLatestVersion = getLatestVersion;
async function startVersionWatch(config) {
    const sourcePath = path.resolve(config.projectDir, config.moduleDir);
    versionWatcher = chokidar_1.default.watch(sourcePath).on('change', async () => {
        latestVersion = await createVersionHash(sourcePath, config.buildDir, config.projectDir);
    });
    latestVersion = await createVersionHash(sourcePath, config.buildDir, config.projectDir);
}
exports.startVersionWatch = startVersionWatch;
async function stopVersionWatch() {
    if (versionWatcher) {
        await versionWatcher.close();
    }
}
exports.stopVersionWatch = stopVersionWatch;
/**
 * Writes resources to the filesystem.
 */
async function writeToOutputDir({ buildDir, mode, locale, bundle }) {
    const { uid, specifier, path: url } = bundle;
    const descriptor = `component://${specifier}@${locale}`;
    let outputFilePath = url;
    if (!url.match(/\.\w+$/)) {
        outputFilePath = `${url}.js`;
    }
    const outputFile = path.join(buildDir, outputFilePath);
    // create output dir
    mkdirp_1.default.sync(path.dirname(outputFile));
    // write the resource to disk
    log(api_1.generateMessage(messages_1.versionMessages.WRITE_FILE, [outputFile]));
    const pipeline = util_1.promisify(stream_1.default.pipeline);
    const write = fs_1.default.createWriteStream(outputFile);
    await pipeline(bundle.getReadableStream(), write);
    // add this resource uids to the map resources.json file in the output dir
    appendUids(buildDir, { versionKey: latestVersion, descriptor, mode, uid });
}
exports.writeToOutputDir = writeToOutputDir;
//# sourceMappingURL=utils.js.map