/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { LightningElement, api } from 'lwc';
import { createNavigationContext } from 'webruntime_navigation/navigationService';

/*
 * Provides a LWC router component. These can be nested and all report to the root router.
 * This cannot extend Router because it must extend LightningElement to be a LWC.
 */

export default class ChildRouter extends LightningElement {
    // Instance of the Router class for this LWC.
    router;

    /**
     * The configuration for the router is passed in from the owner component.
     * {
     *  `routes`: object[],
     *  `basePath`: string,
     *  `noHistory`: boolean,
     *  `caseSensitive`: boolean
     * }
     */
    @api routes;
    @api basePath;
    @api noHistory = false;
    @api caseSensitive = false;

    /**
     * Create a router attached to this component.
     */
    connectedCallback() {
        const config = {
            routes: this.routes,
            basePath: this.basePath,
            noHistory: this.noHistory,
            caseSensitive: this.caseSensitive,
            handleNavigation: this.handleNavigation.bind(this),
        };

        // Create the router.
        this.router = createNavigationContext(this, config);

        // Convert hook APIs into DOM events.
        // The events bubble and are composed (can exit this shadow DOM)
        //      BUT the webruntime-router-setid component stops propagation.
        this.router
            .addPreNavigate(this.preNavigate.bind(this))
            .addPostNavigate(this.postNavigate.bind(this))
            .addErrorNavigate(this.errorNavigate.bind(this))

            // Connect the router.
            .connect();
    }

    /**
     * The preNavigate hook surfaced as a cancelable CustomEvent.
     * @param {object} - transaction, ie:
     * {
     *  `current`: The navigation information `{ route, data }` for the current state, route may be `null`
     *  `next`: The navigation information that will load next (if not stopped)
     * }
     */
    preNavigate(transaction) {
        const event = new CustomEvent('prenavigate', {
            detail: transaction,
            bubbles: true,
            composed: true,
            cancelable: true,
        });
        this.dispatchEvent(event);
        return !event.defaultPrevented;
    }

    /**
     * The postNavigate hook surfaced as a CustomEvent.
     * @param {object} - transaction, ie:
     * {
     *  `current`: The navigation information `{ route, data }` for the current state
     *  `previous`: The navigation information that just unloaded, route may be `null`
     * }
     */
    postNavigate(transaction) {
        this.dispatchEvent(
            new CustomEvent('postnavigate', {
                detail: transaction,
                bubbles: true,
                composed: true,
            })
        );
    }

    /**
     * The errorNavigate hook surfaced as a CustomEvent.
     * @param {object} - error, ie:
     * {
     *  `code`: an integer error code
     *  `message`: a string error message
     *  `level`: 'Error'
     *  `url`: an optional URL where more information on the error can be found
     * }
     */
    errorNavigate(error) {
        this.dispatchEvent(
            new CustomEvent('errornavigate', {
                detail: error,
                bubbles: true,
                composed: true,
            })
        );
    }

    /**
     * The preNavigate hook surfaced as a cancelable CustomEvent.
     * @param {object | string} - input: The route or path being navigated
     * @param {boolean} - shouldReplace
     */
    handleNavigation(input, shouldReplace) {
        const event = new CustomEvent('handlenavigation', {
            detail: {
                input,
                shouldReplace,
            },
            bubbles: true,
            composed: true,
            cancelable: true,
        });
        this.dispatchEvent(event);
        return !event.defaultPrevented;
    }

    /**
     * Disconnect the router after DOM removal.
     */
    disconnectedCallback() {
        if (this.router) {
            this.router.disconnect();
        }
    }
}
