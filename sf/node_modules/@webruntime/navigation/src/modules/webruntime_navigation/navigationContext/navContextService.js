/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { guid, invariant, isObject, messages } from 'webruntime_navigation/utils';
import { LinkContextEvent } from 'wire-service';

/**
 * Provides the ability for a given DOM node to find its closest ancestor to provide navigation services.
 *
 * This is based on the referral implementations from the LWC team.
 *
 * Providers share the same ID value with every consumer over the wire.
 */

// Unique event fired to find the closest ancestor navigation context.
const NAV_CONTEXT_EVENT = `universalcontainercontextevent${guid()}`;

// Keep a cache of context metadata, with their IDs as keys:
//    id => {
//              id,
//              value: { navigate(), generateUrl(), subscribe() },
//              update(value),
//          }
const CACHE = new WeakMap();

/**
 * Return a navigation context ID by DOM node.
 * This is used by areas of code that cannot use the official NavigationContext wire adapter (eg: mixins, other wires)
 * Exported API.
 *
 * @param {HTMLElement} node - The node from which to search for a context
 * @param {boolean} isWired - True if the event is being dispatched from a wire target
 *
 * @return {object} - Navigation context ID
 */
export function getNavigationContextId(node = window, isWired) {
    let id;
    const callback = value => {
        id = value;
    };

    // Fire the event from the given node, with a callback function as a payload.
    // A LinkContextEvent must be fired from wire adapters, otherwise it is blocked.
    // These events are fired synchronously.
    node.dispatchEvent(
        isWired
            ? new LinkContextEvent(NAV_CONTEXT_EVENT, callback)
            : new CustomEvent(NAV_CONTEXT_EVENT, {
                  bubbles: true,
                  composed: true,
                  detail: callback,
              })
    );
    return id;
}

/**
 * Return a navigation context by ID.
 * Exported API.
 *
 * @param {*} id - The ID of a navigation context.
 *
 * @return {object} - { navigate(), generateUrl(), subscribe() }
 */
export function getNavigationContext(id) {
    const metadata = CACHE.get(id);
    invariant(metadata && metadata.value, messages.MISSING_CONTEXT);
    return metadata.value;
}

/**
 * Return navigation data by ID.
 *
 * @param {*} id - The ID of a navigation context.
 *
 * @return {RouteDefinition[]}
 */
export function getNavigationData(id) {
    const metadata = CACHE.get(id);
    invariant(metadata && metadata.data, messages.MISSING_DATA_CONTEXT);
    return metadata.data;
}

/**
 * Ensure the context is undefined OR provides an API value in the correct shape:
 *                  {
 *                      navigate: Function,
 *                      generateUrl: Function,
 *                      subscribe: Function
 *                  }
 *
 * @param {*} context - Object to check
 *
 * @return {object} - A valid context
 */
function validateContext(context) {
    invariant(
        context === undefined ||
            (isObject(context) &&
                typeof context.navigate === 'function' &&
                typeof context.generateUrl === 'function' &&
                typeof context.subscribe === 'function' &&
                Object.keys(context).length === 3),
        messages.INVALID_CONTEXT
    );
    return context;
}

/**
 * Create and return the metadata for this context provider.
 * Cache the metadata by ID.
 *
 * @param {object} contextValue - Context API object
 * @param {RouteDefinition[]} data - Route data for this context
 *
 * @return {object} - The metadata object
 */
function createContextData(contextValue, data) {
    const metadata = {
        // ID must be an object that can't be proxified otherwise we lose it when tracking the value.
        id: Object.freeze(() => {}),
        value: validateContext(contextValue),
        data: data || [],
        update: newValue => {
            metadata.value = validateContext(newValue);
        },
    };

    // Cache and return.
    CACHE.set(metadata.id, metadata);
    return metadata;
}

/**
 *
 * @param {object} contextValue - Context API object
 * @param {HTMLElement} providerNode - Context DOM element
 * @param {RouteDefinition[]} data - Route data for this context
 */
export function provideContext(contextValue, providerNode, data) {
    // Set up this context provider in the cache.
    const contextData = createContextData(contextValue, data);

    // Add a listener to the node for context consumers to find it.
    const eventListener = event => {
        // This event must have a full stop when it is intercepted by a provider.
        event.stopImmediatePropagation();

        // The new consumer provides a callback as a communication channel (see wire above).
        // Emit the context ID over the wire.
        event.detail(contextData.id);
    };
    providerNode.addEventListener(NAV_CONTEXT_EVENT, eventListener);

    // Return functions to:
    //      1. update the context API value
    //      2. disconnect from being a context provider for new consumers
    return {
        id: contextData.id,
        update: contextData.update,
        disconnect: () => providerNode.removeEventListener(NAV_CONTEXT_EVENT, eventListener),
    };
}
