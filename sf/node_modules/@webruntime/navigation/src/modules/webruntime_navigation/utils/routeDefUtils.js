/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { decode } from './uriUtils';
import { isObject } from './typeUtils';

/* A Route Definition is in this form:
    {
        // required data
        "path": "/case/:recordId",

        // Basic routing
        "id": "case-detail",

        // lightning/navigation
        "page": {
            "type": "standard__recordPage",
            "attributes": {
                "objectApiName": "Case"
            }
        },

        // custom data
        "view": "caseDetail"
        "label": "Case Detail"
    }
*/

/**
 * f(route, routes[]) -> RouteDef
 * Match a route's id to a Route Definition id from the given list.
 *
 * @param {object} route - Route to match to a Route Definition
 * @param {array[object]} routeDefs - List of Route Definitions to match to the url
 *
 * @returns {object | null}
 */
export function getRouteDefFromRoute(route = {}, routeDefs = []) {
    const { id: routeId, type: routeType, attributes: routeAttrs = {} } = route;

    // MATCH BY ID, FOR ROUTES:
    // Go through all route definitions to find a match for the given route:
    //      - a route def id = the route id
    //      - each parameter in the route def path must exist as a key in the route attributes
    if (routeId) {
        return (
            routeDefs.find(({ params = [], original: { id } }) => {
                return (
                    id === routeId &&
                    params.every(
                        p =>
                            p.modifier === '?' ||
                            Object.prototype.hasOwnProperty.call(routeAttrs, p.name)
                    )
                );
            }) || null
        );
    }

    // MATCH BY TYPE/ATTRIBUTES, to find a match:
    //      - a route def page type = the route type
    //      - each non-optional parameter in the route def path must exist as a key in the route attributes
    //      - each attribute in the route def page must match an attribute in the route
    //      - if more than 1 route def matches the route, choose the first match
    if (routeType) {
        // Locate all matches.
        const matches = routeDefs.filter(
            ({ params = [], original: { page: { type, attributes: pageAttrs = {} } = {} } }) => {
                return (
                    type === routeType &&
                    params.every(
                        p =>
                            p.modifier === '?' ||
                            Object.prototype.hasOwnProperty.call(routeAttrs, p.name)
                    ) &&
                    Object.keys(pageAttrs).every(key => pageAttrs[key] === routeAttrs[key])
                );
            }
        );

        // Return the first match.
        return matches.length > 0 ? matches[0] : null;
    }

    // NO MATCH:
    return null;
}

/**
 * f(path, routeDef) -> { "attr1": "one", "attr2": "two" }
 * Parse a path into an object of attributes based on the Route Definition's parameterized path.
 * URI decode the path parts that are parsed as attributes.
 *
 * @param {string} path - A path (hopefully) matching the Route Definition
 * @param {object} routeDef - Route Definition containing the path to parameterize
 *
 * @returns {object}
 */
export function getAttributesFromPathAndRouteDef(path, routeDef) {
    const attrs = {};
    if (path && routeDef) {
        // Split the path and the Route Definition path into their parts.
        let pathParts = routeDef.regex.exec(path);
        if (pathParts) {
            pathParts = pathParts.slice(1); // Remove full match string at index 0.
            const routeParts = routeDef.params;

            // For each Route Definition parameter, add an entry to the return object:
            //      { [route def parameter]: path part at matching index }
            routeParts.forEach((part, index) => {
                if (pathParts[index]) {
                    attrs[part.name] = decode(pathParts[index]);
                }
            });
        }

        // Add routeDef.page.attributes to the return object to create a complete page reference.
        if (routeDef.original.page && isObject(routeDef.original.page.attributes)) {
            Object.assign(attrs, routeDef.original.page.attributes);
        }
    }
    return attrs;
}
