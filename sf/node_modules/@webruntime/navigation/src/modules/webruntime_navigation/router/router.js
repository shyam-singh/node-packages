/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { provideContext } from 'webruntime_navigation/navigationContext';
import NavNode from 'webruntime_navigation/navNode';
import {
    createFilterChain,
    createObservable,
    freeze,
    generateMessageObject,
    getPathFromUrl,
    getRelativeUrl,
    getRouteFromUrl,
    getUrlFromRoute,
    invariant,
    isSimpleRoute,
    messages,
} from 'webruntime_navigation/utils';
// reference to a built file
// eslint-disable-next-line import/no-unresolved
import { default as pathToRegexp } from './pathToRegexp';
export { pathToRegexp };

/*
 * Provides a Router class. Extended by the HistoryRouter and composed by the child-router LWCs.
 * Pass in these properties to the constructor for customizing the router:
 *      - basePath
 *      - routes[]
 *      - node
 *      - caseSensitive
 * And optionally provide overrides for these methods:
 *      - handleNavigation(url | route, options)
 *      - getRouteFromUrl(url)
 *      - getUrlFromRoute(route)
 * And add hook listeners with:
 *      - addPreNavigate(function || [function, function, ...])
 *      - addPostNavigate(function || [function, function, ...])
 * The NavigationMixin and CurrentPageReference functionality is automatically handled/provided.
 */

export default class Router extends NavNode {
    // Relative base path for this router.
    basePath = '';

    // An array to hold all registered Route Definitions.
    routes = [];

    // When true the path matching will be case sensitive.
    caseSensitive = false;

    /** START: Internal navigation state variables */
    // The current matching path for this router, used by child to create its full ancestor base path (parent path match + base path).
    pathMatch = '';

    // The current matching info object: { route, data }. Used to hydrate navigation hook listeners.
    infoMatch = null;

    // Keep track of the last URL that was successfully processed. It is used to initialize lazily attached children.
    currentUrl = null;
    /** END: Internal navigation state variables */

    // Create an Observer to hold the current route and data.
    routeObservable = createObservable();

    // Create filter chains for the pre and post hooks.
    preFilters = createFilterChain();
    postFilters = createFilterChain();
    errorFilters = createFilterChain();

    /**
     * Create and configure the Router.
     *
     * @param {object} c - The router config object, all properties are optional
     * @param {string} c.basePath - This router's base path
     * @param {object[]} c.routes - Array of route definitions
     * @param {boolean} c.caseSensitive - True if path matching should be case sensitive
     * @param {function} c.handleNavigation - handleNavigation event handler override
     * @param {function} c.getRouteFromUrl - route => URL translation override
     * @param {function} c.getUrlFromRoute - URL => route translation override
     * @param {HTMLElement} node - DOM node to attach to
     */
    constructor(c = {}, node = window) {
        super(node);
        this.basePath = c.basePath || '';
        this.caseSensitive = c.caseSensitive === true ? true : false;
        this.parseRouteDefinitions(c.routes || []);

        // The translation layer overrides get the default implementation passed in.
        // Pass getRouteFromUrl() into custom handleNavigation functions.
        this.getRouteFromUrl = this._fallback(
            c.getRouteFromUrl,
            this.defaultGetRouteFromUrl,
            this.defaultGetRouteFromUrl.bind(this)
        );
        this.getUrlFromRoute = this._fallback(
            c.getUrlFromRoute,
            this.defaultGetUrlFromRoute,
            this.defaultGetUrlFromRoute.bind(this)
        );
        this.handleEvent = this._fallback(
            c.handleNavigation,
            () => true,
            this.getRouteFromUrl.bind(this)
        );
    }

    /**
     * Parse the route definitions with path-to-regex functionality.
     *
     * @param {object[]} routeDefs - Array of route definitions
     * @example
     * {
     *      original: the user-defined route definition
     *      regex: regular expression based on the route definition path
     *      toPath: function which takes an object of parameters and creates a path
     *      params: an array of objects with info on each path parameter
     * }
     */
    parseRouteDefinitions(routeDefs) {
        this.routes = routeDefs.map(def => {
            invariant(def.path, messages.MISSING_PATH);
            const params = [];
            const regex = pathToRegexp.pathToRegexp(def.path, params, {
                sensitive: this.caseSensitive,
                // True if this is a leaf route, and must match URLs exactly with no trailing segments.
                end: def.exact === false ? false : true,
            });
            const toPath = pathToRegexp.compile(def.path, { encode: encodeURIComponent });
            return { original: def, regex, params, toPath };
        });
    }

    /***** Lifecycle *****/

    /**
     * Override to provide this router as a navigation context.
     */
    connect() {
        super.connect();
        this.contextConnection = provideContext(
            {
                navigate: (input, options) => this.navigate(input, options),
                generateUrl: route => this.generateUrl(route),
                subscribe: (callback, replay) => this.subscribe(callback, replay),
            },
            this.node,
            this.routes.map(r => r.original)
        );
    }

    /**
     * Override to remove this router as a navigation context.
     */
    disconnect() {
        super.disconnect();
        if (this.contextConnection) {
            this.contextConnection.update(undefined);
            this.contextConnection.disconnect();
        }
    }

    /**
     * Add listeners to this router hook which run BEFORE a new URL is processed (root -> leaf).
     *
     * @param {object | object[]} filters
     */
    addPreNavigate(filters) {
        this.preFilters.add(filters);
    }

    /**
     * Add listeners to this router hook which run AFTER a new URL has been processed (root -> leaf).
     *
     * @param {object | object[]} filters
     */
    addPostNavigate(filters) {
        this.postFilters.add(filters);
    }

    /**
     * Add listeners to this router hook which run when there is an error navigating.
     *
     * @param {object | object[]} filters
     */
    addErrorNavigate(filters) {
        this.errorFilters.add(filters);
    }

    /***** URL <=> route translation default implementation *****/

    /**
     * This URL path prefix = parent path match + this base path.
     *
     * @returns {string}
     */
    get prefix() {
        return `${this.parent ? this.parent.pathMatch : ''}${this.basePath}`;
    }

    /**
     * Default implementation: f(URL) -> { route: route, data: routeDef }
     * Remove the base URL before conversion.
     *
     * @param {string} url
     *
     * @returns {object} - { object: route, object: data }
     */
    defaultGetRouteFromUrl(url) {
        // Process relative URLs (i.e.: remove any http*://*.*)
        url = getRelativeUrl(url);

        // The URL must start with the prefix to be eligible to match to a route definition.
        // If the prefix is not found, pass in [] for the route definitions -> fall back to a Simple Route.
        const hasPrefix = url.indexOf(this.prefix) === 0;

        // Pass in the rest of the URL for matching, without the prefix.
        const info = getRouteFromUrl(
            hasPrefix ? url.replace(this.prefix, '') : url,
            hasPrefix ? this.routes : []
        );

        // If the prefix was stripped off of a Simple Route, add it back on, so the path is absolute.
        const { route } = info;
        if (hasPrefix && isSimpleRoute(route)) {
            route.attributes.path = `${this.prefix}${route.attributes.path}`;
        }
        return { route: route, data: info.data };
    }

    /**
     * Default implementation: f(route) -> { url: url || null, data: routeDef }
     * Prefix the result with the parent's match and this router's base path, to return a full URL.
     *
     * @param {object} route - Route to translate into a URL
     *
     * @returns {object} - { string: url, object: data }
     */
    defaultGetUrlFromRoute(route) {
        // If the route is Simple, the URL is absolute, so do not add the prefix.
        const prefix = isSimpleRoute(route) ? '' : this.prefix;
        const info = getUrlFromRoute(route, this.routes);
        return { url: info.url ? `${prefix}${info.url}` : null, data: info.data };
    }

    /***** State change processing *****/

    /**
     * Override parent implementation.
     * Pass the current state down to any new children.
     *
     * @param {child} child - Child router
     */
    async addChild(child) {
        super.addChild(child);
        if (this.currentUrl && (await child.preProcess(this.currentUrl))) {
            child.process(this.currentUrl);
        }
    }

    /**
     * Process the current URL passed down by the parent router.
     * Stop propagation of the navigation event if any preNavigate filter returns false.
     *
     * Update the current path and route matches.
     * Update the observable to hold the new route.
     *
     * After processing, delegate to a child router, if it exists.
     *
     * @param {string} url - Relative URL string to process
     * @param {*} options - Navigation options (e.g. shouldReplace)
     *
     * @returns {boolean} - True if the processing was NOT blocked by a preNavigate listener
     */
    async process(url, options) {
        const info = freeze(this.getRouteFromUrl(url));
        const route = freeze(info.route);

        // Run the root -> leaf chain of pre navigate filters, if this is the root.
        const canContinue = !this.isRoot || (await this.preProcess(url, info));
        if (canContinue.message) {
            // If the pre navigate filters failed, an error message object is returned.
            // Pass the errors, and return.
            this.processError(canContinue);
            return false;
        }

        // Wait for post navigation processing, then hydrate the observables.
        await this.postFilters.compile({ previous: this.infoMatch, current: info });
        this.infoMatch = info;
        this.currentUrl = url;
        this.routeObservable.next(route, freeze(info.data));

        // Delegate to a child.
        if (this.child) {
            this.child.process(url, options);
        }
        return true;
    }

    /**
     * Run the preNavigate filters for this router.
     * After processing, delegate to a child router, if it exists.
     *
     * @param {string} url - Relative URL string to process,
     *                   cannot use a route since the processing is done in context
     * @param {object} info - { route, data }, where data is the route definition by default
     * @param {object} info.route - Route to process
     * @param {object} info.data - Additional data, route definition by default
     *
     * @returns {Promise<boolean>} - Resolves to true if successful
     */
    preProcess(url, info = freeze(this.getRouteFromUrl(url))) {
        const route = freeze(info.route);

        // Check that the URL has a matching route, otherwise it is an error.
        if (route === null) {
            return Promise.resolve(generateMessageObject(messages.MISSING_ROUTE, [url]));
        }

        // Set this router's current matching path, Simple Routes pass on the parent match.
        this.pathMatch = !isSimpleRoute(route)
            ? getPathFromUrl(this.getUrlFromRoute(route).url || '')
            : this.parent
            ? this.parent.pathMatch
            : '';

        // Compile this router's filters; continue with TRUE if there are no filters.
        const canGo = this.preFilters.empty()
            ? Promise.resolve(true)
            : this.preFilters.compile({ current: this.infoMatch, next: info });

        // If the filters pass, run its child's filters.
        return (
            canGo
                .then(canContinue => {
                    return canContinue && this.child ? this.child.preProcess(url) : canContinue;
                })
                // Craft an error message, if the filters have returned false.
                .then(canContinue => {
                    return canContinue
                        ? canContinue
                        : generateMessageObject(messages.PRENAV_FAILED, [url]);
                })
        );
    }

    /**
     * Run the errorNavigate filters for this router.
     * After processing, delegate to a child router, if it exists.
     *
     * @param {object} e - An error object to pass into the error hook listeners.
     */
    processError(e) {
        this.errorFilters.compile(e);
        if (this.child) {
            this.child.processError(e);
        }
    }

    /***** lightning/navigation APIs *****/

    /**
     * lightning/navigation
     * Fire an event to send the navigation event up the DOM.
     * The root router will be the last to catch the event if it is not stopped.
     *
     * @param {string | object} input - URL string or route to navigate to
     * @param {*} options - Usually a boolean; when true the previous browser history
     *                    entry should be replaced by this one
     */
    navigate(input, options) {
        // Ensure there is a string URL to pass to the navigation event.
        const url = typeof input === 'string' ? input : this.getUrlFromRoute(input).url;

        // Check that a given route has a matching URL, otherwise it is an error.
        // We check the route => url conversion in this receiving context.
        if (url === null) {
            this.root.processError(
                generateMessageObject(messages.MISSING_URL, [input.id || input.type])
            );
            return;
        }

        // Fire event up the DOM with the original caller input
        this.node.dispatchEvent(
            new CustomEvent(NavNode.navigationEvent, {
                bubbles: true,
                composed: true,
                detail: { url, options, input },
            })
        );
    }

    /**
     * lightning/navigation
     * Generate a URL based on the given route.
     * Return a Promise containing the URL string.
     *
     * @param   {object} route - Route to generate a url for
     *
     * @returns {Promise<string>}
     */
    generateUrl(route) {
        const info = this.getUrlFromRoute(route);
        return Promise.resolve(info.url || '');
    }

    /**
     * lightning/navigation
     * Subscribe a callback to the Observable on the current route of this router.
     *
     * @param {function} callback - A callback function invoked when the navigation state changes
     *                     callback(route, routeDef)
     * @param {boolean} replay - Flag to determine if callback should be called with current route and data immediately
     */
    subscribe(callback, replay) {
        return this.routeObservable.subscribe(
            {
                next: (route, data) => callback(route, data),
            },
            replay
        );
    }
}
