"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const api_1 = require("@webruntime/api");
const chokidar_1 = require("chokidar");
const utils_1 = require("./utils/utils");
const messages_1 = require("./messages");
const routes_1 = require("./utils/routes");
const views_1 = require("./utils/views");
let watcher;
/**
 * Given route set ID = "base"
 *
 * @example: Get route set data ID => /navigation/routes/latest/dev/en_US/base
 * [{
        "id": "base.cmp",
        "path": "home",
        "component": "my/cmp"
    },
    {
        "id": "base.about",
        "path": "/about/:topic",
        "component": "my/topic"
 * }]
 *
 * @example: Get a generated module to create a Router bound to the given Route Set => /navigation/router/latest/dev/en_US/base
 *
 * @example: Get a generated view => /navigation/view/latest/dev/en_US/base/home
 */
// Hold the Route Set data here, so the Rollup plugin has access.
let routeSetCode = {};
const SET_URI_BASE_PATH = `/${routes_1.ROUTE_PREFIX}es/`;
const SET_URI_PREFIX = `${SET_URI_BASE_PATH}:uid/:mode/:locale`;
const ROUTER_URI_PREFIX = `/${routes_1.ROUTE_PREFIX}er/:uid/:mode/:locale`;
const VIEW_URI_PREFIX = `/${views_1.VIEW_PREFIX}/:uid/:mode/:locale`;
const uri = [
    // Get a Route Set by ID:
    //      "webruntimeRoutes/<setId>"
    //      "/navigation/routes/latest/dev/en_US/<setId>"
    `${SET_URI_PREFIX}/:set`,
    // Generate a Router lwc for a Route Set by ID:
    //      "webruntimerouter/<setId>"
    //      "/navigation/router/latest/dev/en_US/<setId>"
    `${ROUTER_URI_PREFIX}/:set`,
    // Get a Router View from a specific set =>
    //      "webruntimeView/<setId>.<routeId>"
    //      "/navigation/view/latest/dev/en_US/<routeSetId>/<routeId>"
    `${VIEW_URI_PREFIX}/:set/:route`,
];
class RoutingService extends api_1.AddressableService {
    constructor({ projectDir, server: { basePath, resourceRoot } }) {
        super(uri);
        this.mappings = {};
        this.routes = [];
        this.views = {};
        this.projectDir = projectDir;
        this.uriBasePath = `${basePath}${resourceRoot}`;
    }
    /**
     * Tie into the server initialize lifecycle event to do setup.
     */
    async initialize() {
        this.initializeData();
        // Watch for changes in the routes directory.
        // Upon change, re-initialize the data.
        watcher = chokidar_1.watch(path.join(this.projectDir, routes_1.ROUTES_DIR)).on('change', () => {
            this.initializeData();
        });
    }
    /**
     * Read in the route data and set up data structures for Route Definitions and Views.
     */
    initializeData() {
        const routeSets = routes_1.getRouteSets(this.projectDir);
        routes_1.validateRouteSets(routeSets);
        routeSetCode = routes_1.getCodifiedViews(routeSets);
        this.routes = routes_1.flattenRouteSets(routeSets);
        this.views = views_1.getViews(this.routes);
        this.mappings = computeMappings(routeSets, this.views);
    }
    /**
     * Implement a RequestService, which allows Route data to be loaded via HTTP.
     */
    async request(specifier, pivots, { compilerConfig }) {
        try {
            // Views:
            if (specifier.startsWith(views_1.VIEW_NAMESPACE)) {
                return this.compileView(specifier, compilerConfig);
            }
            // Routes & Routers:
            return utils_1.createRequestOutput(specifier, {
                ...compilerConfig,
                name: specifier,
                ...getRouteFiles(specifier),
            });
        }
        catch (e) {
            return utils_1.createErrorDiagnostic(specifier, e.message);
        }
    }
    /**
     * Implement a CompileService, which allows Route data to be inlined into requesting modules.
     */
    getPlugin() {
        const routerLwcs = new Set();
        return {
            name: 'navigation-route-service',
            resolveId(filePath) {
                if (filePath.toLowerCase().startsWith(routes_1.ROUTE_SERVICE_NAMESPACE)) {
                    // Javascript modules.
                    const specifier = filePath.replace(/\.js$/, '');
                    if (specifier.startsWith(routes_1.ROUTER_NAMESPACE)) {
                        // Keep track of LWC Routers, so the corresponding HTML files can be captured.
                        // "webruntimerouter/something" => "./something.html"
                        routerLwcs.add(`.${specifier.replace(routes_1.ROUTER_NAMESPACE, '')}.html`);
                    }
                    return `${specifier}.js`;
                }
                else if (routerLwcs.has(filePath)) {
                    // HTML for LWCs.
                    routerLwcs.delete(filePath);
                    // "./something.html" => "./webruntimerouter/something.html"
                    return `./${routes_1.ROUTER_NAMESPACE}/${filePath.replace(/^\.\//, '')}`;
                }
                return null;
            },
            load(filePath) {
                if (filePath.toLowerCase().startsWith(routes_1.ROUTE_SERVICE_NAMESPACE)) {
                    // Javascript modules.
                    const specifier = filePath.replace(/\.js$/, '');
                    const { files } = getRouteFiles(specifier);
                    return files[specifier];
                }
                else if (filePath.startsWith(`./${routes_1.ROUTER_NAMESPACE}/`)) {
                    // Relative html files for Router LWCs, recorded in resolveId().
                    // "./webruntimerouter/something.html" => "webruntimerouter/something"
                    const specifier = `${routes_1.ROUTER_NAMESPACE}/${path.basename(filePath, '.html')}`;
                    const { files } = getRouteFiles(specifier);
                    return files[filePath];
                }
                return null;
            },
        };
    }
    /**
     * Translate a URL path into a module specifier.
     *
     * @param url
     * @example "/navigation/view/latest/dev/en_US/my/home" => "webruntimeView/my.home"
     */
    toSpecifier(url) {
        const { set, route } = this.parseUrl(url);
        // Views:
        if (route) {
            return `${views_1.VIEW_NAMESPACE}/${set}.${route}`;
        }
        // Routes & Routers:
        return url.startsWith(`${this.uriBasePath}${SET_URI_BASE_PATH}`)
            ? `${routes_1.ROUTES_NAMESPACE}/${set}`
            : `${routes_1.ROUTER_NAMESPACE}/${set}`;
    }
    /**
     * Compile a View for the given specifer.
     *
     * @param specifier
     * @param compilerConfig
     */
    async compileView(specifier, compilerConfig) {
        // Parse the Route Set and Route IDs from the specifier.
        const [setId, routeId] = specifier.replace(`${views_1.VIEW_NAMESPACE}/`, '').split('.');
        const route = this.routes.find(r => r.id === `${setId}.${routeId}`);
        const view = this.views[`${setId}.${routeId}`];
        // Fail if the View is not available.
        if (!route || !view) {
            return utils_1.createErrorDiagnostic(specifier, `Cannot find route or view with id "${routeId}" in set "${setId}"`);
        }
        // Generate a view component, compile and return it.
        const files = views_1.generateViewFiles(routeId, route.path, view);
        return utils_1.createRequestOutput(specifier, {
            ...compilerConfig,
            input: `./${views_1.VIEW_NAMESPACE}/${routeId}/${routeId}.js`,
            name: specifier,
            files,
        });
    }
    /**
     * Tie into the server shutdown lifecycle event to perform cleanup.
     * Close watchers that were started in initialize().
     */
    shutdown() {
        if (watcher) {
            watcher.close();
        }
    }
}
exports.RoutingService = RoutingService;
/**
 * Create an import map from the Route Sets and Views.
 * @example
 *  {
    'webruntimeRoutes/parent': '/navigation/routes/:uid/:mode/:locale/parent',
    'webruntimeRoutes/default': '/navigation/routes/:uid/:mode/:locale/default',
    
    'webruntimerouter/parent': '/navigation/router/:uid/:mode/:locale/parent',
    'webruntimerouter/default': '/navigation/router/:uid/:mode/:locale/default',

    'webruntimeView/app.products': '/navigation/views/:uid/:mode/:locale/app/products',
    'webruntimeView/app.recipes': '/navigation/views/:uid/:mode/:locale/app/recipes',
    'webruntimeView/default.recipe': '/navigation/views/:uid/:mode/:locale/default/recipe',
    'webruntimeView/default.contact': '/navigation/views/:uid/:mode/:locale/default/contact'
 * }
 * @param routesToMap
 * @param views
 */
function computeMappings(routesToMap = {}, views = {}) {
    // Routes & Routers:
    const map = Object.keys(routesToMap).reduce((allMappings, setId) => {
        return {
            ...allMappings,
            // Get a Route Set.
            [`${routes_1.ROUTES_NAMESPACE}/${setId}`]: `${SET_URI_PREFIX}/${setId}`,
            // Get a generated router lwc for a set.
            [`${routes_1.ROUTER_NAMESPACE}/${setId}`]: `${ROUTER_URI_PREFIX}/${setId}`,
        };
    }, {});
    // Views:
    return Object.keys(views).reduce((allMappings, id) => {
        const [setId, routeId] = id.split('.');
        return {
            ...allMappings,
            // Get a single View component from within a set.
            [`${views_1.VIEW_NAMESPACE}/${id}`]: `${VIEW_URI_PREFIX}/${setId}/${routeId}`,
        };
    }, map);
}
/**
 * Return the module files of Route data for the given specifier.
 *
 * @param specifier
 */
function getRouteFiles(specifier) {
    // Get the namespace and set ID, fail if there is no Route Set.
    const [namespace, setId] = specifier.split('/');
    api_1.invariant(namespace && setId, messages_1.messages.MISSING_SET_ID, [specifier]);
    if (namespace === routes_1.ROUTES_NAMESPACE) {
        // Get a Route Set by ID:
        //      "webruntimeRoutes/<setId>"
        //      "/navigation/routes/latest/dev/en_US/<setId>"
        const routeCode = routeSetCode[setId];
        api_1.invariant(routeCode, messages_1.messages.MISSING_ROUTE_SET, [setId]);
        return {
            files: {
                [specifier]: routeCode,
            },
        };
    }
    else if (namespace === routes_1.ROUTER_NAMESPACE) {
        // Get a generated Router lwc for a set by ID:
        //      "webruntimerouter/<setId>"
        //      "/navigation/router/latest/dev/en_US/<setId>"
        return {
            input: `${specifier}.js`,
            files: routes_1.generateRouterFiles(setId),
        };
    }
    // This specifier makes no sense!
    api_1.invariant(false, messages_1.messages.MISSING_ROUTE_DATA, [specifier]);
    return { files: {} };
}
//# sourceMappingURL=routing-service.js.map