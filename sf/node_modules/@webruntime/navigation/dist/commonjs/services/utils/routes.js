"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const api_1 = require("@webruntime/api");
const messages_1 = require("../messages");
const views_1 = require("./views");
const utils_1 = require("./utils");
// URL prefixes and namespaces for routing modules.
exports.ROUTE_PREFIX = `${utils_1.NAVIGATION_NAMESPACE}/rout`;
exports.ROUTE_SERVICE_NAMESPACE = `${utils_1.WEBRUNTIME_NAMESPACE}rout`;
exports.ROUTES_NAMESPACE = `${utils_1.WEBRUNTIME_NAMESPACE}Routes`;
exports.ROUTER_NAMESPACE = `${utils_1.WEBRUNTIME_NAMESPACE}router`;
// Route data locations:
// "/src/routes/*"
// fallback "/src/routes.json"
const ROUTES_FILE_NAME = 'routes';
const ROUTES_FILE = `/src/${ROUTES_FILE_NAME}.json`;
exports.ROUTES_DIR = '/src/routes';
/**
 * Pull in a Route Set from the file system.
 * @example { "id": { "path": "/here" } } => [{ id: 'id', path: '/here' }]
 *
 * @param routePath - The path to the Route data json file
 */
function readRoutes(routePath) {
    api_1.invariant(fs.existsSync(routePath), messages_1.messages.MISSING_ROUTE_PATH, [routePath]);
    const routeObj = JSON.parse(fs.readFileSync(routePath, 'utf8'));
    return Object.keys(routeObj).reduce((routes, id) => routes.concat({ id, ...routeObj[id] }), []);
}
/**
 * Return a map of all Route Sets by ID, for a given project.
 * A Route Set ID is the name of the json file that holds the data.
 * @example {
        parent: [
            { id: 'home', path: '/', component: "x/home" },
            { id: 'products', path: '/products', component: "x/products" },
            { id: 'recipes', path: '/recipes', component: "x/recipes" },
            { id: 'recipe', path: '/recipes/:title', component: "x/recipe" },
            { id: 'contact', path: '/contact', component: "x/contact" }
        ],
        child: [
            { id: 'home', path: '/', component: "c/home" },
            { id: 'about', path: '/about/:topic', component: "c/about"}
        ]
 * }
 *
 * @param projectDir - Root directory for the project
 */
function getRouteSets(projectDir) {
    const routeDir = path.join(projectDir, exports.ROUTES_DIR);
    // Check for Route data files in <projectDir>/src/routes/
    if (fs.existsSync(routeDir)) {
        // Filter out all non-json files.
        return (fs
            .readdirSync(routeDir)
            // Filter out non-JSON files.
            // Filter out files with non-alpha, _ or - characters.
            .filter(file => file.match(/^[a-z_][A-Za-z_-]+\.json$/))
            // Read Route data for each file.
            .reduce((data, routeFile) => {
            const id = routeFile.replace(/\.json$/, '');
            const routePath = path.join(routeDir, routeFile);
            return {
                ...data,
                [id]: readRoutes(routePath),
            };
        }, {}));
    }
    // Check for a Route data file at <projectDir>/src/routes.json
    const routePath = path.join(projectDir, ROUTES_FILE);
    return { [ROUTES_FILE_NAME]: readRoutes(routePath) };
}
exports.getRouteSets = getRouteSets;
/**
 * The ID of each Route Definition is namespaced with its route set ID.
 *
 * @param routes - A Route Set
 * @param setId - Prepend the Route Definition IDs with the set ID
 */
function appendSetIds(routes, setId) {
    return routes.map(r => ({ ...r, id: `${setId}.${r.id || ''}` }));
}
/**
 * Flatten a group of Route Sets into 1 array of Route Definitions
 * Prefix each Route Definition id with its set id, to avoid clashes
 * @example [
            { id: 'parent.home', path: '/', component: "x/home" },
            { id: 'parent.products', path: '/products', component: "x/products" },
            { id: 'parent.recipes', path: '/recipes', component: "x/recipes" },
            { id: 'parent.recipe', path: '/recipes/:title', component: "x/recipe" },
            { id: 'parent.contact', path: '/contact', component: "x/contact" }
            { id: 'child.home', path: '/', component: "c/home" },
            { id: 'child.about', path: '/about/:topic', component: "c/about" }
        ]
 * }
 *
 * @param routeSets - A group of multiple Route Sets
 */
function flattenRouteSets(routeSets) {
    return Object.entries(routeSets).reduce((allRoutes, [setId, routeSet]) => allRoutes.concat(appendSetIds(routeSet, setId)), []);
}
exports.flattenRouteSets = flattenRouteSets;
/**
 * Transform the components of all Route Definitions to be a View dynamic import.
 * * @example:
 *  {
        app: [{ id: 'home', path: '/home', component: "x/home" }, ...],
        child: [{ id: 'home', path: '/', component: "c/home" }. ...],
 *  }
        ==>
 *  {
        app: [{ id: 'home', path: '/home', view: async () => await import("webruntimeView/app.home") }, ...],
        child: [{ id: 'home', path: '/', view: async () => await import("webruntimeView/child.home") }, ...],
 * }
 *
 * @param routeSets - A group of Route Sets
 */
function getCodifiedViews(routeSets) {
    function codifyView(routes, setId) {
        const viewModule = routes.reduce((moduleStr, route) => {
            // Skip component-less Route Definitions.
            if (!route.component) {
                return moduleStr;
            }
            // Make a copy of the Route Definition and remove the component.
            // The component should not be returned to the client with the view being added here.
            const routeCopy = { ...route };
            delete routeCopy.component;
            return `${moduleStr}{"view": async () => await import("${views_1.VIEW_NAMESPACE}/${setId}.${route.id}"),${JSON.stringify(routeCopy).substring(1)},`;
        }, 'export default [');
        return `${viewModule}];`;
    }
    return Object.entries(routeSets).reduce((allSets, [setId, routes]) => ({
        ...allSets,
        [setId]: codifyView(routes, setId),
    }), {});
}
exports.getCodifiedViews = getCodifiedViews;
/**
 * Generate the html template and javascript file for a Router.
 * These get passed into the compiler as "virtual" files.
 *
 * @param setId - ID of the Route Set to pass into the Router
 */
function generateRouterFiles(setId) {
    // Pass the generated javascript and HTML as virtual modules to the compiler.
    return {
        [`${exports.ROUTER_NAMESPACE}/${setId}`]: generateRouterJavascript(setId),
        [`./${exports.ROUTER_NAMESPACE}/${setId}.html`]: generateRouterTemplate(),
    };
}
exports.generateRouterFiles = generateRouterFiles;
/**
 * Generate the lwc template for the declarative Router.
 */
function generateRouterTemplate() {
    return `
        <template>
            <${utils_1.WEBRUNTIME_NAMESPACE}-router routes={routes} base-path={basePath} no-history={noHistory} case-sensitive={caseSensitive}>
                <slot></slot>
            </${utils_1.WEBRUNTIME_NAMESPACE}-router>
        </template>`;
}
/**
 * Generate the lwc Router component and programmatic exports.
 *
 * @param setId - ID of the Route Set to pass into the Router
 */
function generateRouterJavascript(setId) {
    return `
        import { api, LightningElement } from 'lwc';
        import routes from '${exports.ROUTES_NAMESPACE}/${setId}';
        import { createRouter } from '${utils_1.WEBRUNTIME_NAMESPACE}/navigation';

        // Declarative Router:
        export default class ${utils_1.toClassName(exports.ROUTER_NAMESPACE, setId)} extends LightningElement {
            routes = routes;
            @api basePath;
            @api noHistory = false;
            @api caseSensitive = false;
            connectedCallback() {
                // Keep the events inside this router.
                this.addEventListener('prenavigate', this.stopEvent);
                this.addEventListener('postnavigate', this.stopEvent);
                this.addEventListener('errornavigate', this.stopEvent);
                this.addEventListener('handlenavigation', this.stopEvent);
            }
            stopEvent(e) {
                e.stopPropagation();
            }
        }
    
        // Programmatic Router:
        export function connectRouter(config) {
            createRouter({ ...config, routes })
            .addPreNavigate(config.preNavigate)
            .addPostNavigate(config.postNavigate)
            .addErrorNavigate(config.errorNavigate)
            .connect();
        }`;
}
/**
 * Throw an error if any required Route properties are missing.
 *
 * @param routeSet - Set of Route Definitions
 */
const routeIdPattern = new RegExp(/^[a-z-A-Z_]+[.]{1}[a-z-A-Z_]+$/);
const routePathPattern = new RegExp(/^((\/)|(\/:?[a-zA-Z]+\??)+)$/);
const moduleSpecifierPattern = new RegExp(/^[a-zA-Z_\d]+[/]{1}[a-z-A-Z_\d]+$/);
const pageTypePattern = new RegExp(/^[a-zA-Z_]+$/);
function validateRouteSets(routeSets) {
    const routes = flattenRouteSets(routeSets);
    routes.forEach(route => {
        checkString(route.id, routeIdPattern, '', 'none', 'id');
        const [routeSetId, routeId] = route.id.split('.');
        checkString(route.path, routePathPattern, routeSetId, routeId, 'path');
        if (Object.hasOwnProperty.call(route, 'component')) {
            checkString(route.component || '', moduleSpecifierPattern, routeSetId, routeId, 'component');
        }
        if (route.page) {
            checkString(route.page.type, pageTypePattern, routeSetId, routeId, 'page.type');
        }
    });
}
exports.validateRouteSets = validateRouteSets;
/**
 * Check that the given string is non-empty and matches a regular expression.
 *
 * @param str - String to check
 * @param regex - Regular expression to check against
 * @param routeSetId - The Route Definition ID
 * @param routeId - The Route Set ID
 * @param property - The property name that is being checked
 */
function checkString(str, regex, routeSetId, routeId, property) {
    api_1.invariant(str && str.length, messages_1.messages.EMPTY_ROUTE_DATA, [routeId, routeSetId, property]);
    api_1.invariant(regex.test(str), messages_1.messages.INVALID_ROUTE_DATA, [routeId, routeSetId, property]);
}
//# sourceMappingURL=routes.js.map