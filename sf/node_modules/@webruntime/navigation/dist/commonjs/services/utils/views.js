"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const path_to_regexp_1 = require("path-to-regexp");
const utils_1 = require("./utils");
exports.VIEW_PREFIX = `${utils_1.NAVIGATION_NAMESPACE}/view`;
exports.VIEW_NAMESPACE = `${utils_1.WEBRUNTIME_NAMESPACE}View`;
/**
 * From the Route Definitions, create a map of all [route.id]:route.component pairs.
 * Only process Route Definitions with components.
 * @example: NOTE the route IDs are prefixed with their Route Set ID, for uniqueness
 *  {
    'routes.home': 'foundation/home',
    'routes.products': 'foundation/products',
    'routes.recipes': 'foundation/recipes',
    'routes.recipe': 'foundation/recipesItem',
    'routes.contact': 'foundation/contact'
 * }
 *
 * @param routes
 */
function getViews(routes) {
    return routes.reduce((allViews, route) => {
        return route.component
            ? {
                ...allViews,
                [`${route.id}`]: route.component,
            }
            : allViews;
    }, {});
}
exports.getViews = getViews;
/**
 * Generate the html template and javascript file for the lwc.
 * These get passed into the compiler as "virtual" files.
 *
 * @param id - ID of the View/Route Definition
 * @param path - The parameterized path for the Route Definition
 * @param specifier - Component to wrap in the View component
 */
function generateViewFiles(id, path, specifier) {
    // Get the properties from the Route Definition path parameters.
    const properties = path_to_regexp_1.parse(path)
        .filter(p => typeof p === 'object')
        .map(p => (typeof p === 'object' ? p.name : p));
    // Pass the generated javascript and HTML as virtual modules to the compiler.
    return {
        [`./${exports.VIEW_NAMESPACE}/${id}/${id}.js`]: generateViewJavascript(id, properties),
        [`./${exports.VIEW_NAMESPACE}/${id}/${id}.html`]: generateViewTemplate(specifier, properties),
    };
}
exports.generateViewFiles = generateViewFiles;
/**
 * Generate the lwc View template
 *
 * @param specifier - Component to wrap in the View component
 * @param properties - Public properties to pass into the component
 */
function generateViewTemplate(specifier, properties) {
    const nodeName = utils_1.toElementName(specifier);
    // [ 'prop', 'anotherProp' ] => " prop={prop} another-prop={anotherProp}"
    const propHtml = properties.reduce((allProps, prop) => {
        return `${allProps} ${utils_1.toElementName(prop)}={${prop}}`;
    }, '');
    return `
        <template>
            <${nodeName}${propHtml}></${nodeName}>
        </template>`;
}
/**
 * Generate the lwc View template
 *
 * @param specifier - ID of the View/Route Definition
 * @param properties - Public properties to pass into the component
 */
function generateViewJavascript(id, properties) {
    const className = utils_1.toClassName(exports.VIEW_NAMESPACE, id);
    // FUTURE: Validate component @api decorators against Route attributes using the platform-compiler.
    // A View with no properties.
    if (!properties.length) {
        return `
            import { LightningElement } from 'lwc';
            export default class ${className} extends LightningElement {}`;
    }
    // [ 'prop', 'anotherProp' ] => "@track prop; @track anotherProp;"
    const propTrackJs = properties.reduce((allProps, prop) => {
        return `${allProps}@track ${prop}; `;
    }, '');
    // [ 'prop', 'anotherProp' ] => "this.prop = attributes.prop; this.anotherProp = attributes.anotherProp;
    const propSetJs = properties.reduce((allProps, prop) => {
        return `${allProps}this.${prop} = attributes.${prop}; `;
    }, '');
    return `
        import { track, wire, LightningElement } from 'lwc';
        import { NavigationContext, subscribe } from '${utils_1.WEBRUNTIME_NAMESPACE}/navigation';

        export default class ${className} extends LightningElement {
                
            // Keep track of @api properties for the wrapped component.
            ${propTrackJs}
            
            // Get a reference to the navigation context.
            @wire(NavigationContext)
            navContext;

            // Subscribe to updates on the current Route.
            connectedCallback() {
                this.subscription = subscribe(this.navContext, ({ attributes }) => {
                    ${propSetJs}
                });
            }

            // Unsubscribe from the Router on disconnect.
            disconnectedCallback() {
                if (this.subscription) {
                    this.subscription.unsubscribe();
                }
            }
        }`;
}
//# sourceMappingURL=views.js.map