"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Basic utility for collecting performance measurements based on the LWC performance timing utiltiy
 *
 * TODO: Find replacement in LWR framework for the vm.idx value that LWC uses for uniqueness of marks.
 */
const performance = require('perf_hooks').performance;
const isUserTimingSupported = typeof performance !== 'undefined' &&
    typeof performance.mark === 'function' &&
    typeof performance.clearMarks === 'function' &&
    typeof performance.measure === 'function';
function genMeasureName(measure) {
    // Use a random 6 digit number for uniqueness - temporary replacement for LWC uniqueness
    const randNumStr = `${Math.floor(Math.random() * 1000000)}`.padStart(6, '0');
    return `${measure}-${randNumStr}`;
}
function start(mark) {
    const measureName = genMeasureName(mark);
    performance.mark(`${measureName}-start`);
    return measureName;
}
function end(measureName) {
    performance.mark(`${measureName}-end`);
    performance.measure(`${measureName}`, `${measureName}-start`, `${measureName}-end`);
    performance.clearMarks(`${measureName}-start`);
    performance.clearMarks(`${measureName}-end`);
}
function noop() { }
const startMeasure = !isUserTimingSupported ? noop : start;
exports.startMeasure = startMeasure;
const endMeasure = !isUserTimingSupported ? noop : end;
exports.endMeasure = endMeasure;
function Measure(name) {
    return function (target, propertyKey, descriptor) {
        const origFunc = descriptor.value;
        descriptor.value = function () {
            let measureName = '';
            if (typeof name === 'function') {
                measureName = name.apply(this, arguments);
            }
            else {
                measureName = name;
            }
            const measure = startMeasure(measureName);
            const res = origFunc.apply(this, arguments);
            if (res instanceof Promise) {
                return res
                    .then(results => {
                    endMeasure(measure);
                    return results;
                })
                    .catch(err => {
                    endMeasure(measure);
                    throw err;
                });
            }
            endMeasure(measure);
            return res;
        };
        return descriptor;
    };
}
exports.Measure = Measure;
//# sourceMappingURL=performance-timing.js.map