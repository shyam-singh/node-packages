/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

/**
 * Basic utility for collecting performance measurements based on the LWC performance timing utiltiy
 *
 * TODO: Find replacement in LWR framework for the vm.idx value that LWC uses for uniqueness of marks.
 */

const performance = require('perf_hooks').performance;

const isUserTimingSupported: boolean =
    typeof performance !== 'undefined' &&
    typeof performance.mark === 'function' &&
    typeof performance.clearMarks === 'function' &&
    typeof performance.measure === 'function';

function genMeasureName(measure): string {
    // Use a random 6 digit number for uniqueness - temporary replacement for LWC uniqueness
    const randNumStr = `${Math.floor(Math.random() * 1000000)}`.padStart(6, '0');
    return `${measure}-${randNumStr}`;
}

function start(mark): string {
    const measureName = genMeasureName(mark);
    performance.mark(`${measureName}-start`);
    return measureName;
}

function end(measureName) {
    performance.mark(`${measureName}-end`);
    performance.measure(`${measureName}`, `${measureName}-start`, `${measureName}-end`);
    performance.clearMarks(`${measureName}-start`);
    performance.clearMarks(`${measureName}-end`);
}

function noop() {}

const startMeasure = !isUserTimingSupported ? noop : start;

const endMeasure = !isUserTimingSupported ? noop : end;

function Measure(name: string | Function) {
    return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const origFunc = descriptor.value;
        descriptor.value = function() {
            let measureName = '';
            if (typeof name === 'function') {
                measureName = name.apply(this, arguments);
            } else {
                measureName = name;
            }

            const measure = startMeasure(measureName);
            const res = origFunc.apply(this, arguments);

            if (res instanceof Promise) {
                return res
                    .then(results => {
                        endMeasure(measure);
                        return results;
                    })
                    .catch(err => {
                        endMeasure(measure);
                        throw err;
                    });
            }

            endMeasure(measure);
            return res;
        };

        return descriptor;
    };
}

export { endMeasure, startMeasure, Measure };
