/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { createElement } from 'lwc';
import componentWrapper from 'webruntimedesign/componentWrapper';
import interactionsManager from '../interactionsManager';
import { utils as domUtil } from '../../lbf/interactions';
import {
    COMPONENT_WRAPPER_CLASS,
    COMPONENT_WRAPPER_ELEMENT_NAME,
    ELEMENT_ID_ATTRIBUTE_NAME,
    ELEMENT_WRAPPER_CLASS,
    REGION_WRAPPER_CLASS,
    REGION_WRAPPER_DROPZONE_CLASS,
    REGION_WRAPPER_MANUAL_CLASS,
} from './constants';

function getElementSelector(id) {
    return `.${ELEMENT_WRAPPER_CLASS}[${ELEMENT_ID_ATTRIBUTE_NAME}="${id}"]`;
}

function getContainingRegion(element) {
    return closestAncestor(`.${REGION_WRAPPER_CLASS}`, element);
}

function closestAncestor(selector, base = this) {
    function getClosestFrom(el) {
        if (!el || el === document || el === window) {
            return null;
        }

        const found = el.closest(selector);
        return found ? found : getClosestFrom(el.getRootNode().host);
    }

    return getClosestFrom(base);
}

function isOrIsDescendantOfType(typeSelector, baseElement) {
    return baseElement.matches(typeSelector) || !!closestAncestor(typeSelector, baseElement);
}

/**
 * Inserts a component into the container in a dropzone corresponding to the position of the component in the container.
 */
function insertComponent({ beforeId, containerId, component }) {
    const regionWrapperEl = domUtil.querySelector(document, getElementSelector(containerId))
        .parentNode.host;
    const beforeComponentWrapperEl = beforeId
        ? domUtil.querySelector(document, getElementSelector(beforeId)).parentNode.host
        : null;
    const dropzoneEl = findDropzoneEl({
        beforeId,
        regionWrapperEl,
        beforeComponentWrapperEl,
    });

    insertItemToDropzoneEl({
        dropzoneEl,
        itemEl: component,
        beforeComponentWrapperEl,
    });
}

function getValidLastRegion(dropzoneEls) {
    const current = dropzoneEls.pop();

    // this implementation of closest checks the node passed in for equality before moving up
    // the tree, so we need to pass the parent of current here to find a true ancestor
    const closest = domUtil.closest(current.parentNode.host, `.${REGION_WRAPPER_DROPZONE_CLASS}`);
    if (dropzoneEls.some(el => el === closest)) {
        return getValidLastRegion(dropzoneEls);
    }

    return current;
}

/**
 * Find the correct lwc:dom="manual" dropzone element to insert the component into.
 * Due to the DOM manipulation limitation of LWC, all dynamic component CRUD is done in a dropzone.
 */
function findDropzoneEl({ beforeId, regionWrapperEl, beforeComponentWrapperEl }) {
    let dropzoneEl = null;

    if (beforeId) {
        // find if any of container's dropzone contains the beforeItem
        dropzoneEl = domUtil
            .querySelectorAll(regionWrapperEl, `.${REGION_WRAPPER_DROPZONE_CLASS}`)
            .find(el => {
                return domUtil.querySelectorAll(el, getElementSelector(beforeId)).length > 0;
            });

        // if found, we have our dropzone. If not, beforeItem is not in a dropzone and we grab it by index
        if (!dropzoneEl) {
            const indexOfBeforeComponentWrapperEl = Array.from(regionWrapperEl.children).indexOf(
                beforeComponentWrapperEl
            );
            const dropzoneWrapper = regionWrapperEl.children[indexOfBeforeComponentWrapperEl - 1];
            const dropzone = dropzoneWrapper.shadowRoot.querySelector(
                `.${REGION_WRAPPER_DROPZONE_CLASS}`
            );
            if (dropzone && dropzone.classList.contains(REGION_WRAPPER_DROPZONE_CLASS)) {
                dropzoneEl = dropzone;
            }
        }
    } else {
        // if beforeId is missing, we are inserting to the last of the dropzone in the region in the last position
        const dropzoneEls = domUtil.querySelectorAll(
            regionWrapperEl,
            `.${REGION_WRAPPER_DROPZONE_CLASS}`
        );

        if (dropzoneEls.length) {
            return getValidLastRegion(dropzoneEls);
        }

        return null;
    }

    return dropzoneEl;
}

/**
 * Inserts the item to the dropzone.
 */
function insertItemToDropzoneEl({ dropzoneEl, itemEl, beforeComponentWrapperEl }) {
    // checks whether the component is the first in the region.
    if (beforeComponentWrapperEl) {
        // checks whether the component prior to the current has already been moved to the dropzone.
        if (Array.from(dropzoneEl.children).includes(beforeComponentWrapperEl.shadowRoot.host)) {
            dropzoneEl.insertBefore(itemEl, beforeComponentWrapperEl);
        } else {
            dropzoneEl.appendChild(itemEl);
        }
    } else {
        dropzoneEl.appendChild(itemEl);
    }
}

/**
 * Wrapper for creating webruntimedesign/componentWrapper.
 */
async function createComponent(properties) {
    return Object.assign(
        createElement(COMPONENT_WRAPPER_ELEMENT_NAME, {
            is: componentWrapper,
        }),
        properties
    );
}

/**
 * Helper for checking whether the element is visible in the viewable page.
 */
function isElementVisible(element) {
    return element.offsetWidth > 0 && element.offsetHeight > 0;
}

/**
 * Helper for fetching all region elements and updating their visibility, including their "manual" DOM.
 */
function updateRegionsVisibility() {
    const regions = domUtil.querySelectorAll(document, `.${REGION_WRAPPER_CLASS}`);
    regions.forEach(region => updateRegionVisibility(region));
}

/**
 * Helper for updating region element's visibility, including its "manual" DOM.
 */
function updateRegionVisibility(region) {
    const manual = domUtil.querySelector(region, `.${REGION_WRAPPER_MANUAL_CLASS}`);
    const isEmpty = domUtil.querySelector(region, `.${COMPONENT_WRAPPER_CLASS}`) === null;
    manual.style.display = isEmpty ? '' : 'none';
}

/**
 * Helper for toggling @lbf/interactions.
 * State is kept in `window.interactionsEnabled` for global access during design mode.
 */
function toggleInteractions(isEnabled, interactionsCore) {
    window.interactionsEnabled = isEnabled;
    if (isEnabled) {
        interactionsCore.enable();
    } else {
        interactionsCore.disable();
    }
}

function toggleInteractionsProxies(isEnabled) {
    const interactions = interactionsManager.getInteractions();
    if (isEnabled) {
        interactions.enableProxies();
    } else {
        interactions.disableProxies();
    }
}

export {
    insertComponent,
    createComponent,
    isElementVisible,
    updateRegionsVisibility,
    updateRegionVisibility,
    toggleInteractions,
    toggleInteractionsProxies,
    getElementSelector,
    isOrIsDescendantOfType,
    getContainingRegion,
};
