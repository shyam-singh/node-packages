/**
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { utils as domUtil } from '../../lbf/interactions';
import { ConnectionManager } from '../../lbf/utils';
import { updateCSSVars } from '../../styleManager/styleManager';
import {
    createComponent,
    getElementSelector,
    insertComponent,
    toggleInteractions,
    updateRegionsVisibility,
} from '../shared/utils';
import { enableEditorMode } from '../shared/rich-text-editor-utils';
import { isValidDropTargetForComponent } from '../shared/section-utils';
import {
    COMPONENT_LABEL_ATTRIBUTE_NAME,
    ELEMENT_FQN_ATTRIBUTE_NAME,
    ELEMENT_ID_ATTRIBUTE_NAME,
    REGION_WRAPPER_DROPZONE_CLASS,
} from '../shared/constants';

/**
 * Starts ConnectionManager
 */
function startPostMessageManager() {
    return new ConnectionManager();
}

/**
 * Starts listeners that listens to events from the parent window, i.e., builder.
 * These postMessages are contracts between the canvas and the builder.
 */
function startPostMessageListeners({ postMessageManager, interactions }) {
    /**
     * Toggles @lbf/interactions. Originates from Builder's preview mode toggle.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'set-interactions', enabled => {
        toggleInteractions(enabled, interactions);
    });

    /**
     * Handler for starting inline edit mode for the Rich Content Editor in the design environment.
     */
    postMessageManager.registerPostmessageHandler(
        window.parent,
        'open-current-inline-editor',
        params => {
            const { itemId } = params;
            enableEditorMode(itemId, postMessageManager);
        }
    );

    /**
     * Handler for event denoting successful reposition of a component in siteDotCom region.
     * Grabs the component element from the DOM and moves it to the dropzone corresponding to its new position.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'cb-dnd-move-item', data => {
        const { beforeId, container, item } = data.data;

        const componentWrapperEl = domUtil.querySelector(document, getElementSelector(item))
            .parentNode.host;

        insertComponent({
            beforeId,
            containerId: container,
            component: componentWrapperEl,
        });

        interactions.selectComponent(item);

        updateRegionsVisibility();
    });

    /**
     * Handler for event denoting successful deletion of a component in siteDotCom region.
     * Deletes the corresponding component element from the DOM.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'cb-dnd-delete-item', data => {
        const { results } = data;
        interactions.deleteComponent(results.DeletedItemID);

        updateRegionsVisibility();
    });

    /**
     * Handler for event denoting starting of component dragging from builder (e.g., component palette) to the canvas.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'drag-start', data => {
        interactions.dragStart({
            mouseX: data.x,
            mouseY: data.y,
        });
    });

    /**
     * Handler for event denoting external positional change of component dragging from builder (e.g., component palette) to the canvas.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'drag-mouse-position', data => {
        interactions.dragUpdate({
            mouseX: data.x,
            mouseY: data.y,
        });
    });

    /**
     * Handler for event denoting external drop of component dragging from builder (e.g., component palette) to the canvas.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'drag-end', data => {
        const result = interactions.dragEnd({
            mouseX: data.x,
            mouseY: data.y,
        });

        if (!isValidDropTargetForComponent(result.container.element)) {
            return;
        }

        const beforeId = result.position && result.position.beforeId;
        const containerId = result.container.key;

        /**
         * After we calculate the container and position, we postMessage back to the builder to create the component in the SiteDotCom region.
         */
        postMessageManager.sendPostmessage(window.parent, 'drop-item', {
            argument: data.argument,
            type: data.argument.properties.connectorType,
            container: containerId,
            beforeId: beforeId,
        });
    });

    /**
     * Handler for event denoting successful creation of a new component in siteDotCom region.
     * Creates a new LWC component wrapper dynamically and insert the component to the dropzone corresponding to its new position.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'cb-dnd-drop-item', data => {
        const { argument, beforeId, container } = data.data;
        const { CurrentItemID } = data.results;
        const { fqn } = argument.properties; // namespace:fqn

        createComponent({
            componentName: fqn.replace(':', '/'),
            label: argument.label || fqn,
            componentAttributes: data.results.PropertiesJSON.Value,
            componentId: CurrentItemID,
            isLocked: false,
        }).then(componentWrapperEl => {
            insertComponent({
                beforeId,
                containerId: container,
                component: componentWrapperEl,
            });

            interactions.selectComponent(CurrentItemID);

            updateRegionsVisibility();
        });
    });

    /**
     * Handler for event denoting successful property update of a siteDotCom component.
     * Creates a new LWC component wrapper dynamically, insert the component to the dropzone corresponding to its new position and deletes the old component.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'cb-prop-changed', data => {
        const { id, props = {} } = data;
        const origComponentWrapperEl = domUtil.querySelector(document, getElementSelector(id))
            .parentNode.host;
        createComponent({
            componentAttributes: props,
            componentId: origComponentWrapperEl.componentId,
            componentName: origComponentWrapperEl.componentName,
            label: origComponentWrapperEl.label,
            isLocked: origComponentWrapperEl.isLocked,
        }).then(componentWrapperEl => {
            // check if component is already inside a dropzone
            if (
                origComponentWrapperEl.parentNode &&
                !origComponentWrapperEl.parentNode.classList.contains(REGION_WRAPPER_DROPZONE_CLASS)
            ) {
                // if component is not in a dropzone already, find the correct dropzone
                const origComponentWrapperSiblings = origComponentWrapperEl.parentNode.children;
                const indexOfOrig = Array.from(origComponentWrapperSiblings).indexOf(
                    origComponentWrapperEl
                );
                const dropzoneWrapper = Array.from(origComponentWrapperSiblings)[indexOfOrig - 1];
                const dropzoneEl = domUtil.querySelector(
                    dropzoneWrapper,
                    `.${REGION_WRAPPER_DROPZONE_CLASS}`
                );

                // delete the old component from the DOM and interaction's cache
                // since the old and new components have the same id, we need to manually invalidate the cache
                interactions.deleteComponent(id, true);

                // insert the new component into the dropzone
                dropzoneEl.appendChild(componentWrapperEl);

                // register the new component into interactions
                interactions.scan();

                // select the component
                interactions.selectComponent(id);
            } else {
                // get the closest dropZone element from original componentWrapper
                const dropzoneEl = domUtil.closest(
                    origComponentWrapperEl,
                    `.${REGION_WRAPPER_DROPZONE_CLASS}`
                );

                // cache the component list and position before we delete the old component
                const childEls = Array.from(dropzoneEl.childNodes);
                const indexOfOrig = childEls.indexOf(origComponentWrapperEl);

                // delete the old component from the DOM and interaction's cache
                // we can't simply do replaceChild since old and new component shares the id
                interactions.deleteComponent(id, true);

                // insert the new component where the old one was positioned
                dropzoneEl.insertBefore(componentWrapperEl, childEls[indexOfOrig + 1]);

                // register the new component into interactions
                interactions.scan();

                // select the component
                interactions.selectComponent(id);
            }
        });
    });

    /**
     * Handler for event that requests for the current scroll position of th canvas.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'get-scroll-position', () => {
        const yOffset = window.pageYOffset;
        const xOffset = window.pageXOffset;
        const result = {
            top: yOffset,
            left: xOffset,
            bottom: document.documentElement.scrollHeight - yOffset - window.innerHeight,
            right: document.documentElement.scrollWidth - xOffset - window.innerWidth,
        };
        postMessageManager.sendPostmessage(window.parent, 'scroll-positions', result);
    });

    /**
     * Handler for event that requests metadata about a component on the canvas.
     */
    postMessageManager.registerPostmessageHandler(
        window.parent,
        'cb-request-element-attributes',
        itemId => {
            const itemEl = domUtil.querySelector(document, getElementSelector(itemId));
            if (itemEl) {
                postMessageManager.sendPostmessage(
                    window.parent,
                    'cb-response-element-attributes',
                    {
                        allowDelete: false,
                        fqn: itemEl.getAttribute(ELEMENT_FQN_ATTRIBUTE_NAME),
                        id: itemEl.getAttribute(ELEMENT_ID_ATTRIBUTE_NAME),
                        isInTabset: false,
                        isInThemeRegion: false,
                        label: itemEl.getAttribute(COMPONENT_LABEL_ATTRIBUTE_NAME),
                    }
                );
            }
        }
    );

    /**
     * Handler for event that requests that a component be selected on the canvas.
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'select-element', itemId => {
        interactions.selectComponent(itemId);
    });

    /**
     * Handler for event that requests the id of the currently selected component
     */
    postMessageManager.registerPostmessageHandler(window.parent, 'get-selected-element', () => {
        const selectedComponent = interactions.getSelectedComponent();
        let itemId;

        if (selectedComponent) {
            itemId = selectedComponent.element.dataset.itemId;
        }

        postMessageManager.sendPostmessage(window.parent, 'selected-element', itemId);
    });

    /**
     * Handler for event that notifies the canvas of branding property changes.
     */
    postMessageManager.registerPostmessageHandler(
        window.parent,
        'reload-styles',
        ({ brandingSet, brandingDef }) => {
            updateCSSVars({ brandingSet, brandingDef });
        }
    );
}

export { startPostMessageManager, startPostMessageListeners };
