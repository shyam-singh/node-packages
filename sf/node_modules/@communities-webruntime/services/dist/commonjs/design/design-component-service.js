"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@communities-webruntime/common");
const api_1 = require("@webruntime/api");
const compiler_1 = require("@webruntime/compiler");
const view_template_generator_1 = require("../views/view-template-generator");
const template_utils_1 = require("../template-generators/template-utils");
const context_service_1 = require("../context/context-service");
const metadata_service_1 = require("../metadata/metadata-service");
const { getComponent } = metadata_service_1.MetadataService;
const { getContext } = context_service_1.ContextService;
const uri = `/designcomponent/:uid/:mode/:locale/:name`;
/**
 * Addressable service responsible for generating component modules
 * in design mode
 */
class DesignComponentService extends api_1.AddressableService {
    get mappings() {
        const { isDesignMode } = getContext();
        return {
            ...(isDesignMode && {
                [common_1.getDesignComponentModuleSpecifier('')]: `/designcomponent/:uid/:mode/:locale/`,
            }),
        };
    }
    constructor() {
        super(uri);
    }
    initialize() { }
    /**
     * Handle design component requests
     */
    async request(specifier, pivots, { compilerConfig }) {
        var _a, _b;
        const [namespace, uuid] = specifier.split('/');
        const cmp = getComponent(uuid);
        if (!cmp) {
            return {
                type: api_1.RequestOutputTypes.JSON,
                specifier,
                success: false,
                diagnostics: [
                    {
                        code: 'COMM-0001',
                        message: `Cannot find component '${specifier}'`,
                        level: 0,
                    },
                ],
            };
        }
        // generate a template HTML based on the component metadata
        const moduleName = uuid;
        // Using "isTopLevel=true" because it is the top level of this component tree
        // Otherwise, a second component wrapper would be returned for this component
        const { html, attributes } = template_utils_1.component({
            cmp,
            isThemeLayout: false,
            regionName: cmp.region,
            isTopLevel: true,
            attributeSet: {},
            isRenderDesignMode: true,
        });
        const generatedTemplate = `<template>${html}</template>`;
        const generatedJavascript = view_template_generator_1.javascript(moduleName, view_template_generator_1.generateAttributesJS(attributes.attributes));
        // pass the generated javascript and HTML as virtual modules to the compiler
        const files = {
            [`./cmp/${moduleName}/${moduleName}.js`]: generatedJavascript,
            [`./cmp/${moduleName}/${moduleName}.html`]: generatedTemplate,
        };
        const moduleDef = await compiler_1.compile({
            ...compilerConfig,
            input: `./cmp/${moduleName}/${moduleName}.js`,
            namespace,
            name: uuid,
            files,
        });
        return {
            type: api_1.RequestOutputTypes.COMPONENT,
            specifier,
            resource: moduleDef.result,
            metadata: {
                dependencies: ((_a = moduleDef.metadata) === null || _a === void 0 ? void 0 : _a.dependencies) || [],
                dynamicImports: ((_b = moduleDef.metadata) === null || _b === void 0 ? void 0 : _b.dynamicImports) || [],
            },
            success: moduleDef.success,
            diagnostics: moduleDef.diagnostics,
        };
    }
    toSpecifier(url) {
        const { name } = this.parseUrl(url);
        return common_1.getDesignComponentModuleSpecifier(name);
    }
}
exports.DesignComponentService = DesignComponentService;
//# sourceMappingURL=design-component-service.js.map