"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("colors");
const crypto_1 = __importDefault(require("crypto"));
const api_1 = require("@webruntime/api");
const assert_1 = require("../utils/assert");
const observable_folder_hash_1 = __importDefault(require("../utils/observable-folder-hash"));
const filesystem_1 = __importDefault(require("../utils/filesystem"));
const webruntime_context_1 = __importDefault(require("./webruntime-context"));
const { log } = console;
const state = {
    onContextClosedCallbacks: new Set(),
};
class ContextService extends api_1.AddressableService {
    constructor({ projectDir, server: { basePath = '' } }) {
        super([]);
        this.projectDir = projectDir;
        this.basePath = basePath;
    }
    async initialize() {
        const isDesignMode = process.env.isDesignMode === 'true';
        await ContextService.startContext({
            templateDir: this.projectDir,
            basePath: this.basePath,
            isDesignMode,
        });
    }
    async shutdown() {
        await ContextService.endContext();
    }
    request() { }
    /**
     * Start the Web Runtime context and compute the template version key
     * based on the given configuration by computing a hash for srcDir
     * and watching it for changes.
     *
     * @public
     * @param {Object} config The template configuration
     * @param {string} config.templateDir Required, the template module directory
     * @param {string} [config.srcDir] Source directory, used to compute the template version key
     * @param {string|Object} [config.partials] Directory where handlebar partials are stored to be used in templates or representative json object
     * @param {string|Object} [config.routes] The Web Runtime routes configuration file path (i.e. routes.json), or representative json object
     * @param {string|Object} [config.labels]  The Web Runtime labels configuration file path (i.e. labels.json), or representative json object
     * @param {string|Object} [config.theme] The Web Runtime themes configuration file path (i.e. theme.json), or representative json object
     * @param {string} [config.locale] The locale to use
     * @param {string} [config.basePath] The base path to use in branding properties URL values
     * @param {string} [config.isDesignMode] Determines whether the context is design mode
     * @param {string[]} [config.modes] The list of modes in which the resources will be generated, defaults to all modes (dev, compat, prod, prod_compat)
     */
    static async startContext(config) {
        assert_1.assert(!state.currentContext, 'Context already started');
        const context = (state.currentContext = new webruntime_context_1.default(config));
        if (config.versionKey) {
            // version key is already specified,
            // we must be in a worker
            context.versionKey = config.versionKey;
            return context;
        }
        if (context.srcDir) {
            const sourcePath = context.srcDir;
            return observable_folder_hash_1.default(sourcePath).then(observable => {
                state.folderHashSubscription = observable.subscribe({
                    next(hash) {
                        // include folder mtime so that the returned hash changes
                        // when the folder is touched, this is useful for tests
                        const { mtime } = filesystem_1.default.statSync(sourcePath);
                        const versionKey = crypto_1.default
                            .createHash('md5')
                            .update(hash + mtime)
                            .digest('hex')
                            .substring(0, 10);
                        if (!('versionKey' in context) || context.versionKey !== versionKey) {
                            log(`Created template version hash: ${versionKey}`.cyan);
                            context.versionKey = versionKey;
                        }
                    },
                });
                return context;
            });
        }
        throw new Error('Must have source directory specified');
    }
    /**
     * Returns the current context
     * @public
     */
    static getContext() {
        if (state.currentContext != null) {
            return state.currentContext;
        }
        throw new Error('Context not started');
    }
    /**
     * Ends the current context and stops watching srcDir for changes.
     * @public
     */
    static endContext() {
        if (state.folderHashSubscription) {
            state.folderHashSubscription.unsubscribe();
            state.folderHashSubscription = null;
        }
        if (state.currentContext) {
            state.currentContext = null;
            state.onContextClosedCallbacks.forEach(c => c.call(null));
        }
    }
}
exports.ContextService = ContextService;
//# sourceMappingURL=context-service.js.map