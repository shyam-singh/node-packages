/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import App from 'webruntime/app';
import { createElement } from 'lwc';
import { subscribe } from 'webruntime/routingService';
import { load } from 'webruntime_loader/loader';
import { reportError } from 'webruntime/errors';
import { default as mockTemplate } from './fixtures/themeLayout';

const { performance } = window;

jest.mock(
    '@app/viewToThemeLayoutMap',
    () => ({
        default: 'themeLayout',
        Inner: 'themeLayout',
    }),
    { virtual: true }
);

beforeEach(() => {
    delete window.performance;
    window.performance = {
        measure: jest.fn(),
    };

    while (document.body.firstChild) {
        document.body.removeChild(document.body.firstChild);
    }

    jest.resetAllMocks();

    subscribe.mockReturnValue({
        unsubscribe: jest.fn(),
    });

    load.mockReturnValue(
        Promise.resolve({
            default: { html: mockTemplate.html, attributes: mockTemplate.attributes },
        })
    );
});

afterEach(() => {
    jest.clearAllMocks();
    window.performance = performance;
});

jest.mock('webruntime_loader/loader', () => {
    return {
        load: jest.fn(),
    };
});

jest.mock('webruntime/routingService', () => {
    return {
        subscribe: jest.fn(() => {
            return { unsubscribe: jest.fn() };
        }),
    };
});

jest.mock('webruntime/errors', () => ({
    reportError: jest.fn(),
}));

const waitForUnmount = () => {
    // eslint-disable-next-line @lwc/lwc/no-async-operation
    return new Promise(resolve => setTimeout(resolve, 100));
};

describe('webruntime/app', () => {
    it('renders no theme layout', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        expect(element).toMatchSnapshot();
    });

    it('renders the theme layout', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];
        await callback({}, { view: 'Inner' });

        await new Promise(window.requestAnimationFrame);
        expect(element).toMatchSnapshot();
    });

    it('renders the theme layout with empty route params', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];
        await callback({}, { view: 'Inner' });

        await new Promise(window.requestAnimationFrame);
        expect(element).toMatchSnapshot();
    });

    it('renders the theme layout with route params', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];
        await callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'Inner' });

        await new Promise(window.requestAnimationFrame);
        expect(element).toMatchSnapshot();
    });

    it('fetches the template even if the theme layout hasnt changed', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];

        await callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'Inner' });
        expect(load).toHaveBeenCalledTimes(1);

        await callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'Inner' });
        await new Promise(window.requestAnimationFrame);
        expect(load).toHaveBeenCalledTimes(2); // we expect this call to be cached
    });

    it('route params are updated even if the theme layout hasnt changed', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];

        await callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'Inner' });
        expect(load).toHaveBeenCalledTimes(1);

        await callback({ attributes: { recordId: 'FOOBAR' } }, { view: 'Inner' });
        await new Promise(window.requestAnimationFrame);
        expect(load).toHaveBeenCalledTimes(2);
        expect(element).toMatchSnapshot();
    });

    it('subscribes to route changes', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        expect(subscribe).toHaveBeenCalledTimes(1);
    });

    it('unsubscribes when disconnected', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);
        await waitForUnmount();
        document.body.removeChild(element);

        const { unsubscribe } = subscribe.mock.results[0].value;
        expect(unsubscribe).toHaveBeenCalledTimes(1);
    });

    it('sets the right route params when theme layout changes', async () => {
        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];

        await callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'Inner' });
        expect(load).toHaveBeenCalledTimes(1);

        await callback({ attributes: { recordId: 'FOOBAR' } }, { view: 'default' });
        await new Promise(window.requestAnimationFrame);
        expect(load).toHaveBeenCalledTimes(2);
        expect(element).toMatchSnapshot();
    });

    it('reports error if getTemplate fails', async () => {
        load.mockReturnValue(Promise.reject('error'));

        const element = createElement('webruntime-app', { is: App });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];
        await callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'Inner' });

        await new Promise(window.requestAnimationFrame);
        expect(reportError).toHaveBeenCalledWith({
            subject: 'App.getTemplate error',
            error: 'error',
        });
    });
});
