/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { getViewModuleSpecifier } from '@communities-webruntime/common';
import { LightningElement } from 'lwc';
import { subscribe } from 'webruntime/routingService';
import { load } from 'webruntime_loader/loader';
import { reportError } from 'webruntime/errors';
import defaultHtml from './routerContainer.html';

export default class RouterContainer extends LightningElement {
    /**
     * The generated template HTML for the current view
     */
    generatedTemplateHtml = defaultHtml;

    /**
     * The resolved attributes of the current view template
     */
    attributes = {};

    /**
     * Map of the current route parameters
     */
    routeParams = {};

    /**
     * Subscribe to route changes
     */
    connectedCallback() {
        this.subscription = subscribe(this.setRoute.bind(this));
    }

    render() {
        return this.generatedTemplateHtml;
    }

    async setRoute({ attributes = {}, state = {} } = {}, { view } = {}) {
        const viewModuleSpecifier = getViewModuleSpecifier(view);

        // load the new module and report any errors
        let module;
        try {
            // force a rerender of the template by "resetting" the template
            // W-7462929: when routing to the same route, the component doesn't rerender
            this.generatedTemplateHtml = defaultHtml;

            module = await load(viewModuleSpecifier);
        } catch (error) {
            reportError({ subject: 'routerContainer.getTemplate error', error });
        }

        if (module) {
            const template = module.default;
            this.generatedTemplateHtml = template.html;

            // set the route params for the template
            this.routeParams = { ...state, ...attributes };
            this.attributes = template.attributes(this);
        }
    }

    disconnectedCallback() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }

    errorCallback(error, wcstack) {
        reportError({ subject: 'router level error', error, wcstack });
    }
}
