/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { createElement } from 'lwc';
import RouterContainer from 'webruntime/routerContainer';
import { subscribe } from 'webruntime/routingService';
import { reportError } from 'webruntime/errors';
import { load } from 'webruntime_loader/loader';
import { default as mockAbout } from './fixtures/aboutTemplate';

jest.mock('webruntime_loader/loader');

jest.mock('webruntime/routingService', () => {
    return {
        subscribe: jest.fn(() => {
            return { unsubscribe: jest.fn() };
        }),
    };
});

jest.mock('webruntime/errors', () => ({
    reportError: jest.fn(),
}));

beforeEach(() => {
    while (document.body.firstChild) {
        document.body.removeChild(document.body.firstChild);
    }

    jest.resetAllMocks();

    subscribe.mockReturnValue({
        unsubscribe: jest.fn(),
    });

    load.mockReturnValue(
        Promise.resolve({ default: { html: mockAbout.html, attributes: mockAbout.attributes } })
    );
});

afterEach(() => {
    jest.clearAllMocks();
});

const waitForUnmount = () => {
    // eslint-disable-next-line @lwc/lwc/no-async-operation
    return new Promise(resolve => setTimeout(resolve, 100));
};

describe('webruntime/routerContainer', () => {
    it('renders no route', async () => {
        const element = createElement('webruntime-router-container', { is: RouterContainer });
        document.body.appendChild(element);

        expect(element).toMatchSnapshot();
    });

    it('renders route', () => {
        const element = createElement('webruntime-router-container', { is: RouterContainer });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];
        callback({}, { view: 'about' });

        return new Promise(window.requestAnimationFrame).then(() => {
            expect(element).toMatchSnapshot();
        });
    });

    it('renders route with empty route params', () => {
        const element = createElement('webruntime-router-container', { is: RouterContainer });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];
        callback({}, { view: 'about' });

        return new Promise(window.requestAnimationFrame).then(() => {
            expect(element).toMatchSnapshot();
        });
    });

    it('renders route with route params', () => {
        const element = createElement('webruntime-router-container', { is: RouterContainer });
        document.body.appendChild(element);

        const callback = subscribe.mock.calls[0][0];
        callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'about' });

        return new Promise(window.requestAnimationFrame).then(() => {
            expect(element).toMatchSnapshot();
        });
    });

    it('subscribes to route changes', async () => {
        const element = createElement('webruntime-router-container', { is: RouterContainer });
        document.body.appendChild(element);

        expect(subscribe).toHaveBeenCalledTimes(1);
    });

    it('unsubscribes when disconnected', async () => {
        const element = createElement('webruntime-router-container', { is: RouterContainer });
        document.body.appendChild(element);
        await waitForUnmount();
        document.body.removeChild(element);

        const { unsubscribe } = subscribe.mock.results[0].value;
        expect(unsubscribe).toHaveBeenCalledTimes(1);
    });

    it('reports error if getTemplate fails', () => {
        load.mockReturnValue(Promise.reject('error'));

        const element = createElement('webruntime-router-container', { is: RouterContainer });
        document.body.appendChild(element);
        const callback = subscribe.mock.calls[0][0];
        callback({ attributes: { recordId: '001xx000003GYQxAAO' } }, { view: 'Inner' });
        return new Promise(window.requestAnimationFrame).then(() => {
            expect(reportError).toHaveBeenCalledWith({
                subject: 'routerContainer.getTemplate error',
                error: 'error',
            });
        });
    });
});
