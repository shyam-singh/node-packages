/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { isObject, transferProperty } from 'webruntime/utils';
import {
    createRouter,
    generateUrl as webruntimeGenerateUrl,
    navigate as webruntimeNavigate,
    subscribe as webruntimeSubscribe,
} from 'webruntime_navigation/navigation';

import basePath from '@app/basePath';
import routes from '@app/routes';
import isGuest from '@salesforce/user/isGuest';

// find the default route definition to use as a fallback
const defaultRouteDef = routes.find(route => route.isDefault);

const config = {
    basePath,
    caseSensitive: true,
    routes: routes,
    handleNavigation,
    getRouteFromUrl,
    getUrlFromRoute,
};

// create, configure and start the router
const router = createRouter(config)
    .addPreNavigate(isAuthorized)
    .addErrorNavigate(handleError);

router.connect();

/**
 * When navigating to a standard__webPage typed route, open absolute URLs directly.
 * Then block propagation of the navigation event up the router tree.
 *
 * @param {object | string} route - The input to navigate(), could be a string URL or a route object
 */
function handleNavigation(route) {
    if (isObject(route)) {
        const { type, attributes: { url } = { url: null } } = route;
        if (type === 'standard__webPage' && isAbsoluteURL(url)) {
            window.open(url);
            return false;
        }
    }
    return true;
}

/**
 * Override the default URL => route translation
 *
 * @param {string} url - A URL to transform into a route
 * @param {function} defaultImpl - The default implementation of the getRouteFromUrl function
 *
 * @returns {object} - { route: route object, data: route definition object }
 */
function getRouteFromUrl(url, defaultImpl) {
    let { route, data } = defaultImpl(url);

    // Return the default route if no match is found for the URL
    if (route.type === 'standard__simpleRoute') {
        data = defaultRouteDef;
    }

    // Move filterName attribute to state for on-core standard__objectPages
    if (route.type === 'standard__objectPage' && data.path.includes('filterName')) {
        route = transferProperty(route, 'state', 'attributes', 'filterName', 'Default');
    }

    // Move attribute.term to state.term for on-core standard__search
    if (route.type === 'standard__search' && data.path.includes('term')) {
        route = transferProperty(route, 'state', 'attributes', 'term', ' ');
    }

    return { route, data };
}

/**
 * Override the default route => URL translation
 *
 * @param {object} route - A route to transform into a URL, including the queryParams as 'state'
 * @param {function} defaultImpl - The default implementation of the getUrlFromRoute function
 *
 * @returns {object} - { url: string URL, data: route definition object }
 */
function getUrlFromRoute(route = {}, defaultImpl) {
    const { type, attributes: { url } = {} } = route;

    // Return URL directly from standard__webPage types
    if (type === 'standard__webPage') {
        return { url: url ? addBasePath(url) : null, data: null };
    }

    // Move filterName state to attributes for on-core standard__objectPages
    if (type === 'standard__objectPage' && !defaultImpl(route).url) {
        route = transferProperty(route, 'attributes', 'state', 'filterName', 'Default');
    }

    // Move state.term to attributes.term for on-core standard__search
    if (type === 'standard__search' && !defaultImpl(route).url) {
        route = transferProperty(route, 'attributes', 'state', 'term', ' ');
    }

    return defaultImpl(route);
}

/**
 * Is the current user allowed to open this route (page)
 * Public routes -> all users are allowed, Private routes -> only authenticated users
 *
 * If isPublic is not defined on routes -> isAuthorized will always return true
 * @param {object} obj - A transaction object
 * @param {object} obj.next - The information that is next in line for navigation
 * @param {object} obj.next.route - The next route
 * @param {object} obj.next.data - The next route definition
 *
 * @returns {boolean}
 */
async function isAuthorized({ next: { route, data } = {} } = {}) {
    // if guest user trying to access private page -> not authorized
    // check user is allowed to visit page -> if not reload and let the server redirect to the correct login page
    if (isGuest && 'isPublic' in data && !data.isPublic) {
        const url = await generateUrl(route);
        if (url) {
            window.location.href = `${url}`;
        }
        return false;
    }
    return true;
}

/**
 * Handle any navigation error
 *
 * @param {object} error - An error message object
 * @param {string} error.code - An error code
 * @param {int} error.level - An error level
 * @param {string} error.message - An error message
 * @param {string} error.url - The destination URL for which the error occurred, or empty string if not applicable
 */
function handleError({ code, message, url }) {
    // if navigation fails, go to the Error page (aka the "default" route)
    navigate(defaultRouteDef);
    throw new Error(`Routing error: (${code}) ${message} ${url}`);
}

/**
 * Check whether url is absolute url
 *
 * @param {string} url - the url
 */
function isAbsoluteURL(url) {
    return new RegExp('^([a-z]+://|//)', 'i').test(url);
}

/**
 * Normalize a given absolute path with the base path.
 *
 * @param {string} url - A URL to be normalized
 */
function addBasePath(url) {
    if (isAbsoluteURL(url)) {
        return url;
    }
    const baseMissing = basePath && url !== basePath && url.indexOf(`${basePath}/`) !== 0;
    return baseMissing ? `${basePath}${url}` : url;
}

/* Compose the routing APIs with this router's navigation context ID
       This way, Web Runtime API users do not need to know about navigation context
       APIs: navigate, generateUrl, subscribe            */

/**
 * Navigate programmatically.
 *
 * @param {object | string} loc - A route or URL for navigating
 * @param {*} options - Usually a boolean; when true the previous browser history
 *              entry should be replaced by this one
 */
function navigate(loc, options) {
    webruntimeNavigate(router.id, loc, options);
}

/**
 * Generate a URL for the given route.
 *
 * @param {object} route - A route
 *
 * @returns {Promise<string>}
 */
function generateUrl(route) {
    return webruntimeGenerateUrl(router.id, route);
}

/**
 * Subscribe to navigation state changes.
 *
 * @param {function} callback - A callback function invoked when the navigation state changes
 *                     callback(route, routeDef)
 * @param {boolean} replay - Flag to determine if callback should be called with current route and data immediately
 */
function subscribe(callback, replay = true) {
    webruntimeSubscribe(router.id, callback, replay);
}

// export select functions from this instance
export { navigate, generateUrl, subscribe };
