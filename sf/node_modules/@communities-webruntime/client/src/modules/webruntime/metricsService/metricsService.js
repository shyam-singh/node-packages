/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import { METRICS_PATH_PREFIX, WEBRUNTIME_PREFIX } from '@communities-webruntime/common';
import { sendBeacon } from 'webruntime/transport';

/**
 * Check for supports for browser APIs that does not have shims
 */
const supports = {
    hostname: Boolean(window.location && window.location.hostname),
    pathname: Boolean(
        window.location &&
            window.location.pathname !== undefined &&
            window.location.pathname !== null
    ),
    rtt: Boolean(
        window.navigator && window.navigator.connection && window.navigator.connection.rtt
    ),
    PerformanceObserver: Boolean(window.PerformanceObserver),
    PerformancePaintTiming: Boolean(window.PerformancePaintTiming),
    PerformanceResourceTiming: Boolean(window.PerformanceResourceTiming),
    getEntriesByType: Boolean(window.performance.getEntriesByType),
    getEntriesByName: Boolean(window.performance.getEntriesByName),
};

/**
 * Maps to https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType
 */
const PERFORMANCE_ENTRY_TYPE = {
    MARK: 'mark',
    RESOURCE: 'resource',
    MEASURE: 'measure',
    PAINT: 'paint',
    NAVIGATION: 'navigation',
    LONGTASK: 'longtask',
    FRAME: 'frame',
};

/**
 * Holds the metadata for metrics entries
 */
const metadataMap = {};

/**
 * Callback for PerformanceObserver
 * @param {*} PerformanceObserverEntryList
 */
function perfObserver() {
    sendBootstrapMetrics();
}

/**
 * Store the metadata for performance entry objects
 *
 * @param {*} type
 * @param {*} name
 * @param {*} metadata
 */
function setMetadata(type, name, metadata) {
    metadataMap[`${type}${name}`] = metadata;
}

/**
 * Send performance entries objects to the metrics endpoint
 */
function send(payload) {
    sendBeacon({
        path: METRICS_PATH_PREFIX,
        payload: prepPayload(payload),
        contentType: 'text/plain;charset=UTF-8',
    });
}

/**
 * Fetches and send all bootstrap-related metrics
 */
function sendBootstrapMetrics() {
    send({
        bootstrap: getBootstrapMetrics(),
        navigator: getNavigatorMetrics(),
        resources: getResourceMetrics(),
        paint: getPaintMetrics(),
        location: getLocationMetrics(),
    });
}

/**
 * Prepare the payload for sending to the metrics end pont
 */
function prepPayload(payload) {
    const stringifiedPayload = JSON.stringify(payload);
    // trims the size of the payload by rounding all numbers to max 2 decimal places
    return stringifiedPayload.replace(/(":)(\d+\.\d{2,})/g, (_match, p1, p2) => {
        return p1 + Number(p2).toFixed(2);
    });
}

/**
 * Fetches location-related metrics
 */
function getLocationMetrics() {
    return {
        hostname: supports.hostname ? window.location.hostname : null,
        pathname: supports.pathname ? window.location.pathname : null,
    };
}

/**
 * Fetches window paint related metrics
 */
function getPaintMetrics() {
    return supports.PerformancePaintTiming && supports.getEntriesByType
        ? window.performance.getEntriesByType(PERFORMANCE_ENTRY_TYPE.PAINT)
        : null;
}

/**
 * Fetches resource-related metrics
 */
function getResourceMetrics() {
    return supports.PerformanceResourceTiming && supports.getEntriesByType
        ? window.performance.getEntriesByType(PERFORMANCE_ENTRY_TYPE.RESOURCE)
        : null;
}

/**
 * Fetches app and framework bootstrap metrics
 */
function getBootstrapMetrics() {
    if (!supports.getEntriesByName) {
        return null;
    }

    const appBootstrap = window.performance.getEntriesByName(`${WEBRUNTIME_PREFIX}-app-bootstrap`);
    const frameworkBootstrap = window.performance.getEntriesByName(
        `${WEBRUNTIME_PREFIX}-framework-bootstrap`
    );
    return [...appBootstrap, ...frameworkBootstrap];
}

/**
 * Fetches metrics-relevant data from window.navigator if available
 */
function getNavigatorMetrics() {
    return supports.rtt
        ? {
              'connection.rtt': window.navigator.connection.rtt,
          }
        : null;
}

if (supports.PerformanceObserver && supports.PerformancePaintTiming) {
    // instantiate the PerformanceObserver and start observing
    const observer = new window.PerformanceObserver(perfObserver);
    observer.observe({ entryTypes: [PERFORMANCE_ENTRY_TYPE.PAINT] });
} else {
    // send data on window unload
    window.addEventListener(
        'unload',
        () => {
            sendBootstrapMetrics();
        },
        false
    );
}

export { send, sendBootstrapMetrics, setMetadata, PERFORMANCE_ENTRY_TYPE, supports };
