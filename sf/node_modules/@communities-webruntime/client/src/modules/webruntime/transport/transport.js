/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

import basePath from '@app/basePath';
import csrfToken from '@app/csrfToken'; // eslint-disable-line import/no-unresolved
import { assert } from 'webruntime/utils';
import { API_PATH_PREFIX } from '@communities-webruntime/common';

const methodsWithCSRF = ['POST', 'PATCH', 'PUT', 'DELETE'];

/**
 * Makes a request using the fetch API with the given path, method and body.
 *
 * This method takes care of setting the credentials to 'same-origin'
 * and adds the Content-Type header if a body is passed.
 *
 * @param {String} path - The request path, should be absolute but we prepend /<basePath>/api to it
 * @param {Object} init - An options object containing any custom settings that you want to apply to the request.
 * @param {String} init.credentials - The request credentials you want to use for the request, same-origin unless specified
 * @param {String} init.headers - Overrides the HTTP headers
 * @param {String} init.basePath - Overrides the default base path of @app/basePath + API_PATH_PREFIX
 */
async function fetch(path, init = {}) {
    assert(path, 'Path not provided for API request');
    const initParams = {
        ...init,
        headers: { ...init.headers },
        credentials: init.credentials || 'same-origin',
    };

    const url =
        initParams.basePath !== undefined
            ? initParams.basePath + path
            : basePath + API_PATH_PREFIX + path;

    initParams.headers['Content-Type'] =
        initParams.headers['Content-Type'] || (init.body && 'application/json; charset=utf-8');

    addCSRFToken(initParams);

    return window.fetch(url, initParams);
}

function addCSRFToken(params) {
    if (params.method && methodsWithCSRF.includes(params.method)) {
        if (csrfToken) {
            params.headers['CSRF-Token'] = csrfToken;
        }
    }
}

/**
 * Makes a POST request using window.navigator if supported. If not, falls back to fetch POST.
 *
 * @param {*} param parameter containing path, payload, contentType
 * @param {String} param.path url to send the request
 * @param {*} param.payload object to send as the payload of the request
 * @param {String} param.contentType contentType of the payload
 */
function sendBeacon({ path, payload, contentType }) {
    const url = basePath + path;
    const sentBeacon =
        window.navigator &&
        window.navigator.sendBeacon &&
        window.navigator.sendBeacon(url, payload);
    if (!sentBeacon) {
        fetch(path, {
            headers: { 'Content-Type': contentType },
            basePath,
            body: payload,
            method: 'POST',
        });
    }
}

export { fetch, sendBeacon };
