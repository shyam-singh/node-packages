/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

const { navigator } = window;

window.fetch = jest.fn(async () => ({ ok: true, json: () => ({}) }));
const { fetch } = window;

beforeEach(() => {
    jest.resetAllMocks();
    jest.resetModules();
    delete window.navigator;
    window.navigator = {
        sendBeacon: jest.fn(() => true),
    };
});

afterEach(() => {
    jest.clearAllMocks();
    window.navigator = navigator;
});

describe('webruntime/transport/sendBeacon', () => {
    it('uses sendBeacon when supported', () => {
        jest.mock('@app/basePath', () => '/test', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { sendBeacon } = require('../transport');

        // send beacon
        const path = '/test/beacon';
        const subject = 'hej';
        const payload = JSON.stringify({
            subject,
        });
        sendBeacon({
            path,
            payload,
            contentType: '',
        });

        // assertions
        expect(window.navigator.sendBeacon).toHaveBeenCalledWith(`/test${path}`, payload);
    });
    it('uses fetch when sendBeacon is not supported', () => {
        jest.mock('@app/basePath', () => '/mock', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { sendBeacon } = require('../transport');

        // delete window.navigator to mock unsupported browsers
        delete window.navigator;

        // send beacon
        const path = '/beacon';
        const subject = 'hej';
        const contentType = 'text/plain;charset=UTF-8';
        const payload = JSON.stringify({
            subject,
        });
        sendBeacon({
            path,
            payload,
            contentType,
        });

        // assertions
        expect(fetch).toHaveBeenCalledWith(`/mock${path}`, {
            body: payload,
            basePath: '/mock',
            credentials: 'same-origin',
            headers: {
                'Content-Type': contentType,
            },
            method: 'POST',
        });
    });
    it('uses fetch when sendBeacon returns false', () => {
        // mock failure state
        window.navigator.sendBeacon.mockReturnValue(false);
        jest.mock('@app/basePath', () => '', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { sendBeacon } = require('../transport');

        // send beacon
        const subject = 'something happened';
        const path = '/beacon';
        const contentType = 'text/plain;charset=UTF-8';
        const payload = JSON.stringify({
            subject,
        });
        sendBeacon({
            path,
            payload,
            contentType,
        });

        // assertions
        expect(window.navigator.sendBeacon).toHaveBeenCalled();
        expect(fetch).toHaveBeenCalled();
    });
});

describe('webruntime/transport/fetch', () => {
    it('fetches', async () => {
        jest.mock('@app/basePath', () => '', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { fetch: ourFetch } = require('../transport');

        ourFetch('/resource?a=1');

        expect(fetch).toHaveBeenCalledTimes(1);
        expect(fetch).toHaveBeenCalledWith('/webruntime/api/resource?a=1', {
            body: undefined,
            credentials: 'same-origin',
            headers: { 'Content-Type': undefined },
            method: undefined,
        });
    });
    it('fetches with body', async () => {
        jest.mock('@app/basePath', () => '', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { fetch: ourFetch } = require('../transport');

        ourFetch('/resource', { body: JSON.stringify({ a: 1 }) });

        expect(fetch).toHaveBeenCalledTimes(1);
        expect(fetch).toHaveBeenCalledWith('/webruntime/api/resource', {
            body: '{"a":1}',
            credentials: 'same-origin',
            headers: { 'Content-Type': 'application/json; charset=utf-8' },
            method: undefined,
        });
    });
    it('adds base path', async () => {
        jest.mock('@app/basePath', () => '/webruntime', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { fetch: ourFetch } = require('../transport');

        ourFetch('/resource');

        expect(fetch).toHaveBeenCalledTimes(1);
        expect(fetch).toHaveBeenCalledWith('/webruntime/webruntime/api/resource', {
            body: undefined,
            credentials: 'same-origin',
            headers: { 'Content-Type': undefined },
            method: undefined,
        });
    });
    it('returns json', async () => {
        fetch.mockImplementationOnce(async () => ({ ok: true, json: () => ({ b: 3 }) }));
        jest.mock('@app/basePath', () => '', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { fetch: ourFetch } = require('../transport');

        const response = await ourFetch({});
        expect(response.ok).toBe(true);
        expect(response.json().b).toEqual(3);
    });
    it('throws when response is not ok', async () => {
        const error = { ok: false, statusText: 'statusText' };
        fetch.mockImplementationOnce(async () => Promise.reject(error));
        jest.mock('@app/basePath', () => '', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { fetch: ourFetch } = require('../transport');

        return expect(ourFetch({})).rejects.toEqual(error);
    });
    it('does not mutate the actual input params', async () => {
        jest.mock('@app/basePath', () => '', { virtual: true });
        jest.mock('@app/csrfToken', () => '', { virtual: true });
        const { fetch: ourFetch } = require('../transport');

        const init = {
            body: JSON.stringify({ a: 1 }),
            credentials: 'include',
            headers: { 'Content-Type': 'application/xml; charset=iso-8859-8' },
            method: 'POST',
            random: 'Not_Used_By_Fetch',
        };
        ourFetch('/resource', Object.freeze(init));

        expect(fetch).toHaveBeenCalledTimes(1);
        expect(fetch).toHaveBeenCalledWith('/webruntime/api/resource', {
            body: '{"a":1}',
            credentials: 'include',
            headers: { 'Content-Type': 'application/xml; charset=iso-8859-8' },
            method: 'POST',
            random: 'Not_Used_By_Fetch',
        });
    });
    ['POST', 'PATCH', 'PUT', 'DELETE'].forEach(verb => {
        it(`adds CSRF token for ${verb} if available`, async () => {
            jest.mock('@app/basePath', () => '', { virtual: true });
            jest.mock('@app/csrfToken', () => 'test_CSRF', { virtual: true });
            const { fetch: ourFetch } = require('../transport');

            ourFetch('/resource', { method: verb });

            expect(fetch).toHaveBeenCalledTimes(1);
            expect(fetch).toHaveBeenCalledWith('/webruntime/api/resource', {
                body: undefined,
                credentials: 'same-origin',
                headers: { 'CSRF-Token': 'test_CSRF', 'Content-Type': undefined },
                method: verb,
            });
        });
    });
    ['GET', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'].forEach(verb => {
        it(`does not add CSRF token for ${verb} request`, async () => {
            jest.mock('@app/basePath', () => '', { virtual: true });
            jest.mock('@app/csrfToken', () => 'test_CSRF', { virtual: true });
            const { fetch: ourFetch } = require('../transport');

            ourFetch('/resource', { method: verb });

            expect(fetch).toHaveBeenCalledTimes(1);
            expect(fetch).toHaveBeenCalledWith('/webruntime/api/resource', {
                body: undefined,
                credentials: 'same-origin',
                headers: { 'Content-Type': undefined },
                method: verb,
            });
        });
    });
    it('overrides CSRF token if specified', async () => {
        jest.mock('@app/basePath', () => '', { virtual: true });
        jest.mock('@app/csrfToken', () => 'test_CSRF', { virtual: true });
        const { fetch: ourFetch } = require('../transport');

        ourFetch('/resource', { headers: { 'CSRF-Token': 'Override_Me' }, method: 'POST' });

        expect(fetch).toHaveBeenCalledTimes(1);
        expect(fetch).toHaveBeenCalledWith('/webruntime/api/resource', {
            body: undefined,
            credentials: 'same-origin',
            headers: { 'CSRF-Token': 'test_CSRF', 'Content-Type': undefined },
            method: 'POST',
        });
    });
});
