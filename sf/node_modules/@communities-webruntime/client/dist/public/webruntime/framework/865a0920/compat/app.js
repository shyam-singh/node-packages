Webruntime.define('@webruntime/app', ['proxy-compat/callKey1', 'proxy-compat/callKey2', 'proxy-compat/concat', 'proxy-compat/callKey3', 'proxy-compat/callKey0', '@babel/runtime/helpers/slicedToArray', '@app/basePath', 'webruntime_loader/loader', '@babel/runtime/helpers/get', '@babel/runtime/helpers/assertThisInitialized', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/inherits', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', '@babel/runtime/helpers/instanceof', '@babel/runtime/helpers/typeof', 'proxy-compat/setKey', '@babel/runtime/helpers/toConsumableArray', 'proxy-compat/inKey', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', '@app/csrfToken', 'proxy-compat/deleteKey', '@babel/runtime/helpers/defineProperty', 'proxy-compat/callKey4', '@app/routes', '@salesforce/user/isGuest', '@babel/runtime/helpers/objectDestructuringEmpty', '@app/viewToThemeLayoutMap', '@app/brandingProperties'], function (__callKey1, __callKey2, __concat, __callKey3, __callKey0, _slicedToArray, basePath, loader, _get, _assertThisInitialized, _possibleConstructorReturn, _getPrototypeOf, _inherits, _classCallCheck, _createClass, _instanceof, _typeof, __setKey, _toConsumableArray, __inKey, _regeneratorRuntime, _asyncToGenerator, csrfToken, __deleteKey, _defineProperty2, __callKey4, routes, isGuest, _objectDestructuringEmpty, viewToThemeLayoutMap, props) { 'use strict';

    __callKey1 = __callKey1 && __callKey1.hasOwnProperty('default') ? __callKey1['default'] : __callKey1;
    __callKey2 = __callKey2 && __callKey2.hasOwnProperty('default') ? __callKey2['default'] : __callKey2;
    __concat = __concat && __concat.hasOwnProperty('default') ? __concat['default'] : __concat;
    __callKey3 = __callKey3 && __callKey3.hasOwnProperty('default') ? __callKey3['default'] : __callKey3;
    __callKey0 = __callKey0 && __callKey0.hasOwnProperty('default') ? __callKey0['default'] : __callKey0;
    _slicedToArray = _slicedToArray && _slicedToArray.hasOwnProperty('default') ? _slicedToArray['default'] : _slicedToArray;
    basePath = basePath && basePath.hasOwnProperty('default') ? basePath['default'] : basePath;
    _get = _get && _get.hasOwnProperty('default') ? _get['default'] : _get;
    _assertThisInitialized = _assertThisInitialized && _assertThisInitialized.hasOwnProperty('default') ? _assertThisInitialized['default'] : _assertThisInitialized;
    _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;
    _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;
    _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;
    _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;
    _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;
    _instanceof = _instanceof && _instanceof.hasOwnProperty('default') ? _instanceof['default'] : _instanceof;
    _typeof = _typeof && _typeof.hasOwnProperty('default') ? _typeof['default'] : _typeof;
    __setKey = __setKey && __setKey.hasOwnProperty('default') ? __setKey['default'] : __setKey;
    _toConsumableArray = _toConsumableArray && _toConsumableArray.hasOwnProperty('default') ? _toConsumableArray['default'] : _toConsumableArray;
    __inKey = __inKey && __inKey.hasOwnProperty('default') ? __inKey['default'] : __inKey;
    _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;
    _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;
    csrfToken = csrfToken && csrfToken.hasOwnProperty('default') ? csrfToken['default'] : csrfToken;
    __deleteKey = __deleteKey && __deleteKey.hasOwnProperty('default') ? __deleteKey['default'] : __deleteKey;
    _defineProperty2 = _defineProperty2 && _defineProperty2.hasOwnProperty('default') ? _defineProperty2['default'] : _defineProperty2;
    __callKey4 = __callKey4 && __callKey4.hasOwnProperty('default') ? __callKey4['default'] : __callKey4;
    routes = routes && routes.hasOwnProperty('default') ? routes['default'] : routes;
    isGuest = isGuest && isGuest.hasOwnProperty('default') ? isGuest['default'] : isGuest;
    _objectDestructuringEmpty = _objectDestructuringEmpty && _objectDestructuringEmpty.hasOwnProperty('default') ? _objectDestructuringEmpty['default'] : _objectDestructuringEmpty;
    viewToThemeLayoutMap = viewToThemeLayoutMap && viewToThemeLayoutMap.hasOwnProperty('default') ? viewToThemeLayoutMap['default'] : viewToThemeLayoutMap;
    props = props && props.hasOwnProperty('default') ? props['default'] : props;

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * Prefix for log names
     */
    var WEBRUNTIME_PREFIX = 'webruntime';
    /**
     * Add a common prefix to the input URL*
     * @param { string } prefix
     * @param { string } urlString - url part to which the prefix need to be added
     */

    function getPrefixedURL(urlString) {
      return __concat(__concat("/", WEBRUNTIME_PREFIX), urlString);
    }
    /**
     * Path prefix of api calls
     */


    var API_PATH_PREFIX = getPrefixedURL('/api');
    /**
     * Path prefix for Metrics URL
     */

    var METRICS_PATH_PREFIX = getPrefixedURL("/log/metrics");
    /**
     * Path prefix for Errors URL
     */

    var ERRORS_PATH_PREFIX = getPrefixedURL('/log/errors');

    /**
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * Namespaces used for views
     */
    var VIEW_NAMESPACE = '@view';
    /**
     * Returns a module specifier for the view with the given name
     */

    function getViewModuleSpecifier(name) {
      return __concat(__concat("", VIEW_NAMESPACE, "/"), name);
    }

    function sendError(_ref) {
      var _navigator, _sendBeacon;

      var subject = _ref._ES5ProxyType ? _ref.get("subject") : _ref.subject,
          message = _ref._ES5ProxyType ? _ref.get("message") : _ref.message,
          stack = _ref._ES5ProxyType ? _ref.get("stack") : _ref.stack,
          wcstack = _ref._ES5ProxyType ? _ref.get("wcstack") : _ref.wcstack,
          extra = _ref._ES5ProxyType ? _ref.get("extra") : _ref.extra;
      var url = basePath + ERRORS_PATH_PREFIX;

      var _window$location = window._ES5ProxyType ? window.get("location") : window.location,
          pathname = _window$location._ES5ProxyType ? _window$location.get("pathname") : _window$location.pathname,
          hostname = _window$location._ES5ProxyType ? _window$location.get("hostname") : _window$location.hostname;

      var location = {
        pathname: pathname,
        hostname: hostname
      };
      var body = JSON.stringify({
        subject: subject,
        message: message,
        stack: stack,
        wcstack: wcstack,
        extra: extra,
        location: location
      }); // we are not using webruntime/transport/sendBeacon here because it would push the module down in the compiled js
      // and we want this to be high up to catch any errrors occuring early in the js

      var sentBeacon = (window._ES5ProxyType ? window.get("navigator") : window.navigator) && (_navigator = window._ES5ProxyType ? window.get("navigator") : window.navigator, _sendBeacon = _navigator._ES5ProxyType ? _navigator.get("sendBeacon") : _navigator.sendBeacon) && __callKey2(window._ES5ProxyType ? window.get("navigator") : window.navigator, "sendBeacon", url, body);

      if (!sentBeacon) {
        var xhr = new XMLHttpRequest();

        __callKey3(xhr, "open", 'POST', url, true);

        __callKey2(xhr, "setRequestHeader", 'Content-Type', 'text/plain;charset=UTF-8');

        __callKey1(xhr, "send", body);
      }
    }

    function reportError(_ref2) {
      var subject = _ref2._ES5ProxyType ? _ref2.get("subject") : _ref2.subject,
          _ref2$error = _ref2._ES5ProxyType ? _ref2.get("error") : _ref2.error,
          error = _ref2$error === void 0 ? {} : _ref2$error,
          extra = _ref2._ES5ProxyType ? _ref2.get("extra") : _ref2.extra;

      var message = error._ES5ProxyType ? error.get("message") : error.message,
          stack = error._ES5ProxyType ? error.get("stack") : error.stack,
          wcstack = error._ES5ProxyType ? error.get("wcstack") : error.wcstack;
      sendError({
        subject: subject,
        message: message,
        stack: stack,
        wcstack: wcstack,
        extra: extra
      });
    }

    __callKey2(window, "addEventListener", 'error', function () {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var msg = event._ES5ProxyType ? event.get("msg") : event.msg,
          filename = event._ES5ProxyType ? event.get("filename") : event.filename,
          lineno = event._ES5ProxyType ? event.get("lineno") : event.lineno,
          colno = event._ES5ProxyType ? event.get("colno") : event.colno,
          error = event._ES5ProxyType ? event.get("error") : event.error;
      reportError({
        subject: 'window error',
        error: error,
        extra: {
          msg: msg,
          filename: filename,
          lineno: lineno,
          colno: colno
        }
      });
    });

    __callKey2(window, "addEventListener", 'unhandledrejection', function () {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      // extract the data we want to send to the server
      var _event$reason = event._ES5ProxyType ? event.get("reason") : event.reason,
          reason = _event$reason === void 0 ? {} : _event$reason;

      reportError({
        subject: 'unhandledrejection',
        error: reason
      });
    });

    /* proxy-compat-disable */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect() {
      // Don't apply polyfill when ProxyCompat is enabled.
      if ('getKey' in Proxy) {
        return false;
      }

      var proxy = new Proxy([3, 4], {});
      var res = [1, 2].concat(proxy);
      return res.length !== 4;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var isConcatSpreadable = Symbol.isConcatSpreadable;
    var isArray = Array.isArray;
    var _Array$prototype = Array.prototype,
        ArraySlice = _Array$prototype.slice,
        ArrayUnshift = _Array$prototype.unshift,
        ArrayShift = _Array$prototype.shift;

    function isObject(O) {
      return _typeof(O) === 'object' ? O !== null : typeof O === 'function';
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable


    function isSpreadable(O) {
      if (!isObject(O)) {
        return false;
      }

      var spreadable = O[isConcatSpreadable];
      return spreadable !== undefined ? Boolean(spreadable) : isArray(O);
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat


    function ArrayConcatPolyfill() {
      for (var _len = arguments.length, _args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        _args[_key2] = arguments[_key2];
      }

      var O = Object(this);
      var A = [];
      var N = 0;
      var items = ArraySlice.call(arguments);
      ArrayUnshift.call(items, O);

      while (items.length) {
        var E = ArrayShift.call(items);

        if (isSpreadable(E)) {
          var _k = 0;
          var length = E.length;

          for (_k; _k < length; _k += 1, N += 1) {
            if (_k in E) {
              var subElement = E[_k];
              A[N] = subElement;
            }
          }
        } else {
          A[N] = E;
          N += 1;
        }
      }

      return A;
    }

    function apply() {
      Array.prototype.concat = ArrayConcatPolyfill;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    if (detect()) {
      apply();
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function detect$1(propName) {
      return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var _Element$prototype = Element.prototype,
        hasAttribute = _Element$prototype.hasAttribute,
        getAttribute = _Element$prototype.getAttribute,
        setAttribute = _Element$prototype.setAttribute,
        removeAttribute = _Element$prototype.removeAttribute;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // that doesn't follow the regular transformation process. e.g.: `aria-labeledby` <=> `ariaLabelBy`

    var ARIA_REGEX = /^aria/;
    var nodeToAriaPropertyValuesMap = new WeakMap();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var _String$prototype = String.prototype,
        StringReplace = _String$prototype.replace,
        StringToLowerCase = _String$prototype.toLowerCase;

    function getAriaPropertyMap(elm) {
      var map = nodeToAriaPropertyValuesMap.get(elm);

      if (map === undefined) {
        map = {};
        nodeToAriaPropertyValuesMap.set(elm, map);
      }

      return map;
    }

    function getNormalizedAriaPropertyValue(value) {
      return value == null ? null : value + '';
    }

    function createAriaPropertyPropertyDescriptor(propName, attrName) {
      return {
        get: function get() {
          var map = getAriaPropertyMap(this);

          if (hasOwnProperty.call(map, propName)) {
            return map[propName];
          } // otherwise just reflect what's in the attribute


          return hasAttribute.call(this, attrName) ? getAttribute.call(this, attrName) : null;
        },
        set: function set(newValue) {
          var normalizedValue = getNormalizedAriaPropertyValue(newValue);
          var map = getAriaPropertyMap(this);
          map[propName] = normalizedValue; // reflect into the corresponding attribute

          if (newValue === null) {
            removeAttribute.call(this, attrName);
          } else {
            setAttribute.call(this, attrName, newValue);
          }
        },
        configurable: true,
        enumerable: true
      };
    }

    function patch(propName) {
      // Typescript is inferring the wrong function type for this particular
      // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
      // @ts-ignore type-mismatch
      var replaced = StringReplace.call(propName, ARIA_REGEX, 'aria-');
      var attrName = StringToLowerCase.call(replaced);
      var descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);
      Object.defineProperty(Element.prototype, propName, descriptor);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // https://wicg.github.io/aom/spec/aria-reflection.html


    var ElementPrototypeAriaPropertyNames = ['ariaAutoComplete', 'ariaChecked', 'ariaCurrent', 'ariaDisabled', 'ariaExpanded', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaLabel', 'ariaLevel', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaPressed', 'ariaReadOnly', 'ariaRequired', 'ariaSelected', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'ariaLive', 'ariaRelevant', 'ariaAtomic', 'ariaBusy', 'ariaActiveDescendant', 'ariaControls', 'ariaDescribedBy', 'ariaFlowTo', 'ariaLabelledBy', 'ariaOwns', 'ariaPosInSet', 'ariaSetSize', 'ariaColCount', 'ariaColIndex', 'ariaDetails', 'ariaErrorMessage', 'ariaKeyShortcuts', 'ariaModal', 'ariaPlaceholder', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaColSpan', 'role'];
    /**
     * Note: Attributes aria-dropeffect and aria-grabbed were deprecated in
     * ARIA 1.1 and do not have corresponding IDL attributes.
     */

    for (var _i = 0, len = ElementPrototypeAriaPropertyNames.length; _i < len; _i += 1) {
      var propName = ElementPrototypeAriaPropertyNames[_i];

      if (detect$1(propName)) {
        patch(propName);
      }
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function invariant(value, msg) {
      if (!value) {
        throw new Error("Invariant Violation: ".concat(msg));
      }
    }

    function isTrue(value, msg) {
      if (!value) {
        throw new Error("Assert Violation: ".concat(msg));
      }
    }

    function isFalse(value, msg) {
      if (value) {
        throw new Error("Assert Violation: ".concat(msg));
      }
    }

    function fail(msg) {
      throw new Error(msg);
    }

    var assert =
    /*#__PURE__*/
    Object.freeze({
      __proto__: null,
      invariant: invariant,
      isTrue: isTrue,
      isFalse: isFalse,
      fail: fail
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var assign = Object.assign,
        create = Object.create,
        defineProperties = Object.defineProperties,
        defineProperty = Object.defineProperty,
        freeze = Object.freeze,
        getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
        getOwnPropertyNames = Object.getOwnPropertyNames,
        getPrototypeOf = Object.getPrototypeOf,
        hasOwnProperty$1 = Object.hasOwnProperty,
        keys = Object.keys,
        seal = Object.seal,
        setPrototypeOf = Object.setPrototypeOf;
    var isArray$1 = Array.isArray;
    var _Array$prototype2 = Array.prototype,
        forEach = _Array$prototype2.forEach,
        ArrayIndexOf = _Array$prototype2.indexOf,
        ArrayJoin = _Array$prototype2.join,
        ArrayMap = _Array$prototype2.map,
        ArrayPush = _Array$prototype2.push,
        ArrayReduce = _Array$prototype2.reduce,
        ArraySlice$1 = _Array$prototype2.slice,
        ArrayUnshift$1 = _Array$prototype2.unshift;
    var _String$prototype2 = String.prototype,
        StringCharCodeAt = _String$prototype2.charCodeAt,
        StringReplace$1 = _String$prototype2.replace,
        StringSlice = _String$prototype2.slice,
        StringToLowerCase$1 = _String$prototype2.toLowerCase;

    function isUndefined(obj) {
      return obj === undefined;
    }

    function isNull(obj) {
      return obj === null;
    }

    function isTrue$1(obj) {
      return obj === true;
    }

    function isFalse$1(obj) {
      return obj === false;
    }

    function isFunction(obj) {
      return typeof obj === 'function';
    }

    function isObject$1(obj) {
      return _typeof(obj) === 'object';
    }

    function isString(obj) {
      return typeof obj === 'string';
    }

    function isNumber(obj) {
      return typeof obj === 'number';
    }

    var OtS = {}.toString;

    function toString(obj) {
      if (obj && obj.toString) {
        // Arrays might hold objects with "null" prototype So using
        // Array.prototype.toString directly will cause an error Iterate through
        // all the items and handle individually.
        if (isArray$1(obj)) {
          return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
        }

        return obj.toString();
      } else if (_typeof(obj) === 'object') {
        return OtS.call(obj);
      } else {
        return obj + emptyString;
      }
    }

    function getPropertyDescriptor(o, p) {
      do {
        var _d = getOwnPropertyDescriptor(o, p);

        if (!isUndefined(_d)) {
          return _d;
        }

        o = getPrototypeOf(o);
      } while (o !== null);
    }

    var emptyString = '';
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */

    var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';

    function createHiddenField(key, namespace) {
      return hasNativeSymbolsSupport ? Symbol(key) : "$$lwc-".concat(namespace, "-").concat(key, "$$");
    }

    var hiddenFieldsMap = new WeakMap();

    function setHiddenField(o, field, value) {
      var valuesByField = hiddenFieldsMap.get(o);

      if (isUndefined(valuesByField)) {
        valuesByField = create(null);
        hiddenFieldsMap.set(o, valuesByField);
      }

      valuesByField[field] = value;
    }

    function getHiddenField(o, field) {
      var valuesByField = hiddenFieldsMap.get(o);

      if (!isUndefined(valuesByField)) {
        return valuesByField[field];
      }
    }
    /** version: 1.1.13-224.5 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'tabIndex', 'title']; // Few more exceptions that are using the attribute name to match the property in lowercase.
    // this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx
    // and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
    // Note: this list most be in sync with the compiler as well.

    var HTMLPropertyNamesWithLowercasedReflectiveAttributes = ['accessKey', 'readOnly', 'tabIndex', 'bgColor', 'colSpan', 'rowSpan', 'contentEditable', 'dateTime', 'formAction', 'isMap', 'maxLength', 'useMap'];

    function offsetPropertyErrorMessage(name) {
      return "Using the `".concat(name, "` property is an anti-pattern because it rounds the value to an integer. Instead, use the `getBoundingClientRect` method to obtain fractional values for the size of an element and its position relative to the viewport.");
    } // Global HTML Attributes & Properties
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement


    var globalHTMLProperties = assign(create(null), {
      accessKey: {
        attribute: 'accesskey'
      },
      accessKeyLabel: {
        readOnly: true
      },
      className: {
        attribute: 'class',
        error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.'
      },
      contentEditable: {
        attribute: 'contenteditable'
      },
      dataset: {
        readOnly: true,
        error: "Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."
      },
      dir: {
        attribute: 'dir'
      },
      draggable: {
        attribute: 'draggable'
      },
      dropzone: {
        attribute: 'dropzone',
        readOnly: true
      },
      hidden: {
        attribute: 'hidden'
      },
      id: {
        attribute: 'id'
      },
      inputMode: {
        attribute: 'inputmode'
      },
      lang: {
        attribute: 'lang'
      },
      slot: {
        attribute: 'slot',
        error: 'Using the `slot` property is an anti-pattern.'
      },
      spellcheck: {
        attribute: 'spellcheck'
      },
      style: {
        attribute: 'style'
      },
      tabIndex: {
        attribute: 'tabindex'
      },
      title: {
        attribute: 'title'
      },
      translate: {
        attribute: 'translate'
      },
      // additional "global attributes" that are not present in the link above.
      isContentEditable: {
        readOnly: true
      },
      offsetHeight: {
        readOnly: true,
        error: offsetPropertyErrorMessage('offsetHeight')
      },
      offsetLeft: {
        readOnly: true,
        error: offsetPropertyErrorMessage('offsetLeft')
      },
      offsetParent: {
        readOnly: true
      },
      offsetTop: {
        readOnly: true,
        error: offsetPropertyErrorMessage('offsetTop')
      },
      offsetWidth: {
        readOnly: true,
        error: offsetPropertyErrorMessage('offsetWidth')
      },
      role: {
        attribute: 'role'
      }
    });
    var AttrNameToPropNameMap = create(null);
    var PropNameToAttrNameMap = create(null); // Synthetic creation of all AOM property descriptors for Custom Elements

    forEach.call(ElementPrototypeAriaPropertyNames, function (propName) {
      // Typescript is inferring the wrong function type for this particular
      // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
      // @ts-ignore type-mismatch
      var attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));
      AttrNameToPropNameMap[attrName] = propName;
      PropNameToAttrNameMap[propName] = attrName;
    });
    forEach.call(defaultDefHTMLPropertyNames, function (propName) {
      var attrName = StringToLowerCase$1.call(propName);
      AttrNameToPropNameMap[attrName] = propName;
      PropNameToAttrNameMap[propName] = attrName;
    });
    forEach.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, function (propName) {
      var attrName = StringToLowerCase$1.call(propName);
      AttrNameToPropNameMap[attrName] = propName;
      PropNameToAttrNameMap[propName] = attrName;
    });
    var CAMEL_REGEX = /-([a-z])/g;
    /**
     * This method maps between attribute names
     * and the corresponding property name.
     */

    function getPropNameFromAttrName(attrName) {
      if (isUndefined(AttrNameToPropNameMap[attrName])) {
        AttrNameToPropNameMap[attrName] = StringReplace$1.call(attrName, CAMEL_REGEX, function (g) {
          return g[1].toUpperCase();
        });
      }

      return AttrNameToPropNameMap[attrName];
    }

    var CAPS_REGEX = /[A-Z]/g;
    /**
     * This method maps between property names
     * and the corresponding attribute name.
     */

    function getAttrNameFromPropName(propName) {
      if (isUndefined(PropNameToAttrNameMap[propName])) {
        PropNameToAttrNameMap[propName] = StringReplace$1.call(propName, CAPS_REGEX, function (match) {
          return '-' + match.toLowerCase();
        });
      }

      return PropNameToAttrNameMap[propName];
    }

    var controlledElement = null;
    var controlledAttributeName;

    function isAttributeLocked(elm, attrName) {
      return elm !== controlledElement || attrName !== controlledAttributeName;
    }

    function lockAttribute(_elm, _key) {
      controlledElement = null;
      controlledAttributeName = undefined;
    }

    function unlockAttribute(elm, key) {
      controlledElement = elm;
      controlledAttributeName = key;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var nextTickCallbackQueue = [];
    var SPACE_CHAR = 32;
    var EmptyObject = seal(create(null));
    var EmptyArray = seal([]);

    function flushCallbackQueue() {
      {
        if (nextTickCallbackQueue.length === 0) {
          throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");
        }
      }

      var callbacks = nextTickCallbackQueue;
      nextTickCallbackQueue = []; // reset to a new queue

      for (var _i2 = 0, _len2 = callbacks.length; _i2 < _len2; _i2 += 1) {
        callbacks[_i2]();
      }
    }

    function addCallbackToNextTick(callback) {
      {
        if (!isFunction(callback)) {
          throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");
        }
      }

      if (nextTickCallbackQueue.length === 0) {
        Promise.resolve().then(flushCallbackQueue);
      }

      ArrayPush.call(nextTickCallbackQueue, callback);
    }

    function isCircularModuleDependency(value) {
      return hasOwnProperty$1.call(value, '__circular__');
    }
    /**
     * When LWC is used in the context of an Aura application, the compiler produces AMD
     * modules, that doesn't resolve properly circular dependencies between modules. In order
     * to circumvent this issue, the module loader returns a factory with a symbol attached
     * to it.
     *
     * This method returns the resolved value if it received a factory as argument. Otherwise
     * it returns the original value.
     */


    function resolveCircularModuleDependency(fn) {
      {
        if (!isFunction(fn)) {
          throw new TypeError("Circular module dependency must be a function.");
        }
      }

      return fn();
    }

    var useSyntheticShadow = hasOwnProperty$1.call(Element.prototype, '$shadowToken$');
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    function getComponentTag(vm) {
      // Element.prototype.tagName getter might be poisoned. We need to use a try/catch to protect the
      // engine internal when accessing the tagName property.
      try {
        return "<".concat(StringToLowerCase$1.call(vm.elm.tagName), ">");
      } catch (error) {
        return '<invalid-tag-name>';
      }
    } // TODO [#1695]: Unify getComponentStack and getErrorComponentStack


    function getComponentStack(vm) {
      var stack = [];
      var prefix = '';

      while (!isNull(vm.owner)) {
        ArrayPush.call(stack, prefix + getComponentTag(vm));
        vm = vm.owner;
        prefix += '\t';
      }

      return ArrayJoin.call(stack, '\n');
    }

    function getErrorComponentStack(vm) {
      var wcStack = [];
      var currentVm = vm;

      while (!isNull(currentVm)) {
        ArrayPush.call(wcStack, getComponentTag(currentVm));
        currentVm = currentVm.owner;
      }

      return wcStack.reverse().join('\n\t');
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function logError(message, vm) {
      var msg = "[LWC error]: ".concat(message);

      if (!isUndefined(vm)) {
        msg = "".concat(msg, "\n").concat(getComponentStack(vm));
      }

      try {
        throw new Error(msg);
      } catch (e) {
        /* eslint-disable-next-line no-console */
        console.error(e);
      }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function handleEvent(event, vnode) {
      var type = event.type;
      var on = vnode.data.on;
      var handler = on && on[type]; // call event handler if exists

      if (handler) {
        handler.call(undefined, event);
      }
    }

    function createListener() {
      return function handler(event) {
        handleEvent(event, handler.vnode);
      };
    }

    function updateAllEventListeners(oldVnode, vnode) {
      if (isUndefined(oldVnode.listener)) {
        createAllEventListeners(vnode);
      } else {
        vnode.listener = oldVnode.listener;
        vnode.listener.vnode = vnode;
      }
    }

    function createAllEventListeners(vnode) {
      var on = vnode.data.on;

      if (isUndefined(on)) {
        return;
      }

      var elm = vnode.elm;
      var listener = vnode.listener = createListener();
      listener.vnode = vnode;
      var name;

      for (name in on) {
        elm.addEventListener(name, listener);
      }
    }

    var modEvents = {
      update: updateAllEventListeners,
      create: createAllEventListeners
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xmlNS = 'http://www.w3.org/XML/1998/namespace';
    var ColonCharCode = 58;

    function updateAttrs(oldVnode, vnode) {
      var attrs = vnode.data.attrs;

      if (isUndefined(attrs)) {
        return;
      }

      var oldAttrs = oldVnode.data.attrs;

      if (oldAttrs === attrs) {
        return;
      }

      {
        assert.invariant(isUndefined(oldAttrs) || keys(oldAttrs).join(',') === keys(attrs).join(','), "vnode.data.attrs cannot change shape.");
      }

      var elm = vnode.elm;
      var key;
      oldAttrs = isUndefined(oldAttrs) ? EmptyObject : oldAttrs; // update modified attributes, add new attributes
      // this routine is only useful for data-* attributes in all kind of elements
      // and aria-* in standard elements (custom elements will use props for these)

      for (key in attrs) {
        var cur = attrs[key];
        var old = oldAttrs[key];

        if (old !== cur) {
          unlockAttribute(elm, key);

          if (StringCharCodeAt.call(key, 3) === ColonCharCode) {
            // Assume xml namespace
            elm.setAttributeNS(xmlNS, key, cur);
          } else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {
            // Assume xlink namespace
            elm.setAttributeNS(xlinkNS, key, cur);
          } else if (isNull(cur)) {
            elm.removeAttribute(key);
          } else {
            elm.setAttribute(key, cur);
          }

          lockAttribute();
        }
      }
    }

    var emptyVNode = {
      data: {}
    };
    var modAttrs = {
      create: function create(vnode) {
        return updateAttrs(emptyVNode, vnode);
      },
      update: updateAttrs
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    function isLiveBindingProp(sel, key) {
      // For properties with live bindings, we read values from the DOM element
      // instead of relying on internally tracked values.
      return sel === 'input' && (key === 'value' || key === 'checked');
    }

    function update(oldVnode, vnode) {
      var props = vnode.data.props;

      if (isUndefined(props)) {
        return;
      }

      var oldProps = oldVnode.data.props;

      if (oldProps === props) {
        return;
      }

      {
        assert.invariant(isUndefined(oldProps) || keys(oldProps).join(',') === keys(props).join(','), 'vnode.data.props cannot change shape.');
      }

      var elm = vnode.elm;
      var isFirstPatch = isUndefined(oldProps);
      var sel = vnode.sel;

      for (var key in props) {
        var cur = props[key];

        {
          if (!(key in elm)) {
            // TODO [#1297]: Move this validation to the compiler
            assert.fail("Unknown public property \"".concat(key, "\" of element <").concat(sel, ">. This is likely a typo on the corresponding attribute \"").concat(getAttrNameFromPropName(key), "\"."));
          }
        } // if it is the first time this element is patched, or the current value is different to the previous value...


        if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {
          elm[key] = cur;
        }
      }
    }

    var emptyVNode$1 = {
      data: {}
    };
    var modProps = {
      create: function create(vnode) {
        return update(emptyVNode$1, vnode);
      },
      update: update
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var classNameToClassMap = create(null);

    function getMapFromClassName(className) {
      // Intentionally using == to match undefined and null values from computed style attribute
      if (className == null) {
        return EmptyObject;
      } // computed class names must be string


      className = isString(className) ? className : className + '';
      var map = classNameToClassMap[className];

      if (map) {
        return map;
      }

      map = create(null);
      var start = 0;
      var o;
      var len = className.length;

      for (o = 0; o < len; o++) {
        if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {
          if (o > start) {
            map[StringSlice.call(className, start, o)] = true;
          }

          start = o + 1;
        }
      }

      if (o > start) {
        map[StringSlice.call(className, start, o)] = true;
      }

      classNameToClassMap[className] = map;

      {
        // just to make sure that this object never changes as part of the diffing algo
        freeze(map);
      }

      return map;
    }

    function updateClassAttribute(oldVnode, vnode) {
      var elm = vnode.elm,
          newClass = vnode.data.className;
      var oldClass = oldVnode.data.className;

      if (oldClass === newClass) {
        return;
      }

      var classList = elm.classList;
      var newClassMap = getMapFromClassName(newClass);
      var oldClassMap = getMapFromClassName(oldClass);
      var name;

      for (name in oldClassMap) {
        // remove only if it is not in the new class collection and it is not set from within the instance
        if (isUndefined(newClassMap[name])) {
          classList.remove(name);
        }
      }

      for (name in newClassMap) {
        if (isUndefined(oldClassMap[name])) {
          classList.add(name);
        }
      }
    }

    var emptyVNode$2 = {
      data: {}
    };
    var modComputedClassName = {
      create: function create(vnode) {
        return updateClassAttribute(emptyVNode$2, vnode);
      },
      update: updateClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    function updateStyleAttribute(oldVnode, vnode) {
      var newStyle = vnode.data.style;

      if (oldVnode.data.style === newStyle) {
        return;
      }

      var elm = vnode.elm;
      var style = elm.style;

      if (!isString(newStyle) || newStyle === '') {
        removeAttribute.call(elm, 'style');
      } else {
        style.cssText = newStyle;
      }
    }

    var emptyVNode$3 = {
      data: {}
    };
    var modComputedStyle = {
      create: function create(vnode) {
        return updateStyleAttribute(emptyVNode$3, vnode);
      },
      update: updateStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
    // different classnames properties individually instead of via a string.

    function createClassAttribute(vnode) {
      var elm = vnode.elm,
          classMap = vnode.data.classMap;

      if (isUndefined(classMap)) {
        return;
      }

      var classList = elm.classList;

      for (var name in classMap) {
        classList.add(name);
      }
    }

    var modStaticClassName = {
      create: createClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline style into an object. It's faster to set the
    // different style properties individually instead of via a string.

    function createStyleAttribute(vnode) {
      var elm = vnode.elm,
          styleMap = vnode.data.styleMap;

      if (isUndefined(styleMap)) {
        return;
      }

      var style = elm.style;

      for (var name in styleMap) {
        style[name] = styleMap[name];
      }
    }

    var modStaticStyle = {
      create: createStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    function createContext(vnode) {
      var context = vnode.data.context;

      if (isUndefined(context)) {
        return;
      }

      var elm = vnode.elm;
      var vm = getAssociatedVMIfPresent(elm);

      if (!isUndefined(vm)) {
        assign(vm.context, context);
      }
    }

    var contextModule = {
      create: createContext
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
    @license
    Copyright (c) 2015 Simon Friis Vindum.
    This code may only be used under the MIT License found at
    https://github.com/snabbdom/snabbdom/blob/master/LICENSE
    Code distributed by Snabbdom as part of the Snabbdom project at
    https://github.com/snabbdom/snabbdom/
    */

    function isUndef(s) {
      return s === undefined;
    }

    function sameVnode(vnode1, vnode2) {
      return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }

    function isVNode(vnode) {
      return vnode != null;
    }

    function createKeyToOldIdx(children, beginIdx, endIdx) {
      var map = {};
      var j, key, ch; // TODO [#1637]: simplify this by assuming that all vnodes has keys

      for (j = beginIdx; j <= endIdx; ++j) {
        ch = children[j];

        if (isVNode(ch)) {
          key = ch.key;

          if (key !== undefined) {
            map[key] = j;
          }
        }
      }

      return map;
    }

    function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];

        if (isVNode(ch)) {
          ch.hook.create(ch);
          ch.hook.insert(ch, parentElm, before);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx]; // text nodes do not have logic associated to them

        if (isVNode(ch)) {
          ch.hook.remove(ch, parentElm);
        }
      }
    }

    function updateDynamicChildren(parentElm, oldCh, newCh) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx;
      var idxInOld;
      var elmToMove;
      var before;

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (!isVNode(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
        } else if (!isVNode(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (!isVNode(newStartVnode)) {
          newStartVnode = newCh[++newStartIdx];
        } else if (!isVNode(newEndVnode)) {
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode);
          newEndVnode.hook.move(oldStartVnode, parentElm, oldEndVnode.elm.nextSibling);
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode);
          newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (oldKeyToIdx === undefined) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }

          idxInOld = oldKeyToIdx[newStartVnode.key];

          if (isUndef(idxInOld)) {
            // New element
            newStartVnode.hook.create(newStartVnode);
            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            elmToMove = oldCh[idxInOld];

            if (isVNode(elmToMove)) {
              if (elmToMove.sel !== newStartVnode.sel) {
                // New element
                newStartVnode.hook.create(newStartVnode);
                newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
              } else {
                patchVnode(elmToMove, newStartVnode);
                oldCh[idxInOld] = undefined;
                newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);
              }
            }

            newStartVnode = newCh[++newStartIdx];
          }
        }
      }

      if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
        if (oldStartIdx > oldEndIdx) {
          var n = newCh[newEndIdx + 1];
          before = isVNode(n) ? n.elm : null;
          addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
        } else {
          removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
        }
      }
    }

    function updateStaticChildren(parentElm, oldCh, newCh) {
      var length = newCh.length;

      if (oldCh.length === 0) {
        // the old list is empty, we can directly insert anything new
        addVnodes(parentElm, null, newCh, 0, length);
        return;
      } // if the old list is not empty, the new list MUST have the same
      // amount of nodes, that's why we call this static children


      var referenceElm = null;

      for (var _i3 = length - 1; _i3 >= 0; _i3 -= 1) {
        var vnode = newCh[_i3];
        var oldVNode = oldCh[_i3];

        if (vnode !== oldVNode) {
          if (isVNode(oldVNode)) {
            if (isVNode(vnode)) {
              // both vnodes must be equivalent, and se just need to patch them
              patchVnode(oldVNode, vnode);
              referenceElm = vnode.elm;
            } else {
              // removing the old vnode since the new one is null
              oldVNode.hook.remove(oldVNode, parentElm);
            }
          } else if (isVNode(vnode)) {
            // this condition is unnecessary
            vnode.hook.create(vnode); // insert the new node one since the old one is null

            vnode.hook.insert(vnode, parentElm, referenceElm);
            referenceElm = vnode.elm;
          }
        }
      }
    }

    function patchVnode(oldVnode, vnode) {
      if (oldVnode !== vnode) {
        vnode.elm = oldVnode.elm;
        vnode.hook.update(oldVnode, vnode);
      }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function generateDataDescriptor(options) {
      return assign({
        configurable: true,
        enumerable: true,
        writable: true
      }, options);
    }

    function generateAccessorDescriptor(options) {
      return assign({
        configurable: true,
        enumerable: true
      }, options);
    }

    var isDomMutationAllowed = false;

    function unlockDomMutation() {

      isDomMutationAllowed = true;
    }

    function lockDomMutation() {

      isDomMutationAllowed = false;
    }

    function portalRestrictionErrorMessage(name, type) {
      return "The `".concat(name, "` ").concat(type, " is available only on elements that use the `lwc:dom=\"manual\"` directive.");
    }

    function getNodeRestrictionsDescriptors(node, options) {
      // and returns the first descriptor for the property


      var originalTextContentDescriptor = getPropertyDescriptor(node, 'textContent');
      var originalNodeValueDescriptor = getPropertyDescriptor(node, 'nodeValue');
      var appendChild = node.appendChild,
          insertBefore = node.insertBefore,
          removeChild = node.removeChild,
          replaceChild = node.replaceChild;
      return {
        appendChild: generateDataDescriptor({
          value: function value(aChild) {
            if (_instanceof(this, Element) && isFalse$1(options.isPortal)) {
              logError(portalRestrictionErrorMessage('appendChild', 'method'));
            }

            return appendChild.call(this, aChild);
          }
        }),
        insertBefore: generateDataDescriptor({
          value: function value(newNode, referenceNode) {
            if (!isDomMutationAllowed && _instanceof(this, Element) && isFalse$1(options.isPortal)) {
              logError(portalRestrictionErrorMessage('insertBefore', 'method'));
            }

            return insertBefore.call(this, newNode, referenceNode);
          }
        }),
        removeChild: generateDataDescriptor({
          value: function value(aChild) {
            if (!isDomMutationAllowed && _instanceof(this, Element) && isFalse$1(options.isPortal)) {
              logError(portalRestrictionErrorMessage('removeChild', 'method'));
            }

            return removeChild.call(this, aChild);
          }
        }),
        replaceChild: generateDataDescriptor({
          value: function value(newChild, oldChild) {
            if (_instanceof(this, Element) && isFalse$1(options.isPortal)) {
              logError(portalRestrictionErrorMessage('replaceChild', 'method'));
            }

            return replaceChild.call(this, newChild, oldChild);
          }
        }),
        nodeValue: generateAccessorDescriptor({
          get: function get() {
            return originalNodeValueDescriptor.get.call(this);
          },
          set: function set(value) {
            if (!isDomMutationAllowed && _instanceof(this, Element) && isFalse$1(options.isPortal)) {
              logError(portalRestrictionErrorMessage('nodeValue', 'property'));
            }

            originalNodeValueDescriptor.set.call(this, value);
          }
        }),
        textContent: generateAccessorDescriptor({
          get: function get() {
            return originalTextContentDescriptor.get.call(this);
          },
          set: function set(value) {
            if (_instanceof(this, Element) && isFalse$1(options.isPortal)) {
              logError(portalRestrictionErrorMessage('textContent', 'property'));
            }

            originalTextContentDescriptor.set.call(this, value);
          }
        })
      };
    }

    function getElementRestrictionsDescriptors(elm, options) {

      var descriptors = getNodeRestrictionsDescriptors(elm, options);
      var originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');
      var originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
      assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalInnerHTMLDescriptor.get.call(this);
          },
          set: function set(value) {
            if (isFalse$1(options.isPortal)) {
              logError(portalRestrictionErrorMessage('innerHTML', 'property'), getAssociatedVMIfPresent(this));
            }

            return originalInnerHTMLDescriptor.set.call(this, value);
          }
        }),
        outerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalOuterHTMLDescriptor.get.call(this);
          },
          set: function set(_value) {
            throw new TypeError("Invalid attempt to set outerHTML on Element.");
          }
        })
      });
      return descriptors;
    }

    function getShadowRootRestrictionsDescriptors(sr, options) {
      // thing when using the real shadow root, because if that's the case,
      // the component will not work when running with synthetic shadow.


      var originalQuerySelector = sr.querySelector;
      var originalQuerySelectorAll = sr.querySelectorAll;
      var originalAddEventListener = sr.addEventListener;
      var descriptors = getNodeRestrictionsDescriptors(sr, options);
      var originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');
      var originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');
      assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalInnerHTMLDescriptor.get.call(this);
          },
          set: function set(_value) {
            throw new TypeError("Invalid attempt to set innerHTML on ShadowRoot.");
          }
        }),
        textContent: generateAccessorDescriptor({
          get: function get() {
            return originalTextContentDescriptor.get.call(this);
          },
          set: function set(_value) {
            throw new TypeError("Invalid attempt to set textContent on ShadowRoot.");
          }
        }),
        addEventListener: generateDataDescriptor({
          value: function value(type, listener, options) {
            var vmBeingRendered = getVMBeingRendered();
            assert.invariant(!isInvokingRender, "".concat(vmBeingRendered, ".render() method has side effects on the state of ").concat(toString(sr), " by adding an event listener for \"").concat(type, "\"."));
            assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(vmBeingRendered, " has side effects on the state of ").concat(toString(sr), " by adding an event listener for \"").concat(type, "\".")); // TODO [#420]: this is triggered when the component author attempts to add a listener
            // programmatically into its Component's shadow root

            if (!isUndefined(options)) {
              logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));
            } // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch


            return originalAddEventListener.apply(this, arguments);
          }
        }),
        querySelector: generateDataDescriptor({
          value: function value() {
            var vm = getAssociatedVM(this);
            assert.isFalse(isBeingConstructed(vm), "this.template.querySelector() cannot be called during the construction of the custom element for ".concat(vm, " because no content has been rendered yet.")); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch

            return originalQuerySelector.apply(this, arguments);
          }
        }),
        querySelectorAll: generateDataDescriptor({
          value: function value() {
            var vm = getAssociatedVM(this);
            assert.isFalse(isBeingConstructed(vm), "this.template.querySelectorAll() cannot be called during the construction of the custom element for ".concat(vm, " because no content has been rendered yet.")); // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch

            return originalQuerySelectorAll.apply(this, arguments);
          }
        })
      });
      var BlockedShadowRootMethods = {
        cloneNode: 0,
        getElementById: 0,
        getSelection: 0,
        elementsFromPoint: 0,
        dispatchEvent: 0
      };
      forEach.call(getOwnPropertyNames(BlockedShadowRootMethods), function (methodName) {
        var descriptor = generateAccessorDescriptor({
          get: function get() {
            throw new Error("Disallowed method \"".concat(methodName, "\" in ShadowRoot."));
          }
        });
        descriptors[methodName] = descriptor;
      });
      return descriptors;
    } // Custom Elements Restrictions:
    // -----------------------------


    function getCustomElementRestrictionsDescriptors(elm, options) {

      var descriptors = getNodeRestrictionsDescriptors(elm, options);
      var originalAddEventListener = elm.addEventListener;
      var originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');
      var originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
      var originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');
      return assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalInnerHTMLDescriptor.get.call(this);
          },
          set: function set(_value) {
            throw new TypeError("Invalid attempt to set innerHTML on HTMLElement.");
          }
        }),
        outerHTML: generateAccessorDescriptor({
          get: function get() {
            return originalOuterHTMLDescriptor.get.call(this);
          },
          set: function set(_value) {
            throw new TypeError("Invalid attempt to set outerHTML on HTMLElement.");
          }
        }),
        textContent: generateAccessorDescriptor({
          get: function get() {
            return originalTextContentDescriptor.get.call(this);
          },
          set: function set(_value) {
            throw new TypeError("Invalid attempt to set textContent on HTMLElement.");
          }
        }),
        addEventListener: generateDataDescriptor({
          value: function value(type, listener, options) {
            var vmBeingRendered = getVMBeingRendered();
            assert.invariant(!isInvokingRender, "".concat(vmBeingRendered, ".render() method has side effects on the state of ").concat(toString(this), " by adding an event listener for \"").concat(type, "\"."));
            assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(vmBeingRendered, " has side effects on the state of ").concat(toString(elm), " by adding an event listener for \"").concat(type, "\".")); // TODO [#420]: this is triggered when the component author attempts to add a listener
            // programmatically into a lighting element node

            if (!isUndefined(options)) {
              logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));
            } // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch


            return originalAddEventListener.apply(this, arguments);
          }
        })
      });
    }

    function getComponentRestrictionsDescriptors() {

      return {
        tagName: generateAccessorDescriptor({
          get: function get() {
            throw new Error("Usage of property `tagName` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.");
          },
          configurable: true,
          enumerable: false
        })
      };
    }

    function getLightningElementPrototypeRestrictionsDescriptors(proto) {

      var originalDispatchEvent = proto.dispatchEvent;
      var descriptors = {
        dispatchEvent: generateDataDescriptor({
          value: function value(event) {
            var vm = getAssociatedVM(this);
            assert.isFalse(isBeingConstructed(vm), "this.dispatchEvent() should not be called during the construction of the custom element for ".concat(getComponentTag(vm), " because no one is listening just yet."));

            if (!isNull(event) && isObject$1(event)) {
              var type = event.type;

              if (!/^[a-z][a-z0-9_]*$/.test(type)) {
                logError("Invalid event type \"".concat(type, "\" dispatched in element ").concat(getComponentTag(vm), ". Event name must start with a lowercase letter and followed only lowercase letters, numbers, and underscores"), vm);
              }
            } // Typescript does not like it when you treat the `arguments` object as an array
            // @ts-ignore type-mismatch


            return originalDispatchEvent.apply(this, arguments);
          }
        })
      };
      forEach.call(getOwnPropertyNames(globalHTMLProperties), function (propName) {
        if (propName in proto) {
          return; // no need to redefine something that we are already exposing
        }

        descriptors[propName] = generateAccessorDescriptor({
          get: function get() {
            var _globalHTMLProperties = globalHTMLProperties[propName],
                error = _globalHTMLProperties.error,
                attribute = _globalHTMLProperties.attribute;
            var msg = [];
            msg.push("Accessing the global HTML property \"".concat(propName, "\" is disabled."));

            if (error) {
              msg.push(error);
            } else if (attribute) {
              msg.push("Instead access it via `this.getAttribute(\"".concat(attribute, "\")`."));
            }

            logError(msg.join('\n'), getAssociatedVM(this));
          },
          set: function set() {
            var readOnly = globalHTMLProperties[propName].readOnly;

            if (readOnly) {
              logError("The global HTML property `".concat(propName, "` is read-only."), getAssociatedVM(this));
            }
          }
        });
      });
      return descriptors;
    }

    function markNodeFromVNode(node) {

      node.$fromTemplate$ = true;
    }

    function patchElementWithRestrictions(elm, options) {
      defineProperties(elm, getElementRestrictionsDescriptors(elm, options));
    } // This routine will prevent access to certain properties on a shadow root instance to guarantee
    // that all components will work fine in IE11 and other browsers without shadow dom support.


    function patchShadowRootWithRestrictions(sr, options) {
      defineProperties(sr, getShadowRootRestrictionsDescriptors(sr, options));
    }

    function patchCustomElementWithRestrictions(elm, options) {
      var restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm, options);
      var elmProto = getPrototypeOf(elm);
      setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));
    }

    function patchComponentWithRestrictions(cmp) {
      defineProperties(cmp, getComponentRestrictionsDescriptors());
    }

    function patchLightningElementPrototypeWithRestrictions(proto) {
      defineProperties(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var noop = function noop() {
      return void 0;
    };

    function observeElementChildNodes(elm) {
      elm.$domManual$ = true;
    }

    function setElementShadowToken(elm, token) {
      elm.$shadowToken$ = token;
    }

    function updateNodeHook(oldVnode, vnode) {
      var text = vnode.text;

      if (oldVnode.text !== text) {
        {
          unlockDomMutation();
        }
        /**
         * Compiler will never produce a text property that is not string
         */


        vnode.elm.nodeValue = text;

        {
          lockDomMutation();
        }
      }
    }

    function insertNodeHook(vnode, parentNode, referenceNode) {
      {
        unlockDomMutation();
      }

      parentNode.insertBefore(vnode.elm, referenceNode);

      {
        lockDomMutation();
      }
    }

    function removeNodeHook(vnode, parentNode) {
      {
        unlockDomMutation();
      }

      parentNode.removeChild(vnode.elm);

      {
        lockDomMutation();
      }
    }

    function createElmHook(vnode) {
      modEvents.create(vnode); // Attrs need to be applied to element before props
      // IE11 will wipe out value on radio inputs if value
      // is set before type=radio.

      modAttrs.create(vnode);
      modProps.create(vnode);
      modStaticClassName.create(vnode);
      modStaticStyle.create(vnode);
      modComputedClassName.create(vnode);
      modComputedStyle.create(vnode);
      contextModule.create(vnode);
    }

    var LWCDOMMode;

    (function (LWCDOMMode) {
      LWCDOMMode["manual"] = "manual";
    })(LWCDOMMode || (LWCDOMMode = {}));

    function fallbackElmHook(vnode) {
      var owner = vnode.owner;
      var elm = vnode.elm;

      if (isTrue$1(useSyntheticShadow)) {
        var context = vnode.data.context;
        var shadowAttribute = owner.context.shadowAttribute;

        if (!isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual) {
          // this element will now accept any manual content inserted into it
          observeElementChildNodes(elm);
        } // when running in synthetic shadow mode, we need to set the shadowToken value
        // into each element from the template, so they can be styled accordingly.


        setElementShadowToken(elm, shadowAttribute);
      }

      {
        var _context = vnode.data.context;
        var isPortal = !isUndefined(_context) && !isUndefined(_context.lwc) && _context.lwc.dom === LWCDOMMode.manual;
        patchElementWithRestrictions(elm, {
          isPortal: isPortal
        });
      }
    }

    function updateElmHook(oldVnode, vnode) {
      // Attrs need to be applied to element before props
      // IE11 will wipe out value on radio inputs if value
      // is set before type=radio.
      modAttrs.update(oldVnode, vnode);
      modProps.update(oldVnode, vnode);
      modComputedClassName.update(oldVnode, vnode);
      modComputedStyle.update(oldVnode, vnode);
    }

    function insertCustomElmHook(vnode) {
      var vm = getAssociatedVM(vnode.elm);
      appendVM(vm);
    }

    function updateChildrenHook(oldVnode, vnode) {
      var children = vnode.children,
          owner = vnode.owner;
      var fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;
      runWithBoundaryProtection(owner, owner.owner, noop, function () {
        fn(vnode.elm, oldVnode.children, children);
      }, noop);
    }

    function allocateChildrenHook(vnode) {
      var vm = getAssociatedVM(vnode.elm);
      var children = vnode.children;
      vm.aChildren = children;

      if (isTrue$1(useSyntheticShadow)) {
        // slow path
        allocateInSlot(vm, children); // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!

        vnode.children = EmptyArray;
      }
    }

    function createViewModelHook(vnode) {
      var elm = vnode.elm;

      if (!isUndefined(getAssociatedVMIfPresent(elm))) {
        // There is a possibility that a custom element is registered under tagName,
        // in which case, the initialization is already carry on, and there is nothing else
        // to do here since this hook is called right after invoking `document.createElement`.
        return;
      }

      var mode = vnode.mode,
          ctor = vnode.ctor,
          owner = vnode.owner;
      var def = getComponentDef(ctor);
      setElementProto(elm, def);

      if (isTrue$1(useSyntheticShadow)) {
        var shadowAttribute = owner.context.shadowAttribute; // when running in synthetic shadow mode, we need to set the shadowToken value
        // into each element from the template, so they can be styled accordingly.

        setElementShadowToken(elm, shadowAttribute);
      }

      createVM(elm, ctor, {
        mode: mode,
        owner: owner
      });

      {
        assert.isTrue(isArray$1(vnode.children), "Invalid vnode for a custom element, it must have children defined.");
      }

      {
        patchCustomElementWithRestrictions(elm, EmptyObject);
      }
    }

    function createCustomElmHook(vnode) {
      modEvents.create(vnode); // Attrs need to be applied to element before props
      // IE11 will wipe out value on radio inputs if value
      // is set before type=radio.

      modAttrs.create(vnode);
      modProps.create(vnode);
      modStaticClassName.create(vnode);
      modStaticStyle.create(vnode);
      modComputedClassName.create(vnode);
      modComputedStyle.create(vnode);
      contextModule.create(vnode);
    }

    function createChildrenHook(vnode) {
      var elm = vnode.elm,
          children = vnode.children;

      for (var j = 0; j < children.length; ++j) {
        var ch = children[j];

        if (ch != null) {
          ch.hook.create(ch);
          ch.hook.insert(ch, elm, null);
        }
      }
    }

    function rerenderCustomElmHook(vnode) {
      var vm = getAssociatedVM(vnode.elm);

      {
        assert.isTrue(isArray$1(vnode.children), "Invalid vnode for a custom element, it must have children defined.");
      }

      rerenderVM(vm);
    }

    function updateCustomElmHook(oldVnode, vnode) {
      // Attrs need to be applied to element before props
      // IE11 will wipe out value on radio inputs if value
      // is set before type=radio.
      modAttrs.update(oldVnode, vnode);
      modProps.update(oldVnode, vnode);
      modComputedClassName.update(oldVnode, vnode);
      modComputedStyle.update(oldVnode, vnode);
    }

    function removeElmHook(vnode) {
      // this method only needs to search on child vnodes from template
      // to trigger the remove hook just in case some of those children
      // are custom elements.
      var children = vnode.children,
          elm = vnode.elm;

      for (var j = 0, _len3 = children.length; j < _len3; ++j) {
        var ch = children[j];

        if (!isNull(ch)) {
          ch.hook.remove(ch, elm);
        }
      }
    }

    function removeCustomElmHook(vnode) {
      // for custom elements we don't have to go recursively because the removeVM routine
      // will take care of disconnecting any child VM attached to its shadow as well.
      removeVM(getAssociatedVM(vnode.elm));
    } // Using a WeakMap instead of a WeakSet because this one works in IE11 :(


    var FromIteration = new WeakMap(); // dynamic children means it was generated by an iteration
    // in a template, and will require a more complex diffing algo.

    function markAsDynamicChildren(children) {
      FromIteration.set(children, 1);
    }

    function hasDynamicChildren(children) {
      return FromIteration.has(children);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var Services = create(null);
    var hooks = ['wiring', 'locator', 'rendered', 'connected', 'disconnected'];
    /**
     * EXPERIMENTAL: This function allows for the registration of "services"
     * in LWC by exposing hooks into the component life-cycle. This API is
     * subject to change or being removed.
     */

    function register(service) {
      {
        assert.isTrue(isObject$1(service), "Invalid service declaration, ".concat(service, ": service must be an object"));
      }

      for (var _i4 = 0; _i4 < hooks.length; ++_i4) {
        var hookName = hooks[_i4];

        if (hookName in service) {
          var l = Services[hookName];

          if (isUndefined(l)) {
            Services[hookName] = l = [];
          }

          ArrayPush.call(l, service[hookName]);
        }
      }
    }

    function invokeServiceHook(vm, cbs) {
      {
        assert.isTrue(isArray$1(cbs) && cbs.length > 0, "Optimize invokeServiceHook() to be invoked only when needed");
      }

      var component = vm.component,
          data = vm.data,
          def = vm.def,
          context = vm.context;

      for (var _i5 = 0, _len4 = cbs.length; _i5 < _len4; ++_i5) {
        cbs[_i5].call(undefined, component, data, def, context);
      }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var CHAR_S = 115;
    var CHAR_V = 118;
    var CHAR_G = 103;
    var NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';
    var SymbolIterator = Symbol.iterator;
    var TextHook = {
      create: function create(vnode) {
        vnode.elm = document.createTextNode(vnode.text);
        linkNodeToShadow(vnode);

        {
          markNodeFromVNode(vnode.elm);
        }
      },
      update: updateNodeHook,
      insert: insertNodeHook,
      move: insertNodeHook,
      remove: removeNodeHook
    };
    var CommentHook = {
      create: function create(vnode) {
        vnode.elm = document.createComment(vnode.text);
        linkNodeToShadow(vnode);

        {
          markNodeFromVNode(vnode.elm);
        }
      },
      update: updateNodeHook,
      insert: insertNodeHook,
      move: insertNodeHook,
      remove: removeNodeHook
    }; // insert is called after update, which is used somewhere else (via a module)
    // to mark the vm as inserted, that means we cannot use update as the main channel
    // to rehydrate when dirty, because sometimes the element is not inserted just yet,
    // which breaks some invariants. For that reason, we have the following for any
    // Custom Element that is inserted via a template.

    var ElementHook = {
      create: function create(vnode) {
        var data = vnode.data,
            sel = vnode.sel,
            clonedElement = vnode.clonedElement;
        var ns = data.ns; // TODO [#1364]: supporting the ability to inject a cloned StyleElement via a vnode this is
        // used for style tags for native shadow

        if (isUndefined(clonedElement)) {
          vnode.elm = isUndefined(ns) ? document.createElement(sel) : document.createElementNS(ns, sel);
        } else {
          vnode.elm = clonedElement;
        }

        linkNodeToShadow(vnode);

        {
          markNodeFromVNode(vnode.elm);
        }

        fallbackElmHook(vnode);
        createElmHook(vnode);
      },
      update: function update(oldVnode, vnode) {
        updateElmHook(oldVnode, vnode);
        updateChildrenHook(oldVnode, vnode);
      },
      insert: function insert(vnode, parentNode, referenceNode) {
        insertNodeHook(vnode, parentNode, referenceNode);
        createChildrenHook(vnode);
      },
      move: function move(vnode, parentNode, referenceNode) {
        insertNodeHook(vnode, parentNode, referenceNode);
      },
      remove: function remove(vnode, parentNode) {
        removeNodeHook(vnode, parentNode);
        removeElmHook(vnode);
      }
    };
    var CustomElementHook = {
      create: function create(vnode) {
        var sel = vnode.sel;
        vnode.elm = document.createElement(sel);
        linkNodeToShadow(vnode);

        {
          markNodeFromVNode(vnode.elm);
        }

        createViewModelHook(vnode);
        allocateChildrenHook(vnode);
        createCustomElmHook(vnode);
      },
      update: function update(oldVnode, vnode) {
        updateCustomElmHook(oldVnode, vnode); // in fallback mode, the allocation will always set children to
        // empty and delegate the real allocation to the slot elements

        allocateChildrenHook(vnode); // in fallback mode, the children will be always empty, so, nothing
        // will happen, but in native, it does allocate the light dom

        updateChildrenHook(oldVnode, vnode); // this will update the shadowRoot

        rerenderCustomElmHook(vnode);
      },
      insert: function insert(vnode, parentNode, referenceNode) {
        insertNodeHook(vnode, parentNode, referenceNode);
        var vm = getAssociatedVM(vnode.elm);

        {
          assert.isTrue(vm.state === VMState.created, "".concat(vm, " cannot be recycled."));
        }

        runConnectedCallback(vm);
        createChildrenHook(vnode);
        insertCustomElmHook(vnode);
      },
      move: function move(vnode, parentNode, referenceNode) {
        insertNodeHook(vnode, parentNode, referenceNode);
      },
      remove: function remove(vnode, parentNode) {
        removeNodeHook(vnode, parentNode);
        removeCustomElmHook(vnode);
      }
    };

    function linkNodeToShadow(vnode) {
      // TODO [#1164]: this should eventually be done by the polyfill directly
      vnode.elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;
    } // TODO [#1136]: this should be done by the compiler, adding ns to every sub-element


    function addNS(vnode) {
      var data = vnode.data,
          children = vnode.children,
          sel = vnode.sel;
      data.ns = NamespaceAttributeForSVG; // TODO [#1275]: review why `sel` equal `foreignObject` should get this `ns`

      if (isArray$1(children) && sel !== 'foreignObject') {
        for (var j = 0, n = children.length; j < n; ++j) {
          var childNode = children[j];

          if (childNode != null && childNode.hook === ElementHook) {
            addNS(childNode);
          }
        }
      }
    }

    function addVNodeToChildLWC(vnode) {
      ArrayPush.call(getVMBeingRendered().velements, vnode);
    } // [h]tml node


    function h(sel, data, children) {
      var vmBeingRendered = getVMBeingRendered();

      {
        assert.isTrue(isString(sel), "h() 1st argument sel must be a string.");
        assert.isTrue(isObject$1(data), "h() 2nd argument data must be an object.");
        assert.isTrue(isArray$1(children), "h() 3rd argument children must be an array.");
        assert.isTrue('key' in data, " <".concat(sel, "> \"key\" attribute is invalid or missing for ").concat(vmBeingRendered, ". Key inside iterator is either undefined or null.")); // checking reserved internal data properties

        assert.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
        assert.isFalse(data.styleMap && data.style, "vnode.data.styleMap and vnode.data.style ambiguous declaration.");

        if (data.style && !isString(data.style)) {
          logError("Invalid 'style' attribute passed to <".concat(sel, "> is ignored. This attribute must be a string value."), vmBeingRendered);
        }

        forEach.call(children, function (childVnode) {
          if (childVnode != null) {
            assert.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, "".concat(childVnode, " is not a vnode."));
          }
        });
      }

      var key = data.key;
      var text, elm;
      var vnode = {
        sel: sel,
        data: data,
        children: children,
        text: text,
        elm: elm,
        key: key,
        hook: ElementHook,
        owner: vmBeingRendered
      };

      if (sel.length === 3 && StringCharCodeAt.call(sel, 0) === CHAR_S && StringCharCodeAt.call(sel, 1) === CHAR_V && StringCharCodeAt.call(sel, 2) === CHAR_G) {
        addNS(vnode);
      }

      return vnode;
    } // [t]ab[i]ndex function


    function ti(value) {
      // if value is greater than 0, we normalize to 0
      // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
      // If value is less than -1, we don't care
      var shouldNormalize = value > 0 && !(isTrue$1(value) || isFalse$1(value));

      {
        var _vmBeingRendered = getVMBeingRendered();

        if (shouldNormalize) {
          logError("Invalid tabindex value `".concat(toString(value), "` in template for ").concat(_vmBeingRendered, ". This attribute must be set to 0 or -1."), _vmBeingRendered);
        }
      }

      return shouldNormalize ? 0 : value;
    } // [s]lot element node


    function s(slotName, data, children, slotset) {
      {
        assert.isTrue(isString(slotName), "s() 1st argument slotName must be a string.");
        assert.isTrue(isObject$1(data), "s() 2nd argument data must be an object.");
        assert.isTrue(isArray$1(children), "h() 3rd argument children must be an array.");
      }

      if (!isUndefined(slotset) && !isUndefined(slotset[slotName]) && slotset[slotName].length !== 0) {
        children = slotset[slotName];
      }

      var vnode = h('slot', data, children);

      if (useSyntheticShadow) {
        // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(children);
      }

      return vnode;
    } // [c]ustom element node


    function c(sel, Ctor, data) {
      var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EmptyArray;

      if (isCircularModuleDependency(Ctor)) {
        Ctor = resolveCircularModuleDependency(Ctor);
      }

      var vmBeingRendered = getVMBeingRendered();

      {
        assert.isTrue(isString(sel), "c() 1st argument sel must be a string.");
        assert.isTrue(isFunction(Ctor), "c() 2nd argument Ctor must be a function.");
        assert.isTrue(isObject$1(data), "c() 3nd argument data must be an object.");
        assert.isTrue(arguments.length === 3 || isArray$1(children), "c() 4nd argument data must be an array."); // checking reserved internal data properties

        assert.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
        assert.isFalse(data.styleMap && data.style, "vnode.data.styleMap and vnode.data.style ambiguous declaration.");

        if (data.style && !isString(data.style)) {
          logError("Invalid 'style' attribute passed to <".concat(sel, "> is ignored. This attribute must be a string value."), vmBeingRendered);
        }

        if (arguments.length === 4) {
          forEach.call(children, function (childVnode) {
            if (childVnode != null) {
              assert.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, "".concat(childVnode, " is not a vnode."));
            }
          });
        }
      }

      var key = data.key;
      var text, elm;
      var vnode = {
        sel: sel,
        data: data,
        children: children,
        text: text,
        elm: elm,
        key: key,
        hook: CustomElementHook,
        ctor: Ctor,
        owner: vmBeingRendered,
        mode: 'open'
      };
      addVNodeToChildLWC(vnode);
      return vnode;
    } // [i]terable node


    function i(iterable, factory) {
      var list = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic

      sc(list);
      var vmBeingRendered = getVMBeingRendered();

      if (isUndefined(iterable) || iterable === null) {
        {
          logError("Invalid template iteration for value \"".concat(toString(iterable), "\" in ").concat(vmBeingRendered, ". It must be an Array or an iterable Object."), vmBeingRendered);
        }

        return list;
      }

      {
        assert.isFalse(isUndefined(iterable[SymbolIterator]), "Invalid template iteration for value `".concat(toString(iterable), "` in ").concat(vmBeingRendered, ". It must be an array-like object and not `null` nor `undefined`."));
      }

      var iterator = iterable[SymbolIterator]();

      {
        assert.isTrue(iterator && isFunction(iterator.next), "Invalid iterator function for \"".concat(toString(iterable), "\" in ").concat(vmBeingRendered, "."));
      }

      var next = iterator.next();
      var j = 0;
      var _next = next,
          value = _next.value,
          last = _next.done;
      var keyMap;
      var iterationError;

      {
        keyMap = create(null);
      }

      while (last === false) {
        // implementing a look-back-approach because we need to know if the element is the last
        next = iterator.next();
        last = next.done; // template factory logic based on the previous collected value

        var vnode = factory(value, j, j === 0, last);

        if (isArray$1(vnode)) {
          ArrayPush.apply(list, vnode);
        } else {
          ArrayPush.call(list, vnode);
        }

        {
          var vnodes = isArray$1(vnode) ? vnode : [vnode];
          forEach.call(vnodes, function (childVnode) {
            if (!isNull(childVnode) && isObject$1(childVnode) && !isUndefined(childVnode.sel)) {
              var key = childVnode.key;

              if (isString(key) || isNumber(key)) {
                if (keyMap[key] === 1 && isUndefined(iterationError)) {
                  iterationError = "Duplicated \"key\" attribute value for \"<".concat(childVnode.sel, ">\" in ").concat(vmBeingRendered, " for item number ").concat(j, ". A key with value \"").concat(childVnode.key, "\" appears more than once in the iteration. Key values must be unique numbers or strings.");
                }

                keyMap[key] = 1;
              } else if (isUndefined(iterationError)) {
                iterationError = "Invalid \"key\" attribute value in \"<".concat(childVnode.sel, ">\" in ").concat(vmBeingRendered, " for item number ").concat(j, ". Set a unique \"key\" value on all iterated child elements.");
              }
            }
          });
        } // preparing next value


        j += 1;
        value = next.value;
      }

      {
        if (!isUndefined(iterationError)) {
          logError(iterationError, vmBeingRendered);
        }
      }

      return list;
    }
    /**
     * [f]lattening
     */


    function f(items) {
      {
        assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');
      }

      var len = items.length;
      var flattened = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic

      sc(flattened);

      for (var j = 0; j < len; j += 1) {
        var item = items[j];

        if (isArray$1(item)) {
          ArrayPush.apply(flattened, item);
        } else {
          ArrayPush.call(flattened, item);
        }
      }

      return flattened;
    } // [t]ext node


    function t(text) {
      var data = EmptyObject;
      var sel, children, key, elm;
      return {
        sel: sel,
        data: data,
        children: children,
        text: text,
        elm: elm,
        key: key,
        hook: TextHook,
        owner: getVMBeingRendered()
      };
    } // comment node


    function p(text) {
      var data = EmptyObject;
      var sel = '!';
      var children, key, elm;
      return {
        sel: sel,
        data: data,
        children: children,
        text: text,
        elm: elm,
        key: key,
        hook: CommentHook,
        owner: getVMBeingRendered()
      };
    } // [d]ynamic value to produce a text vnode


    function d(value) {
      if (value == null) {
        return null;
      }

      return t(value);
    } // [b]ind function


    function b(fn) {
      var vmBeingRendered = getVMBeingRendered();

      if (isNull(vmBeingRendered)) {
        throw new Error();
      }

      var vm = vmBeingRendered;
      return function (event) {
        invokeEventListener(vm, fn, vm.component, event);
      };
    } // [f]unction_[b]ind


    function fb(fn) {
      var vmBeingRendered = getVMBeingRendered();

      if (isNull(vmBeingRendered)) {
        throw new Error();
      }

      var vm = vmBeingRendered;
      return function () {
        return invokeComponentCallback(vm, fn, ArraySlice$1.call(arguments));
      };
    } // [l]ocator_[l]istener function


    function ll(originalHandler, id, context) {
      var vm = getVMBeingRendered();

      if (isNull(vm)) {
        throw new Error();
      } // bind the original handler with b() so we can call it
      // after resolving the locator


      var eventListener = b(originalHandler); // create a wrapping handler to resolve locator, and
      // then invoke the original handler.

      return function (event) {
        // located service for the locator metadata
        var locator = vm.context.locator;

        if (!isUndefined(locator)) {
          var locatorService = Services.locator;

          if (locatorService) {
            locator.resolved = {
              target: id,
              host: locator.id,
              targetContext: isFunction(context) && context(),
              hostContext: isFunction(locator.context) && locator.context()
            }; // a registered `locator` service will be invoked with
            // access to the context.locator.resolved, which will contain:
            // outer id, outer context, inner id, and inner context

            invokeServiceHook(vm, locatorService);
          }
        } // invoke original event listener via b()


        eventListener(event);
      };
    } // [k]ey function


    function k(compilerKey, obj) {
      switch (_typeof(obj)) {
        case 'number':
        case 'string':
          return compilerKey + ':' + obj;

        case 'object':
          {
            assert.fail("Invalid key value \"".concat(obj, "\" in ").concat(getVMBeingRendered(), ". Key must be a string or number."));
          }

      }
    } // [g]lobal [id] function


    function gid(id) {
      var vmBeingRendered = getVMBeingRendered();

      if (isUndefined(id) || id === '') {
        {
          logError("Invalid id value \"".concat(id, "\". The id attribute must contain a non-empty string."), vmBeingRendered);
        }

        return id;
      } // We remove attributes when they are assigned a value of null


      if (isNull(id)) {
        return null;
      }

      return "".concat(id, "-").concat(vmBeingRendered.idx);
    } // [f]ragment [id] function


    function fid(url) {
      var vmBeingRendered = getVMBeingRendered();

      if (isUndefined(url) || url === '') {
        {
          if (isUndefined(url)) {
            logError("Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.", vmBeingRendered);
          }
        }

        return url;
      } // We remove attributes when they are assigned a value of null


      if (isNull(url)) {
        return null;
      } // Apply transformation only for fragment-only-urls


      if (/^#/.test(url)) {
        return "".concat(url, "-").concat(vmBeingRendered.idx);
      }

      return url;
    }
    /**
     * Map to store an index value assigned to any dynamic component reference ingested
     * by dc() api. This allows us to generate a unique unique per template per dynamic
     * component reference to avoid diffing algo mismatches.
     */


    var DynamicImportedComponentMap = new Map();
    var dynamicImportedComponentCounter = 0;
    /**
     * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`
     */

    function dc(sel, Ctor, data, children) {
      {
        assert.isTrue(isString(sel), "dc() 1st argument sel must be a string.");
        assert.isTrue(isObject$1(data), "dc() 3nd argument data must be an object.");
        assert.isTrue(arguments.length === 3 || isArray$1(children), "dc() 4nd argument data must be an array.");
      } // null or undefined values should produce a null value in the VNodes


      if (Ctor == null) {
        return null;
      }

      if (!isComponentConstructor(Ctor)) {
        throw new Error("Invalid LWC Constructor ".concat(toString(Ctor), " for custom element <").concat(sel, ">."));
      }

      var idx = DynamicImportedComponentMap.get(Ctor);

      if (isUndefined(idx)) {
        idx = dynamicImportedComponentCounter++;
        DynamicImportedComponentMap.set(Ctor, idx);
      } // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo
      // to identify different constructors as vnodes with different keys to avoid reusing the
      // element used for previous constructors.


      data.key = "dc:".concat(idx, ":").concat(data.key);
      return c(sel, Ctor, data, children);
    }
    /**
     * slow children collection marking mechanism. this API allows the compiler to signal
     * to the engine that a particular collection of children must be diffed using the slow
     * algo based on keys due to the nature of the list. E.g.:
     *
     *   - slot element's children: the content of the slot has to be dynamic when in synthetic
     *                              shadow mode because the `vnode.children` might be the slotted
     *                              content vs default content, in which case the size and the
     *                              keys are not matching.
     *   - children that contain dynamic components
     *   - children that are produced by iteration
     *
     */


    function sc(vnodes) {
      {
        assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');
      } // We have to mark the vnodes collection as dynamic so we can later on
      // choose to use the snabbdom virtual dom diffing algo instead of our
      // static dummy algo.


      markAsDynamicChildren(vnodes);
      return vnodes;
    }

    var api =
    /*#__PURE__*/
    Object.freeze({
      __proto__: null,
      h: h,
      ti: ti,
      s: s,
      c: c,
      i: i,
      f: f,
      t: t,
      p: p,
      d: d,
      b: b,
      fb: fb,
      ll: ll,
      k: k,
      gid: gid,
      fid: fid,
      dc: dc,
      sc: sc
    });
    var signedTemplateSet = new Set();

    function defaultEmptyTemplate() {
      return [];
    }

    signedTemplateSet.add(defaultEmptyTemplate);

    function isTemplateRegistered(tpl) {
      return signedTemplateSet.has(tpl);
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */


    function registerTemplate(tpl) {
      signedTemplateSet.add(tpl); // chaining this method as a way to wrap existing
      // assignment of templates easily, without too much transformation

      return tpl;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker
     * Service and other similar libraries to sanitize vulnerable attributes.
     * This API is subject to change or being removed.
     */


    function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
      // locker-service patches this function during runtime to sanitize vulnerable attributes.
      // when ran off-core this function becomes a noop and returns the user authored value.
      return attrValue;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var CachedStyleFragments = create(null);

    function createStyleElement(styleContent) {
      var elm = document.createElement('style');
      elm.type = 'text/css';
      elm.textContent = styleContent;
      return elm;
    }

    function getCachedStyleElement(styleContent) {
      var fragment = CachedStyleFragments[styleContent];

      if (isUndefined(fragment)) {
        fragment = document.createDocumentFragment();
        var styleElm = createStyleElement(styleContent);
        fragment.appendChild(styleElm);
        CachedStyleFragments[styleContent] = fragment;
      }

      return fragment.cloneNode(true).firstChild;
    }

    var globalStyleParent = document.head || document.body || document;
    var InsertedGlobalStyleContent = create(null);

    function insertGlobalStyle(styleContent) {
      // inserts the global style when needed, otherwise does nothing
      if (isUndefined(InsertedGlobalStyleContent[styleContent])) {
        InsertedGlobalStyleContent[styleContent] = true;
        var elm = createStyleElement(styleContent);
        globalStyleParent.appendChild(elm);
      }
    }

    function createStyleVNode(elm) {
      var vnode = h('style', {
        key: 'style'
      }, EmptyArray); // TODO [#1364]: supporting the ability to inject a cloned StyleElement
      // forcing the diffing algo to use the cloned style for native shadow

      vnode.clonedElement = elm;
      return vnode;
    }
    /**
     * Reset the styling token applied to the host element.
     */


    function resetStyleAttributes(vm) {
      var context = vm.context,
          elm = vm.elm; // Remove the style attribute currently applied to the host element.

      var oldHostAttribute = context.hostAttribute;

      if (!isUndefined(oldHostAttribute)) {
        removeAttribute.call(elm, oldHostAttribute);
      } // Reset the scoping attributes associated to the context.


      context.hostAttribute = context.shadowAttribute = undefined;
    }
    /**
     * Apply/Update the styling token applied to the host element.
     */


    function applyStyleAttributes(vm, hostAttribute, shadowAttribute) {
      var context = vm.context,
          elm = vm.elm; // Remove the style attribute currently applied to the host element.

      setAttribute.call(elm, hostAttribute, '');
      context.hostAttribute = hostAttribute;
      context.shadowAttribute = shadowAttribute;
    }

    function collectStylesheets(stylesheets, hostSelector, shadowSelector, isNative, aggregatorFn) {
      forEach.call(stylesheets, function (sheet) {
        if (isArray$1(sheet)) {
          collectStylesheets(sheet, hostSelector, shadowSelector, isNative, aggregatorFn);
        } else {
          aggregatorFn(sheet(hostSelector, shadowSelector, isNative));
        }
      });
    }

    function evaluateCSS(stylesheets, hostAttribute, shadowAttribute) {
      {
        assert.isTrue(isArray$1(stylesheets), "Invalid stylesheets.");
      }

      if (useSyntheticShadow) {
        var hostSelector = "[".concat(hostAttribute, "]");
        var shadowSelector = "[".concat(shadowAttribute, "]");
        collectStylesheets(stylesheets, hostSelector, shadowSelector, false, function (textContent) {
          insertGlobalStyle(textContent);
        });
        return null;
      } else {
        // Native shadow in place, we need to act accordingly by using the `:host` selector, and an
        // empty shadow selector since it is not really needed.
        var buffer = '';
        collectStylesheets(stylesheets, emptyString, emptyString, true, function (textContent) {
          buffer += textContent;
        });
        return createStyleVNode(getCachedStyleElement(buffer));
      }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var GlobalMeasurementPhase;

    (function (GlobalMeasurementPhase) {
      GlobalMeasurementPhase["REHYDRATE"] = "lwc-rehydrate";
      GlobalMeasurementPhase["HYDRATE"] = "lwc-hydrate";
    })(GlobalMeasurementPhase || (GlobalMeasurementPhase = {})); // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
    // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.


    var isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

    function getMarkName(phase, vm) {
      // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce
      // the right measures for components that are recursive.
      return "".concat(getComponentTag(vm), " - ").concat(phase, " - ").concat(vm.idx);
    }

    function getMeasureName(phase, vm) {
      return "".concat(getComponentTag(vm), " - ").concat(phase);
    }

    function start(markName) {
      performance.mark(markName);
    }

    function end(measureName, markName) {
      performance.measure(measureName, markName); // Clear the created marks and measure to avoid filling the performance entries buffer.
      // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.

      performance.clearMarks(markName);
      performance.clearMarks(measureName);
    }

    function noop$1() {
      /* do nothing */
    }

    var startMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
      var markName = getMarkName(phase, vm);
      start(markName);
    };
    var endMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
      var markName = getMarkName(phase, vm);
      var measureName = getMeasureName(phase, vm);
      end(measureName, markName);
    };
    var startGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
      var markName = isUndefined(vm) ? phase : getMarkName(phase, vm);
      start(markName);
    };
    var endGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
      var markName = isUndefined(vm) ? phase : getMarkName(phase, vm);
      end(phase, markName);
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var isUpdatingTemplate = false;
    var vmBeingRendered = null;

    function getVMBeingRendered() {
      return vmBeingRendered;
    }

    function setVMBeingRendered(vm) {
      vmBeingRendered = vm;
    }

    var EmptySlots = create(null);

    function validateSlots(vm, html) {

      var _vm$cmpSlots = vm.cmpSlots,
          cmpSlots = _vm$cmpSlots === void 0 ? EmptySlots : _vm$cmpSlots;
      var _html$slots = html.slots,
          slots = _html$slots === void 0 ? EmptyArray : _html$slots;

      for (var slotName in cmpSlots) {
        // eslint-disable-next-line lwc-internal/no-production-assert
        assert.isTrue(isArray$1(cmpSlots[slotName]), "Slots can only be set to an array, instead received ".concat(toString(cmpSlots[slotName]), " for slot \"").concat(slotName, "\" in ").concat(vm, "."));

        if (slotName !== '' && ArrayIndexOf.call(slots, slotName) === -1) {
          // TODO [#1297]: this should never really happen because the compiler should always validate
          // eslint-disable-next-line lwc-internal/no-production-assert
          logError("Ignoring unknown provided slot name \"".concat(slotName, "\" in ").concat(vm, ". Check for a typo on the slot attribute."), vm);
        }
      }
    }

    function validateFields(vm, html) {

      var component = vm.component; // validating identifiers used by template that should be provided by the component

      var _html$ids = html.ids,
          ids = _html$ids === void 0 ? [] : _html$ids;
      forEach.call(ids, function (propName) {
        if (!(propName in component)) {
          // eslint-disable-next-line lwc-internal/no-production-assert
          logError("The template rendered by ".concat(vm, " references `this.").concat(propName, "`, which is not declared. Check for a typo in the template."), vm);
        }
      });
    }

    function evaluateTemplate(vm, html) {
      {
        assert.isTrue(isFunction(html), "evaluateTemplate() second argument must be an imported template instead of ".concat(toString(html)));
      }

      var isUpdatingTemplateInception = isUpdatingTemplate;
      var vmOfTemplateBeingUpdatedInception = vmBeingRendered;
      var vnodes = [];
      runWithBoundaryProtection(vm, vm.owner, function () {
        // pre
        vmBeingRendered = vm;

        {
          startMeasure('render', vm);
        }
      }, function () {
        // job
        var component = vm.component,
            context = vm.context,
            cmpSlots = vm.cmpSlots,
            cmpTemplate = vm.cmpTemplate,
            tro = vm.tro;
        tro.observe(function () {
          // reset the cache memoizer for template when needed
          if (html !== cmpTemplate) {
            // perf opt: do not reset the shadow root during the first rendering (there is nothing to reset)
            if (!isUndefined(cmpTemplate)) {
              // It is important to reset the content to avoid reusing similar elements generated from a different
              // template, because they could have similar IDs, and snabbdom just rely on the IDs.
              resetShadowRoot(vm);
            } // Check that the template was built by the compiler


            if (isUndefined(html) || !isTemplateRegistered(html)) {
              throw new TypeError("Invalid template returned by the render() method on ".concat(vm, ". It must return an imported template (e.g.: `import html from \"./").concat(vm.def.name, ".html\"`), instead, it has returned: ").concat(toString(html), "."));
            }

            vm.cmpTemplate = html; // Populate context with template information

            context.tplCache = create(null);
            resetStyleAttributes(vm);
            var stylesheets = html.stylesheets,
                stylesheetTokens = html.stylesheetTokens;

            if (isUndefined(stylesheets) || stylesheets.length === 0) {
              context.styleVNode = null;
            } else if (!isUndefined(stylesheetTokens)) {
              var hostAttribute = stylesheetTokens.hostAttribute,
                  shadowAttribute = stylesheetTokens.shadowAttribute;
              applyStyleAttributes(vm, hostAttribute, shadowAttribute); // Caching style vnode so it can be reused on every render

              context.styleVNode = evaluateCSS(stylesheets, hostAttribute, shadowAttribute);
            }

            if ("development" !== 'production') {
              // one time operation for any new template returned by render()
              // so we can warn if the template is attempting to use a binding
              // that is not provided by the component instance.
              validateFields(vm, html);
            }
          }

          if ("development" !== 'production') {
            assert.isTrue(isObject$1(context.tplCache), "vm.context.tplCache must be an object associated to ".concat(cmpTemplate, ".")); // validating slots in every rendering since the allocated content might change over time

            validateSlots(vm, html);
          } // right before producing the vnodes, we clear up all internal references
          // to custom elements from the template.


          vm.velements = []; // Set the global flag that template is being updated

          isUpdatingTemplate = true;
          vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);
          var styleVNode = context.styleVNode;

          if (!isNull(styleVNode)) {
            ArrayUnshift$1.call(vnodes, styleVNode);
          }
        });
      }, function () {
        // post
        isUpdatingTemplate = isUpdatingTemplateInception;
        vmBeingRendered = vmOfTemplateBeingUpdatedInception;

        {
          endMeasure('render', vm);
        }
      });

      {
        assert.invariant(isArray$1(vnodes), "Compiler should produce html functions that always return an array.");
      }

      return vnodes;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var isInvokingRender = false;
    var vmBeingConstructed = null;

    function isBeingConstructed(vm) {
      return vmBeingConstructed === vm;
    }

    function invokeComponentCallback(vm, fn, args) {
      var component = vm.component,
          callHook = vm.callHook,
          context = vm.context,
          owner = vm.owner;
      var result;
      runWithBoundaryProtection(vm, owner, function () {}, function () {
        // job
        result = callHook(component, fn, args);
      }, function () {});
      return result;
    }

    function invokeComponentConstructor(vm, Ctor) {
      var vmBeingConstructedInception = vmBeingConstructed;
      var error;

      {
        startMeasure('constructor', vm);
      }

      vmBeingConstructed = vm;
      /**
       * Constructors don't need to be wrapped with a boundary because for root elements
       * it should throw, while elements from template are already wrapped by a boundary
       * associated to the diffing algo.
       */

      try {
        // job
        var result = new Ctor(); // Check indirectly if the constructor result is an instance of LightningElement. Using
        // the "instanceof" operator would not work here since Locker Service provides its own
        // implementation of LightningElement, so we indirectly check if the base constructor is
        // invoked by accessing the component on the vm.

        if (vmBeingConstructed.component !== result) {
          throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
        }
      } catch (e) {
        error = Object(e);
      } finally {
        {
          endMeasure('constructor', vm);
        }

        vmBeingConstructed = vmBeingConstructedInception;

        if (!isUndefined(error)) {
          error.wcStack = getErrorComponentStack(vm); // re-throwing the original error annotated after restoring the context

          throw error; // eslint-disable-line no-unsafe-finally
        }
      }
    }

    function invokeComponentRenderMethod(vm) {
      var render = vm.def.render,
          callHook = vm.callHook,
          component = vm.component,
          context = vm.context,
          owner = vm.owner;
      var isRenderBeingInvokedInception = isInvokingRender;
      var vmBeingRenderedInception = getVMBeingRendered();
      var html;
      var renderInvocationSuccessful = false;
      runWithBoundaryProtection(vm, owner, function () {
        isInvokingRender = true;
        setVMBeingRendered(vm);
      }, function () {
        // job
        vm.tro.observe(function () {
          html = callHook(component, render);
          renderInvocationSuccessful = true;
        });
      }, function () {
        isInvokingRender = isRenderBeingInvokedInception;
        setVMBeingRendered(vmBeingRenderedInception);
      }); // If render() invocation failed, process errorCallback in boundary and return an empty template

      return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];
    }

    function invokeEventListener(vm, fn, thisValue, event) {
      var callHook = vm.callHook,
          owner = vm.owner,
          context = vm.context;
      runWithBoundaryProtection(vm, owner, function () {}, function () {
        // job
        if ("development" !== 'production') {
          assert.isTrue(isFunction(fn), "Invalid event handler for event '".concat(event.type, "' on ").concat(vm, "."));
        }

        callHook(thisValue, fn, [event]);
      }, function () {});
    }
    /*
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var create$1 = Object.create;
    var _Array$prototype3 = Array.prototype,
        ArraySplice$1 = _Array$prototype3.splice,
        ArrayIndexOf$1 = _Array$prototype3.indexOf,
        ArrayPush$1 = _Array$prototype3.push;
    var TargetToReactiveRecordMap = new WeakMap();

    function isUndefined$1(obj) {
      return obj === undefined;
    }

    function getReactiveRecord(target) {
      var reactiveRecord = TargetToReactiveRecordMap.get(target);

      if (isUndefined$1(reactiveRecord)) {
        var newRecord = create$1(null);
        reactiveRecord = newRecord;
        TargetToReactiveRecordMap.set(target, newRecord);
      }

      return reactiveRecord;
    }

    var currentReactiveObserver = null;

    function valueMutated(target, key) {
      var reactiveRecord = TargetToReactiveRecordMap.get(target);

      if (!isUndefined$1(reactiveRecord)) {
        var reactiveObservers = reactiveRecord[key];

        if (!isUndefined$1(reactiveObservers)) {
          for (var _i6 = 0, _len5 = reactiveObservers.length; _i6 < _len5; _i6 += 1) {
            var ro = reactiveObservers[_i6];
            ro.notify();
          }
        }
      }
    }

    function valueObserved(target, key) {
      // We should determine if an active Observing Record is present to track mutations.
      if (currentReactiveObserver === null) {
        return;
      }

      var ro = currentReactiveObserver;
      var reactiveRecord = getReactiveRecord(target);
      var reactiveObservers = reactiveRecord[key];

      if (isUndefined$1(reactiveObservers)) {
        reactiveObservers = [];
        reactiveRecord[key] = reactiveObservers;
      } else if (reactiveObservers[0] === ro) {
        return; // perf optimization considering that most subscriptions will come from the same record
      }

      if (ArrayIndexOf$1.call(reactiveObservers, ro) === -1) {
        ro.link(reactiveObservers);
      }
    }

    var ReactiveObserver =
    /*#__PURE__*/
    function () {
      function ReactiveObserver(callback) {
        _classCallCheck(this, ReactiveObserver);

        this.listeners = [];
        this.callback = callback;
      }

      _createClass(ReactiveObserver, [{
        key: "observe",
        value: function observe(job) {
          var inceptionReactiveRecord = currentReactiveObserver;
          currentReactiveObserver = this;
          var error;

          try {
            job();
          } catch (e) {
            error = Object(e);
          } finally {
            currentReactiveObserver = inceptionReactiveRecord;

            if (error !== undefined) {
              throw error; // eslint-disable-line no-unsafe-finally
            }
          }
        }
        /**
         * This method is responsible for disconnecting the Reactive Observer
         * from any Reactive Record that has a reference to it, to prevent future
         * notifications about previously recorded access.
         */

      }, {
        key: "reset",
        value: function reset() {
          var listeners = this.listeners;
          var len = listeners.length;

          if (len > 0) {
            for (var _i7 = 0; _i7 < len; _i7 += 1) {
              var set = listeners[_i7];
              var pos = ArrayIndexOf$1.call(listeners[_i7], this);
              ArraySplice$1.call(set, pos, 1);
            }

            listeners.length = 0;
          }
        } // friend methods

      }, {
        key: "notify",
        value: function notify() {
          this.callback.call(undefined, this);
        }
      }, {
        key: "link",
        value: function link(reactiveObservers) {
          ArrayPush$1.call(reactiveObservers, this); // we keep track of observing records where the observing record was added to so we can do some clean up later on

          ArrayPush$1.call(this.listeners, reactiveObservers);
        }
      }]);

      return ReactiveObserver;
    }();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var signedComponentToMetaMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */

    function registerComponent(Ctor, _ref) {
      var name = _ref.name,
          template = _ref.tmpl;
      signedComponentToMetaMap.set(Ctor, {
        name: name,
        template: template
      }); // chaining this method as a way to wrap existing
      // assignment of component constructor easily, without too much transformation

      return Ctor;
    }

    function getComponentRegisteredMeta(Ctor) {
      return signedComponentToMetaMap.get(Ctor);
    }

    function createComponent(uninitializedVm, Ctor) {
      // create the component instance
      invokeComponentConstructor(uninitializedVm, Ctor);
      var initializedVm = uninitializedVm;

      if (isUndefined(initializedVm.component)) {
        throw new ReferenceError("Invalid construction for ".concat(Ctor, ", you must extend LightningElement."));
      }
    }

    function linkComponent(vm) {
      var wire = vm.def.wire;

      if (!isUndefined(wire)) {
        var wiring = Services.wiring;

        if (wiring) {
          invokeServiceHook(vm, wiring);
        }
      }
    }

    function getTemplateReactiveObserver(vm) {
      return new ReactiveObserver(function () {
        {
          assert.invariant(!isInvokingRender, "Mutating property is not allowed during the rendering life-cycle of ".concat(getVMBeingRendered(), "."));
          assert.invariant(!isUpdatingTemplate, "Mutating property is not allowed while updating template of ".concat(getVMBeingRendered(), "."));
        }

        var isDirty = vm.isDirty;

        if (isFalse$1(isDirty)) {
          markComponentAsDirty(vm);
          scheduleRehydration(vm);
        }
      });
    }

    function renderComponent(vm) {
      {
        assert.invariant(vm.isDirty, "".concat(vm, " is not dirty."));
      }

      vm.tro.reset();
      var vnodes = invokeComponentRenderMethod(vm);
      vm.isDirty = false;
      vm.isScheduled = false;

      {
        assert.invariant(isArray$1(vnodes), "".concat(vm, ".render() should always return an array of vnodes instead of ").concat(vnodes));
      }

      return vnodes;
    }

    function markComponentAsDirty(vm) {
      {
        var _vmBeingRendered2 = getVMBeingRendered();

        assert.isFalse(vm.isDirty, "markComponentAsDirty() for ".concat(vm, " should not be called when the component is already dirty."));
        assert.isFalse(isInvokingRender, "markComponentAsDirty() for ".concat(vm, " cannot be called during rendering of ").concat(_vmBeingRendered2, "."));
        assert.isFalse(isUpdatingTemplate, "markComponentAsDirty() for ".concat(vm, " cannot be called while updating template of ").concat(_vmBeingRendered2, "."));
      }

      vm.isDirty = true;
    }

    var cmpEventListenerMap = new WeakMap();

    function getWrappedComponentsListener(vm, listener) {
      if (!isFunction(listener)) {
        throw new TypeError(); // avoiding problems with non-valid listeners
      }

      var wrappedListener = cmpEventListenerMap.get(listener);

      if (isUndefined(wrappedListener)) {
        wrappedListener = function wrappedListener(event) {
          invokeEventListener(vm, listener, undefined, event);
        };

        cmpEventListenerMap.set(listener, wrappedListener);
      }

      return wrappedListener;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function createObservedFieldsDescriptorMap(fields) {
      return ArrayReduce.call(fields, function (acc, field) {
        acc[field] = createObservedFieldPropertyDescriptor(field);
        return acc;
      }, {});
    }

    function createObservedFieldPropertyDescriptor(key) {
      return {
        get: function get() {
          var vm = getAssociatedVM(this);
          valueObserved(this, key);
          return vm.cmpTrack[key];
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);

          if (newValue !== vm.cmpTrack[key]) {
            vm.cmpTrack[key] = newValue;

            if (isFalse$1(vm.isDirty)) {
              valueMutated(this, key);
            }
          }
        },
        enumerable: true,
        configurable: true
      };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * This is a descriptor map that contains
     * all standard properties that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base HTML Element and
     * Base Lightning Element should support.
     */


    var HTMLElementOriginalDescriptors = create(null);
    forEach.call(ElementPrototypeAriaPropertyNames, function (propName) {
      // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
      // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
      var descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);

      if (!isUndefined(descriptor)) {
        HTMLElementOriginalDescriptors[propName] = descriptor;
      }
    });
    forEach.call(defaultDefHTMLPropertyNames, function (propName) {
      // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
      // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
      // this category, so, better to be sure.
      var descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);

      if (!isUndefined(descriptor)) {
        HTMLElementOriginalDescriptors[propName] = descriptor;
      }
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var ShadowRootInnerHTMLSetter = getOwnPropertyDescriptor(ShadowRoot.prototype, 'innerHTML').set;

    var _dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent; // IE11

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * This operation is called with a descriptor of an standard html property
     * that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
     * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
     */


    function createBridgeToElementDescriptor(propName, descriptor) {
      var _get = descriptor.get,
          _set = descriptor.set,
          enumerable = descriptor.enumerable,
          configurable = descriptor.configurable;

      if (!isFunction(_get)) {
        {
          assert.fail("Detected invalid public property descriptor for HTMLElement.prototype.".concat(propName, " definition. Missing the standard getter."));
        }

        throw new TypeError();
      }

      if (!isFunction(_set)) {
        {
          assert.fail("Detected invalid public property descriptor for HTMLElement.prototype.".concat(propName, " definition. Missing the standard setter."));
        }

        throw new TypeError();
      }

      return {
        enumerable: enumerable,
        configurable: configurable,
        get: function get() {
          var vm = getAssociatedVM(this);

          if (isBeingConstructed(vm)) {
            {
              var name = vm.elm.constructor.name;
              logError("`".concat(name, "` constructor can't read the value of property `").concat(propName, "` because the owner component hasn't set the value yet. Instead, use the `").concat(name, "` constructor to set a default value for the property."), vm);
            }

            return;
          }

          valueObserved(this, propName);
          return _get.call(vm.elm);
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);

          {
            var _vmBeingRendered3 = getVMBeingRendered();

            assert.invariant(!isInvokingRender, "".concat(_vmBeingRendered3, ".render() method has side effects on the state of ").concat(vm, ".").concat(propName));
            assert.invariant(!isUpdatingTemplate, "When updating the template of ".concat(_vmBeingRendered3, ", one of the accessors used by the template has side effects on the state of ").concat(vm, ".").concat(propName));
            assert.isFalse(isBeingConstructed(vm), "Failed to construct '".concat(getComponentTag(vm), "': The result must not have attributes."));
            assert.invariant(!isObject$1(newValue) || isNull(newValue), "Invalid value \"".concat(newValue, "\" for \"").concat(propName, "\" of ").concat(vm, ". Value cannot be an object, must be a primitive value."));
          }

          if (newValue !== vm.cmpProps[propName]) {
            vm.cmpProps[propName] = newValue;

            if (isFalse$1(vm.isDirty)) {
              // perf optimization to skip this step if not in the DOM
              valueMutated(this, propName);
            }
          }

          return _set.call(vm.elm, newValue);
        }
      };
    }

    function getLinkedElement(cmp) {
      return getAssociatedVM(cmp).elm;
    }
    /**
     * This class is the base class for any LWC element.
     * Some elements directly extends this class, others implement it via inheritance.
     **/


    function BaseLightningElementConstructor() {
      // This should be as performant as possible, while any initialization should be done lazily
      if (isNull(vmBeingConstructed)) {
        throw new ReferenceError('Illegal constructor');
      }

      {
        assert.invariant(_instanceof(vmBeingConstructed.elm, HTMLElement), "Component creation requires a DOM element to be associated to ".concat(vmBeingConstructed, "."));
      }

      var vm = vmBeingConstructed;
      var elm = vm.elm,
          mode = vm.mode,
          ctor = vm.def.ctor;
      var component = this;
      vm.component = component;
      vm.tro = getTemplateReactiveObserver(vm);
      vm.oar = create(null); // interaction hooks
      // We are intentionally hiding this argument from the formal API of LWCElement because
      // we don't want folks to know about it just yet.

      if (arguments.length === 1) {
        var _arguments$ = arguments[0],
            _callHook = _arguments$.callHook,
            _setHook = _arguments$.setHook,
            _getHook = _arguments$.getHook;
        vm.callHook = _callHook;
        vm.setHook = _setHook;
        vm.getHook = _getHook;
      } // attaching the shadowRoot


      var shadowRootOptions = {
        mode: mode,
        delegatesFocus: !!ctor.delegatesFocus,
        '$$lwc-synthetic-mode$$': true
      };
      var cmpRoot = elm.attachShadow(shadowRootOptions); // linking elm, shadow root and component with the VM

      associateVM(component, vm);
      associateVM(cmpRoot, vm);
      associateVM(elm, vm); // VM is now initialized

      vm.cmpRoot = cmpRoot;

      {
        patchComponentWithRestrictions(component);
        patchShadowRootWithRestrictions(cmpRoot, EmptyObject);
      }

      return this;
    } // HTML Element - The Good Parts


    BaseLightningElementConstructor.prototype = {
      constructor: BaseLightningElementConstructor,
      dispatchEvent: function dispatchEvent(_event) {
        var elm = getLinkedElement(this); // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch;

        return _dispatchEvent.apply(elm, arguments);
      },
      addEventListener: function addEventListener(type, listener, options) {
        var vm = getAssociatedVM(this);

        {
          var _vmBeingRendered4 = getVMBeingRendered();

          assert.invariant(!isInvokingRender, "".concat(_vmBeingRendered4, ".render() method has side effects on the state of ").concat(vm, " by adding an event listener for \"").concat(type, "\"."));
          assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(_vmBeingRendered4, " has side effects on the state of ").concat(vm, " by adding an event listener for \"").concat(type, "\"."));
          assert.invariant(isFunction(listener), "Invalid second argument for this.addEventListener() in ".concat(vm, " for event \"").concat(type, "\". Expected an EventListener but received ").concat(listener, "."));
        }

        var wrappedListener = getWrappedComponentsListener(vm, listener);
        vm.elm.addEventListener(type, wrappedListener, options);
      },
      removeEventListener: function removeEventListener(type, listener, options) {
        var vm = getAssociatedVM(this);
        var wrappedListener = getWrappedComponentsListener(vm, listener);
        vm.elm.removeEventListener(type, wrappedListener, options);
      },
      setAttributeNS: function setAttributeNS(ns, attrName, _value) {
        var elm = getLinkedElement(this);

        {
          var vm = getAssociatedVM(this);
          assert.isFalse(isBeingConstructed(vm), "Failed to construct '".concat(getComponentTag(vm), "': The result must not have attributes."));
        }

        unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch

        elm.setAttributeNS.apply(elm, arguments);
        lockAttribute();
      },
      removeAttributeNS: function removeAttributeNS(ns, attrName) {
        var elm = getLinkedElement(this);
        unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch

        elm.removeAttributeNS.apply(elm, arguments);
        lockAttribute();
      },
      removeAttribute: function removeAttribute(attrName) {
        var elm = getLinkedElement(this);
        unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch

        elm.removeAttribute.apply(elm, arguments);
        lockAttribute();
      },
      setAttribute: function setAttribute(attrName, _value) {
        var elm = getLinkedElement(this);

        {
          var vm = getAssociatedVM(this);
          assert.isFalse(isBeingConstructed(vm), "Failed to construct '".concat(getComponentTag(vm), "': The result must not have attributes."));
        }

        unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch

        elm.setAttribute.apply(elm, arguments);
        lockAttribute();
      },
      getAttribute: function getAttribute(attrName) {
        var elm = getLinkedElement(this);
        unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch

        var value = elm.getAttribute.apply(elm, arguments);
        lockAttribute();
        return value;
      },
      getAttributeNS: function getAttributeNS(ns, attrName) {
        var elm = getLinkedElement(this);
        unlockAttribute(elm, attrName); // Typescript does not like it when you treat the `arguments` object as an array
        // @ts-ignore type-mismatch

        var value = elm.getAttributeNS.apply(elm, arguments);
        lockAttribute();
        return value;
      },
      getBoundingClientRect: function getBoundingClientRect() {
        var elm = getLinkedElement(this);

        {
          var vm = getAssociatedVM(this);
          assert.isFalse(isBeingConstructed(vm), "this.getBoundingClientRect() should not be called during the construction of the custom element for ".concat(getComponentTag(vm), " because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks."));
        }

        return elm.getBoundingClientRect();
      },

      /**
       * Returns the first element that is a descendant of node that
       * matches selectors.
       */
      // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
      // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;
      querySelector: function querySelector(selectors) {
        var vm = getAssociatedVM(this);

        {
          assert.isFalse(isBeingConstructed(vm), "this.querySelector() cannot be called during the construction of the custom element for ".concat(getComponentTag(vm), " because no children has been added to this element yet."));
        }

        var elm = vm.elm;
        return elm.querySelector(selectors);
      },

      /**
       * Returns all element descendants of node that
       * match selectors.
       */
      // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,
      // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,
      querySelectorAll: function querySelectorAll(selectors) {
        var vm = getAssociatedVM(this);

        {
          assert.isFalse(isBeingConstructed(vm), "this.querySelectorAll() cannot be called during the construction of the custom element for ".concat(getComponentTag(vm), " because no children has been added to this element yet."));
        }

        var elm = vm.elm;
        return elm.querySelectorAll(selectors);
      },

      /**
       * Returns all element descendants of node that
       * match the provided tagName.
       */
      getElementsByTagName: function getElementsByTagName(tagNameOrWildCard) {
        var vm = getAssociatedVM(this);

        {
          assert.isFalse(isBeingConstructed(vm), "this.getElementsByTagName() cannot be called during the construction of the custom element for ".concat(getComponentTag(vm), " because no children has been added to this element yet."));
        }

        var elm = vm.elm;
        return elm.getElementsByTagName(tagNameOrWildCard);
      },

      /**
       * Returns all element descendants of node that
       * match the provide classnames.
       */
      getElementsByClassName: function getElementsByClassName(names) {
        var vm = getAssociatedVM(this);

        {
          assert.isFalse(isBeingConstructed(vm), "this.getElementsByClassName() cannot be called during the construction of the custom element for ".concat(getComponentTag(vm), " because no children has been added to this element yet."));
        }

        var elm = vm.elm;
        return elm.getElementsByClassName(names);
      },

      get classList() {
        {
          var vm = getAssociatedVM(this); // TODO [#1290]: this still fails in dev but works in production, eventually, we should just throw in all modes

          assert.isFalse(isBeingConstructed(vm), "Failed to construct ".concat(vm, ": The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead."));
        }

        return getLinkedElement(this).classList;
      },

      get template() {
        var vm = getAssociatedVM(this);
        return vm.cmpRoot;
      },

      get shadowRoot() {
        // From within the component instance, the shadowRoot is always
        // reported as "closed". Authors should rely on this.template instead.
        return null;
      },

      render: function render() {
        var vm = getAssociatedVM(this);
        return vm.def.template;
      },
      toString: function toString() {
        var vm = getAssociatedVM(this);
        return "[object ".concat(vm.def.name, "]");
      }
    }; // Typescript is inferring the wrong function type for this particular
    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
    // @ts-ignore type-mismatch

    var baseDescriptors = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), function (descriptors, propName) {
      descriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);
      return descriptors;
    }, create(null));
    defineProperties(BaseLightningElementConstructor.prototype, baseDescriptors);

    {
      patchLightningElementPrototypeWithRestrictions(BaseLightningElementConstructor.prototype);
    }

    freeze(BaseLightningElementConstructor);
    seal(BaseLightningElementConstructor.prototype); // @ts-ignore

    var BaseLightningElement = BaseLightningElementConstructor;
    /**
     * Copyright (C) 2017 salesforce.com, inc.
     */

    var isArray$2 = Array.isArray;
    var getPrototypeOf$1 = Object.getPrototypeOf,
        ObjectCreate = Object.create,
        ObjectDefineProperty = Object.defineProperty,
        _isExtensible = Object.isExtensible,
        getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor,
        getOwnPropertyNames$1 = Object.getOwnPropertyNames,
        getOwnPropertySymbols = Object.getOwnPropertySymbols,
        _preventExtensions = Object.preventExtensions,
        hasOwnProperty$2 = Object.hasOwnProperty;
    var _Array$prototype4 = Array.prototype,
        ArrayPush$2 = _Array$prototype4.push,
        ArrayConcat = _Array$prototype4.concat;
    var OtS$1 = {}.toString;

    function toString$1(obj) {
      if (obj && obj.toString) {
        return obj.toString();
      } else if (_typeof(obj) === 'object') {
        return OtS$1.call(obj);
      } else {
        return obj + '';
      }
    }

    function isUndefined$2(obj) {
      return obj === undefined;
    }

    function isFunction$1(obj) {
      return typeof obj === 'function';
    }

    function isObject$2(obj) {
      return _typeof(obj) === 'object';
    }

    var proxyToValueMap = new WeakMap();

    function registerProxy(proxy, value) {
      proxyToValueMap.set(proxy, value);
    }

    var unwrap = function unwrap(replicaOrAny) {
      return proxyToValueMap.get(replicaOrAny) || replicaOrAny;
    };

    function wrapValue(membrane, value) {
      return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
    }
    /**
     * Unwrap property descriptors will set value on original descriptor
     * We only need to unwrap if value is specified
     * @param descriptor external descrpitor provided to define new property on original value
     */


    function unwrapDescriptor(descriptor) {
      if (hasOwnProperty$2.call(descriptor, 'value')) {
        descriptor.value = unwrap(descriptor.value);
      }

      return descriptor;
    }

    function lockShadowTarget(membrane, shadowTarget, originalTarget) {
      var targetKeys = ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
      targetKeys.forEach(function (key) {
        var descriptor = getOwnPropertyDescriptor$1(originalTarget, key); // We do not need to wrap the descriptor if configurable
        // Because we can deal with wrapping it when user goes through
        // Get own property descriptor. There is also a chance that this descriptor
        // could change sometime in the future, so we can defer wrapping
        // until we need to

        if (!descriptor.configurable) {
          descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
        }

        ObjectDefineProperty(shadowTarget, key, descriptor);
      });

      _preventExtensions(shadowTarget);
    }

    var ReactiveProxyHandler =
    /*#__PURE__*/
    function () {
      function ReactiveProxyHandler(membrane, value) {
        _classCallCheck(this, ReactiveProxyHandler);

        this.originalTarget = value;
        this.membrane = membrane;
      }

      _createClass(ReactiveProxyHandler, [{
        key: "get",
        value: function get(shadowTarget, key) {
          var originalTarget = this.originalTarget,
              membrane = this.membrane;
          var value = originalTarget[key];
          var valueObserved = membrane.valueObserved;
          valueObserved(originalTarget, key);
          return membrane.getProxy(value);
        }
      }, {
        key: "set",
        value: function set(shadowTarget, key, value) {
          var originalTarget = this.originalTarget,
              valueMutated = this.membrane.valueMutated;
          var oldValue = originalTarget[key];

          if (oldValue !== value) {
            originalTarget[key] = value;
            valueMutated(originalTarget, key);
          } else if (key === 'length' && isArray$2(originalTarget)) {
            // fix for issue #236: push will add the new index, and by the time length
            // is updated, the internal length is already equal to the new length value
            // therefore, the oldValue is equal to the value. This is the forking logic
            // to support this use case.
            valueMutated(originalTarget, key);
          }

          return true;
        }
      }, {
        key: "deleteProperty",
        value: function deleteProperty(shadowTarget, key) {
          var originalTarget = this.originalTarget,
              valueMutated = this.membrane.valueMutated;
          delete originalTarget[key];
          valueMutated(originalTarget, key);
          return true;
        }
      }, {
        key: "apply",
        value: function apply(shadowTarget, thisArg, argArray) {
          /* No op */
        }
      }, {
        key: "construct",
        value: function construct(target, argArray, newTarget) {
          /* No op */
        }
      }, {
        key: "has",
        value: function has(shadowTarget, key) {
          var originalTarget = this.originalTarget,
              valueObserved = this.membrane.valueObserved;
          valueObserved(originalTarget, key);
          return key in originalTarget;
        }
      }, {
        key: "ownKeys",
        value: function ownKeys(shadowTarget) {
          var originalTarget = this.originalTarget;
          return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        }
      }, {
        key: "isExtensible",
        value: function isExtensible(shadowTarget) {
          var shadowIsExtensible = _isExtensible(shadowTarget);

          if (!shadowIsExtensible) {
            return shadowIsExtensible;
          }

          var originalTarget = this.originalTarget,
              membrane = this.membrane;

          var targetIsExtensible = _isExtensible(originalTarget);

          if (!targetIsExtensible) {
            lockShadowTarget(membrane, shadowTarget, originalTarget);
          }

          return targetIsExtensible;
        }
      }, {
        key: "setPrototypeOf",
        value: function setPrototypeOf(shadowTarget, prototype) {
          {
            throw new Error("Invalid setPrototypeOf invocation for reactive proxy ".concat(toString$1(this.originalTarget), ". Prototype of reactive objects cannot be changed."));
          }
        }
      }, {
        key: "getPrototypeOf",
        value: function getPrototypeOf(shadowTarget) {
          var originalTarget = this.originalTarget;
          return getPrototypeOf$1(originalTarget);
        }
      }, {
        key: "getOwnPropertyDescriptor",
        value: function getOwnPropertyDescriptor(shadowTarget, key) {
          var originalTarget = this.originalTarget,
              membrane = this.membrane;
          var valueObserved = this.membrane.valueObserved; // keys looked up via hasOwnProperty need to be reactive

          valueObserved(originalTarget, key);
          var desc = getOwnPropertyDescriptor$1(originalTarget, key);

          if (isUndefined$2(desc)) {
            return desc;
          }

          var shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);

          if (!isUndefined$2(shadowDescriptor)) {
            return shadowDescriptor;
          } // Note: by accessing the descriptor, the key is marked as observed
          // but access to the value, setter or getter (if available) cannot observe
          // mutations, just like regular methods, in which case we just do nothing.


          desc = wrapDescriptor(membrane, desc, wrapValue);

          if (!desc.configurable) {
            // If descriptor from original target is not configurable,
            // We must copy the wrapped descriptor over to the shadow target.
            // Otherwise, proxy will throw an invariant error.
            // This is our last chance to lock the value.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
            ObjectDefineProperty(shadowTarget, key, desc);
          }

          return desc;
        }
      }, {
        key: "preventExtensions",
        value: function preventExtensions(shadowTarget) {
          var originalTarget = this.originalTarget,
              membrane = this.membrane;
          lockShadowTarget(membrane, shadowTarget, originalTarget);

          _preventExtensions(originalTarget);

          return true;
        }
      }, {
        key: "defineProperty",
        value: function defineProperty(shadowTarget, key, descriptor) {
          var originalTarget = this.originalTarget,
              membrane = this.membrane;
          var valueMutated = membrane.valueMutated;
          var configurable = descriptor.configurable; // We have to check for value in descriptor
          // because Object.freeze(proxy) calls this method
          // with only { configurable: false, writeable: false }
          // Additionally, method will only be called with writeable:false
          // if the descriptor has a value, as opposed to getter/setter
          // So we can just check if writable is present and then see if
          // value is present. This eliminates getter and setter descriptors

          if (hasOwnProperty$2.call(descriptor, 'writable') && !hasOwnProperty$2.call(descriptor, 'value')) {
            var originalDescriptor = getOwnPropertyDescriptor$1(originalTarget, key);
            descriptor.value = originalDescriptor.value;
          }

          ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));

          if (configurable === false) {
            ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
          }

          valueMutated(originalTarget, key);
          return true;
        }
      }]);

      return ReactiveProxyHandler;
    }();

    function wrapReadOnlyValue(membrane, value) {
      return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
    }

    var ReadOnlyHandler =
    /*#__PURE__*/
    function () {
      function ReadOnlyHandler(membrane, value) {
        _classCallCheck(this, ReadOnlyHandler);

        this.originalTarget = value;
        this.membrane = membrane;
      }

      _createClass(ReadOnlyHandler, [{
        key: "get",
        value: function get(shadowTarget, key) {
          var membrane = this.membrane,
              originalTarget = this.originalTarget;
          var value = originalTarget[key];
          var valueObserved = membrane.valueObserved;
          valueObserved(originalTarget, key);
          return membrane.getReadOnlyProxy(value);
        }
      }, {
        key: "set",
        value: function set(shadowTarget, key, value) {
          {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid mutation: Cannot set \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
          }
        }
      }, {
        key: "deleteProperty",
        value: function deleteProperty(shadowTarget, key) {
          {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid mutation: Cannot delete \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
          }
        }
      }, {
        key: "apply",
        value: function apply(shadowTarget, thisArg, argArray) {
          /* No op */
        }
      }, {
        key: "construct",
        value: function construct(target, argArray, newTarget) {
          /* No op */
        }
      }, {
        key: "has",
        value: function has(shadowTarget, key) {
          var originalTarget = this.originalTarget,
              valueObserved = this.membrane.valueObserved;
          valueObserved(originalTarget, key);
          return key in originalTarget;
        }
      }, {
        key: "ownKeys",
        value: function ownKeys(shadowTarget) {
          var originalTarget = this.originalTarget;
          return ArrayConcat.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols(originalTarget));
        }
      }, {
        key: "setPrototypeOf",
        value: function setPrototypeOf(shadowTarget, prototype) {
          {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid prototype mutation: Cannot set prototype on \"".concat(originalTarget, "\". \"").concat(originalTarget, "\" prototype is read-only."));
          }
        }
      }, {
        key: "getOwnPropertyDescriptor",
        value: function getOwnPropertyDescriptor(shadowTarget, key) {
          var originalTarget = this.originalTarget,
              membrane = this.membrane;
          var valueObserved = membrane.valueObserved; // keys looked up via hasOwnProperty need to be reactive

          valueObserved(originalTarget, key);
          var desc = getOwnPropertyDescriptor$1(originalTarget, key);

          if (isUndefined$2(desc)) {
            return desc;
          }

          var shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);

          if (!isUndefined$2(shadowDescriptor)) {
            return shadowDescriptor;
          } // Note: by accessing the descriptor, the key is marked as observed
          // but access to the value or getter (if available) cannot be observed,
          // just like regular methods, in which case we just do nothing.


          desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);

          if (hasOwnProperty$2.call(desc, 'set')) {
            desc.set = undefined; // readOnly membrane does not allow setters
          }

          if (!desc.configurable) {
            // If descriptor from original target is not configurable,
            // We must copy the wrapped descriptor over to the shadow target.
            // Otherwise, proxy will throw an invariant error.
            // This is our last chance to lock the value.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
            ObjectDefineProperty(shadowTarget, key, desc);
          }

          return desc;
        }
      }, {
        key: "preventExtensions",
        value: function preventExtensions(shadowTarget) {
          {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid mutation: Cannot preventExtensions on ".concat(originalTarget, "\". \"").concat(originalTarget, " is read-only."));
          }
        }
      }, {
        key: "defineProperty",
        value: function defineProperty(shadowTarget, key, descriptor) {
          {
            var originalTarget = this.originalTarget;
            throw new Error("Invalid mutation: Cannot defineProperty \"".concat(key.toString(), "\" on \"").concat(originalTarget, "\". \"").concat(originalTarget, "\" is read-only."));
          }
        }
      }]);

      return ReadOnlyHandler;
    }();

    function extract(objectOrArray) {
      if (isArray$2(objectOrArray)) {
        return objectOrArray.map(function (item) {
          var original = unwrap(item);

          if (original !== item) {
            return extract(original);
          }

          return item;
        });
      }

      var obj = ObjectCreate(getPrototypeOf$1(objectOrArray));
      var names = getOwnPropertyNames$1(objectOrArray);
      return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce(function (seed, key) {
        var item = objectOrArray[key];
        var original = unwrap(item);

        if (original !== item) {
          seed[key] = extract(original);
        } else {
          seed[key] = item;
        }

        return seed;
      }, obj);
    }

    var formatter = {
      header: function header(plainOrProxy) {
        var originalTarget = unwrap(plainOrProxy); // if originalTarget is falsy or not unwrappable, exit

        if (!originalTarget || originalTarget === plainOrProxy) {
          return null;
        }

        var obj = extract(plainOrProxy);
        return ['object', {
          object: obj
        }];
      },
      hasBody: function hasBody() {
        return false;
      },
      body: function body() {
        return null;
      }
    }; // Inspired from paulmillr/es6-shim
    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185

    function getGlobal() {
      // the only reliable means to get the global object is `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof globalThis !== 'undefined') {
        return globalThis;
      }

      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof window !== 'undefined') {
        return window;
      }

      if (typeof global !== 'undefined') {
        return global;
      } // Gracefully degrade if not able to locate the global object


      return {};
    }

    function init() {

      var global = getGlobal(); // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools
      //  - Go to Settings,
      //  - Under console, select "Enable custom formatters"
      // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview

      var devtoolsFormatters = global.devtoolsFormatters || [];
      ArrayPush$2.call(devtoolsFormatters, formatter);
      global.devtoolsFormatters = devtoolsFormatters;
    }

    {
      init();
    }

    function createShadowTarget(value) {
      var shadowTarget = undefined;

      if (isArray$2(value)) {
        shadowTarget = [];
      } else if (isObject$2(value)) {
        shadowTarget = {};
      }

      return shadowTarget;
    }

    var ObjectDotPrototype = Object.prototype;

    function defaultValueIsObservable(value) {
      // intentionally checking for null
      if (value === null) {
        return false;
      } // treat all non-object types, including undefined, as non-observable values


      if (_typeof(value) !== 'object') {
        return false;
      }

      if (isArray$2(value)) {
        return true;
      }

      var proto = getPrototypeOf$1(value);
      return proto === ObjectDotPrototype || proto === null || getPrototypeOf$1(proto) === null;
    }

    var defaultValueObserved = function defaultValueObserved(obj, key) {
      /* do nothing */
    };

    var defaultValueMutated = function defaultValueMutated(obj, key) {
      /* do nothing */
    };

    var defaultValueDistortion = function defaultValueDistortion(value) {
      return value;
    };

    function wrapDescriptor(membrane, descriptor, getValue) {
      var set = descriptor.set,
          get = descriptor.get;

      if (hasOwnProperty$2.call(descriptor, 'value')) {
        descriptor.value = getValue(membrane, descriptor.value);
      } else {
        if (!isUndefined$2(get)) {
          descriptor.get = function () {
            // invoking the original getter with the original target
            return getValue(membrane, get.call(unwrap(this)));
          };
        }

        if (!isUndefined$2(set)) {
          descriptor.set = function (value) {
            // At this point we don't have a clear indication of whether
            // or not a valid mutation will occur, we don't have the key,
            // and we are not sure why and how they are invoking this setter.
            // Nevertheless we preserve the original semantics by invoking the
            // original setter with the original target and the unwrapped value
            set.call(unwrap(this), membrane.unwrapProxy(value));
          };
        }
      }

      return descriptor;
    }

    var ReactiveMembrane =
    /*#__PURE__*/
    function () {
      function ReactiveMembrane(options) {
        _classCallCheck(this, ReactiveMembrane);

        this.valueDistortion = defaultValueDistortion;
        this.valueMutated = defaultValueMutated;
        this.valueObserved = defaultValueObserved;
        this.valueIsObservable = defaultValueIsObservable;
        this.objectGraph = new WeakMap();

        if (!isUndefined$2(options)) {
          var _valueDistortion = options.valueDistortion,
              _valueMutated = options.valueMutated,
              _valueObserved = options.valueObserved,
              valueIsObservable = options.valueIsObservable;
          this.valueDistortion = isFunction$1(_valueDistortion) ? _valueDistortion : defaultValueDistortion;
          this.valueMutated = isFunction$1(_valueMutated) ? _valueMutated : defaultValueMutated;
          this.valueObserved = isFunction$1(_valueObserved) ? _valueObserved : defaultValueObserved;
          this.valueIsObservable = isFunction$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
        }
      }

      _createClass(ReactiveMembrane, [{
        key: "getProxy",
        value: function getProxy(value) {
          var unwrappedValue = unwrap(value);
          var distorted = this.valueDistortion(unwrappedValue);

          if (this.valueIsObservable(distorted)) {
            var o = this.getReactiveState(unwrappedValue, distorted); // when trying to extract the writable version of a readonly
            // we return the readonly.

            return o.readOnly === value ? value : o.reactive;
          }

          return distorted;
        }
      }, {
        key: "getReadOnlyProxy",
        value: function getReadOnlyProxy(value) {
          value = unwrap(value);
          var distorted = this.valueDistortion(value);

          if (this.valueIsObservable(distorted)) {
            return this.getReactiveState(value, distorted).readOnly;
          }

          return distorted;
        }
      }, {
        key: "unwrapProxy",
        value: function unwrapProxy(p) {
          return unwrap(p);
        }
      }, {
        key: "getReactiveState",
        value: function getReactiveState(value, distortedValue) {
          var objectGraph = this.objectGraph;
          var reactiveState = objectGraph.get(distortedValue);

          if (reactiveState) {
            return reactiveState;
          }

          var membrane = this;
          reactiveState = {
            get reactive() {
              var reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue); // caching the reactive proxy after the first time it is accessed

              var proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
              registerProxy(proxy, value);
              ObjectDefineProperty(this, 'reactive', {
                value: proxy
              });
              return proxy;
            },

            get readOnly() {
              var readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue); // caching the readOnly proxy after the first time it is accessed

              var proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
              registerProxy(proxy, value);
              ObjectDefineProperty(this, 'readOnly', {
                value: proxy
              });
              return proxy;
            }

          };
          objectGraph.set(distortedValue, reactiveState);
          return reactiveState;
        }
      }]);

      return ReactiveMembrane;
    }();
    /** version: 0.26.0 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function valueDistortion(value) {
      return value;
    }

    var reactiveMembrane = new ReactiveMembrane({
      valueObserved: valueObserved,
      valueMutated: valueMutated,
      valueDistortion: valueDistortion
    });
    /**
     * EXPERIMENTAL: This function implements an unwrap mechanism that
     * works for observable membrane objects. This API is subject to
     * change or being removed.
     */

    var unwrap$1 = function unwrap$1(value) {
      var unwrapped = reactiveMembrane.unwrapProxy(value);

      if (unwrapped !== value) {
        // if value is a proxy, unwrap to access original value and apply distortion
        return valueDistortion(unwrapped);
      }

      return value;
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // from the element instance, and get the value or set a new value on the component.
    // This means that across different elements, similar names can get the exact same
    // descriptor, so we can cache them:


    var cachedGetterByKey = create(null);
    var cachedSetterByKey = create(null);

    function createGetter(key) {
      var fn = cachedGetterByKey[key];

      if (isUndefined(fn)) {
        fn = cachedGetterByKey[key] = function () {
          var vm = getAssociatedVM(this);
          var getHook = vm.getHook;
          return getHook(vm.component, key);
        };
      }

      return fn;
    }

    function createSetter(key) {
      var fn = cachedSetterByKey[key];

      if (isUndefined(fn)) {
        fn = cachedSetterByKey[key] = function (newValue) {
          var vm = getAssociatedVM(this);
          var setHook = vm.setHook;
          newValue = reactiveMembrane.getReadOnlyProxy(newValue);
          setHook(vm.component, key, newValue);
        };
      }

      return fn;
    }

    function createMethodCaller(methodName) {
      return function () {
        var vm = getAssociatedVM(this);
        var callHook = vm.callHook,
            component = vm.component;
        var fn = component[methodName];
        return callHook(vm.component, fn, ArraySlice$1.call(arguments));
      };
    }

    function HTMLBridgeElementFactory(SuperClass, props, methods) {
      var HTMLBridgeElement;
      /**
       * Modern browsers will have all Native Constructors as regular Classes
       * and must be instantiated with the new keyword. In older browsers,
       * specifically IE11, those are objects with a prototype property defined,
       * since they are not supposed to be extended or instantiated with the
       * new keyword. This forking logic supports both cases, specifically because
       * wc.ts relies on the construction path of the bridges to create new
       * fully qualifying web components.
       */

      if (isFunction(SuperClass)) {
        HTMLBridgeElement =
        /*#__PURE__*/
        function (_SuperClass) {
          _inherits(HTMLBridgeElement, _SuperClass);

          function HTMLBridgeElement() {
            _classCallCheck(this, HTMLBridgeElement);

            return _possibleConstructorReturn(this, _getPrototypeOf(HTMLBridgeElement).apply(this, arguments));
          }

          return HTMLBridgeElement;
        }(SuperClass);
      } else {
        HTMLBridgeElement = function HTMLBridgeElement() {
          // Bridge classes are not supposed to be instantiated directly in
          // browsers that do not support web components.
          throw new TypeError('Illegal constructor');
        }; // prototype inheritance dance


        setPrototypeOf(HTMLBridgeElement, SuperClass);
        setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);
        defineProperty(HTMLBridgeElement.prototype, 'constructor', {
          writable: true,
          configurable: true,
          value: HTMLBridgeElement
        });
      }

      var descriptors = create(null); // expose getters and setters for each public props on the new Element Bridge

      for (var _i8 = 0, _len6 = props.length; _i8 < _len6; _i8 += 1) {
        var _propName = props[_i8];
        descriptors[_propName] = {
          get: createGetter(_propName),
          set: createSetter(_propName),
          enumerable: true,
          configurable: true
        };
      } // expose public methods as props on the new Element Bridge


      for (var _i9 = 0, _len7 = methods.length; _i9 < _len7; _i9 += 1) {
        var methodName = methods[_i9];
        descriptors[methodName] = {
          value: createMethodCaller(methodName),
          writable: true,
          configurable: true
        };
      }

      defineProperties(HTMLBridgeElement.prototype, descriptors);
      return HTMLBridgeElement;
    }

    var BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, getOwnPropertyNames(HTMLElementOriginalDescriptors), []);
    freeze(BaseBridgeElement);
    seal(BaseBridgeElement.prototype);
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    function track(target, prop, descriptor) {
      if (arguments.length === 1) {
        return reactiveMembrane.getProxy(target);
      }

      {
        if (arguments.length !== 3) {
          assert.fail("@track decorator can only be used with one argument to return a trackable object, or as a decorator function.");
        }

        if (!isUndefined(descriptor)) {
          var get = descriptor.get,
              set = descriptor.set,
              configurable = descriptor.configurable,
              writable = descriptor.writable;
          assert.isTrue(!get && !set, "Compiler Error: A @track decorator can only be applied to a public field.");
          assert.isTrue(configurable !== false, "Compiler Error: A @track decorator can only be applied to a configurable property.");
          assert.isTrue(writable !== false, "Compiler Error: A @track decorator can only be applied to a writable property.");
        }
      }

      return createTrackedPropertyDescriptor(target, prop, isUndefined(descriptor) ? true : descriptor.enumerable === true);
    }

    function createTrackedPropertyDescriptor(Ctor, key, enumerable) {
      return {
        get: function get() {
          var vm = getAssociatedVM(this);
          valueObserved(this, key);
          return vm.cmpTrack[key];
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);

          {
            var _vmBeingRendered5 = getVMBeingRendered();

            assert.invariant(!isInvokingRender, "".concat(_vmBeingRendered5, ".render() method has side effects on the state of ").concat(vm, ".").concat(toString(key)));
            assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(_vmBeingRendered5, " has side effects on the state of ").concat(vm, ".").concat(toString(key)));
          }

          var reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);

          if (reactiveOrAnyValue !== vm.cmpTrack[key]) {
            vm.cmpTrack[key] = reactiveOrAnyValue;

            if (isFalse$1(vm.isDirty)) {
              // perf optimization to skip this step if the track property is on a component that is already dirty
              valueMutated(this, key);
            }
          }
        },
        enumerable: enumerable,
        configurable: true
      };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function wireDecorator(target, prop, descriptor) {
      {
        if (!isUndefined(descriptor)) {
          var get = descriptor.get,
              set = descriptor.set,
              configurable = descriptor.configurable,
              writable = descriptor.writable;
          assert.isTrue(!get && !set, "Compiler Error: A @wire decorator can only be applied to a public field.");
          assert.isTrue(configurable !== false, "Compiler Error: A @wire decorator can only be applied to a configurable property.");
          assert.isTrue(writable !== false, "Compiler Error: A @wire decorator can only be applied to a writable property.");
        }
      }

      return createTrackedPropertyDescriptor(target, prop, isObject$1(descriptor) ? descriptor.enumerable === true : true);
    }
    /**
     * @wire decorator to wire fields and methods to a wire adapter in
     * LWC Components. This function implements the internals of this
     * decorator.
     */


    function wire(_adapter, _config) {
      var len = arguments.length;

      if (len > 0 && len < 3) {
        return wireDecorator;
      } else {
        {
          assert.fail('@wire(adapter, config?) may only be used as a decorator.');
        }

        throw new TypeError();
      }
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */

    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var create$2 = Object.create;

    function isUndefined$3(obj) {
      return obj === undefined;
    }

    function isTrue$1$1(obj) {
      return obj === true;
    }

    function isFalse$1$1(obj) {
      return obj === false;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */


    var hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
    /** version: 1.1.13-224.5 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Cached reference to globalThis

    var _globalThis;

    if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object') {
      _globalThis = globalThis;
    }

    function getGlobalThis() {
      if (_typeof(_globalThis) === 'object') {
        return _globalThis;
      }

      try {
        // eslint-disable-next-line no-extend-native
        Object.defineProperty(Object.prototype, '__magic__', {
          get: function get() {
            return this;
          },
          configurable: true
        }); // @ts-ignore
        // __magic__ is undefined in Safari 10 and IE10 and older.
        // eslint-disable-next-line no-undef

        _globalThis = __magic__; // @ts-ignore

        delete Object.prototype.__magic__;
      } catch (ex) {// In IE8, Object.defineProperty only works on DOM objects.
      } finally {
        // If the magic above fails for some reason we assume that we are in a
        // legacy browser. Assume `window` exists in this case.
        if (typeof _globalThis === 'undefined') {
          _globalThis = window;
        }
      }

      return _globalThis;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var _globalThis$1 = getGlobalThis();

    if (!_globalThis$1.lwcRuntimeFlags) {
      Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {
        value: create$2(null)
      });
    }

    var runtimeFlags = _globalThis$1.lwcRuntimeFlags; // This function is not supported for use within components and is meant for
    // configuring runtime feature flags during app initialization.

    function setFeatureFlag(name, value) {
      var isBoolean = isTrue$1$1(value) || isFalse$1$1(value);

      if (!isBoolean) {
        var message = "Failed to set the value \"".concat(value, "\" for the runtime feature flag \"").concat(name, "\". Runtime feature flags can only be set to a boolean value.");

        {
          throw new TypeError(message);
        }
      }

      if (isUndefined$3(featureFlagLookup[name])) {
        // eslint-disable-next-line no-console
        console.warn("Failed to set the value \"".concat(value, "\" for the runtime feature flag \"").concat(name, "\" because it is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package."));
        return;
      }

      {
        // Allow the same flag to be set more than once outside of production to enable testing
        runtimeFlags[name] = value;
      }
    } // This function is exposed to components to facilitate testing so we add a
    // check to make sure it is not invoked in production.


    function setFeatureFlagForTest(name, value) {
      {
        return setFeatureFlag(name, value);
      }
    }

    var featureFlagLookup = {
      ENABLE_REACTIVE_SETTER: null,
      // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.
      ENABLE_ELEMENT_PATCH: null,
      ENABLE_NODE_LIST_PATCH: null,
      ENABLE_HTML_COLLECTIONS_PATCH: null,
      ENABLE_NODE_PATCH: null
    };
    /** version: 1.1.13-224.5 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * @api decorator to mark public fields and public methods in
     * LWC Components. This function implements the internals of this
     * decorator.
     */

    function api$1(target, propName, descriptor) {
      {
        if (arguments.length !== 3) {
          assert.fail("@api decorator can only be used as a decorator function.");
        }
      }

      {
        assert.invariant(!descriptor || isFunction(descriptor.get) || isFunction(descriptor.set), "Invalid property ".concat(toString(propName), " definition in ").concat(target, ", it cannot be a prototype definition if it is a public property. Instead use the constructor to define it."));

        if (isObject$1(descriptor) && isFunction(descriptor.set)) {
          assert.isTrue(isObject$1(descriptor) && isFunction(descriptor.get), "Missing getter for property ".concat(toString(propName), " decorated with @api in ").concat(target, ". You cannot have a setter without the corresponding getter."));
        }
      }

      var meta = getDecoratorsRegisteredMeta(target); // initializing getters and setters for each public prop on the target prototype

      if (isObject$1(descriptor) && (isFunction(descriptor.get) || isFunction(descriptor.set))) {
        // if it is configured as an accessor it must have a descriptor
        // @ts-ignore it must always be set before calling this method
        meta.props[propName].config = isFunction(descriptor.set) ? 3 : 1;
        return createPublicAccessorDescriptor(target, propName, descriptor);
      } else {
        // @ts-ignore it must always be set before calling this method
        meta.props[propName].config = 0;
        return createPublicPropertyDescriptor(target, propName, descriptor);
      }
    }

    function createPublicPropertyDescriptor(proto, key, descriptor) {
      return {
        get: function get() {
          var vm = getAssociatedVM(this);

          if (isBeingConstructed(vm)) {
            {
              var name = vm.elm.constructor.name;
              logError("`".concat(name, "` constructor can\u2019t read the value of property `").concat(toString(key), "` because the owner component hasn\u2019t set the value yet. Instead, use the `").concat(name, "` constructor to set a default value for the property."), vm);
            }

            return;
          }

          valueObserved(this, key);
          return vm.cmpProps[key];
        },
        set: function set(newValue) {
          var vm = getAssociatedVM(this);

          {
            var _vmBeingRendered6 = getVMBeingRendered();

            assert.invariant(!isInvokingRender, "".concat(_vmBeingRendered6, ".render() method has side effects on the state of ").concat(vm, ".").concat(toString(key)));
            assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(_vmBeingRendered6, " has side effects on the state of ").concat(vm, ".").concat(toString(key)));
          }

          vm.cmpProps[key] = newValue; // avoid notification of observability if the instance is already dirty

          if (isFalse$1(vm.isDirty)) {
            // perf optimization to skip this step if the component is dirty already.
            valueMutated(this, key);
          }
        },
        enumerable: isUndefined(descriptor) ? true : descriptor.enumerable
      };
    }

    var AccessorReactiveObserver =
    /*#__PURE__*/
    function (_ReactiveObserver) {
      _inherits(AccessorReactiveObserver, _ReactiveObserver);

      function AccessorReactiveObserver(vm, set) {
        var _this;

        _classCallCheck(this, AccessorReactiveObserver);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AccessorReactiveObserver).call(this, function () {
          if (isFalse$1(_this.debouncing)) {
            _this.debouncing = true;
            addCallbackToNextTick(function () {
              if (isTrue$1(_this.debouncing)) {
                var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),
                    value = _assertThisInitialize.value;

                var dirtyStateBeforeSetterCall = vm.isDirty,
                    component = vm.component,
                    _idx = vm.idx;
                set.call(component, value); // de-bouncing after the call to the original setter to prevent
                // infinity loop if the setter itself is mutating things that
                // were accessed during the previous invocation.

                _this.debouncing = false;

                if (isTrue$1(vm.isDirty) && isFalse$1(dirtyStateBeforeSetterCall) && _idx > 0) {
                  // immediate rehydration due to a setter driven mutation, otherwise
                  // the component will get rendered on the second tick, which it is not
                  // desirable.
                  rerenderVM(vm);
                }
              }
            });
          }
        }));
        _this.debouncing = false;
        return _this;
      }

      _createClass(AccessorReactiveObserver, [{
        key: "reset",
        value: function reset(value) {
          _get(_getPrototypeOf(AccessorReactiveObserver.prototype), "reset", this).call(this);

          this.debouncing = false;

          if (arguments.length > 0) {
            this.value = value;
          }
        }
      }]);

      return AccessorReactiveObserver;
    }(ReactiveObserver);

    function createPublicAccessorDescriptor(Ctor, key, descriptor) {
      var _get3 = descriptor.get,
          _set2 = descriptor.set,
          enumerable = descriptor.enumerable;

      if (!isFunction(_get3)) {
        {
          assert.fail("Invalid attempt to create public property descriptor ".concat(toString(key), " in ").concat(Ctor, ". It is missing the getter declaration with @api get ").concat(toString(key), "() {} syntax."));
        }

        throw new TypeError();
      }

      return {
        get: function get() {
          {
            // Assert that the this value is an actual Component with an associated VM.
            getAssociatedVM(this);
          }

          return _get3.call(this);
        },
        set: function set(newValue) {
          var _this2 = this;

          var vm = getAssociatedVM(this);

          {
            var _vmBeingRendered7 = getVMBeingRendered();

            assert.invariant(!isInvokingRender, "".concat(_vmBeingRendered7, ".render() method has side effects on the state of ").concat(vm, ".").concat(toString(key)));
            assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(_vmBeingRendered7, " has side effects on the state of ").concat(vm, ".").concat(toString(key)));
          }

          if (_set2) {
            if (runtimeFlags.ENABLE_REACTIVE_SETTER) {
              var ro = vm.oar[key];

              if (isUndefined(ro)) {
                ro = vm.oar[key] = new AccessorReactiveObserver(vm, _set2);
              } // every time we invoke this setter from outside (through this wrapper setter)
              // we should reset the value and then debounce just in case there is a pending
              // invocation the next tick that is not longer relevant since the value is changing
              // from outside.


              ro.reset(newValue);
              ro.observe(function () {
                _set2.call(_this2, newValue);
              });
            } else {
              _set2.call(this, newValue);
            }
          } else {
            assert.fail("Invalid attempt to set a new value for property ".concat(toString(key), " of ").concat(vm, " that does not has a setter decorated with @api."));
          }
        },
        enumerable: enumerable
      };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * EXPERIMENTAL: This function allows for the registration of "services" in
     * LWC by exposing hooks into the component life-cycle. This API is subject
     * to change or being removed.
     */


    function decorate(Ctor, decorators) {
      // intentionally comparing decorators with null and undefined
      if (!isFunction(Ctor) || decorators == null) {
        throw new TypeError();
      }

      var props = getOwnPropertyNames(decorators); // intentionally allowing decoration of classes only for now

      var target = Ctor.prototype;

      for (var _i10 = 0, _len8 = props.length; _i10 < _len8; _i10 += 1) {
        var _propName2 = props[_i10];
        var decorator = decorators[_propName2];

        if (!isFunction(decorator)) {
          throw new TypeError();
        }

        var originalDescriptor = getOwnPropertyDescriptor(target, _propName2);
        var descriptor = decorator(Ctor, _propName2, originalDescriptor);

        if (!isUndefined(descriptor)) {
          defineProperty(target, _propName2, descriptor);
        }
      }

      return Ctor; // chaining
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var signedDecoratorToMetaMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */

    function registerDecorators(Ctor, meta) {
      var decoratorMap = create(null);
      var props = getPublicPropertiesHash(Ctor, meta.publicProps);
      var methods = getPublicMethodsHash(Ctor, meta.publicMethods);
      var wire$1 = getWireHash(Ctor, meta.wire);
      var track$1 = getTrackHash(Ctor, meta.track);
      var fields = meta.fields;
      signedDecoratorToMetaMap.set(Ctor, {
        props: props,
        methods: methods,
        wire: wire$1,
        track: track$1,
        fields: fields
      });

      for (var _propName3 in props) {
        decoratorMap[_propName3] = api$1;
      }

      if (wire$1) {
        for (var _propName4 in wire$1) {
          var wireDef = wire$1[_propName4];

          if (wireDef.method) {
            // for decorated methods we need to do nothing
            continue;
          }

          decoratorMap[_propName4] = wire(wireDef.adapter, wireDef.params);
        }
      }

      if (track$1) {
        for (var _propName5 in track$1) {
          decoratorMap[_propName5] = track;
        }
      }

      decorate(Ctor, decoratorMap);
      return Ctor;
    }

    function getDecoratorsRegisteredMeta(Ctor) {
      return signedDecoratorToMetaMap.get(Ctor);
    }

    function getTrackHash(target, track) {
      if (isUndefined(track) || getOwnPropertyNames(track).length === 0) {
        return EmptyObject;
      } // TODO [#1302]: check that anything in `track` is correctly defined in the prototype


      return assign(create(null), track);
    }

    function getWireHash(target, wire) {
      if (isUndefined(wire) || getOwnPropertyNames(wire).length === 0) {
        return;
      } // TODO [#1302]: check that anything in `wire` is correctly defined in the prototype


      return assign(create(null), wire);
    }

    function getPublicPropertiesHash(target, props) {
      if (isUndefined(props) || getOwnPropertyNames(props).length === 0) {
        return EmptyObject;
      }

      return getOwnPropertyNames(props).reduce(function (propsHash, propName) {
        var attr = getAttrNameFromPropName(propName);
        propsHash[propName] = assign({
          config: 0,
          type: 'any',
          attr: attr
        }, props[propName]);
        return propsHash;
      }, create(null));
    }

    function getPublicMethodsHash(target, publicMethods) {
      if (isUndefined(publicMethods) || publicMethods.length === 0) {
        return EmptyObject;
      }

      return publicMethods.reduce(function (methodsHash, methodName) {
        {
          assert.isTrue(isFunction(target.prototype[methodName]), "Component \"".concat(target.name, "\" should have a method `").concat(methodName, "` instead of ").concat(target.prototype[methodName], "."));
        }

        methodsHash[methodName] = target.prototype[methodName];
        return methodsHash;
      }, create(null));
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var CtorToDefMap = new WeakMap();

    function getCtorProto(Ctor, subclassComponentName) {
      var proto = getPrototypeOf(Ctor);

      if (isNull(proto)) {
        throw new ReferenceError("Invalid prototype chain for ".concat(subclassComponentName, ", you must extend LightningElement."));
      } // covering the cases where the ref is circular in AMD


      if (isCircularModuleDependency(proto)) {
        var _p = resolveCircularModuleDependency(proto);

        {
          if (isNull(_p)) {
            throw new ReferenceError("Circular module dependency for ".concat(subclassComponentName, ", must resolve to a constructor that extends LightningElement."));
          }
        } // escape hatch for Locker and other abstractions to provide their own base class instead
        // of our Base class without having to leak it to user-land. If the circular function returns
        // itself, that's the signal that we have hit the end of the proto chain, which must always
        // be base.


        proto = _p === proto ? BaseLightningElement : _p;
      }

      return proto;
    }

    function createComponentDef(Ctor, meta, subclassComponentName) {
      {
        // local to dev block
        var ctorName = Ctor.name; // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.
        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);

        assert.isTrue(Ctor.constructor, "Missing ".concat(ctorName, ".constructor, ").concat(ctorName, " should have a \"constructor\" property."));
      }

      var name = meta.name;
      var template = meta.template;
      var decoratorsMeta = getDecoratorsRegisteredMeta(Ctor);
      var props = {};
      var methods = {};
      var wire;
      var track = {};
      var fields;

      if (!isUndefined(decoratorsMeta)) {
        props = decoratorsMeta.props;
        methods = decoratorsMeta.methods;
        wire = decoratorsMeta.wire;
        track = decoratorsMeta.track;
        fields = decoratorsMeta.fields;
      }

      var proto = Ctor.prototype;
      var connectedCallback = proto.connectedCallback,
          disconnectedCallback = proto.disconnectedCallback,
          renderedCallback = proto.renderedCallback,
          errorCallback = proto.errorCallback,
          render = proto.render;
      var superProto = getCtorProto(Ctor, subclassComponentName);
      var superDef = superProto !== BaseLightningElement ? getComponentDef(superProto, subclassComponentName) : null;
      var SuperBridge = isNull(superDef) ? BaseBridgeElement : superDef.bridge;
      var bridge = HTMLBridgeElementFactory(SuperBridge, getOwnPropertyNames(props), getOwnPropertyNames(methods));

      if (!isNull(superDef)) {
        props = assign(create(null), superDef.props, props);
        methods = assign(create(null), superDef.methods, methods);
        wire = superDef.wire || wire ? assign(create(null), superDef.wire, wire) : undefined;
        track = assign(create(null), superDef.track, track);
        connectedCallback = connectedCallback || superDef.connectedCallback;
        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
        renderedCallback = renderedCallback || superDef.renderedCallback;
        errorCallback = errorCallback || superDef.errorCallback;
        render = render || superDef.render;
        template = template || superDef.template;
      }

      props = assign(create(null), HTML_PROPS, props);

      if (!isUndefined(fields)) {
        defineProperties(proto, createObservedFieldsDescriptorMap(fields));
      }

      if (isUndefined(template)) {
        // default template
        template = defaultEmptyTemplate;
      }

      var def = {
        ctor: Ctor,
        name: name,
        wire: wire,
        track: track,
        props: props,
        methods: methods,
        bridge: bridge,
        template: template,
        connectedCallback: connectedCallback,
        disconnectedCallback: disconnectedCallback,
        renderedCallback: renderedCallback,
        errorCallback: errorCallback,
        render: render
      };

      {
        freeze(Ctor.prototype);
      }

      return def;
    }
    /**
     * EXPERIMENTAL: This function allows for the identification of LWC
     * constructors. This API is subject to change or being removed.
     */


    function isComponentConstructor(ctor) {
      if (!isFunction(ctor)) {
        return false;
      } // Fast path: LightningElement is part of the prototype chain of the constructor.


      if (_instanceof(ctor.prototype, BaseLightningElement)) {
        return true;
      } // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
      // climb up the constructor prototype chain to check in case there are circular dependencies
      // to resolve.


      var current = ctor;

      do {
        if (isCircularModuleDependency(current)) {
          var circularResolved = resolveCircularModuleDependency(current); // If the circular function returns itself, that's the signal that we have hit the end of the proto chain,
          // which must always be a valid base constructor.

          if (circularResolved === current) {
            return true;
          }

          current = circularResolved;
        }

        if (current === BaseLightningElement) {
          return true;
        }
      } while (!isNull(current) && (current = getPrototypeOf(current))); // Finally return false if the LightningElement is not part of the prototype chain.


      return false;
    }
    /**
     * EXPERIMENTAL: This function allows for the collection of internal
     * component metadata. This API is subject to change or being removed.
     */


    function getComponentDef(Ctor, subclassComponentName) {
      var def = CtorToDefMap.get(Ctor);

      if (isUndefined(def)) {
        if (!isComponentConstructor(Ctor)) {
          throw new TypeError("".concat(Ctor, " is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration."));
        }

        var meta = getComponentRegisteredMeta(Ctor);

        if (isUndefined(meta)) {
          // TODO [#1295]: remove this workaround after refactoring tests
          meta = {
            template: undefined,
            name: Ctor.name
          };
        }

        def = createComponentDef(Ctor, meta, subclassComponentName || Ctor.name);
        CtorToDefMap.set(Ctor, def);
      }

      return def;
    }
    /**
     * EXPERIMENTAL: This function provides access to the component constructor,
     * given an HTMLElement. This API is subject to change or being removed.
     */


    function getComponentConstructor(elm) {
      var ctor = null;

      if (_instanceof(elm, HTMLElement)) {
        var vm = getAssociatedVMIfPresent(elm);

        if (!isUndefined(vm)) {
          ctor = vm.def.ctor;
        }
      }

      return ctor;
    } // Only set prototype for public methods and properties
    // No DOM Patching occurs here


    function setElementProto(elm, def) {
      setPrototypeOf(elm, def.bridge.prototype);
    } // Typescript is inferring the wrong function type for this particular
    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
    // @ts-ignore type-mismatch


    var HTML_PROPS = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), function (props, propName) {
      var attrName = getAttrNameFromPropName(propName);
      props[propName] = {
        config: 3,
        type: 'any',
        attr: attrName
      };
      return props;
    }, create(null));
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var VMState;

    (function (VMState) {
      VMState[VMState["created"] = 0] = "created";
      VMState[VMState["connected"] = 1] = "connected";
      VMState[VMState["disconnected"] = 2] = "disconnected";
    })(VMState || (VMState = {}));

    var idx = 0;
    /** The internal slot used to associate different objects the engine manipulates with the VM */

    var ViewModelReflection = createHiddenField('ViewModel', 'engine');

    function callHook(cmp, fn) {
      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return fn.apply(cmp, args);
    }

    function setHook(cmp, prop, newValue) {
      cmp[prop] = newValue;
    }

    function getHook(cmp, prop) {
      return cmp[prop];
    }

    function rerenderVM(vm) {
      rehydrate(vm);
    }

    function appendRootVM(vm) {
      runConnectedCallback(vm);
      rehydrate(vm);
    }

    function appendVM(vm) {
      rehydrate(vm);
    } // just in case the component comes back, with this we guarantee re-rendering it
    // while preventing any attempt to rehydration until after reinsertion.


    function resetComponentStateWhenRemoved(vm) {
      var state = vm.state;

      if (state !== VMState.disconnected) {
        var oar = vm.oar,
            tro = vm.tro; // Making sure that any observing record will not trigger the rehydrated on this vm

        tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked

        for (var key in oar) {
          oar[key].reset();
        }

        runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)

        runShadowChildNodesDisconnectedCallback(vm);
        runLightChildNodesDisconnectedCallback(vm);
      }
    } // this method is triggered by the diffing algo only when a vnode from the
    // old vnode.children is removed from the DOM.


    function removeVM(vm) {
      {
        assert.isTrue(vm.state === VMState.connected || vm.state === VMState.disconnected, "".concat(vm, " must have been connected."));
      }

      resetComponentStateWhenRemoved(vm);
    } // this method is triggered by the removal of a root element from the DOM.


    function removeRootVM(vm) {
      resetComponentStateWhenRemoved(vm);
    }

    function createVM(elm, Ctor, options) {
      {
        assert.invariant(_instanceof(elm, HTMLElement), "VM creation requires a DOM element instead of ".concat(elm, "."));
      }

      var def = getComponentDef(Ctor);
      var isRoot = options.isRoot,
          mode = options.mode,
          owner = options.owner;
      idx += 1;
      var uninitializedVm = {
        // component creation index is defined once, and never reset, it can
        // be preserved from one insertion to another without any issue
        idx: idx,
        state: VMState.created,
        isScheduled: false,
        isDirty: true,
        isRoot: isTrue$1(isRoot),
        mode: mode,
        def: def,
        owner: owner,
        elm: elm,
        data: EmptyObject,
        context: create(null),
        cmpProps: create(null),
        cmpTrack: create(null),
        cmpSlots: useSyntheticShadow ? create(null) : undefined,
        callHook: callHook,
        setHook: setHook,
        getHook: getHook,
        children: EmptyArray,
        aChildren: EmptyArray,
        velements: EmptyArray,
        // Perf optimization to preserve the shape of this obj
        cmpTemplate: undefined,
        component: undefined,
        cmpRoot: undefined,
        tro: undefined,
        oar: undefined
      };

      {
        uninitializedVm.toString = function () {
          return "[object:vm ".concat(def.name, " (").concat(uninitializedVm.idx, ")]");
        };
      } // create component instance associated to the vm and the element


      createComponent(uninitializedVm, Ctor); // link component to the wire service

      var initializedVm = uninitializedVm;
      linkComponent(initializedVm);
    }

    function assertIsVM(obj) {
      if (isNull(obj) || !isObject$1(obj) || !('cmpRoot' in obj)) {
        throw new TypeError("".concat(obj, " is not a VM."));
      }
    }

    function associateVM(obj, vm) {
      setHiddenField(obj, ViewModelReflection, vm);
    }

    function getAssociatedVM(obj) {
      var vm = getHiddenField(obj, ViewModelReflection);

      {
        assertIsVM(vm);
      }

      return vm;
    }

    function getAssociatedVMIfPresent(obj) {
      var maybeVm = getHiddenField(obj, ViewModelReflection);

      {
        if (!isUndefined(maybeVm)) {
          assertIsVM(maybeVm);
        }
      }

      return maybeVm;
    }

    function rehydrate(vm) {
      {
        assert.isTrue(_instanceof(vm.elm, HTMLElement), "rehydration can only happen after ".concat(vm, " was patched the first time."));
      }

      if (isTrue$1(vm.isDirty)) {
        var children = renderComponent(vm);
        patchShadowRoot(vm, children);
      }
    }

    function patchShadowRoot(vm, newCh) {
      var cmpRoot = vm.cmpRoot,
          oldCh = vm.children;
      vm.children = newCh; // caching the new children collection

      if (newCh.length > 0 || oldCh.length > 0) {
        // patch function mutates vnodes by adding the element reference,
        // however, if patching fails it contains partial changes.
        if (oldCh !== newCh) {
          var fn = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;
          runWithBoundaryProtection(vm, vm, function () {
            // pre
            {
              startMeasure('patch', vm);
            }
          }, function () {
            // job
            fn(cmpRoot, oldCh, newCh);
          }, function () {
            // post
            {
              endMeasure('patch', vm);
            }
          });
        }
      }

      if (vm.state === VMState.connected) {
        // If the element is connected, that means connectedCallback was already issued, and
        // any successive rendering should finish with the call to renderedCallback, otherwise
        // the connectedCallback will take care of calling it in the right order at the end of
        // the current rehydration process.
        runRenderedCallback(vm);
      }
    }

    function runRenderedCallback(vm) {
      var rendered = Services.rendered;

      if (rendered) {
        invokeServiceHook(vm, rendered);
      }

      var renderedCallback = vm.def.renderedCallback;

      if (!isUndefined(renderedCallback)) {
        {
          startMeasure('renderedCallback', vm);
        }

        invokeComponentCallback(vm, renderedCallback);

        {
          endMeasure('renderedCallback', vm);
        }
      }
    }

    var rehydrateQueue = [];

    function flushRehydrationQueue() {
      startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);

      {
        assert.invariant(rehydrateQueue.length, "If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ".concat(rehydrateQueue, "."));
      }

      var vms = rehydrateQueue.sort(function (a, b) {
        return a.idx - b.idx;
      });
      rehydrateQueue = []; // reset to a new queue

      for (var _i11 = 0, _len9 = vms.length; _i11 < _len9; _i11 += 1) {
        var vm = vms[_i11];

        try {
          rehydrate(vm);
        } catch (error) {
          if (_i11 + 1 < _len9) {
            // pieces of the queue are still pending to be rehydrated, those should have priority
            if (rehydrateQueue.length === 0) {
              addCallbackToNextTick(flushRehydrationQueue);
            }

            ArrayUnshift$1.apply(rehydrateQueue, ArraySlice$1.call(vms, _i11 + 1));
          } // we need to end the measure before throwing.


          endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE); // re-throwing the original error will break the current tick, but since the next tick is
          // already scheduled, it should continue patching the rest.

          throw error; // eslint-disable-line no-unsafe-finally
        }
      }

      endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
    }

    function runConnectedCallback(vm) {
      var state = vm.state;

      if (state === VMState.connected) {
        return; // nothing to do since it was already connected
      }

      vm.state = VMState.connected; // reporting connection

      var connected = Services.connected;

      if (connected) {
        invokeServiceHook(vm, connected);
      }

      var connectedCallback = vm.def.connectedCallback;

      if (!isUndefined(connectedCallback)) {
        {
          startMeasure('connectedCallback', vm);
        }

        invokeComponentCallback(vm, connectedCallback);

        {
          endMeasure('connectedCallback', vm);
        }
      }
    }

    function runDisconnectedCallback(vm) {
      {
        assert.isTrue(vm.state !== VMState.disconnected, "".concat(vm, " must be inserted."));
      }

      if (isFalse$1(vm.isDirty)) {
        // this guarantees that if the component is reused/reinserted,
        // it will be re-rendered because we are disconnecting the reactivity
        // linking, so mutations are not automatically reflected on the state
        // of disconnected components.
        vm.isDirty = true;
      }

      vm.state = VMState.disconnected; // reporting disconnection

      var disconnected = Services.disconnected;

      if (disconnected) {
        invokeServiceHook(vm, disconnected);
      }

      var disconnectedCallback = vm.def.disconnectedCallback;

      if (!isUndefined(disconnectedCallback)) {
        {
          startMeasure('disconnectedCallback', vm);
        }

        invokeComponentCallback(vm, disconnectedCallback);

        {
          endMeasure('disconnectedCallback', vm);
        }
      }
    }

    function runShadowChildNodesDisconnectedCallback(vm) {
      var vCustomElementCollection = vm.velements; // reporting disconnection for every child in inverse order since they are inserted in reserved order

      for (var _i12 = vCustomElementCollection.length - 1; _i12 >= 0; _i12 -= 1) {
        var elm = vCustomElementCollection[_i12].elm; // There are two cases where the element could be undefined:
        // * when there is an error during the construction phase, and an
        //   error boundary picks it, there is a possibility that the VCustomElement
        //   is not properly initialized, and therefore is should be ignored.
        // * when slotted custom element is not used by the element where it is slotted
        //   into it, as a result, the custom element was never initialized.

        if (!isUndefined(elm)) {
          var childVM = getAssociatedVM(elm);
          resetComponentStateWhenRemoved(childVM);
        }
      }
    }

    function runLightChildNodesDisconnectedCallback(vm) {
      var adoptedChildren = vm.aChildren;
      recursivelyDisconnectChildren(adoptedChildren);
    }
    /**
     * The recursion doesn't need to be a complete traversal of the vnode graph,
     * instead it can be partial, when a custom element vnode is found, we don't
     * need to continue into its children because by attempting to disconnect the
     * custom element itself will trigger the removal of anything slotted or anything
     * defined on its shadow.
     */


    function recursivelyDisconnectChildren(vnodes) {
      for (var _i13 = 0, _len10 = vnodes.length; _i13 < _len10; _i13 += 1) {
        var vnode = vnodes[_i13];

        if (!isNull(vnode) && isArray$1(vnode.children) && !isUndefined(vnode.elm)) {
          // vnode is a VElement with children
          if (isUndefined(vnode.ctor)) {
            // it is a VElement, just keep looking (recursively)
            recursivelyDisconnectChildren(vnode.children);
          } else {
            // it is a VCustomElement, disconnect it and ignore its children
            resetComponentStateWhenRemoved(getAssociatedVM(vnode.elm));
          }
        }
      }
    } // This is a super optimized mechanism to remove the content of the shadowRoot
    // without having to go into snabbdom. Especially useful when the reset is a consequence
    // of an error, in which case the children VNodes might not be representing the current
    // state of the DOM


    function resetShadowRoot(vm) {
      vm.children = EmptyArray;
      ShadowRootInnerHTMLSetter.call(vm.cmpRoot, ''); // disconnecting any known custom element inside the shadow of the this vm

      runShadowChildNodesDisconnectedCallback(vm);
    }

    function scheduleRehydration(vm) {
      if (!vm.isScheduled) {
        vm.isScheduled = true;

        if (rehydrateQueue.length === 0) {
          addCallbackToNextTick(flushRehydrationQueue);
        }

        ArrayPush.call(rehydrateQueue, vm);
      }
    }

    function getErrorBoundaryVM(vm) {
      var currentVm = vm;

      while (!isNull(currentVm)) {
        if (!isUndefined(currentVm.def.errorCallback)) {
          return currentVm;
        }

        currentVm = currentVm.owner;
      }
    }
    /**
     * EXPERIMENTAL: This function detects whether or not a Node is
     * controlled by a LWC template. This API is subject to
     * change or being removed.
     */


    function isNodeFromTemplate(node) {
      if (isFalse$1(_instanceof(node, Node))) {
        return false;
      } // TODO [#1250]: skipping the shadowRoot instances itself makes no sense, we need to revisit this with locker


      if (_instanceof(node, ShadowRoot)) {
        return false;
      }

      if (useSyntheticShadow) {
        // TODO [#1252]: old behavior that is still used by some pieces of the platform, specifically, nodes inserted
        // manually on places where `lwc:dom="manual"` directive is not used, will be considered global elements.
        if (isUndefined(node.$shadowResolver$)) {
          return false;
        }
      }

      var root = node.getRootNode();
      return _instanceof(root, ShadowRoot);
    } // slow path routine
    // NOTE: we should probably more this routine to the synthetic shadow folder
    // and get the allocation to be cached by in the elm instead of in the VM


    function allocateInSlot(vm, children) {
      {
        assert.invariant(isObject$1(vm.cmpSlots), "When doing manual allocation, there must be a cmpSlots object available.");
      }

      var oldSlots = vm.cmpSlots;
      var cmpSlots = vm.cmpSlots = create(null);

      for (var _i14 = 0, _len11 = children.length; _i14 < _len11; _i14 += 1) {
        var vnode = children[_i14];

        if (isNull(vnode)) {
          continue;
        }

        var data = vnode.data;
        var slotName = data.attrs && data.attrs.slot || '';
        var vnodes = cmpSlots[slotName] = cmpSlots[slotName] || []; // re-keying the vnodes is necessary to avoid conflicts with default content for the slot
        // which might have similar keys. Each vnode will always have a key that
        // starts with a numeric character from compiler. In this case, we add a unique
        // notation for slotted vnodes keys, e.g.: `@foo:1:1`

        vnode.key = "@".concat(slotName, ":").concat(vnode.key);
        ArrayPush.call(vnodes, vnode);
      }

      if (isFalse$1(vm.isDirty)) {
        // We need to determine if the old allocation is really different from the new one
        // and mark the vm as dirty
        var oldKeys = keys(oldSlots);

        if (oldKeys.length !== keys(cmpSlots).length) {
          markComponentAsDirty(vm);
          return;
        }

        for (var _i15 = 0, _len12 = oldKeys.length; _i15 < _len12; _i15 += 1) {
          var key = oldKeys[_i15];

          if (isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {
            markComponentAsDirty(vm);
            return;
          }

          var oldVNodes = oldSlots[key];
          var _vnodes = cmpSlots[key];

          for (var j = 0, a = cmpSlots[key].length; j < a; j += 1) {
            if (oldVNodes[j] !== _vnodes[j]) {
              markComponentAsDirty(vm);
              return;
            }
          }
        }
      }
    }

    function runWithBoundaryProtection(vm, owner, pre, job, post) {
      var error;
      pre();

      try {
        job();
      } catch (e) {
        error = Object(e);
      } finally {
        post();

        if (!isUndefined(error)) {
          error.wcStack = error.wcStack || getErrorComponentStack(vm);
          var errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);

          if (isUndefined(errorBoundaryVm)) {
            throw error; // eslint-disable-line no-unsafe-finally
          }

          resetShadowRoot(vm); // remove offenders

          {
            startMeasure('errorCallback', errorBoundaryVm);
          } // error boundaries must have an ErrorCallback


          var errorCallback = errorBoundaryVm.def.errorCallback;
          invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);

          {
            endMeasure('errorCallback', errorBoundaryVm);
          }
        }
      }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var _Node$prototype = Node.prototype,
        _appendChild = _Node$prototype.appendChild,
        _insertBefore = _Node$prototype.insertBefore,
        _removeChild = _Node$prototype.removeChild,
        _replaceChild = _Node$prototype.replaceChild;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var ConnectingSlot = createHiddenField('connecting', 'engine');
    var DisconnectingSlot = createHiddenField('disconnecting', 'engine');

    function callNodeSlot(node, slot) {
      {
        assert.isTrue(node, "callNodeSlot() should not be called for a non-object");
      }

      var fn = getHiddenField(node, slot);

      if (!isUndefined(fn)) {
        fn();
      }

      return node; // for convenience
    } // monkey patching Node methods to be able to detect the insertions and removal of
    // root elements created via createElement.


    assign(Node.prototype, {
      appendChild: function appendChild(newChild) {
        var appendedNode = _appendChild.call(this, newChild);

        return callNodeSlot(appendedNode, ConnectingSlot);
      },
      insertBefore: function insertBefore(newChild, referenceNode) {
        var insertedNode = _insertBefore.call(this, newChild, referenceNode);

        return callNodeSlot(insertedNode, ConnectingSlot);
      },
      removeChild: function removeChild(oldChild) {
        var removedNode = _removeChild.call(this, oldChild);

        return callNodeSlot(removedNode, DisconnectingSlot);
      },
      replaceChild: function replaceChild(newChild, oldChild) {
        var replacedNode = _replaceChild.call(this, newChild, oldChild);

        callNodeSlot(replacedNode, DisconnectingSlot);
        callNodeSlot(newChild, ConnectingSlot);
        return replacedNode;
      }
    });
    /**
     * EXPERIMENTAL: This function is almost identical to document.createElement
     * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)
     * with the slightly difference that in the options, you can pass the `is`
     * property set to a Constructor instead of just a string value. The intent
     * is to allow the creation of an element controlled by LWC without having
     * to register the element as a custom element. E.g.:
     *
     * const el = createElement('x-foo', { is: FooCtor });
     *
     * If the value of `is` attribute is not a constructor,
     * then it throws a TypeError.
     */

    function createElement(sel, options) {
      if (!isObject$1(options) || isNull(options)) {
        throw new TypeError("\"createElement\" function expects an object as second parameter but received \"".concat(toString(options), "\"."));
      }

      var Ctor = options.is;

      if (!isFunction(Ctor)) {
        throw new TypeError("\"createElement\" function expects a \"is\" option with a valid component constructor.");
      }

      var mode = options.mode !== 'closed' ? 'open' : 'closed'; // Create element with correct tagName

      var element = document.createElement(sel);

      if (!isUndefined(getAssociatedVMIfPresent(element))) {
        // There is a possibility that a custom element is registered under tagName,
        // in which case, the initialization is already carry on, and there is nothing else
        // to do here.
        return element;
      }

      if (isCircularModuleDependency(Ctor)) {
        Ctor = resolveCircularModuleDependency(Ctor);
      }

      var def = getComponentDef(Ctor);
      setElementProto(element, def);

      {
        patchCustomElementWithRestrictions(element, EmptyObject);
      } // In case the element is not initialized already, we need to carry on the manual creation


      createVM(element, Ctor, {
        mode: mode,
        isRoot: true,
        owner: null
      }); // Handle insertion and removal from the DOM manually

      setHiddenField(element, ConnectingSlot, function () {
        var vm = getAssociatedVM(element);
        startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);

        if (vm.state === VMState.connected) {
          // usually means moving the element from one place to another, which is observable via life-cycle hooks
          removeRootVM(vm);
        }

        appendRootVM(vm);
        endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);
      });
      setHiddenField(element, DisconnectingSlot, function () {
        var vm = getAssociatedVM(element);
        removeRootVM(vm);
      });
      return element;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * EXPERIMENTAL: This function allows you to create a reactive readonly
     * membrane around any object value. This API is subject to change or
     * being removed.
     */


    function readonly(obj) {
      {
        // TODO [#1292]: Remove the readonly decorator
        if (arguments.length !== 1) {
          assert.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');
        }
      }

      return reactiveMembrane.getReadOnlyProxy(obj);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * This function builds a Web Component class from a LWC constructor
     * so it can be registered as a new element via customElements.define()
     * at any given time. E.g.:
     *
     *      import { buildCustomElementConstructor } from 'lwc';
     *      import Foo from 'ns/foo';
     *      const WC = buildCustomElementConstructor(Foo);
     *      customElements.define('x-foo', WC);
     *      const elm = document.createElement('x-foo');
     *
     */


    function buildCustomElementConstructor(Ctor, options) {
      var _a;

      var _getComponentDef = getComponentDef(Ctor),
          props = _getComponentDef.props,
          BaseElement = _getComponentDef.bridge;

      var normalizedOptions = {
        mode: 'open',
        isRoot: true,
        owner: null
      };

      if (isObject$1(options) && !isNull(options)) {
        var mode = options.mode;

        if (mode === 'closed') {
          normalizedOptions.mode = mode;
        }
      }

      return _a =
      /*#__PURE__*/
      function (_BaseElement) {
        _inherits(_a, _BaseElement);

        function _a() {
          var _this3;

          _classCallCheck(this, _a);

          _this3 = _possibleConstructorReturn(this, _getPrototypeOf(_a).call(this));
          createVM(_assertThisInitialized(_assertThisInitialized(_this3)), Ctor, normalizedOptions);

          {
            patchCustomElementWithRestrictions(_assertThisInitialized(_assertThisInitialized(_this3)), EmptyObject);
          }

          return _this3;
        }

        _createClass(_a, [{
          key: "connectedCallback",
          value: function connectedCallback() {
            var vm = getAssociatedVM(this);
            appendRootVM(vm);
          }
        }, {
          key: "disconnectedCallback",
          value: function disconnectedCallback() {
            var vm = getAssociatedVM(this);
            removeRootVM(vm);
          }
        }, {
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(attrName, oldValue, newValue) {
            if (oldValue === newValue) {
              // ignoring similar values for better perf
              return;
            }

            var propName = getPropNameFromAttrName(attrName);

            if (isUndefined(props[propName])) {
              // ignoring unknown attributes
              return;
            }

            if (!isAttributeLocked(this, attrName)) {
              // ignoring changes triggered by the engine itself during:
              // * diffing when public props are attempting to reflect to the DOM
              // * component via `this.setAttribute()`, should never update the prop.
              // Both cases, the the setAttribute call is always wrap by the unlocking
              // of the attribute to be changed
              return;
            } // reflect attribute change to the corresponding props when changed
            // from outside.


            this[propName] = newValue;
          }
        }]);

        return _a;
      }(BaseElement), // collecting all attribute names from all public props to apply
      // the reflection from attributes to props via attributeChangedCallback.
      _a.observedAttributes = ArrayMap.call(getOwnPropertyNames(props), function (propName) {
        return props[propName].attr;
      }), _a;
    }
    /** version: 1.1.13-224.5 */

    var lwc = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LightningElement: BaseLightningElement,
        api: api$1,
        buildCustomElementConstructor: buildCustomElementConstructor,
        createElement: createElement,
        decorate: decorate,
        getComponentConstructor: getComponentConstructor,
        getComponentDef: getComponentDef,
        isComponentConstructor: isComponentConstructor,
        isNodeFromTemplate: isNodeFromTemplate,
        readonly: readonly,
        register: register,
        registerComponent: registerComponent,
        registerDecorators: registerDecorators,
        registerTemplate: registerTemplate,
        sanitizeAttribute: sanitizeAttribute,
        setFeatureFlag: setFeatureFlag,
        setFeatureFlagForTest: setFeatureFlagForTest,
        track: track,
        unwrap: unwrap$1,
        wire: wire
    });

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // We're calling conosle.log and console.error directly instead of importing log and error from console because
    // it turned out that the transpiled compat mode code caused a problem in IE11.
    // see detailed explanation here https://git.soma.salesforce.com/communities/webruntime/pull/1284
    function log() {
      var _console, _console3, _log;

      for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
        __setKey(msg, _key, arguments[_key]);
      }

      // eslint-disable-next-line no-console
      __callKey2((_console3 = _console = console, _log = _console3._ES5ProxyType ? _console3.get("log") : _console3.log), "apply", _console, __concat(["[webruntime]"], msg));
    }
    function logError$1() {
      var _console2, _console4, _error;

      for (var _len2 = arguments.length, msg = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        __setKey(msg, _key2, arguments[_key2]);
      }

      // eslint-disable-next-line no-console
      __callKey2((_console4 = _console2 = console, _error = _console4._ES5ProxyType ? _console4.get("error") : _console4.error), "apply", _console2, __concat(["[webruntime]"], msg));
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }
    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function assert$1(assertion, message) {
      if (!assertion) {
        throw new Error(message);
      }
    }
    /**
     * f(any) -> true/false
     *
     * @param {*} obj - Item to check if it's an object
     *
     * @returns {boolean}
     */

    function isObject$3(obj) {
      return _typeof(obj) === 'object' && obj !== null && !Array.compatIsArray(obj);
    }
    /**
     * Transform an object by moving a property from one of its object to another.
     *
     * @param {object} obj - Object to transform
     * @param {string} to - Name of the object property which holds the object to move a property into
     * @param {string} from - Name of the object property which holds the object to move a property from
     * @param {string} fromProp - Property on the 'from' object to move into the 'to' object
     * @param {*} [defaultValue] - Default value to assign to the property
     * @param {string} [toProp = fromProp] - Property name on the 'to' object getting added
     */

    function transferProperty() {
      var _objectSpread3, _to, _fromProp, _from, _fromProp2;

      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var to = arguments.length > 1 ? arguments[1] : undefined;
      var from = arguments.length > 2 ? arguments[2] : undefined;
      var fromProp = arguments.length > 3 ? arguments[3] : undefined;
      var defaultValue = arguments.length > 4 ? arguments[4] : undefined;
      var toProp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : fromProp;
      var existsInTo = (obj._ES5ProxyType ? obj.get(to) : obj[to]) && (_to = obj._ES5ProxyType ? obj.get(to) : obj[to], _fromProp = _to._ES5ProxyType ? _to.get(fromProp) : _to[fromProp]);
      defaultValue = typeof existsInTo !== 'undefined' ? existsInTo : defaultValue;
      obj = _objectSpread({}, obj, (_objectSpread3 = {}, _defineProperty2(_objectSpread3, to, _objectSpread({}, obj._ES5ProxyType ? obj.get(to) : obj[to], _defineProperty2({}, toProp, isObject$3(obj._ES5ProxyType ? obj.get(from) : obj[from]) && (_from = obj._ES5ProxyType ? obj.get(from) : obj[from], _fromProp2 = _from._ES5ProxyType ? _from.get(fromProp) : _from[fromProp]) || defaultValue))), _defineProperty2(_objectSpread3, from, _objectSpread({}, obj._ES5ProxyType ? obj.get(from) : obj[from])), _objectSpread3));

      __deleteKey(obj._ES5ProxyType ? obj.get(from) : obj[from], fromProp);

      return obj;
    }

    function _objectSpread$1(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$1(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$1(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }
    var methodsWithCSRF = ['POST', 'PATCH', 'PUT', 'DELETE'];
    /**
     * Makes a request using the fetch API with the given path, method and body.
     *
     * This method takes care of setting the credentials to 'same-origin'
     * and adds the Content-Type header if a body is passed.
     *
     * @param {String} path - The request path, should be absolute but we prepend /<basePath>/api to it
     * @param {Object} init - An options object containing any custom settings that you want to apply to the request.
     * @param {String} init.credentials - The request credentials you want to use for the request, same-origin unless specified
     * @param {String} init.headers - Overrides the HTTP headers
     * @param {String} init.basePath - Overrides the default base path of @app/basePath + API_PATH_PREFIX
     */

    function fetch(_x) {
      return __callKey2(_fetch, "apply", this, arguments);
    }

    function _fetch() {
      _fetch = _asyncToGenerator(
      /*#__PURE__*/
      __callKey1(_regeneratorRuntime, "mark", function _callee(path) {
        var init,
            initParams,
            url,
            _args = arguments;
        return __callKey2(_regeneratorRuntime, "wrap", function _callee$(_context) {
          var _headers, _ContentType;

          while (1) {
            switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
              case 0:
                init = (_args._ES5ProxyType ? _args.get("length") : _args.length) > 1 && (_args._ES5ProxyType ? _args.get(1) : _args[1]) !== undefined ? _args._ES5ProxyType ? _args.get(1) : _args[1] : {};
                assert$1(path, 'Path not provided for API request');
                initParams = _objectSpread$1({}, init, {
                  headers: _objectSpread$1({}, init._ES5ProxyType ? init.get("headers") : init.headers),
                  credentials: (init._ES5ProxyType ? init.get("credentials") : init.credentials) || 'same-origin'
                });
                url = (initParams._ES5ProxyType ? initParams.get("basePath") : initParams.basePath) !== undefined ? (initParams._ES5ProxyType ? initParams.get("basePath") : initParams.basePath) + path : basePath + API_PATH_PREFIX + path;

                __setKey(initParams._ES5ProxyType ? initParams.get("headers") : initParams.headers, 'Content-Type', (_headers = initParams._ES5ProxyType ? initParams.get("headers") : initParams.headers, _ContentType = _headers._ES5ProxyType ? _headers.get('Content-Type') : _headers['Content-Type']) || (init._ES5ProxyType ? init.get("body") : init.body) && 'application/json; charset=utf-8');

                addCSRFToken(initParams);
                return __callKey2(_context, "abrupt", "return", __callKey2(window, "fetch", url, initParams));

              case 7:
              case "end":
                return __callKey0(_context, "stop");
            }
          }
        }, _callee);
      }));
      return __callKey2(_fetch, "apply", this, arguments);
    }

    function addCSRFToken(params) {
      if ((params._ES5ProxyType ? params.get("method") : params.method) && __callKey1(methodsWithCSRF, "includes", params._ES5ProxyType ? params.get("method") : params.method)) {
        if (csrfToken) {
          __setKey(params._ES5ProxyType ? params.get("headers") : params.headers, 'CSRF-Token', csrfToken);
        }
      }
    }
    /**
     * Makes a POST request using window.navigator if supported. If not, falls back to fetch POST.
     *
     * @param {*} param parameter containing path, payload, contentType
     * @param {String} param.path url to send the request
     * @param {*} param.payload object to send as the payload of the request
     * @param {String} param.contentType contentType of the payload
     */


    function sendBeacon(_ref) {
      var _navigator, _sendBeacon;

      var path = _ref._ES5ProxyType ? _ref.get("path") : _ref.path,
          payload = _ref._ES5ProxyType ? _ref.get("payload") : _ref.payload,
          contentType = _ref._ES5ProxyType ? _ref.get("contentType") : _ref.contentType;
      var url = basePath + path;

      var sentBeacon = (window._ES5ProxyType ? window.get("navigator") : window.navigator) && (_navigator = window._ES5ProxyType ? window.get("navigator") : window.navigator, _sendBeacon = _navigator._ES5ProxyType ? _navigator.get("sendBeacon") : _navigator.sendBeacon) && __callKey2(window._ES5ProxyType ? window.get("navigator") : window.navigator, "sendBeacon", url, payload);

      if (!sentBeacon) {
        fetch(path, {
          headers: {
            'Content-Type': contentType
          },
          basePath: basePath,
          body: payload,
          method: 'POST'
        });
      }
    }

    var transport = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fetch: fetch,
        sendBeacon: sendBeacon
    });

    var _location, _hostname, _location2, _pathname, _location3, _pathname2, _navigator, _connection, _navigator2, _connection2, _rtt, _performance, _getEntriesByType, _performance2, _getEntriesByName;
    /**
     * Check for supports for browser APIs that does not have shims
     */

    var supports = {
      hostname: Boolean((window._ES5ProxyType ? window.get("location") : window.location) && (_location = window._ES5ProxyType ? window.get("location") : window.location, _hostname = _location._ES5ProxyType ? _location.get("hostname") : _location.hostname)),
      pathname: Boolean((window._ES5ProxyType ? window.get("location") : window.location) && (_location2 = window._ES5ProxyType ? window.get("location") : window.location, _pathname = _location2._ES5ProxyType ? _location2.get("pathname") : _location2.pathname) !== undefined && (_location3 = window._ES5ProxyType ? window.get("location") : window.location, _pathname2 = _location3._ES5ProxyType ? _location3.get("pathname") : _location3.pathname) !== null),
      rtt: Boolean((window._ES5ProxyType ? window.get("navigator") : window.navigator) && (_navigator = window._ES5ProxyType ? window.get("navigator") : window.navigator, _connection = _navigator._ES5ProxyType ? _navigator.get("connection") : _navigator.connection) && (_navigator2 = window._ES5ProxyType ? window.get("navigator") : window.navigator, _connection2 = _navigator2._ES5ProxyType ? _navigator2.get("connection") : _navigator2.connection, _rtt = _connection2._ES5ProxyType ? _connection2.get("rtt") : _connection2.rtt)),
      PerformanceObserver: Boolean(window._ES5ProxyType ? window.get("PerformanceObserver") : window.PerformanceObserver),
      PerformancePaintTiming: Boolean(window._ES5ProxyType ? window.get("PerformancePaintTiming") : window.PerformancePaintTiming),
      PerformanceResourceTiming: Boolean(window._ES5ProxyType ? window.get("PerformanceResourceTiming") : window.PerformanceResourceTiming),
      getEntriesByType: Boolean((_performance = window._ES5ProxyType ? window.get("performance") : window.performance, _getEntriesByType = _performance._ES5ProxyType ? _performance.get("getEntriesByType") : _performance.getEntriesByType)),
      getEntriesByName: Boolean((_performance2 = window._ES5ProxyType ? window.get("performance") : window.performance, _getEntriesByName = _performance2._ES5ProxyType ? _performance2.get("getEntriesByName") : _performance2.getEntriesByName))
    };
    /**
     * Maps to https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType
     */

    var PERFORMANCE_ENTRY_TYPE = {
      MARK: 'mark',
      RESOURCE: 'resource',
      MEASURE: 'measure',
      PAINT: 'paint',
      NAVIGATION: 'navigation',
      LONGTASK: 'longtask',
      FRAME: 'frame'
    };
    /**
     * Holds the metadata for metrics entries
     */

    var metadataMap = {};
    /**
     * Callback for PerformanceObserver
     * @param {*} PerformanceObserverEntryList
     */

    function perfObserver() {
      sendBootstrapMetrics();
    }
    /**
     * Store the metadata for performance entry objects
     *
     * @param {*} type
     * @param {*} name
     * @param {*} metadata
     */


    function setMetadata(type, name, metadata) {
      __setKey(metadataMap, __concat(__concat("", type), name), metadata);
    }
    /**
     * Send performance entries objects to the metrics endpoint
     */


    function send(payload) {
      sendBeacon({
        path: METRICS_PATH_PREFIX,
        payload: prepPayload(payload),
        contentType: 'text/plain;charset=UTF-8'
      });
    }
    /**
     * Fetches and send all bootstrap-related metrics
     */


    function sendBootstrapMetrics() {
      send({
        bootstrap: getBootstrapMetrics(),
        navigator: getNavigatorMetrics(),
        resources: getResourceMetrics(),
        paint: getPaintMetrics(),
        location: getLocationMetrics()
      });
    }
    /**
     * Prepare the payload for sending to the metrics end pont
     */


    function prepPayload(payload) {
      var stringifiedPayload = JSON.stringify(payload); // trims the size of the payload by rounding all numbers to max 2 decimal places

      return __callKey2(stringifiedPayload, "replace", /(":)(\d+\.\d{2,})/g, function (_match, p1, p2) {
        return p1 + __callKey1(Number(p2), "toFixed", 2);
      });
    }
    /**
     * Fetches location-related metrics
     */


    function getLocationMetrics() {
      var _location4, _hostname2, _location5, _pathname3;

      return {
        hostname: (supports._ES5ProxyType ? supports.get("hostname") : supports.hostname) ? (_location4 = window._ES5ProxyType ? window.get("location") : window.location, _hostname2 = _location4._ES5ProxyType ? _location4.get("hostname") : _location4.hostname) : null,
        pathname: (supports._ES5ProxyType ? supports.get("pathname") : supports.pathname) ? (_location5 = window._ES5ProxyType ? window.get("location") : window.location, _pathname3 = _location5._ES5ProxyType ? _location5.get("pathname") : _location5.pathname) : null
      };
    }
    /**
     * Fetches window paint related metrics
     */


    function getPaintMetrics() {
      return (supports._ES5ProxyType ? supports.get("PerformancePaintTiming") : supports.PerformancePaintTiming) && (supports._ES5ProxyType ? supports.get("getEntriesByType") : supports.getEntriesByType) ? __callKey1(window._ES5ProxyType ? window.get("performance") : window.performance, "getEntriesByType", PERFORMANCE_ENTRY_TYPE._ES5ProxyType ? PERFORMANCE_ENTRY_TYPE.get("PAINT") : PERFORMANCE_ENTRY_TYPE.PAINT) : null;
    }
    /**
     * Fetches resource-related metrics
     */


    function getResourceMetrics() {
      return (supports._ES5ProxyType ? supports.get("PerformanceResourceTiming") : supports.PerformanceResourceTiming) && (supports._ES5ProxyType ? supports.get("getEntriesByType") : supports.getEntriesByType) ? __callKey1(window._ES5ProxyType ? window.get("performance") : window.performance, "getEntriesByType", PERFORMANCE_ENTRY_TYPE._ES5ProxyType ? PERFORMANCE_ENTRY_TYPE.get("RESOURCE") : PERFORMANCE_ENTRY_TYPE.RESOURCE) : null;
    }
    /**
     * Fetches app and framework bootstrap metrics
     */


    function getBootstrapMetrics() {
      if (!(supports._ES5ProxyType ? supports.get("getEntriesByName") : supports.getEntriesByName)) {
        return null;
      }

      var appBootstrap = __callKey1(window._ES5ProxyType ? window.get("performance") : window.performance, "getEntriesByName", __concat("", WEBRUNTIME_PREFIX, "-app-bootstrap"));

      var frameworkBootstrap = __callKey1(window._ES5ProxyType ? window.get("performance") : window.performance, "getEntriesByName", __concat("", WEBRUNTIME_PREFIX, "-framework-bootstrap"));

      return __concat(_toConsumableArray(appBootstrap), _toConsumableArray(frameworkBootstrap));
    }
    /**
     * Fetches metrics-relevant data from window.navigator if available
     */


    function getNavigatorMetrics() {
      var _navigator3, _connection3, _rtt2;

      return (supports._ES5ProxyType ? supports.get("rtt") : supports.rtt) ? {
        'connection.rtt': (_navigator3 = window._ES5ProxyType ? window.get("navigator") : window.navigator, _connection3 = _navigator3._ES5ProxyType ? _navigator3.get("connection") : _navigator3.connection, _rtt2 = _connection3._ES5ProxyType ? _connection3.get("rtt") : _connection3.rtt)
      } : null;
    }

    if ((supports._ES5ProxyType ? supports.get("PerformanceObserver") : supports.PerformanceObserver) && (supports._ES5ProxyType ? supports.get("PerformancePaintTiming") : supports.PerformancePaintTiming)) {
      // instantiate the PerformanceObserver and start observing
      var observer = new (window._ES5ProxyType ? window.get("PerformanceObserver") : window.PerformanceObserver)(perfObserver);

      __callKey1(observer, "observe", {
        entryTypes: [PERFORMANCE_ENTRY_TYPE._ES5ProxyType ? PERFORMANCE_ENTRY_TYPE.get("PAINT") : PERFORMANCE_ENTRY_TYPE.PAINT]
      });
    } else {
      // send data on window unload
      __callKey3(window, "addEventListener", 'unload', function () {
        sendBootstrapMetrics();
      }, false);
    }

    function getMarkName$1(ns, name) {
      return __concat(__concat("", WEBRUNTIME_PREFIX, "-"), __callKey1(__callKey1([ns, name], "filter", Boolean), "join", ':'));
    }

    function performanceMarkHelper(ns, name, ctx) {
      var markName = getMarkName$1(ns, name);
      setMetadata(PERFORMANCE_ENTRY_TYPE._ES5ProxyType ? PERFORMANCE_ENTRY_TYPE.get("MARK") : PERFORMANCE_ENTRY_TYPE.MARK, markName, ctx);

      __callKey1(window._ES5ProxyType ? window.get("performance") : window.performance, "mark", markName);
    }

    function mark(ns, name, ctx) {
      performanceMarkHelper(ns, name, ctx);
    }

    function markStart(ns, name, ctx) {
      performanceMarkHelper(ns, name, ctx);
    }

    function markEnd(ns, name, ctx) {
      var markName = getMarkName$1(ns, name);
      setMetadata(PERFORMANCE_ENTRY_TYPE._ES5ProxyType ? PERFORMANCE_ENTRY_TYPE.get("MEASURE") : PERFORMANCE_ENTRY_TYPE.MEASURE, markName, ctx);

      try {
        __callKey2(window._ES5ProxyType ? window.get("performance") : window.performance, "measure", markName, markName);
      } catch (ex) {
        logError$1(__concat("[instrumentation] no startMark named ", markName, " found"), ex._ES5ProxyType ? ex.get("stack") : ex.stack);
      }
    }

    function time() {
      return Date.now();
    }

    function perfStart(name, attributes, eventSource) {
      {
        log("[instrumentation] perfStart()", {
          name: name,
          attributes: attributes,
          eventSource: eventSource
        });
      }
    }

    function perfEnd(name, attributes, eventSource) {
      {
        log("[instrumentation] perfEnd()", {
          name: name,
          attributes: attributes,
          eventSource: eventSource
        });
      }
    }

    function interaction(target, scope, context, eventSource, eventType) {
      {
        log("[instrumentation] interaction()", {
          target: target,
          scope: scope,
          context: context,
          eventSource: eventSource,
          eventType: eventType
        });
      }
    }

    function registerPlugin(pluginConfig) {
      {
        log("[instrumentation] registerPlugin()", {
          pluginConfig: pluginConfig
        });
      }
    }

    function registerPeriodicLogger(name, callback) {
      {
        log("[instrumentation] registerPeriodicLogger()", {
          name: name,
          callback: callback
        });
      }
    }

    function registerCacheStats(name) {
      {
        log("[instrumentation] registerCacheStats()", {
          name: name
        });
      }

      return {
        logHits: function logHits(count) {
          {
            log("[instrumentation] registerCacheStats().logHits()", {
              name: name,
              count: count
            });
          }
        },
        logMisses: function logMisses(count) {
          {
            log("[instrumentation] registerCacheStats().logMisses()", {
              name: name,
              count: count
            });
          }
        },
        unRegister: function unRegister() {
          {
            log("[instrumentation] registerCacheStats().unRegister()", {
              name: name
            });
          }
        }
      };
    }

    function error(attributes, eventSource, eventType) {
      {
        log("[instrumentation] error()", {
          attributes: attributes,
          eventSource: eventSource,
          eventType: eventType
        });
      }
    }

    function removePeriodicLogger(id) {
      {
        log("[instrumentation] removePeriodicLogger()", {
          id: id
        });
      }
    }

    function enablePlugin(name) {
      {
        log("[instrumentation] enablePlugin()", {
          name: name
        });
      }
    }

    function disablePlugin(name) {
      {
        log("[instrumentation] disablePlugin()", {
          name: name
        });
      }
    }

    function trackScenario(nameIn, attributes, eventSourceIn) {
      {
        log("[instrumentation] trackScenario()", {
          nameIn: nameIn,
          attributes: attributes,
          eventSourceIn: eventSourceIn
        });
      }
    }

    function counter(metricsKey) {
      return {
        increment: function increment(value) {
          {
            log("[instrumentation] counter.increment()", {
              metricsKey: metricsKey,
              value: value
            });
          }
        },
        decrement: function decrement(value) {
          {
            log("[instrumentation] counter.decrement()", {
              metricsKey: metricsKey,
              value: value
            });
          }
        },
        getValue: function getValue() {
          {
            log("[instrumentation] counter.getValue()", {
              metricsKey: metricsKey
            });
          }

          return 0;
        },
        reset: function reset() {
          {
            log("[instrumentation] counter.reset()", {
              metricsKey: metricsKey
            });
          }
        }
      };
    }

    function gauge(metricsKey) {
      return {
        setValue: function setValue(value) {
          {
            log("[instrumentation] setValue()", {
              metricsKey: metricsKey,
              value: value
            });
          }
        },
        getValue: function getValue() {
          {
            log("[instrumentation] getValue()", {
              metricsKey: metricsKey
            });
          }

          return 0;
        },
        reset: function reset() {
          {
            log("[instrumentation] reset()", {
              metricsKey: metricsKey
            });
          }
        }
      };
    }

    function percentileHistogram(metricsKey) {
      return {
        update: function update(value) {
          {
            log("[instrumentation] percentileHistogram.update()", {
              metricsKey: metricsKey,
              value: value
            });
          }
        },
        getValue: function getValue() {
          {
            log("[instrumentation] percentileHistogram.getValue()", {
              metricsKey: metricsKey
            });
          }

          return [];
        },
        reset: function reset() {
          {
            log("[instrumentation] percentileHistogram.reset()", {
              metricsKey: metricsKey
            });
          }
        }
      };
    }

    function timer(metricsKey) {
      return {
        addDuration: function addDuration() {
          {
            log("[instrumentation] timer.addDuration()", {
              metricsKey: metricsKey
            });
          }
        },
        time: function time() {
          {
            log("[instrumentation] timer.time()", {
              metricsKey: metricsKey
            });
          }
        },
        getValue: function getValue() {
          {
            log("[instrumentation] timer.getValue()", {
              metricsKey: metricsKey
            });
          }

          return [];
        },
        reset: function reset() {
          {
            log("[instrumentation] timer.reset()", {
              metricsKey: metricsKey
            });
          }
        },
        get: function get() {
          {
            log("[instrumentation] timer.get()", {
              metricsKey: metricsKey
            });
          }
        }
      };
    } // exports must match https://swarm.soma.salesforce.com/files/app/main/core/ui-instrumentation-components/modules/instrumentation/service/service.js

    var auraInstrumentation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        disablePlugin: disablePlugin,
        enablePlugin: enablePlugin,
        error: error,
        interaction: interaction,
        mark: mark,
        markEnd: markEnd,
        markStart: markStart,
        perfEnd: perfEnd,
        perfStart: perfStart,
        registerCacheStats: registerCacheStats,
        registerPeriodicLogger: registerPeriodicLogger,
        registerPlugin: registerPlugin,
        removePeriodicLogger: removePeriodicLogger,
        time: time,
        trackScenario: trackScenario,
        counter: counter,
        gauge: gauge,
        percentileHistogram: percentileHistogram,
        timer: timer
    });

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // !!! EXACT COPY of iso8601Utils.js from lightning-components repository !!!

    /*
     * Regex to test a string for an ISO8601 Date. The following formats are matched.
     * Note that if a time element is present (e.g. 'T'), the string should have a time zone designator (Z or +hh:mm or -hh:mm).
     *
     *  YYYY
     *  YYYY-MM
     *  YYYY-MM-DD
     *  YYYY-MM-DDThh:mmTZD
     *  YYYY-MM-DDThh:mm:ssTZD
     *  YYYY-MM-DDThh:mm:ss.STZD
     *
     *
     * @see: https://www.w3.org/TR/NOTE-datetime
     */
    var ISO8601_STRICT_PATTERN = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z){1})?)?)?$/i;
    /* Regex to test a string for an ISO8601 partial time or full time:
     * hh:mm
     * hh:mm:ss
     * hh:mm:ss.S
     * full time = partial time + TZD
     */

    var ISO8601_TIME_PATTERN = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;
    var STANDARD_TIME_FORMAT = 'HH:mm:ss.SSS';
    var STANDARD_DATE_FORMAT = 'YYYY-MM-DD';
    var TIME_SEPARATOR = 'T';
    var TIMEZONE_INDICATOR = /(Z|([+-])(\d{2}):(\d{2}))$/;
    function isValidISODateTimeString(dateTimeString) {
      return isValidISO8601String(dateTimeString) && isValidDate(dateTimeString);
    }
    function isValidISOTimeString(timeString) {
      if (!isValidISO8601TimeString(timeString)) {
        return false;
      }

      var timeOnly = removeTimeZoneSuffix(timeString);
      return isValidDate(__concat("2018-09-09T", timeOnly, "Z"));
    }
    function removeTimeZoneSuffix(dateTimeString) {
      if (typeof dateTimeString === 'string') {
        var _dateTimeString$split, _;

        return _dateTimeString$split = __callKey1(dateTimeString, "split", TIMEZONE_INDICATOR), _ = _dateTimeString$split._ES5ProxyType ? _dateTimeString$split.get(0) : _dateTimeString$split[0];
      }

      return dateTimeString;
    }

    function isValidISO8601String(dateTimeString) {
      if (typeof dateTimeString !== 'string') {
        return false;
      }

      return __callKey1(ISO8601_STRICT_PATTERN, "test", dateTimeString);
    }

    function isValidISO8601TimeString(timeString) {
      if (typeof timeString !== 'string') {
        return false;
      }

      return __callKey1(ISO8601_TIME_PATTERN, "test", timeString);
    }

    function isValidDate(value) {
      // Date.parse returns NaN if the argument doesn't represent a valid date
      var timeStamp = Date.parse(value);
      return isFinite(timeStamp);
    }

    var _tmpl = void 0;

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // !!! EXACT COPY of defaultDurationConfig.js from lightning-components repository !!!
    // inspired by the duration logic in moment.js (extremely simplified) https://github.com/moment/moment
    // Only using this in defaultConfig when we're outside of an aura context.
    // Reasons for this are because the Intl api currently doesn't match the existing text formats:
    // e.g. format(1, 'day') returns 'in 1 day' or 'tomorrow' (numeric=always/auto) in chrome, the existing moment implementation returns 'in a day'
    // Intl.RelativeTimeFormat is also only supported by a handful of browsers (as of 220):
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RelativeTimeFormat#Browser_compatibility
    // The following two labels will be used even on browsers that support Intl.RelativeTimeFormat

    var labelSecondsLater = 'in a few seconds';
    var labelSecondsAgo = 'a few seconds ago'; // These labels will only be used as fallback in browsers that do not support Intl.RelativeTimeFormat

    var fallbackFutureLabel = 'in {0} {1}'; // e.g. in 1 minute

    var fallbackPastLabel = '{0} {1} ago'; // e.g. 1 minute ago

    var fallbackPluralSuffix = 's'; // plural suffix for the units, e.g. in 10 minutes
    // The threshold values come from moment.js

    var units = {
      SECONDS: {
        name: 'second',
        threshold: 45
      },
      // a few seconds to minute
      MINUTES: {
        name: 'minute',
        threshold: 45
      },
      // minutes to hour
      HOURS: {
        name: 'hour',
        threshold: 22
      },
      // hours to day
      DAYS: {
        name: 'day',
        threshold: 26
      },
      // days to month
      MONTHS: {
        name: 'month',
        threshold: 11
      },
      // months to year
      YEARS: {
        name: 'year'
      }
    };
    var SECOND_TO_MILLISECONDS = 1000;
    var MINUTE_TO_MILLISECONDS = 6e4; // 60 * SECOND_TO_MILLISECONDS;

    var HOUR_TO_MILLISECONDS = 36e5; // 60 * MINUTE_TO_MILLISECONDS

    var DAY_TO_MILLISECONDS = 864e5; // 24 * HOUR_TO_MILLISECONDS;

    var Duration =
    /*#__PURE__*/
    function () {
      function Duration(milliseconds) {
        _classCallCheck(this, Duration);

        __setKey(this, "milliseconds", 0);

        if (typeof milliseconds !== 'number') {
          __setKey(this, "isValid", false); // eslint-disable-next-line no-console


          __callKey1(console, "warn", __concat(__concat("The value of milliseconds passed into Duration must be of type number, \n                but we are getting the ", _typeof(milliseconds), " value \""), milliseconds, "\" instead.\n                "));

          return;
        }

        __setKey(this, "isValid", true);

        __setKey(this, "milliseconds", milliseconds);
      }

      _createClass(Duration, [{
        key: "humanize",
        value: function humanize(locale) {
          if (!(this._ES5ProxyType ? this.get("isValid") : this.isValid)) {
            return '';
          }

          var unit = findBestUnitMatch(this);

          if (unit === (units._ES5ProxyType ? units.get("SECONDS") : units.SECONDS)) {
            var isLater = (this._ES5ProxyType ? this.get("milliseconds") : this.milliseconds) > 0;
            return isLater ? labelSecondsLater : labelSecondsAgo;
          }

          return format(locale, __callKey1(this, "asIn", unit), unit._ES5ProxyType ? unit.get("name") : unit.name);
        }
      }, {
        key: "asIn",
        value: function asIn(unit) {
          switch (unit) {
            case units._ES5ProxyType ? units.get("SECONDS") : units.SECONDS:
              return Math.round((this._ES5ProxyType ? this.get("milliseconds") : this.milliseconds) / SECOND_TO_MILLISECONDS);

            case units._ES5ProxyType ? units.get("MINUTES") : units.MINUTES:
              return Math.round((this._ES5ProxyType ? this.get("milliseconds") : this.milliseconds) / MINUTE_TO_MILLISECONDS);

            case units._ES5ProxyType ? units.get("HOURS") : units.HOURS:
              return Math.round((this._ES5ProxyType ? this.get("milliseconds") : this.milliseconds) / HOUR_TO_MILLISECONDS);

            case units._ES5ProxyType ? units.get("DAYS") : units.DAYS:
              return Math.round((this._ES5ProxyType ? this.get("milliseconds") : this.milliseconds) / DAY_TO_MILLISECONDS);

            case units._ES5ProxyType ? units.get("MONTHS") : units.MONTHS:
              return Math.round(daysToMonth((this._ES5ProxyType ? this.get("milliseconds") : this.milliseconds) / DAY_TO_MILLISECONDS));

            case units._ES5ProxyType ? units.get("YEARS") : units.YEARS:
            default:
              return Math.round(daysToMonth((this._ES5ProxyType ? this.get("milliseconds") : this.milliseconds) / DAY_TO_MILLISECONDS) / 12);
          }
        }
      }]);

      return Duration;
    }();

    registerDecorators(Duration, {
      fields: ["milliseconds"]
    });

    var Duration$1 = registerComponent(Duration, {
      tmpl: _tmpl
    });

    function daysToMonth(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      var daysToMonthRatio = 4800 / 146097;
      return days * daysToMonthRatio;
    }

    function findBestUnitMatch(duration) {
      // Traversing the object keys in order from Seconds to Years
      // http://exploringjs.com/es6/ch_oop-besides-classes.html#_traversal-order-of-properties
      var match = __callKey1(Object.compatKeys(units), "find", function (key) {
        var unit = units._ES5ProxyType ? units.get(key) : units[key]; // Year is the max and doesn't have a threshold

        return unit === (units._ES5ProxyType ? units.get("YEARS") : units.YEARS) || Math.abs(__callKey1(duration, "asIn", unit)) < (unit._ES5ProxyType ? unit.get("threshold") : unit.threshold);
      });

      return units._ES5ProxyType ? units.get(match) : units[match];
    }

    function format(locale, value, unit) {
      if (__inKey(window, 'Intl') && (Intl._ES5ProxyType ? Intl.get("RelativeTimeFormat") : Intl.RelativeTimeFormat)) {
        var formatter = new (Intl._ES5ProxyType ? Intl.get("RelativeTimeFormat") : Intl.RelativeTimeFormat)(locale, {
          style: 'long',
          numeric: 'always'
        });
        return __callKey2(formatter, "format", value, unit);
      }

      return fallbackFormatter(value, unit);
    }

    function fallbackFormatter(value, unit) {
      // eslint-disable-next-line no-console
      __callKey1(console, "warn", "The current environment does not support formatters for relative time.");

      var absoluteValue = Math.abs(value);
      var unitString = absoluteValue !== 1 ? unit + fallbackPluralSuffix : unit;
      var label = value > 0 ? fallbackFutureLabel : fallbackPastLabel;
      return formatString(label, absoluteValue, unitString);
    }

    function formatString(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        __setKey(args, _key - 1, arguments[_key]);
      }

      return __callKey2(str, "replace", /{(\d+)}/g, function (match, i) {
        return args._ES5ProxyType ? args.get(i) : args[i];
      });
    }

    var MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var DATE_FORMAT = {
      short: 'M/d/yyyy',
      medium: 'MMM d, yyyy',
      long: 'MMMM d, yyyy'
    };
    var TIME_FORMAT = {
      short: 'h:mm a',
      medium: 'h:mm:ss a',
      long: 'h:mm:ss a'
    }; // The parseTime method normalizes the time format so that minor deviations are accepted

    var TIME_FORMAT_SIMPLE = {
      short: 'h:m a',
      medium: 'h:m:s a',
      long: 'h:m:s a'
    }; // Only works with dates and iso strings
    // formats the date object by ignoring the timezone offset
    // e.g. assume date is Mar 11 2019 00:00:00 GMT+1100:
    // formatDate(date, 'YYYY-MM-DD') -> 2019-03-11

    function formatDate(value, format) {
      var isUTC = false;
      var dateString = value;

      if (typeof value === 'string') {
        var _value$split, _;

        dateString = (_value$split = __callKey1(value, "split", TIME_SEPARATOR), _ = _value$split._ES5ProxyType ? _value$split.get(0) : _value$split[0]);
        isUTC = true;
      }

      return formatDateInternal(dateString, format, isUTC);
    } // Only works with date objects.
    // formats the date object according to UTC.
    // e.g. assume date is Mar 11 2019 00:00:00 GMT+1100:
    // formatDateUTC(date, 'YYYY-MM-DD') -> 2019-03-10


    function formatDateUTC(value, format) {
      return formatDateInternal(value, format, true);
    } // Only works with a date object


    function formatTime(date, format) {
      if (!isDate(date)) {
        return new Date('');
      }

      var hours = (__callKey0(date, "getHours") + 11) % 12 + 1;
      var suffix = __callKey0(date, "getHours") >= 12 ? 'PM' : 'AM';

      switch (format) {
        case STANDARD_TIME_FORMAT:
          // 16:12:32.000
          return __concat(__concat(__concat(__concat("", pad(__callKey0(date, "getHours")), ":"), pad(__callKey0(date, "getMinutes")), ":"), pad(__callKey0(date, "getSeconds")), "."), doublePad(__callKey0(date, "getMilliseconds")));

        case TIME_FORMAT._ES5ProxyType ? TIME_FORMAT.get("short") : TIME_FORMAT.short:
          // 4:12 PM;
          return __concat(__concat(__concat("", hours, ":"), pad(__callKey0(date, "getMinutes")), " "), suffix);

        case TIME_FORMAT._ES5ProxyType ? TIME_FORMAT.get("medium") : TIME_FORMAT.medium:
        case TIME_FORMAT._ES5ProxyType ? TIME_FORMAT.get("long") : TIME_FORMAT.long:
        default:
          // 4:12:32 PM;
          return __concat(__concat(__concat(__concat("", hours, ":"), pad(__callKey0(date, "getMinutes")), ":"), pad(__callKey0(date, "getSeconds")), " "), suffix);
      }
    } // Only works with a date object
    // formats the date object according to UTC.
    // e.g. assume date is Mar 11 2019 00:00:00 GMT+1100:
    // formatDateTimeUTC(date) -> 2019-03-10  1:00:00 PM


    function formatDateTimeUTC(value) {
      if (!isDate(value)) {
        return new Date('');
      }

      var date = new Date(__callKey0(value, "getTime"));
      return __concat(__concat("", formatDateUTC(date), ", "), formatTime(addTimezoneOffset(date)));
    } // parses ISO8601 date/time strings. Currently only used to parse ISO time strings without a TZD. Some examples:
    // 20:00:00.000             -> Feb 26 2019 20:00:00 GMT-0500
    // 2019-03-11               -> Mar 11 2019 00:00:00 GMT-0400
    // 2019-03-11T00:00:00.000Z -> Mar 10 2019 20:00:00 GMT-0400


    function parseDateTimeISO8601(value) {
      var isoString = null;
      var shouldAddOffset = true;

      if (isValidISOTimeString(value)) {
        isoString = __concat("2014-03-20T", addTimezoneSuffix(value));
      } else if (isValidISODateTimeString(value)) {
        if (__callKey1(value, "indexOf", TIME_SEPARATOR) > 0) {
          isoString = addTimezoneSuffix(value);
          shouldAddOffset = false;
        } else {
          isoString = __concat("", value, "T00:00:00.000Z");
        }
      }

      if (isoString) {
        // Browsers differ on how they treat iso strings without a timezone offset (local vs utc time)
        var parsedDate = new Date(isoString);

        if (shouldAddOffset) {
          addTimezoneOffset(parsedDate);
        }

        return parsedDate;
      }

      return null;
    } // called by the datepicker and calendar for parsing iso and formatted date strings
    // called by the timepicker to parse the formatted time string


    function parseDateTime(value, format) {
      if (format === STANDARD_DATE_FORMAT && isValidISODateTimeString(value)) {
        return parseDateTimeISO8601(value);
      }

      if (__callKey1(Object.compatValues(DATE_FORMAT), "includes", format)) {
        return parseFormattedDate(value, format);
      }

      if (__callKey1(Object.compatValues(TIME_FORMAT_SIMPLE), "includes", format)) {
        return parseFormattedTime(value);
      }

      return null;
    } // The input to this method is always an ISO string with timezone offset.


    function parseDateTimeUTC(value) {
      return parseDateTimeISO8601(addTimezoneSuffix(value));
    }

    function isBefore(date1, date2, unit) {
      var normalizedDate1 = getDate(date1);
      var normalizedDate2 = getDate(date2);

      if (!normalizedDate1 || !normalizedDate2) {
        return false;
      }

      return __callKey0(startOf(normalizedDate1, unit), "getTime") < __callKey0(startOf(normalizedDate2, unit), "getTime");
    } // unit can be millisecond, minute, day


    function isAfter(date1, date2, unit) {
      var normalizedDate1 = getDate(date1);
      var normalizedDate2 = getDate(date2);

      if (!normalizedDate1 || !normalizedDate2) {
        return false;
      }

      return __callKey0(startOf(normalizedDate1, unit), "getTime") > __callKey0(startOf(normalizedDate2, unit), "getTime");
    } // We're not doing timezone conversion in the default config. Only converting from UTC to system timezone


    function UTCToWallTime(date, timezone, callback) {
      var utcDate = new Date(__callKey0(date, "getTime"));
      callback(subtractTimezoneOffset(utcDate));
    } // We're not doing timezone conversion in the default config. Only converting from system timezone to UTC


    function WallTimeToUTC(date, timezone, callback) {
      var localDate = new Date(__callKey0(date, "getTime"));
      callback(addTimezoneOffset(localDate));
    } // We're assuming en-US locale so we don't need translation between calendar systems


    function translateToOtherCalendar(date) {
      return date;
    } // We're assuming en-US locale so we don't need translation between calendar systems


    function translateFromOtherCalendar(date) {
      return date;
    } // We're assuming en-US locale so we don't need translation of digits


    function translateToLocalizedDigits(input) {
      return input;
    } // We're assuming en-US locale so we don't need translation of digits


    function translateFromLocalizedDigits(input) {
      return input;
    } // This is called from the numberFormat library when the value exceeds the safe length.
    // We currently rely on aura to format large numbers


    function getNumberFormat() {
      return {
        format: function format(value) {
          // eslint-disable-next-line no-console
          __callKey1(console, "warn", __concat("The current environment does not support large numbers and the original value of ", value, " will be returned."));

          return value;
        }
      };
    } // relativeDateTime (currently the only user of duration) uses unit="minutes"
    // The default implementation here assumes the unit is always minutes.


    function duration(minutes) {
      return new Duration$1(minutes * 60 * 1000);
    }

    function displayDuration(value) {
      return __callKey1(value, "humanize", 'en');
    } // parses a time string formatted in en-US locale i.e. h:mm:ss a


    function parseFormattedTime(value) {
      var _ref, _ref2;

      // for time strings it's easier to just split on :.\s
      var values = __callKey1(__callKey0(value, "trim"), "split", /[:.\s*]/); // at least two parts i.e. 12 PM, and at most 5 parts i.e. 12:34:21.432 PM


      var length = values._ES5ProxyType ? values.get("length") : values.length;

      if (!values || length < 2 || length > 5) {
        return null;
      }

      var ampm = (_ref = length - 1, _ref2 = values._ES5ProxyType ? values.get(_ref) : values[_ref]);
      var isBeforeNoon = __callKey0(ampm, "toLowerCase") === 'am';
      var isAfternoon = __callKey0(ampm, "toLowerCase") === 'pm'; // remove ampm

      values.splice(-1, 1);

      var allNumbers = __callKey1(values, "every", function (item) {
        return !isNaN(item);
      });

      if (!isAfternoon && !isBeforeNoon || !allNumbers) {
        return null;
      }

      var hours = values._ES5ProxyType ? values.get(0) : values[0];
      var hour24 = pad(isAfternoon ? hours % 12 + 12 : hours % 12);
      var minutes = length >= 3 && (values._ES5ProxyType ? values.get(1) : values[1]) || '0';
      var seconds = length >= 4 && (values._ES5ProxyType ? values.get(2) : values[2]) || '0';
      var milliseconds = length === 5 && (values._ES5ProxyType ? values.get(3) : values[3]) || '0';
      var newDate = new Date('2014-03-20');

      __callKey4(newDate, "setHours", hour24, minutes, seconds, milliseconds);

      return isDate(newDate) ? newDate : null;
    } // parses a date string formatted in en-US locale, i.e. MMM d, yyyy


    function parseFormattedDate(value, format) {
      // default to medium style pattern
      var pattern = /^([a-zA-Z]{3})\s*(\d{1,2}),\s*(\d{4})$/;

      switch (format) {
        case DATE_FORMAT._ES5ProxyType ? DATE_FORMAT.get("short") : DATE_FORMAT.short:
          pattern = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/;
          break;

        case DATE_FORMAT._ES5ProxyType ? DATE_FORMAT.get("long") : DATE_FORMAT.long:
          pattern = /^([a-zA-Z]+)\s*(\d{1,2}),\s*(\d{4})$/;
          break;
      } // matches[1]: month, matches[2]: day, matches[3]: year


      var match = __callKey1(pattern, "exec", __callKey0(value, "trim"));

      if (!match) {
        return null;
      }

      var month = match._ES5ProxyType ? match.get(1) : match[1];
      var day = match._ES5ProxyType ? match.get(2) : match[2];
      var year = match._ES5ProxyType ? match.get(3) : match[3]; // for long and medium style formats, we need to find the month index

      if (format !== (DATE_FORMAT._ES5ProxyType ? DATE_FORMAT.get("short") : DATE_FORMAT.short)) {
        month = __callKey1(MONTH_NAMES, "findIndex", function (item) {
          return __callKey1(__callKey0(item, "toLowerCase"), "includes", __callKey0(month, "toLowerCase"));
        }); // the actual month for the ISO string is 1 more than the index

        month += 1;
      }

      var isoValue = __concat(__concat(__concat("", year, "-"), pad(month), "-"), pad(day));

      var newDate = new Date(__concat("", isoValue, "T00:00:00.000Z"));
      return isDate(newDate) ? addTimezoneOffset(newDate) : null;
    }

    function formatDateInternal(value, format, isUTC) {
      var _date$getMonth, _date$getMonth2;

      var date = getDate(value);

      if (!date) {
        // return Invalid Date
        return new Date('');
      }

      if (isUTC && isDate(value)) {
        // if value is an ISO string, we already add the timezone offset when parsing the date string.
        addTimezoneOffset(date);
      }

      switch (format) {
        case STANDARD_DATE_FORMAT:
          return __concat(__concat(__concat("", __callKey0(date, "getFullYear"), "-"), pad(__callKey0(date, "getMonth") + 1), "-"), pad(__callKey0(date, "getDate")));

        case DATE_FORMAT._ES5ProxyType ? DATE_FORMAT.get("short") : DATE_FORMAT.short:
          return __concat(__concat(__concat("", __callKey0(date, "getMonth") + 1, "/"), __callKey0(date, "getDate"), "/"), __callKey0(date, "getFullYear"));

        case DATE_FORMAT._ES5ProxyType ? DATE_FORMAT.get("long") : DATE_FORMAT.long:
          return __concat(__concat(__concat("", (_date$getMonth = __callKey0(date, "getMonth"), _date$getMonth2 = MONTH_NAMES._ES5ProxyType ? MONTH_NAMES.get(_date$getMonth) : MONTH_NAMES[_date$getMonth]), " "), __callKey0(date, "getDate"), ", "), __callKey0(date, "getFullYear"));

        case DATE_FORMAT._ES5ProxyType ? DATE_FORMAT.get("medium") : DATE_FORMAT.medium:
        default:
          {
            var _date$getMonth3, _date$getMonth4;

            var shortMonthName = __callKey2((_date$getMonth3 = __callKey0(date, "getMonth"), _date$getMonth4 = MONTH_NAMES._ES5ProxyType ? MONTH_NAMES.get(_date$getMonth3) : MONTH_NAMES[_date$getMonth3]), "substring", 0, 3);

            return __concat(__concat(__concat("", shortMonthName, " "), __callKey0(date, "getDate"), ", "), __callKey0(date, "getFullYear"));
          }
      }
    } // unit can be 'day' or 'minute', otherwise will default to milliseconds. These are the only units that are currently used in the codebase.


    function startOf(date, unit) {
      switch (unit) {
        case 'day':
          __callKey1(date, "setHours", 0);

          __callKey1(date, "setMinutes", 0);

        // falls through

        case 'minute':
          __callKey1(date, "setSeconds", 0);

          __callKey1(date, "setMilliseconds", 0);

          break;
      }

      return date;
    }

    function isDate(value) {
      return __callKey1(Object.prototype._ES5ProxyType ? Object.prototype.get("toString") : Object.prototype.toString, "call", value) === '[object Date]' && !isNaN(__callKey0(value, "getTime"));
    }

    function addTimezoneSuffix(value) {
      // first remove TZD if the string has one, and then add Z
      return __concat("", removeTimeZoneSuffix(value), "Z");
    }

    function addTimezoneOffset(date) {
      __callKey1(date, "setMinutes", __callKey0(date, "getMinutes") + __callKey0(date, "getTimezoneOffset"));

      return date;
    }

    function subtractTimezoneOffset(date) {
      __callKey1(date, "setMinutes", __callKey0(date, "getMinutes") - __callKey0(date, "getTimezoneOffset"));

      return date;
    }

    function getDate(value) {
      if (!value) {
        return null;
      }

      if (isDate(value)) {
        return new Date(__callKey0(value, "getTime"));
      }

      if (isFinite(value) && (typeof value === 'number' || typeof value === 'string')) {
        return new Date(parseInt(value, 10));
      }

      if (typeof value === 'string') {
        return parseDateTimeISO8601(value);
      }

      return null;
    }

    function pad(n) {
      return Number(n) < 10 ? __concat("0", n) : n;
    }

    function doublePad(n) {
      return Number(n) < 10 ? __concat("00", n) : Number(n) < 100 ? __concat("0", n) : n;
    }

    var localizationService = {
      formatDate: formatDate,
      formatDateUTC: formatDateUTC,
      formatTime: formatTime,
      formatDateTimeUTC: formatDateTimeUTC,
      parseDateTimeISO8601: parseDateTimeISO8601,
      parseDateTime: parseDateTime,
      parseDateTimeUTC: parseDateTimeUTC,
      isBefore: isBefore,
      isAfter: isAfter,
      UTCToWallTime: UTCToWallTime,
      WallTimeToUTC: WallTimeToUTC,
      translateToOtherCalendar: translateToOtherCalendar,
      translateFromOtherCalendar: translateFromOtherCalendar,
      translateToLocalizedDigits: translateToLocalizedDigits,
      translateFromLocalizedDigits: translateFromLocalizedDigits,
      getNumberFormat: getNumberFormat,
      duration: duration,
      displayDuration: displayDuration
    };

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    function getLocalizationService() {
      return localizationService;
    }

    function getPathPrefix() {
      return basePath;
    }

    function getToken() {
      return null;
    }

    function getIconSvgTemplates() {
      return null;
    }

    function getOneConfig() {
      return {
        densitySetting: ''
      };
    }

    var lightningConfigProvider = {
      getOneConfig: getOneConfig,
      getIconSvgTemplates: getIconSvgTemplates,
      getToken: getToken,
      getPathPrefix: getPathPrefix,
      getLocalizationService: getLocalizationService
    };

    var lightningConfigProvider$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': lightningConfigProvider,
        getOneConfig: getOneConfig,
        getIconSvgTemplates: getIconSvgTemplates,
        getToken: getToken,
        getPathPrefix: getPathPrefix,
        getLocalizationService: getLocalizationService
    });

    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */

    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function invariant$1(value, msg) {
      if (!value) {
        throw new Error(__concat("Invariant Violation: ", msg));
      }
    }

    function isTrue$2(value, msg) {
      if (!value) {
        throw new Error(__concat("Assert Violation: ", msg));
      }
    }

    function isFalse$2(value, msg) {
      if (value) {
        throw new Error(__concat("Assert Violation: ", msg));
      }
    }

    function fail$1(msg) {
      throw new Error(msg);
    }

    var assert$2 =
    /*#__PURE__*/
    Object.freeze({
      __proto__: null,
      invariant: invariant$1,
      isTrue: isTrue$2,
      isFalse: isFalse$2,
      fail: fail$1
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */

    var hasNativeSymbolsSupport$2 = __callKey0(Symbol('x'), "toString") === 'Symbol(x)';
    /** version: 1.1.13-224.5 */

    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // key in engine service context for wire service context

    var CONTEXT_ID = '@wire'; // key in wire service context for updated listener metadata

    var CONTEXT_UPDATED = 'updated'; // key in wire service context for connected listener metadata

    var CONTEXT_CONNECTED = 'connected'; // key in wire service context for disconnected listener metadata

    var CONTEXT_DISCONNECTED = 'disconnected'; // wire event target life cycle connectedCallback hook event type

    var CONNECT = 'connect'; // wire event target life cycle disconnectedCallback hook event type

    var DISCONNECT = 'disconnect'; // wire event target life cycle config changed hook event type

    var CONFIG = 'config';
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Detects property changes by installing setter/getter overrides on the component
     * instance.
     */

    /**
     * Invokes the provided change listeners with the resolved component properties.
     * @param configListenerMetadatas List of config listener metadata (config listeners and their context)
     * @param paramValues Values for all wire adapter config params
     */

    function invokeConfigListeners(configListenerMetadatas, paramValues) {
      __callKey1(configListenerMetadatas, "forEach", function (metadata) {
        var listener = metadata._ES5ProxyType ? metadata.get("listener") : metadata.listener,
            statics = metadata._ES5ProxyType ? metadata.get("statics") : metadata.statics,
            reactives = metadata._ES5ProxyType ? metadata.get("reactives") : metadata.reactives;
        var reactiveValues = Object.create(null);

        if (reactives) {
          var keys = Object.compatKeys(reactives);

          for (var j = 0, jlen = keys._ES5ProxyType ? keys.get("length") : keys.length; j < jlen; j++) {
            var _reactives$key, _reactives$key2;

            var key = keys._ES5ProxyType ? keys.get(j) : keys[j];
            var value = (_reactives$key = reactives._ES5ProxyType ? reactives.get(key) : reactives[key], _reactives$key2 = paramValues._ES5ProxyType ? paramValues.get(_reactives$key) : paramValues[_reactives$key]);

            __setKey(reactiveValues, key, value);
          }
        } // TODO [#1634]: consider read-only membrane to enforce invariant of immutable config


        var config = Object.compatAssign({}, statics, reactiveValues);

        __callKey2(listener, "call", undefined, config);
      });
    }
    /**
     * Marks a reactive parameter as having changed.
     * @param cmp The component
     * @param reactiveParameter Reactive parameter that has changed
     * @param configContext The service context
     */


    function updated(cmp, reactiveParameter, configContext) {
      if (!(configContext._ES5ProxyType ? configContext.get("mutated") : configContext.mutated)) {
        __setKey(configContext, "mutated", new Set()); // collect all prop changes via a microtask


        __callKey1(Promise.resolve(), "then", __callKey3(updatedFuture, "bind", undefined, cmp, configContext));
      }

      __callKey1(configContext._ES5ProxyType ? configContext.get("mutated") : configContext.mutated, "add", reactiveParameter);
    }

    function updatedFuture(cmp, configContext) {
      var uniqueListeners = new Set(); // configContext.mutated must be set prior to invoking this function

      var mutated = configContext._ES5ProxyType ? configContext.get("mutated") : configContext.mutated;

      __deleteKey(configContext, "mutated");

      __callKey1(mutated, "forEach", function (reactiveParameter) {
        var _values, _reactiveParameter$re, _reactiveParameter$re2, _listeners, _reactiveParameter$he, _reactiveParameter$he2;

        var value = getReactiveParameterValue(cmp, reactiveParameter);

        if ((_values = configContext._ES5ProxyType ? configContext.get("values") : configContext.values, _reactiveParameter$re = reactiveParameter._ES5ProxyType ? reactiveParameter.get("reference") : reactiveParameter.reference, _reactiveParameter$re2 = _values._ES5ProxyType ? _values.get(_reactiveParameter$re) : _values[_reactiveParameter$re]) === value) {
          return;
        }

        __setKey(configContext._ES5ProxyType ? configContext.get("values") : configContext.values, reactiveParameter._ES5ProxyType ? reactiveParameter.get("reference") : reactiveParameter.reference, value);

        var listeners = (_listeners = configContext._ES5ProxyType ? configContext.get("listeners") : configContext.listeners, _reactiveParameter$he = reactiveParameter._ES5ProxyType ? reactiveParameter.get("head") : reactiveParameter.head, _reactiveParameter$he2 = _listeners._ES5ProxyType ? _listeners.get(_reactiveParameter$he) : _listeners[_reactiveParameter$he]);

        for (var i = 0, len = listeners._ES5ProxyType ? listeners.get("length") : listeners.length; i < len; i++) {
          __callKey1(uniqueListeners, "add", listeners._ES5ProxyType ? listeners.get(i) : listeners[i]);
        }
      });

      invokeConfigListeners(uniqueListeners, configContext._ES5ProxyType ? configContext.get("values") : configContext.values);
    }
    /**
     * Gets the value of an @wire reactive parameter.
     * @param cmp The component
     * @param reactiveParameter The parameter to get
     */


    function getReactiveParameterValue(cmp, reactiveParameter) {
      var _reactiveParameter$he3, _reactiveParameter$he4;

      var value = (_reactiveParameter$he3 = reactiveParameter._ES5ProxyType ? reactiveParameter.get("head") : reactiveParameter.head, _reactiveParameter$he4 = cmp._ES5ProxyType ? cmp.get(_reactiveParameter$he3) : cmp[_reactiveParameter$he3]);

      if (!(reactiveParameter._ES5ProxyType ? reactiveParameter.get("tail") : reactiveParameter.tail)) {
        return value;
      }

      var segments = reactiveParameter._ES5ProxyType ? reactiveParameter.get("tail") : reactiveParameter.tail;

      for (var i = 0, len = segments._ES5ProxyType ? segments.get("length") : segments.length; i < len && value != null; i++) {
        var segment = segments._ES5ProxyType ? segments.get(i) : segments[i];

        if (_typeof(value) !== 'object' || !__inKey(value, segment)) {
          return undefined;
        }

        value = value._ES5ProxyType ? value.get(segment) : value[segment];
      }

      return value;
    }
    /**
     * Installs setter override to trap changes to a property, triggering the config listeners.
     * @param cmp The component
     * @param reactiveParameter Reactive parameter that defines the property to monitor
     * @param configContext The service context
     */


    function installTrap(cmp, reactiveParameter, configContext) {
      var callback = __callKey4(updated, "bind", undefined, cmp, reactiveParameter, configContext);

      var newDescriptor = getOverrideDescriptor(cmp, reactiveParameter._ES5ProxyType ? reactiveParameter.get("head") : reactiveParameter.head, callback);
      Object.compatDefineProperty(cmp, reactiveParameter._ES5ProxyType ? reactiveParameter.get("head") : reactiveParameter.head, newDescriptor);
    }
    /**
     * Finds the descriptor of the named property on the prototype chain
     * @param target The target instance/constructor function
     * @param propName Name of property to find
     * @param protoSet Prototypes searched (to avoid circular prototype chains)
     */


    function findDescriptor(target, propName, protoSet) {
      protoSet = protoSet || [];

      if (!target || __callKey1(protoSet, "indexOf", target) > -1) {
        return null; // null, undefined, or circular prototype definition
      }

      var descriptor = Object.compatGetOwnPropertyDescriptor(target, propName);

      if (descriptor) {
        return descriptor;
      }

      var proto = Object.getPrototypeOf(target);

      if (!proto) {
        return null;
      }

      protoSet.push(target);
      return findDescriptor(proto, propName, protoSet);
    }
    /**
     * Gets a property descriptor that monitors the provided property for changes
     * @param cmp The component
     * @param prop The name of the property to be monitored
     * @param callback A function to invoke when the prop's value changes
     * @return A property descriptor
     */


    function getOverrideDescriptor(cmp, prop, callback) {
      var descriptor = findDescriptor(cmp, prop);
      var enumerable;
      var get;
      var set; // This does not cover the override of existing descriptors at the instance level
      // and that's ok because eventually we will not need to do any of these :)

      if (descriptor === null || (descriptor._ES5ProxyType ? descriptor.get("get") : descriptor.get) === undefined && (descriptor._ES5ProxyType ? descriptor.get("set") : descriptor.set) === undefined) {
        var value = cmp._ES5ProxyType ? cmp.get(prop) : cmp[prop];
        enumerable = true;

        get = function get() {
          return value;
        };

        set = function set(newValue) {
          value = newValue;
          callback();
        };
      } else {
        var originalSet = descriptor._ES5ProxyType ? descriptor.get("set") : descriptor.set,
            originalGet = descriptor._ES5ProxyType ? descriptor.get("get") : descriptor.get;
        enumerable = descriptor._ES5ProxyType ? descriptor.get("enumerable") : descriptor.enumerable;

        set = function set(newValue) {
          if (originalSet) {
            __callKey2(originalSet, "call", cmp, newValue);
          }

          callback();
        };

        get = function get() {
          return originalGet ? __callKey1(originalGet, "call", cmp) : undefined;
        };
      }

      return {
        set: set,
        get: get,
        enumerable: enumerable,
        configurable: true
      };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var ValueChangedEventType = 'ValueChangedEvent';
    /**
     * Event fired by wire adapters to emit a new value.
     */

    var ValueChangedEvent = function ValueChangedEvent(value) {
      _classCallCheck(this, ValueChangedEvent);

      __setKey(this, "type", ValueChangedEventType);

      __setKey(this, "value", value);
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var LinkContextEventType = 'LinkContextEvent';
    /**
     * Event fired by wire adapters to link to a context provider
     */

    var LinkContextEvent = function LinkContextEvent(uid, callback) {
      _classCallCheck(this, LinkContextEvent);

      __setKey(this, "type", LinkContextEventType);

      __setKey(this, "uid", uid);

      __setKey(this, "callback", callback);
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    function removeListener(listeners, toRemove) {
      var idx = __callKey1(listeners, "indexOf", toRemove);

      if (idx > -1) {
        listeners.splice(idx, 1);
      }
    }

    function removeConfigListener(configListenerMetadatas, toRemove) {
      for (var i = 0, len = configListenerMetadatas._ES5ProxyType ? configListenerMetadatas.get("length") : configListenerMetadatas.length; i < len; i++) {
        var _i, _listener;

        if ((_i = configListenerMetadatas._ES5ProxyType ? configListenerMetadatas.get(i) : configListenerMetadatas[i], _listener = _i._ES5ProxyType ? _i.get("listener") : _i.listener) === toRemove) {
          configListenerMetadatas.splice(i, 1);
          return;
        }
      }
    }

    function buildReactiveParameter(reference) {
      if (!__callKey1(reference, "includes", '.')) {
        return {
          reference: reference,
          head: reference
        };
      }

      var segments = __callKey1(reference, "split", '.');

      return {
        reference: reference,
        head: segments.shift(),
        tail: segments
      };
    }

    var WireEventTarget =
    /*#__PURE__*/
    function () {
      function WireEventTarget(cmp, def, context, wireDef, wireTarget) {
        _classCallCheck(this, WireEventTarget);

        __setKey(this, "_cmp", cmp);

        __setKey(this, "_def", def);

        __setKey(this, "_context", context);

        __setKey(this, "_wireDef", wireDef);

        __setKey(this, "_wireTarget", wireTarget);
      }

      _createClass(WireEventTarget, [{
        key: "addEventListener",
        value: function addEventListener(type, listener) {
          var _this = this;

          switch (type) {
            case CONNECT:
              {
                var _context, _CONTEXT_ID, _CONTEXT_CONNECTED;

                var connectedListeners = (_context = this._ES5ProxyType ? this.get("_context") : this._context, _CONTEXT_ID = _context._ES5ProxyType ? _context.get(CONTEXT_ID) : _context[CONTEXT_ID], _CONTEXT_CONNECTED = _CONTEXT_ID._ES5ProxyType ? _CONTEXT_ID.get(CONTEXT_CONNECTED) : _CONTEXT_ID[CONTEXT_CONNECTED]);

                {
                  __callKey2(assert$2, "isFalse", __callKey1(connectedListeners, "includes", listener), 'must not call addEventListener("connect") with the same listener');
                }

                connectedListeners.push(listener);
                break;
              }

            case DISCONNECT:
              {
                var _context2, _CONTEXT_ID2, _CONTEXT_DISCONNECTED;

                var disconnectedListeners = (_context2 = this._ES5ProxyType ? this.get("_context") : this._context, _CONTEXT_ID2 = _context2._ES5ProxyType ? _context2.get(CONTEXT_ID) : _context2[CONTEXT_ID], _CONTEXT_DISCONNECTED = _CONTEXT_ID2._ES5ProxyType ? _CONTEXT_ID2.get(CONTEXT_DISCONNECTED) : _CONTEXT_ID2[CONTEXT_DISCONNECTED]);

                {
                  __callKey2(assert$2, "isFalse", __callKey1(disconnectedListeners, "includes", listener), 'must not call addEventListener("disconnect") with the same listener');
                }

                disconnectedListeners.push(listener);
                break;
              }

            case CONFIG:
              {
                var _wireDef, _params, _wireDef2, _static, _reactiveKeys, _length, _context3, _CONTEXT_ID3, _CONTEXT_UPDATED;

                var reactives = (_wireDef = this._ES5ProxyType ? this.get("_wireDef") : this._wireDef, _params = _wireDef._ES5ProxyType ? _wireDef.get("params") : _wireDef.params);
                var statics = (_wireDef2 = this._ES5ProxyType ? this.get("_wireDef") : this._wireDef, _static = _wireDef2._ES5ProxyType ? _wireDef2.get("static") : _wireDef2.static);
                var reactiveKeys; // no reactive parameters. fire config once with static parameters (if present).

                if (!reactives || (_reactiveKeys = reactiveKeys = Object.compatKeys(reactives), _length = _reactiveKeys._ES5ProxyType ? _reactiveKeys.get("length") : _reactiveKeys.length) === 0) {
                  var config = statics || Object.create(null);

                  __callKey2(listener, "call", undefined, config);

                  return;
                }

                var configListenerMetadata = {
                  listener: listener,
                  statics: statics,
                  reactives: reactives
                }; // setup listeners for all reactive parameters

                var configContext = (_context3 = this._ES5ProxyType ? this.get("_context") : this._context, _CONTEXT_ID3 = _context3._ES5ProxyType ? _context3.get(CONTEXT_ID) : _context3[CONTEXT_ID], _CONTEXT_UPDATED = _CONTEXT_ID3._ES5ProxyType ? _CONTEXT_ID3.get(CONTEXT_UPDATED) : _CONTEXT_ID3[CONTEXT_UPDATED]);

                __callKey1(reactiveKeys, "forEach", function (key) {
                  var _listeners2, _reactiveParameter$he5, _reactiveParameter$he6;

                  var reactiveParameter = buildReactiveParameter(reactives._ES5ProxyType ? reactives.get(key) : reactives[key]);
                  var configListenerMetadatas = (_listeners2 = configContext._ES5ProxyType ? configContext.get("listeners") : configContext.listeners, _reactiveParameter$he5 = reactiveParameter._ES5ProxyType ? reactiveParameter.get("head") : reactiveParameter.head, _reactiveParameter$he6 = _listeners2._ES5ProxyType ? _listeners2.get(_reactiveParameter$he5) : _listeners2[_reactiveParameter$he5]);

                  if (!configListenerMetadatas) {
                    configListenerMetadatas = [configListenerMetadata];

                    __setKey(configContext._ES5ProxyType ? configContext.get("listeners") : configContext.listeners, reactiveParameter._ES5ProxyType ? reactiveParameter.get("head") : reactiveParameter.head, configListenerMetadatas);

                    installTrap(_this._ES5ProxyType ? _this.get("_cmp") : _this._cmp, reactiveParameter, configContext);
                  } else {
                    configListenerMetadatas.push(configListenerMetadata);
                  } // enqueue to pickup default values


                  updated(_this._ES5ProxyType ? _this.get("_cmp") : _this._cmp, reactiveParameter, configContext);
                });

                break;
              }

            default:
              throw new Error(__concat("unsupported event type ", type));
          }
        }
      }, {
        key: "removeEventListener",
        value: function removeEventListener(type, listener) {
          switch (type) {
            case CONNECT:
              {
                var _context4, _CONTEXT_ID4, _CONTEXT_CONNECTED2;

                var connectedListeners = (_context4 = this._ES5ProxyType ? this.get("_context") : this._context, _CONTEXT_ID4 = _context4._ES5ProxyType ? _context4.get(CONTEXT_ID) : _context4[CONTEXT_ID], _CONTEXT_CONNECTED2 = _CONTEXT_ID4._ES5ProxyType ? _CONTEXT_ID4.get(CONTEXT_CONNECTED) : _CONTEXT_ID4[CONTEXT_CONNECTED]);
                removeListener(connectedListeners, listener);
                break;
              }

            case DISCONNECT:
              {
                var _context5, _CONTEXT_ID5, _CONTEXT_DISCONNECTED2;

                var disconnectedListeners = (_context5 = this._ES5ProxyType ? this.get("_context") : this._context, _CONTEXT_ID5 = _context5._ES5ProxyType ? _context5.get(CONTEXT_ID) : _context5[CONTEXT_ID], _CONTEXT_DISCONNECTED2 = _CONTEXT_ID5._ES5ProxyType ? _CONTEXT_ID5.get(CONTEXT_DISCONNECTED) : _CONTEXT_ID5[CONTEXT_DISCONNECTED]);
                removeListener(disconnectedListeners, listener);
                break;
              }

            case CONFIG:
              {
                var _context6, _CONTEXT_ID6, _CONTEXT_UPDATED2, _listeners3, _wireDef3, _params2;

                var paramToConfigListenerMetadata = (_context6 = this._ES5ProxyType ? this.get("_context") : this._context, _CONTEXT_ID6 = _context6._ES5ProxyType ? _context6.get(CONTEXT_ID) : _context6[CONTEXT_ID], _CONTEXT_UPDATED2 = _CONTEXT_ID6._ES5ProxyType ? _CONTEXT_ID6.get(CONTEXT_UPDATED) : _CONTEXT_ID6[CONTEXT_UPDATED], _listeners3 = _CONTEXT_UPDATED2._ES5ProxyType ? _CONTEXT_UPDATED2.get("listeners") : _CONTEXT_UPDATED2.listeners);
                var reactives = (_wireDef3 = this._ES5ProxyType ? this.get("_wireDef") : this._wireDef, _params2 = _wireDef3._ES5ProxyType ? _wireDef3.get("params") : _wireDef3.params);

                if (reactives) {
                  __callKey1(Object.compatKeys(reactives), "forEach", function (key) {
                    var _reactiveParameter$he7, _reactiveParameter$he8;

                    var reactiveParameter = buildReactiveParameter(reactives._ES5ProxyType ? reactives.get(key) : reactives[key]);
                    var configListenerMetadatas = (_reactiveParameter$he7 = reactiveParameter._ES5ProxyType ? reactiveParameter.get("head") : reactiveParameter.head, _reactiveParameter$he8 = paramToConfigListenerMetadata._ES5ProxyType ? paramToConfigListenerMetadata.get(_reactiveParameter$he7) : paramToConfigListenerMetadata[_reactiveParameter$he7]);

                    if (configListenerMetadatas) {
                      removeConfigListener(configListenerMetadatas, listener);
                    }
                  });
                }

                break;
              }

            default:
              throw new Error(__concat("unsupported event type ", type));
          }
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(evt) {
          if (_instanceof(evt, ValueChangedEvent)) {
            var _wireDef4, _method;

            var value = evt._ES5ProxyType ? evt.get("value") : evt.value;

            if (_wireDef4 = this._ES5ProxyType ? this.get("_wireDef") : this._wireDef, _method = _wireDef4._ES5ProxyType ? _wireDef4.get("method") : _wireDef4.method) {
              __callKey1(this._ES5ProxyType ? this.get("_cmp") : this._cmp, this._ES5ProxyType ? this.get("_wireTarget") : this._wireTarget, value);
            } else {
              __setKey(this._ES5ProxyType ? this.get("_cmp") : this._cmp, this._ES5ProxyType ? this.get("_wireTarget") : this._wireTarget, value);
            }

            return false; // canceling signal since we don't want this to propagate
          } else if (_instanceof(evt, LinkContextEvent)) {
            var uid = evt._ES5ProxyType ? evt.get("uid") : evt.uid,
                callback = evt._ES5ProxyType ? evt.get("callback") : evt.callback; // This event is responsible for connecting the host element with another
            // element in the composed path that is providing contextual data. The provider
            // must be listening for a special dom event with the name corresponding to `uid`,
            // which must remain secret, to guarantee that the linkage is only possible via
            // the corresponding wire adapter.

            var internalDomEvent = new CustomEvent(uid, {
              bubbles: true,
              composed: true,
              // avoid leaking the callback function directly to prevent a side channel
              // during the linking phase to the context provider.
              detail: function detail() {
                __callKey2(callback, "apply", void 0, arguments);
              }
            });

            __callKey1(this._ES5ProxyType ? this.get("_cmp") : this._cmp, "dispatchEvent", internalDomEvent);

            return false; // canceling signal since we don't want this to propagate
          } else if ((evt._ES5ProxyType ? evt.get("type") : evt.type) === 'WireContextEvent' || (evt._ES5ProxyType ? evt.get("type") : evt.type) === 'wirecontextevent') {
            // TODO [#1357]: remove this branch
            return __callKey1(this._ES5ProxyType ? this.get("_cmp") : this._cmp, "dispatchEvent", evt);
          } else {
            throw new Error(__concat("Invalid event ", evt, "."));
          }
        }
      }]);

      return WireEventTarget;
    }();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // wire adapters: wire adapter id => adapter ctor


    var adapterFactories = new Map();
    /**
     * Invokes the specified callbacks.
     * @param listeners functions to call
     */

    function invokeListener(listeners) {
      for (var i = 0, len = listeners._ES5ProxyType ? listeners.get("length") : listeners.length; i < len; ++i) {
        __callKey1(listeners._ES5ProxyType ? listeners.get(i) : listeners[i], "call", undefined);
      }
    }
    /**
     * The wire service.
     *
     * This service is registered with the engine's service API. It connects service
     * callbacks to wire adapter lifecycle events.
     */


    var wireService = {
      wiring: function wiring(cmp, data, def, context) {
        var wireContext = __setKey(context, CONTEXT_ID, Object.create(null));

        __setKey(wireContext, CONTEXT_CONNECTED, []);

        __setKey(wireContext, CONTEXT_DISCONNECTED, []);

        __setKey(wireContext, CONTEXT_UPDATED, {
          listeners: {},
          values: {}
        }); // engine guarantees invocation only if def.wire is defined


        var wireStaticDef = def._ES5ProxyType ? def.get("wire") : def.wire;
        var wireTargets = Object.compatKeys(wireStaticDef);

        var _loop = function _loop(i, len) {
          var wireTarget = wireTargets._ES5ProxyType ? wireTargets.get(i) : wireTargets[i];
          var wireDef = wireStaticDef._ES5ProxyType ? wireStaticDef.get(wireTarget) : wireStaticDef[wireTarget];

          var adapterFactory = __callKey1(adapterFactories, "get", wireDef._ES5ProxyType ? wireDef.get("adapter") : wireDef.adapter);

          {
            __callKey2(assert$2, "isTrue", wireDef._ES5ProxyType ? wireDef.get("adapter") : wireDef.adapter, __concat("@wire on \"", wireTarget, "\": adapter id must be truthy"));

            __callKey2(assert$2, "isTrue", adapterFactory, __concat(__concat("@wire on \"", wireTarget, "\": unknown adapter id: "), String(wireDef._ES5ProxyType ? wireDef.get("adapter") : wireDef.adapter))); // enforce restrictions of reactive parameters


            if (wireDef._ES5ProxyType ? wireDef.get("params") : wireDef.params) {
              __callKey1(Object.compatKeys(wireDef._ES5ProxyType ? wireDef.get("params") : wireDef.params), "forEach", function (param) {
                var _params3, _param;

                var prop = (_params3 = wireDef._ES5ProxyType ? wireDef.get("params") : wireDef.params, _param = _params3._ES5ProxyType ? _params3.get(param) : _params3[param]);

                var segments = __callKey1(prop, "split", '.');

                __callKey1(segments, "forEach", function (segment) {
                  __callKey2(assert$2, "isTrue", (segment._ES5ProxyType ? segment.get("length") : segment.length) > 0, __concat("@wire on \"", wireTarget, "\": reactive parameters must not be empty"));
                });

                __callKey2(assert$2, "isTrue", (segments._ES5ProxyType ? segments.get(0) : segments[0]) !== wireTarget, __concat(__concat("@wire on \"", wireTarget, "\": reactive parameter \""), segments._ES5ProxyType ? segments.get(0) : segments[0], "\" must not refer to self")); // restriction for dot-notation reactive parameters


                if ((segments._ES5ProxyType ? segments.get("length") : segments.length) > 1) {
                  var _segments$, _segments$2, _method2;

                  // @wire emits a stream of immutable values. an emit sets the target property; it does not mutate a previously emitted value.
                  // restricting dot-notation reactive parameters to reference other @wire targets makes trapping the 'head' of the parameter
                  // sufficient to observe the value change.
                  __callKey2(assert$2, "isTrue", __callKey1(wireTargets, "includes", segments._ES5ProxyType ? segments.get(0) : segments[0]) && (_segments$ = segments._ES5ProxyType ? segments.get(0) : segments[0], _segments$2 = wireStaticDef._ES5ProxyType ? wireStaticDef.get(_segments$) : wireStaticDef[_segments$], _method2 = _segments$2._ES5ProxyType ? _segments$2.get("method") : _segments$2.method) !== 1, __concat(__concat("@wire on \"", wireTarget, "\": dot-notation reactive parameter \""), prop, "\" must refer to a @wire property"));
                }
              });
            }
          }

          if (adapterFactory) {
            var wireEventTarget = new WireEventTarget(cmp, def, context, wireDef, wireTarget);
            adapterFactory({
              dispatchEvent: __callKey1(wireEventTarget._ES5ProxyType ? wireEventTarget.get("dispatchEvent") : wireEventTarget.dispatchEvent, "bind", wireEventTarget),
              addEventListener: __callKey1(wireEventTarget._ES5ProxyType ? wireEventTarget.get("addEventListener") : wireEventTarget.addEventListener, "bind", wireEventTarget),
              removeEventListener: __callKey1(wireEventTarget._ES5ProxyType ? wireEventTarget.get("removeEventListener") : wireEventTarget.removeEventListener, "bind", wireEventTarget)
            });
          }
        };

        for (var i = 0, len = wireTargets._ES5ProxyType ? wireTargets.get("length") : wireTargets.length; i < len; i++) {
          _loop(i);
        }
      },
      connected: function connected(cmp, data, def, context) {
        var _CONTEXT_ID7, _CONTEXT_CONNECTED3;

        var listeners;

        {
          __callKey2(assert$2, "isTrue", !(def._ES5ProxyType ? def.get("wire") : def.wire) || (context._ES5ProxyType ? context.get(CONTEXT_ID) : context[CONTEXT_ID]), 'wire service was not initialized prior to component creation:  "connected" service hook invoked without necessary context');
        }

        if (!(def._ES5ProxyType ? def.get("wire") : def.wire) || !(listeners = (_CONTEXT_ID7 = context._ES5ProxyType ? context.get(CONTEXT_ID) : context[CONTEXT_ID], _CONTEXT_CONNECTED3 = _CONTEXT_ID7._ES5ProxyType ? _CONTEXT_ID7.get(CONTEXT_CONNECTED) : _CONTEXT_ID7[CONTEXT_CONNECTED]))) {
          return;
        }

        invokeListener(listeners);
      },
      disconnected: function disconnected(cmp, data, def, context) {
        var _CONTEXT_ID8, _CONTEXT_DISCONNECTED3;

        var listeners;

        {
          __callKey2(assert$2, "isTrue", !(def._ES5ProxyType ? def.get("wire") : def.wire) || (context._ES5ProxyType ? context.get(CONTEXT_ID) : context[CONTEXT_ID]), 'wire service was not initialized prior to component creation:  "disconnected" service hook invoked without necessary context');
        }

        if (!(def._ES5ProxyType ? def.get("wire") : def.wire) || !(listeners = (_CONTEXT_ID8 = context._ES5ProxyType ? context.get(CONTEXT_ID) : context[CONTEXT_ID], _CONTEXT_DISCONNECTED3 = _CONTEXT_ID8._ES5ProxyType ? _CONTEXT_ID8.get(CONTEXT_DISCONNECTED) : _CONTEXT_ID8[CONTEXT_DISCONNECTED]))) {
          return;
        }

        invokeListener(listeners);
      }
    };
    /**
     * Registers the wire service.
     */

    function registerWireService(registerService) {
      registerService(wireService);
    }
    /**
     * Registers a wire adapter.
     */


    function register$1(adapterId, adapterFactory) {
      {
        __callKey2(assert$2, "isTrue", adapterId, 'adapter id must be truthy');

        __callKey2(assert$2, "isTrue", typeof adapterFactory === 'function', 'adapter factory must be a callable');
      }

      __callKey2(adapterFactories, "set", adapterId, adapterFactory);
    }
    /** version: 1.1.13-224.5 */

    var wireService$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        LinkContextEvent: LinkContextEvent,
        ValueChangedEvent: ValueChangedEvent,
        register: register$1,
        registerWireService: registerWireService
    });

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * Creates a filter chain as an array. Filters can return true, false or a Promise resulting in true or false.
     *
     * @returns {object}
     */
    function createFilterChain() {
      // The filter array.
      var filters = []; // Return true if this chain contains no filters.

      var empty = function empty() {
        return (filters._ES5ProxyType ? filters.get("length") : filters.length) === 0;
      };

      var addSingle = function addSingle(filter) {
        if (typeof filter === 'function') {
          filters.push(filter);
        }
      }; // Add a filter or array of filters to the chain.


      var add = function add() {
        var f = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        if (Array.compatIsArray(f)) {
          __callKey1(f, "forEach", function (l) {
            return addSingle(l);
          });
        } else {
          addSingle(f);
        }
      }; // Get the Promised results for all filters.


      var compile = function compile() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          __setKey(args, _key, arguments[_key]);
        }

        // Call all the functions with the given arguments.
        // Return Promise<true> if there are no filters.
        return (filters._ES5ProxyType ? filters.get("length") : filters.length) === 0 ? Promise.resolve(true) : // Reduce the listener array down to a single value:
        //      any false -> false
        //      all truthy -> true
        // Previous is a Promise and current is a function.
        __callKey1(__callKey1(__callKey2(filters, "reduce", function (previous, current) {
          // Chain the current to the previous listener function; reject false values.
          // Remember that previous is a Promise and current is a functions.
          return __callKey1(previous, "then", function (val) {
            return val === false ? Promise.reject() : Promise.resolve(__callKey2(current, "apply", void 0, args));
          }); // Start optimistically with TRUE.
        }, Promise.resolve(true)) // Handle any trailing false values
        // This happens when the last listener returns a Promise that resolves to false
        , "then", function (val) {
          return val === false ? false : true;
        }) // If caught promise rejection contains an Error, throw instead of resolving to false
        , "catch", function (error) {
          if (_instanceof(error, Error)) {
            throw error;
          } else {
            return false;
          }
        });
      }; // Return the API methods.


      return {
        add: add,
        compile: compile,
        empty: empty
      };
    }

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Manipulates the browser history on the window.
     * Ths just uses the window.history functionality directly.
     */

    /**
     * Sets a history state.

     * @param {string} path - query to set
     * @param {object} route - history state object
     */
    function set(path) {
      var route = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      __callKey3(window._ES5ProxyType ? window.get("history") : window.history, "pushState", route, null, path);
    }
    /**
     * Replaces the current history state.
     * @param {string} path - query to use as a replacement
     * @param {object} route - history state object
     */

    function replace(path) {
      var route = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      __callKey3(window._ES5ProxyType ? window.get("history") : window.history, "replaceState", route, null, path);
    }

    function _objectSpread$2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$2(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$2(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }
    /** @hidden */

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var DiagnosticLevel = {
      Fatal: 0,
      Error: 1,
      Warning: 2,
      Log: 3
    };

    function replaceArgs(message, args) {
      return Array.compatIsArray(args) ? __callKey2(message, "replace", /\{([0-9]+)\}/g, function (_, index) {
        return args._ES5ProxyType ? args.get(index) : args[index];
      }) : message;
    }

    function generateMessage(info, args) {
      return __concat(__concat("LWR", info._ES5ProxyType ? info.get("code") : info.code, ": "), replaceArgs(info._ES5ProxyType ? info.get("message") : info.message, args));
    }
    function generateMessageObject(info, args) {
      return _objectSpread$2({}, info, {
        code: __concat("LWR", info._ES5ProxyType ? info.get("code") : info.code),
        message: replaceArgs(info._ES5ProxyType ? info.get("message") : info.message, args)
      });
    }
    function invariant$2(condition, errorInfo, args) {
      if (!condition) {
        throw new Error(generateMessage(errorInfo, args));
      }
    }
    var messages = {
      INVALID_MIXIN_CMP: {
        code: 4001,
        message: '{0} must be an Element type',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      MISSING_CONTEXT: {
        code: 4002,
        message: 'Could not find context to perform navigation action.',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      INVALID_CONTEXT: {
        code: 4003,
        message: 'Cannot register navigation context; it must have this shape: { navigate, generateUrl, subscribe }',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      MULTIPLE_ROOTS: {
        code: 4004,
        message: 'Router connection failed. There can only be one root router.',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      MULTIPLE_CHILDREN: {
        code: 4005,
        message: 'Could not add to the navigation hierarchy. There can only be one child per navigation node.',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      MISSING_ROUTE: {
        code: 4006,
        message: 'A route cannot be created to navigate to URL "{0}"',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      MISSING_URL: {
        code: 4007,
        message: 'A URL cannot be created to navigate to route "{0}"',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      PRENAV_FAILED: {
        code: 4008,
        message: 'A preNavigate hook listener blocked routing to "{0}"',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Warning") : DiagnosticLevel.Warning,
        url: ''
      },
      MISSING_PATH: {
        code: 4009,
        message: 'A route definition must contain a "path" property.',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      MISSING_ROUTE_CMP: {
        code: 4016,
        message: 'Expected a route view component with a default export.',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      },
      MISSING_DATA_CONTEXT: {
        code: 4018,
        message: 'Could not find context to retrieve navigation data.',
        level: DiagnosticLevel._ES5ProxyType ? DiagnosticLevel.get("Error") : DiagnosticLevel.Error,
        url: ''
      }
    };

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /**
     * Creates a simple observable object, which can have any number of observers.
     *
     * @returns {object}
     */
    function createObservable() {
      // Keep track of the current value and error.
      var currentValues = [];
      var currentError = null; // Observer list with functions to add and remove members safely.

      var observers = [];

      var addObserver = function addObserver(obs) {
        return observers.push(obs);
      };

      var removeObserver = function removeObserver(obsIndex) {
        __setKey(observers, obsIndex, null);
      }; // On next, broadcast the value to all observers.
      // Clear out current error.


      var next = function next() {
        for (var _len = arguments.length, value = new Array(_len), _key = 0; _key < _len; _key++) {
          __setKey(value, _key, arguments[_key]);
        }

        __callKey1(__callKey1(observers, "filter", function (obs) {
          return obs !== null;
        }), "forEach", function (obs) {
          return (obs._ES5ProxyType ? obs.get("next") : obs.next) && __callKey2(obs._ES5ProxyType ? obs.get("next") : obs.next, "apply", obs, value);
        });

        currentValues = value;
        currentError = null;
      }; // On error, broadcast the error to all observers.
      // Clear out current value.


      var error = function error(err) {
        __callKey1(__callKey1(observers, "filter", function (obs) {
          return obs !== null;
        }), "forEach", function (obs) {
          return (obs._ES5ProxyType ? obs.get("error") : obs.error) && __callKey1(obs, "error", err);
        });

        currentValues = [];
        currentError = err;
      }; // On complete, call complete on all observers.
      // Clear out all observers + current value and error.


      var complete = function complete() {
        __callKey1(__callKey1(observers, "filter", function (obs) {
          return obs !== null;
        }), "forEach", function (obs) {
          return (obs._ES5ProxyType ? obs.get("complete") : obs.complete) && __callKey0(obs, "complete");
        });

        observers = [];
        currentValues = [];
        currentError = null;
      }; // Observable can be subscribed and unsubscribed, by multiple observers.


      var subscribe = function subscribe(obs) {
        var replay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        addObserver(obs); // Push the current value and error, if they exist.

        if ((obs._ES5ProxyType ? obs.get("next") : obs.next) && (currentValues._ES5ProxyType ? currentValues.get("length") : currentValues.length) && replay) {
          __callKey2(obs._ES5ProxyType ? obs.get("next") : obs.next, "apply", obs, _toConsumableArray(currentValues));
        }

        if (currentError) {
          error(currentError);
        } // On unsubscribe, the observer is nulled out.


        var obsIndex = (observers._ES5ProxyType ? observers.get("length") : observers.length) - 1;
        return {
          unsubscribe: function unsubscribe() {
            return removeObserver(obsIndex);
          }
        };
      }; // Return the observation methods + the associated observable.


      return {
        next: next,
        error: error,
        complete: complete,
        subscribe: subscribe
      };
    }

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Utilities for parsing URLs.
     * Definitions:
     *      - URL: absolute "http://www.somewhere.com/some/path?with=params&more=params" or relative "/some/path?with=params&more=params"
     *      - path: A URL's pathname: "/some/path"
     *      - query: A URL's search parameters: "?with=params&more=params"
     */

    /**
     * helper: f(url) -> new URL
     * Query parameter values are URI decoded.

     * @param {string} url - URL string to turn into a URL object

     * @returns {object} { href, pathname, searchParams }
     
     * @example 
     * {
     *      href: 'http://localhost:3001/products?lwr.mode=prod&lwr.locale=es#section',
     *      origin: 'http://localhost:3001',
     *      pathname: '/products',
     *      searchParams: {
     *          'lwr.mode': 'prod',
     *          'lwr.locale': 'es'
     *      }
     * }
     */
    function getUrlObject() {
      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      // Ensure this is a full URL.
      url = url || '';

      if (__callKey1(url, "indexOf", '://') < 0) {
        var _location, _port, _location2, _port2, _location3, _protocol, _location4, _hostname;

        // get the current port string (or empty)
        var port = (_location = window._ES5ProxyType ? window.get("location") : window.location, _port = _location._ES5ProxyType ? _location.get("port") : _location.port) ? __concat(":", (_location2 = window._ES5ProxyType ? window.get("location") : window.location, _port2 = _location2._ES5ProxyType ? _location2.get("port") : _location2.port)) : ''; // construct the new base url using the original protocol, hostname, and port

        var origin = __concat(__concat(__concat("", (_location3 = window._ES5ProxyType ? window.get("location") : window.location, _protocol = _location3._ES5ProxyType ? _location3.get("protocol") : _location3.protocol), "//"), (_location4 = window._ES5ProxyType ? window.get("location") : window.location, _hostname = _location4._ES5ProxyType ? _location4.get("hostname") : _location4.hostname)), port); // does the path start with a slash? If so do nothing


        var prefix = __callKey1(url, "charAt", 0) === '/' ? '' : '/'; // construct the final URL

        url = origin + prefix + url;
      } // Parse the URL using an anchor.


      var searchParams = {};

      var link = __callKey1(document, "createElement", 'a');

      __setKey(link, "href", url); // Pull the search params out of the search query string.


      var queryStr = __callKey1(link._ES5ProxyType ? link.get("search") : link.search, "substring", 1);

      if (queryStr) {
        __callKey1(__callKey1(queryStr, "split", '&'), "forEach", function (pair) {
          var _pair$split = __callKey1(pair, "split", '='),
              _pair$split2 = _slicedToArray(_pair$split, 2),
              key = _pair$split2._ES5ProxyType ? _pair$split2.get(0) : _pair$split2[0],
              _pair$split2$ = _pair$split2._ES5ProxyType ? _pair$split2.get(1) : _pair$split2[1],
              value = _pair$split2$ === void 0 ? '' : _pair$split2$;

          __setKey(searchParams, decode(key), decode(value));
        });
      }

      return {
        href: link._ES5ProxyType ? link.get("href") : link.href,
        origin: __concat(__concat(__concat("", link._ES5ProxyType ? link.get("protocol") : link.protocol, "//"), link._ES5ProxyType ? link.get("hostname") : link.hostname), (link._ES5ProxyType ? link.get("port") : link.port) ? __concat(":", link._ES5ProxyType ? link.get("port") : link.port) : ''),
        pathname: __callKey2(link._ES5ProxyType ? link.get("pathname") : link.pathname, "replace", /(\/)?/, '/'),
        // ensure there is a leading slash (IE11)
        searchParams: searchParams
      };
    }
    /**
     * f(url) -> "/some/relative/path?param1=one&param2=two&param3"

     * @param {string} url - URL string to make relative, may be a no-op

     * @return {string}
     */

    function getRelativeUrl(url) {
      var urlObj = getUrlObject(url); // Remove port number from both href and origin before doing string replace.
      // The port number gets included on the origin in IE11 with https but not
      // href which breaks the string replace.

      var href = __callKey2(urlObj._ES5ProxyType ? urlObj.get("href") : urlObj.href, "replace", /:\d+/, '');

      var origin = __callKey2(urlObj._ES5ProxyType ? urlObj.get("origin") : urlObj.origin, "replace", /:\d+/, '');

      return __callKey2(href, "replace", origin, '');
    }
    /**
     * f(url) -> "/some/relative/path"
     *
     * @param   {string} url - URL string to parse for a path
     *
     * @returns {string}
     */

    function getPathFromUrl(url) {
      var _getUrlObject, _pathname;

      var path = (_getUrlObject = getUrlObject(url), _pathname = _getUrlObject._ES5ProxyType ? _getUrlObject.get("pathname") : _getUrlObject.pathname); // Remove trailing slash.

      return path === '/' ? '/' : __callKey2(path, "replace", /\/$/, '');
    }
    /**
     * f(url) -> { "param1": "one", "param2": "two", param3: "" }
     * Parameters without values get set to an empty string.
     *
     * @param {string} url - URL string to parse for a query object
     *
     * @returns {object}
     */

    function getQueryFromUrl(url) {
      var _getUrlObject2, _searchParams;

      return _getUrlObject2 = getUrlObject(url), _searchParams = _getUrlObject2._ES5ProxyType ? _getUrlObject2.get("searchParams") : _getUrlObject2.searchParams;
    }
    /**
     * f({ "param1": "one", "param2": "two", param3: "" }) -> "?param1=one&param2=two&param3"
     * Query parameter values, but not keys, get URI encoded.
     *
     * @param {object} queryObject - Query object to turn into a string
     *
     * @returns {string}
     */

    function getQueryString() {
      var queryObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var keys = Object.compatKeys(queryObj);
      return (keys._ES5ProxyType ? keys.get("length") : keys.length // handle params without values here
      ) ? __concat("?", __callKey1(__callKey1(keys, "map", function (key) {
        return (queryObj._ES5ProxyType ? queryObj.get(key) : queryObj[key]) ? __concat(__concat("", key, "="), encode(queryObj._ES5ProxyType ? queryObj.get(key) : queryObj[key])) : key;
      }), "join", '&')) : '';
    }
    /**
     * f("one two &") -> "one+two+%26"
     *
     * @param   {string} str - String to URI encode, replace spaces with +
     *
     * @returns {string}
     */

    function encode() {
      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      str = str || '';
      return __callKey2(encodeURIComponent(str), "replace", /%20/g, '+');
    }
    /**
     * f("one+two+%26") -> "one two &"
     *
     * @param {string} str - String to URI decode, + is a space
     *
     * @returns {string}
     */

    function decode() {
      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      str = str || '';
      return decodeURIComponent(__callKey2(str, "replace", /\+/g, ' '));
    }

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    /*
     * Utilities for checking type, including route types.
     */

    /**
     * f(any) -> true/false
     *
     * @param {*} o - Item to check if it's an object
     *
     * @returns {boolean}
     */
    function isObject$4(o) {
      return _typeof(o) === 'object' && o !== null && !Array.compatIsArray(o);
    }
    /**
     * f(any) -> void
     *
     * @param {*} o - Object to freeze 2 layers deep (e.g. { prop: 'p', o: { one: 1, two: 2 } })
     */

    function freeze$1(o) {
      if (isObject$4(o)) {
        try {
          Object.freeze(o);

          __callKey1(Object.compatKeys(o), "forEach", function (key) {
            return _typeof(o._ES5ProxyType ? o.get(key) : o[key]) === 'object' && Object.freeze(o._ES5ProxyType ? o.get(key) : o[key]);
          });
        } catch (e) {// Squash errors that occur when trying to freeze a Proxy.
          // This can happen when the Object has previously been sent over the wire-service.
        }
      }

      return o;
    }
    /**
     * Return a 4 character identifier.
     */

    function guid() {
      return __callKey1(__callKey1(Math.floor((1 + Math.random()) * 0x10000), "toString", 16), "substring", 1);
    }
    /* A Simple Route is in this form:
     * {
     *     type: "standard_simpleRoute",
     *     attributes: {   // required
     *         path: "/some/relative/path"
     *     }
     *     state: {       // optional query params
     *         param1: "one"
     *     }
     * }
     * It matches this relative url: /some/relative/path?param1=one
     * The Simple Route is the default in the webruntime Router.
     */

    var simpleRouteType = 'standard__simpleRoute';
    /**
     * helper: f(any) -> true/false
     *
     * @param {*} route - Item to check if it's a Simple Route
     *
     * @returns {boolean}
     */

    function isSimpleRoute(route) {
      var _Object$compatKeys, _length;

      // A route is a Simple Route if it is valid and contains only 1 attribute: 'path'
      return isValidRoute(route) && isObject$4(route._ES5ProxyType ? route.get("attributes") : route.attributes) && (_Object$compatKeys = Object.compatKeys(route._ES5ProxyType ? route.get("attributes") : route.attributes), _length = _Object$compatKeys._ES5ProxyType ? _Object$compatKeys.get("length") : _Object$compatKeys.length) === 1 && __callKey2(Object.prototype._ES5ProxyType ? Object.prototype.get("compatHasOwnProperty") : Object.prototype.compatHasOwnProperty, "call", route._ES5ProxyType ? route.get("attributes") : route.attributes, 'path');
    }
    /**
     * f(route) -> true/false
     *
     * @param {*} route - Item to check if it's a valid route
     *
     * @returns {boolean}
     */

    function isValidRoute(route) {
      // Ensure the type is Object with an id OR a type.
      return isObject$4(route) && (__callKey2(Object.prototype._ES5ProxyType ? Object.prototype.get("compatHasOwnProperty") : Object.prototype.compatHasOwnProperty, "call", route, 'id') || __callKey2(Object.prototype._ES5ProxyType ? Object.prototype.get("compatHasOwnProperty") : Object.prototype.compatHasOwnProperty, "call", route, 'type'));
    }

    /* A Route Definition is in this form:
        {
            // required data
            "path": "/case/:recordId",

            // Basic routing
            "id": "case-detail",

            // lightning/navigation
            "page": {
                "type": "standard__recordPage",
                "attributes": {
                    "objectApiName": "Case"
                }
            },

            // custom data
            "view": "caseDetail"
            "label": "Case Detail"
        }
    */

    /**
     * f(route, routes[]) -> RouteDef
     * Match a route's id to a Route Definition id from the given list.
     *
     * @param {object} route - Route to match to a Route Definition
     * @param {array[object]} routeDefs - List of Route Definitions to match to the url
     *
     * @returns {object | null}
     */

    function getRouteDefFromRoute() {
      var route = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var routeDefs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var routeId = route._ES5ProxyType ? route.get("id") : route.id,
          routeType = route._ES5ProxyType ? route.get("type") : route.type,
          _route$attributes = route._ES5ProxyType ? route.get("attributes") : route.attributes,
          routeAttrs = _route$attributes === void 0 ? {} : _route$attributes; // MATCH BY ID, FOR ROUTES:
      // Go through all route definitions to find a match for the given route:
      //      - a route def id = the route id
      //      - each parameter in the route def path must exist as a key in the route attributes


      if (routeId) {
        return __callKey1(routeDefs, "find", function (_ref) {
          var _original, _id;

          var _ref$params = _ref._ES5ProxyType ? _ref.get("params") : _ref.params,
              params = _ref$params === void 0 ? [] : _ref$params,
              id = (_original = _ref._ES5ProxyType ? _ref.get("original") : _ref.original, _id = _original._ES5ProxyType ? _original.get("id") : _original.id);

          return id === routeId && __callKey1(params, "every", function (p) {
            return (p._ES5ProxyType ? p.get("modifier") : p.modifier) === '?' || __callKey2(Object.prototype._ES5ProxyType ? Object.prototype.get("compatHasOwnProperty") : Object.prototype.compatHasOwnProperty, "call", routeAttrs, p._ES5ProxyType ? p.get("name") : p.name);
          });
        }) || null;
      } // MATCH BY TYPE/ATTRIBUTES, to find a match:
      //      - a route def page type = the route type
      //      - each non-optional parameter in the route def path must exist as a key in the route attributes
      //      - each attribute in the route def page must match an attribute in the route
      //      - if more than 1 route def matches the route, choose the first match


      if (routeType) {
        // Locate all matches.
        var matches = __callKey1(routeDefs, "filter", function (_ref2) {
          var _original2, _page;

          var _ref2$params = _ref2._ES5ProxyType ? _ref2.get("params") : _ref2.params,
              params = _ref2$params === void 0 ? [] : _ref2$params,
              _ref2$original$page = (_original2 = _ref2._ES5ProxyType ? _ref2.get("original") : _ref2.original, _page = _original2._ES5ProxyType ? _original2.get("page") : _original2.page);

          _ref2$original$page = _ref2$original$page === void 0 ? {} : _ref2$original$page;

          var type = _ref2$original$page._ES5ProxyType ? _ref2$original$page.get("type") : _ref2$original$page.type,
              _ref2$original$page$a = _ref2$original$page._ES5ProxyType ? _ref2$original$page.get("attributes") : _ref2$original$page.attributes,
              pageAttrs = _ref2$original$page$a === void 0 ? {} : _ref2$original$page$a;

          return type === routeType && __callKey1(params, "every", function (p) {
            return (p._ES5ProxyType ? p.get("modifier") : p.modifier) === '?' || __callKey2(Object.prototype._ES5ProxyType ? Object.prototype.get("compatHasOwnProperty") : Object.prototype.compatHasOwnProperty, "call", routeAttrs, p._ES5ProxyType ? p.get("name") : p.name);
          }) && __callKey1(Object.compatKeys(pageAttrs), "every", function (key) {
            return (pageAttrs._ES5ProxyType ? pageAttrs.get(key) : pageAttrs[key]) === (routeAttrs._ES5ProxyType ? routeAttrs.get(key) : routeAttrs[key]);
          });
        }); // Return the first match.


        return (matches._ES5ProxyType ? matches.get("length") : matches.length) > 0 ? matches._ES5ProxyType ? matches.get(0) : matches[0] : null;
      } // NO MATCH:


      return null;
    }
    /**
     * f(path, routeDef) -> { "attr1": "one", "attr2": "two" }
     * Parse a path into an object of attributes based on the Route Definition's parameterized path.
     * URI decode the path parts that are parsed as attributes.
     *
     * @param {string} path - A path (hopefully) matching the Route Definition
     * @param {object} routeDef - Route Definition containing the path to parameterize
     *
     * @returns {object}
     */

    function getAttributesFromPathAndRouteDef(path, routeDef) {
      var attrs = {};

      if (path && routeDef) {
        var _original3, _page2, _original4, _page3, _attributes;

        // Split the path and the Route Definition path into their parts.
        var pathParts = __callKey1(routeDef._ES5ProxyType ? routeDef.get("regex") : routeDef.regex, "exec", path);

        if (pathParts) {
          pathParts = __callKey1(pathParts, "slice", 1); // Remove full match string at index 0.

          var routeParts = routeDef._ES5ProxyType ? routeDef.get("params") : routeDef.params; // For each Route Definition parameter, add an entry to the return object:
          //      { [route def parameter]: path part at matching index }

          __callKey1(routeParts, "forEach", function (part, index) {
            if (pathParts._ES5ProxyType ? pathParts.get(index) : pathParts[index]) {
              __setKey(attrs, part._ES5ProxyType ? part.get("name") : part.name, decode(pathParts._ES5ProxyType ? pathParts.get(index) : pathParts[index]));
            }
          });
        } // Add routeDef.page.attributes to the return object to create a complete page reference.


        if ((_original3 = routeDef._ES5ProxyType ? routeDef.get("original") : routeDef.original, _page2 = _original3._ES5ProxyType ? _original3.get("page") : _original3.page) && isObject$4((_original4 = routeDef._ES5ProxyType ? routeDef.get("original") : routeDef.original, _page3 = _original4._ES5ProxyType ? _original4.get("page") : _original4.page, _attributes = _page3._ES5ProxyType ? _page3.get("attributes") : _page3.attributes))) {
          var _original5, _page4, _attributes2;

          Object.compatAssign(attrs, (_original5 = routeDef._ES5ProxyType ? routeDef.get("original") : routeDef.original, _page4 = _original5._ES5ProxyType ? _original5.get("page") : _original5.page, _attributes2 = _page4._ES5ProxyType ? _page4.get("attributes") : _page4.attributes));
        }
      }

      return attrs;
    }

    function _objectSpread$3(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$3(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$3(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }
    /*
     * Utilities for handling routes.
     * Includes translation from URL to route, and vice versa.
     */

    /**
     * f(route, routes[]?) -> "/some/relative/path?param1=one&param2=two"
     * Match a route to a Route Definition, use these to build a URL.
     *
     * @param {object} route - Route to parse for a URL (ie: path+query)
     * @param {array[object]} routeDefs - List of Route Definitions to match to the route
     *
     * @returns {string | null} Returns null if a URL cannot be built.
     */

    function getUrlFromRoute(route) {
      var routeDefs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var routeDef = getRouteDefFromRoute(route, routeDefs);
      var path = getPathFromRoute(route, routeDef);
      return {
        url: path ? path + getQueryStringFromRoute(route) : null,
        data: routeDef ? routeDef._ES5ProxyType ? routeDef.get("original") : routeDef.original : null
      };
    }
    /**
     * f(route, RouteDef?) -> "/some/relative/path"
     * De-parameterize the route attributes into a path, using the Route Definition path.
     *
     * @param {object} route - Route to parse for a path
     * @param {object} routeDef - Route definition which matches the route,
     *                   use its path to compile the parameterized path,
     *                   a missing Route Definition means the route is handled as a Simple Route
     *
     * @returns {string}
     */

    function getPathFromRoute(route, routeDef) {
      var _original, _path2;

      // Return the included URL for Simple Routes (no route match)
      if (isSimpleRoute(route)) {
        var _attributes, _path;

        return _attributes = route._ES5ProxyType ? route.get("attributes") : route.attributes, _path = _attributes._ES5ProxyType ? _attributes.get("path") : _attributes.path;
      } // Return null for invalid or non-matching routes.


      if (!routeDef || !isValidRoute(route)) {
        return null;
      } // De-parameterize the route's attributes according to the Route Definition path.
      // Ensure spaces are encoded with '+' not '%20'.


      return (_original = routeDef._ES5ProxyType ? routeDef.get("original") : routeDef.original, _path2 = _original._ES5ProxyType ? _original.get("path") : _original.path) === '/' ? '/' : __callKey2(__callKey1(routeDef, "toPath", route._ES5ProxyType ? route.get("attributes") : route.attributes), "replace", /%20/g, '+');
    }
    /**
     * helper: f(route) -> "?param1=one&param2=two"
     *
     * @param {object} route - Route to parse for a query (the state)
     *
     * @returns {string}
     */

    function getQueryStringFromRoute() {
      var route = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // Transform the route into a query string, if it exists.
      return __callKey2(Object.prototype._ES5ProxyType ? Object.prototype.get("compatHasOwnProperty") : Object.prototype.compatHasOwnProperty, "call", route, 'state') && isObject$4(route._ES5ProxyType ? route.get("state") : route.state) ? getQueryString(route._ES5ProxyType ? route.get("state") : route.state) : '';
    }
    /**
     * f(URL, routes[]?) -> route
     * Match a URL's path to a Route Definition, use these to build a route.
     *
     * @param {string} url - URL string to turn into a route
     * @param {array[object]} routeDefs - List of Route Definitions to match to the url
     *
     * @returns {object}
     */

    function getRouteFromUrl(url) {
      var routeDefs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      // Parse the URL.
      var path = getPathFromUrl(url);
      var queryObj = getQueryFromUrl(url); // Try to match the URL to a Route Definition.

      var routeDef = __callKey1(routeDefs, "find", function (def) {
        return __callKey1(def._ES5ProxyType ? def.get("regex") : def.regex, "test", path);
      }) || null;
      var route; // If there is no Route Definition match, return a Simple Route.

      if (!routeDef) {
        route = {
          route: {
            // Ensure there is a type included.
            type: simpleRouteType,
            attributes: {
              path: path
            },
            state: _objectSpread$3({}, queryObj)
          },
          data: null
        };
      } else {
        var _page, _type;

        // Pull the parameters defined in routeDef.path out of the URL into an attributes object.
        var attributes = getAttributesFromPathAndRouteDef(path, routeDef); // Return the route with the Route Definition as data.

        var originalRouteDef = routeDef._ES5ProxyType ? routeDef.get("original") : routeDef.original;
        route = {
          route: {
            id: originalRouteDef._ES5ProxyType ? originalRouteDef.get("id") : originalRouteDef.id,
            attributes: _objectSpread$3({}, attributes),
            state: _objectSpread$3({}, queryObj)
          },
          data: originalRouteDef
        }; // Include the route definition type, if it exists.
        // This is to support the Salesforce page reference shape.

        if ((originalRouteDef._ES5ProxyType ? originalRouteDef.get("page") : originalRouteDef.page) && (_page = originalRouteDef._ES5ProxyType ? originalRouteDef.get("page") : originalRouteDef.page, _type = _page._ES5ProxyType ? _page.get("type") : _page.type)) {
          var _page2, _type2;

          __setKey(route._ES5ProxyType ? route.get("route") : route.route, "type", (_page2 = originalRouteDef._ES5ProxyType ? originalRouteDef.get("page") : originalRouteDef.page, _type2 = _page2._ES5ProxyType ? _page2.get("type") : _page2.type));
        }
      }

      return route;
    }

    /**
     * Provides the ability for a given DOM node to find its closest ancestor to provide navigation services.
     *
     * This is based on the referral implementations from the LWC team.
     *
     * Providers share the same ID value with every consumer over the wire.
     */
    // Unique event fired to find the closest ancestor navigation context.

    var NAV_CONTEXT_EVENT = __concat("universalcontainercontextevent", guid()); // Keep a cache of context metadata, with their IDs as keys:
    //    id => {
    //              id,
    //              value: { navigate(), generateUrl(), subscribe() },
    //              update(value),
    //          }


    var CACHE = new WeakMap();
    /**
     * Return a navigation context ID by DOM node.
     * This is used by areas of code that cannot use the official NavigationContext wire adapter (eg: mixins, other wires)
     * Exported API.
     *
     * @param {HTMLElement} node - The node from which to search for a context
     * @param {boolean} isWired - True if the event is being dispatched from a wire target
     *
     * @return {object} - Navigation context ID
     */

    function getNavigationContextId() {
      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var isWired = arguments.length > 1 ? arguments[1] : undefined;
      var id;

      var callback = function callback(value) {
        id = value;
      }; // Fire the event from the given node, with a callback function as a payload.
      // A LinkContextEvent must be fired from wire adapters, otherwise it is blocked.
      // These events are fired synchronously.


      __callKey1(node, "dispatchEvent", isWired ? new LinkContextEvent(NAV_CONTEXT_EVENT, callback) : new CustomEvent(NAV_CONTEXT_EVENT, {
        bubbles: true,
        composed: true,
        detail: callback
      }));

      return id;
    }
    /**
     * Return a navigation context by ID.
     * Exported API.
     *
     * @param {*} id - The ID of a navigation context.
     *
     * @return {object} - { navigate(), generateUrl(), subscribe() }
     */

    function getNavigationContext(id) {
      var metadata = __callKey1(CACHE, "get", id);

      invariant$2(metadata && (metadata._ES5ProxyType ? metadata.get("value") : metadata.value), messages._ES5ProxyType ? messages.get("MISSING_CONTEXT") : messages.MISSING_CONTEXT);
      return metadata._ES5ProxyType ? metadata.get("value") : metadata.value;
    }
    /**
     * Ensure the context is undefined OR provides an API value in the correct shape:
     *                  {
     *                      navigate: Function,
     *                      generateUrl: Function,
     *                      subscribe: Function
     *                  }
     *
     * @param {*} context - Object to check
     *
     * @return {object} - A valid context
     */

    function validateContext(context) {
      var _Object$compatKeys, _length;

      invariant$2(context === undefined || isObject$4(context) && typeof (context._ES5ProxyType ? context.get("navigate") : context.navigate) === 'function' && typeof (context._ES5ProxyType ? context.get("generateUrl") : context.generateUrl) === 'function' && typeof (context._ES5ProxyType ? context.get("subscribe") : context.subscribe) === 'function' && (_Object$compatKeys = Object.compatKeys(context), _length = _Object$compatKeys._ES5ProxyType ? _Object$compatKeys.get("length") : _Object$compatKeys.length) === 3, messages._ES5ProxyType ? messages.get("INVALID_CONTEXT") : messages.INVALID_CONTEXT);
      return context;
    }
    /**
     * Create and return the metadata for this context provider.
     * Cache the metadata by ID.
     *
     * @param {object} contextValue - Context API object
     * @param {RouteDefinition[]} data - Route data for this context
     *
     * @return {object} - The metadata object
     */


    function createContextData(contextValue, data) {
      var metadata = {
        // ID must be an object that can't be proxified otherwise we lose it when tracking the value.
        id: Object.freeze(function () {}),
        value: validateContext(contextValue),
        data: data || [],
        update: function update(newValue) {
          __setKey(metadata, "value", validateContext(newValue));
        }
      }; // Cache and return.

      __callKey2(CACHE, "set", metadata._ES5ProxyType ? metadata.get("id") : metadata.id, metadata);

      return metadata;
    }
    /**
     *
     * @param {object} contextValue - Context API object
     * @param {HTMLElement} providerNode - Context DOM element
     * @param {RouteDefinition[]} data - Route data for this context
     */


    function provideContext(contextValue, providerNode, data) {
      // Set up this context provider in the cache.
      var contextData = createContextData(contextValue, data); // Add a listener to the node for context consumers to find it.

      var eventListener = function eventListener(event) {
        // This event must have a full stop when it is intercepted by a provider.
        __callKey0(event, "stopImmediatePropagation"); // The new consumer provides a callback as a communication channel (see wire above).
        // Emit the context ID over the wire.


        __callKey1(event, "detail", contextData._ES5ProxyType ? contextData.get("id") : contextData.id);
      };

      __callKey2(providerNode, "addEventListener", NAV_CONTEXT_EVENT, eventListener); // Return functions to:
      //      1. update the context API value
      //      2. disconnect from being a context provider for new consumers


      return {
        id: contextData._ES5ProxyType ? contextData.get("id") : contextData.id,
        update: contextData._ES5ProxyType ? contextData.get("update") : contextData.update,
        disconnect: function disconnect() {
          return __callKey2(providerNode, "removeEventListener", NAV_CONTEXT_EVENT, eventListener);
        }
      };
    }

    /**
     * Services @wire(NavigationContext) requests.
     * Hooks up to an Observable from the current navigation context.
     *
     * @param {*} NavigationContext - Wire name
     * @param {WireEventTarget} target - Component target to listen to the wire
     */

    var NavigationContext = function NavigationContext() {
      throw new Error('Imperative use is not supported. Use @wire(NavigationContext)');
    };

    register$1(NavigationContext, function (target) {
      // Invoked when a component is connected.
      // Dispatch an event to find the closest navigation context.
      __callKey2(target, "addEventListener", 'connect', function () {
        // Return the context ID as the wire value.
        // Do not expose the actual navigation API.
        __callKey1(target, "dispatchEvent", new ValueChangedEvent(getNavigationContextId(target, true)));
      }); // There is no 'disconnect' listener because the value of this wire never changes/updates.

    });

    /*
     * Provide eventing support for navigation events and navigation tree building.
     * Extended by Router.
     */
    // Event fired when a component calls navigate().

    var NAV_EVENT = __concat("universalcontainernavigationevent", guid()); // Internal event fired to find nearest ancestor.


    var PARENT_EVENT = __concat("universalcontainerparentevent", guid());

    var NavNode =
    /*#__PURE__*/
    function () {
      // DOM node to which this is attached.
      // A reference to this node's parent and child.
      // Event name(s).

      /**
       * Merge properties and create NavNode.
       *
       * @param {HTMLElement} node - DOM node to attach to
       */
      function NavNode() {
        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

        _classCallCheck(this, NavNode);

        __setKey(this, "node", window);

        __setKey(this, "parent", null);

        __setKey(this, "child", null); // The node property is locked in during construction.


        Object.compatAssign(this, {
          node: node
        });
      }
      /**
       * Return the properties and methods that define this node as a navigation context provider.
       * This function is expected to be overridden by extender classes.
       */


      _createClass(NavNode, [{
        key: "_fallback",

        /**
         * Create a function which calls the given fcn, with extra parameters (...rest).
         * If fcn does not exist, use a fallback.
         *
         * @param {function} fcn - Function to transform
         * @param {function} fallbackFcn - Function to use as a fallback
         * @param  {...any} rest - Additional arguments to pass to the new function
         */
        value: function _fallback(fcn, fallbackFcn) {
          for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            __setKey(rest, _key - 2, arguments[_key]);
          }

          return fcn ? function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              __setKey(args, _key2, arguments[_key2]);
            }

            return __callKey2(fcn, "apply", void 0, __concat(args, rest));
          } : fallbackFcn;
        }
        /***** Set up and tear down event listeners *****/

        /**
         * Fire an event to find the nearest ancestor NavNode.
         * Add the NavNode as this one's parent.
         * Add this one as the NavNode's child.
         */

      }, {
        key: "connectToParent",
        value: function connectToParent() {
          var _this = this;

          __callKey1(this._ES5ProxyType ? this.get("node") : this.node, "dispatchEvent", new CustomEvent(PARENT_EVENT, {
            bubbles: true,
            composed: true,
            detail: function detail(parent) {
              __setKey(_this, "parent", parent);

              __callKey1(parent, "addChild", _this);
            }
          }));
        }
        /**
         * Add the given node as a child to this node, if it doesn't already have one.
         * The Error prevents sibling nodes from being added under this node.
         *
         * @param {NavNode} child
         */

      }, {
        key: "addChild",
        value: function addChild(child) {
          var _this2 = this;

          // Temp fix for https://github.com/salesforce/lwc/issues/1894

          /* eslint-disable-next-line */
          setTimeout(function () {
            invariant$2(!(_this2._ES5ProxyType ? _this2.get("child") : _this2.child), messages._ES5ProxyType ? messages.get("MULTIPLE_CHILDREN") : messages.MULTIPLE_CHILDREN);

            __setKey(_this2, "child", child);
          }, 0);
        }
        /**
         * Connect this node to the tree hierarchy and eventing.
         */

      }, {
        key: "connect",
        value: function connect() {
          // Connect this node as a child to its closest ancestor.
          __callKey0(this, "connectToParent"); // Add listeners for parent discovery and navigation events.


          __setKey(this, "handleParentEvent", __callKey1(this._ES5ProxyType ? this.get("_handleParentEvent") : this._handleParentEvent, "bind", this));

          __setKey(this, "handleNavEvent", __callKey1(this._ES5ProxyType ? this.get("_handleEvent") : this._handleEvent, "bind", this));

          __callKey2(this._ES5ProxyType ? this.get("node") : this.node, "addEventListener", PARENT_EVENT, this._ES5ProxyType ? this.get("handleParentEvent") : this.handleParentEvent);

          __callKey2(this._ES5ProxyType ? this.get("node") : this.node, "addEventListener", NavNode._ES5ProxyType ? NavNode.get("navigationEvent") : NavNode.navigationEvent, this._ES5ProxyType ? this.get("handleNavEvent") : this.handleNavEvent);
        }
        /**
         * Disconnect this node to the tree hierarchy and eventing.
         */

      }, {
        key: "disconnect",
        value: function disconnect() {
          // Remove event listeners.
          __callKey2(this._ES5ProxyType ? this.get("node") : this.node, "removeEventListener", PARENT_EVENT, this._ES5ProxyType ? this.get("handleParentEvent") : this.handleParentEvent);

          __callKey2(this._ES5ProxyType ? this.get("node") : this.node, "removeEventListener", NavNode._ES5ProxyType ? NavNode.get("navigationEvent") : NavNode.navigationEvent, this._ES5ProxyType ? this.get("handleNavEvent") : this.handleNavEvent); // Detach from parent.


          if (this._ES5ProxyType ? this.get("parent") : this.parent) {
            __setKey(this._ES5ProxyType ? this.get("parent") : this.parent, "child", null);
          }

          __setKey(this, "parent", null); // Detach from child.


          if (this._ES5ProxyType ? this.get("child") : this.child) {
            __setKey(this._ES5ProxyType ? this.get("child") : this.child, "parent", null);
          }

          __setKey(this, "child", null);
        }
        /***** Tree pointer info *****/

        /**
         * This node is the root if it does not have a parent.
         *
         * @returns {boolean}
         */

      }, {
        key: "_handleParentEvent",

        /***** Navigation and parent location event handlers *****/

        /**
         * Be discovered as a parent for descendent components.
         * Stop immediate propagation because we only want 1 parent to be found.
         *
         * @param {Event} event - With detail: callback
         */
        value: function _handleParentEvent(event) {
          __callKey0(event, "stopImmediatePropagation");

          if (event && (event._ES5ProxyType ? event.get("detail") : event.detail)) {
            __callKey1(event, "detail", this);
          }
        }
        /**
         * Inspect a navigation event bubbling up from a descendent component.
         * This node can choose to stop the event by returning false.
         * If propagation is not stopped, and this node is the root (no parent),
         *      then begin the root -> leaf processing of this new route.
         *      This will update the navigation event subscribers in each NavNode, top down.
         *
         * @param {Event} event - With detail: { url, options }
         */

      }, {
        key: "_handleEvent",
        value: function _handleEvent(event) {
          var _event$detail = event._ES5ProxyType ? event.get("detail") : event.detail,
              url = _event$detail._ES5ProxyType ? _event$detail.get("url") : _event$detail.url,
              options = _event$detail._ES5ProxyType ? _event$detail.get("options") : _event$detail.options,
              input = _event$detail._ES5ProxyType ? _event$detail.get("input") : _event$detail.input;

          if (!__callKey2(this, "handleEvent", input, options)) {
            __callKey0(event, "stopPropagation");
          } else if (this._ES5ProxyType ? this.get("isRoot") : this.isRoot) {
            __callKey2(this, "process", url, options);
          }
        }
        /**
         * A hook for when an event is bubbling up through this node.
         * Return false if propagation of the event should be stopped.
         * This default implementation is a no-op.
         *
         * @returns {boolean}
         */

      }, {
        key: "handleEvent",
        value: function handleEvent() {
          return true;
        }
        /**
         * The work a node needs to do during an "event".
         * This default implementation is a no-op.
         *
         * @returns {boolean}
         */

      }, {
        key: "process",
        value: function process() {
          return true;
        }
      }, {
        key: "context",
        get: function get() {
          return this;
        }
      }, {
        key: "isRoot",
        get: function get() {
          return !(this._ES5ProxyType ? this.get("parent") : this.parent);
        }
        /**
         * Search up the node chain until the root node is hit.
         *
         * @returns {NavNode}
         */

      }, {
        key: "root",
        get: function get() {
          var maybe = this;

          while (!(maybe._ES5ProxyType ? maybe.get("isRoot") : maybe.isRoot)) {
            maybe = maybe._ES5ProxyType ? maybe.get("parent") : maybe.parent;
          }

          return maybe;
        }
      }]);

      return NavNode;
    }();

    __setKey(NavNode, "navigationEvent", NAV_EVENT);

    registerDecorators(NavNode, {
      fields: ["node", "parent", "child"]
    });

    var NavNode$1 = registerComponent(NavNode, {
      tmpl: _tmpl
    });

    /* eslint-disable */

    /**
     * Tokenize input string.
     */

    function lexer(str) {
      var tokens = [];
      var i = 0;

      while (i < (str._ES5ProxyType ? str.get("length") : str.length)) {
        var _ref19, _ref20;

        var char = str._ES5ProxyType ? str.get(i) : str[i];

        if (char === "*" || char === "+" || char === "?") {
          var _ref, _ref2;

          tokens.push({
            type: "MODIFIER",
            index: i,
            value: (_ref = i++, _ref2 = str._ES5ProxyType ? str.get(_ref) : str[_ref])
          });
          continue;
        }

        if (char === "\\") {
          var _ref3, _ref4;

          tokens.push({
            type: "ESCAPED_CHAR",
            index: i++,
            value: (_ref3 = i++, _ref4 = str._ES5ProxyType ? str.get(_ref3) : str[_ref3])
          });
          continue;
        }

        if (char === "{") {
          var _ref5, _ref6;

          tokens.push({
            type: "OPEN",
            index: i,
            value: (_ref5 = i++, _ref6 = str._ES5ProxyType ? str.get(_ref5) : str[_ref5])
          });
          continue;
        }

        if (char === "}") {
          var _ref7, _ref8;

          tokens.push({
            type: "CLOSE",
            index: i,
            value: (_ref7 = i++, _ref8 = str._ES5ProxyType ? str.get(_ref7) : str[_ref7])
          });
          continue;
        }

        if (char === ":") {
          var name = "";
          var j = i + 1;

          while (j < (str._ES5ProxyType ? str.get("length") : str.length)) {
            var code = __callKey1(str, "charCodeAt", j);

            if ( // `0-9`
            code >= 48 && code <= 57 || // `A-Z`
            code >= 65 && code <= 90 || // `a-z`
            code >= 97 && code <= 122 || // `_`
            code === 95) {
              var _ref9, _ref10;

              name += (_ref9 = j++, _ref10 = str._ES5ProxyType ? str.get(_ref9) : str[_ref9]);
              continue;
            }

            break;
          }

          if (!name) throw new TypeError("Missing parameter name at " + i);
          tokens.push({
            type: "NAME",
            index: i,
            value: name
          });
          i = j;
          continue;
        }

        if (char === "(") {
          var count = 1;
          var pattern = "";
          var j = i + 1;

          if ((str._ES5ProxyType ? str.get(j) : str[j]) === "?") {
            throw new TypeError("Pattern cannot start with \"?\" at " + j);
          }

          while (j < (str._ES5ProxyType ? str.get("length") : str.length)) {
            var _ref17, _ref18;

            if ((str._ES5ProxyType ? str.get(j) : str[j]) === "\\") {
              var _ref11, _ref12, _ref13, _ref14;

              pattern += (_ref11 = j++, _ref12 = str._ES5ProxyType ? str.get(_ref11) : str[_ref11]) + (_ref13 = j++, _ref14 = str._ES5ProxyType ? str.get(_ref13) : str[_ref13]);
              continue;
            }

            if ((str._ES5ProxyType ? str.get(j) : str[j]) === ")") {
              count--;

              if (count === 0) {
                j++;
                break;
              }
            } else if ((str._ES5ProxyType ? str.get(j) : str[j]) === "(") {
              var _ref15, _ref16;

              count++;

              if ((_ref15 = j + 1, _ref16 = str._ES5ProxyType ? str.get(_ref15) : str[_ref15]) !== "?") {
                throw new TypeError("Capturing groups are not allowed at " + j);
              }
            }

            pattern += (_ref17 = j++, _ref18 = str._ES5ProxyType ? str.get(_ref17) : str[_ref17]);
          }

          if (count) throw new TypeError("Unbalanced pattern at " + i);
          if (!pattern) throw new TypeError("Missing pattern at " + i);
          tokens.push({
            type: "PATTERN",
            index: i,
            value: pattern
          });
          i = j;
          continue;
        }

        tokens.push({
          type: "CHAR",
          index: i,
          value: (_ref19 = i++, _ref20 = str._ES5ProxyType ? str.get(_ref19) : str[_ref19])
        });
      }

      tokens.push({
        type: "END",
        index: i,
        value: ""
      });
      return tokens;
    }
    /**
     * Parse a string for the raw tokens.
     */


    function parse(str, options) {
      if (options === void 0) {
        options = {};
      }

      var tokens = lexer(str);

      var _a = options._ES5ProxyType ? options.get("prefixes") : options.prefixes,
          prefixes = _a === void 0 ? "./" : _a;

      var defaultPattern = "[^" + escapeString((options._ES5ProxyType ? options.get("delimiter") : options.delimiter) || "/#?") + "]+?";
      var result = [];
      var key = 0;
      var i = 0;
      var path = "";

      var tryConsume = function tryConsume(type) {
        var _i2, _type, _ref21, _ref22, _value;

        if (i < (tokens._ES5ProxyType ? tokens.get("length") : tokens.length) && (_i2 = tokens._ES5ProxyType ? tokens.get(i) : tokens[i], _type = _i2._ES5ProxyType ? _i2.get("type") : _i2.type) === type) return _ref21 = i++, _ref22 = tokens._ES5ProxyType ? tokens.get(_ref21) : tokens[_ref21], _value = _ref22._ES5ProxyType ? _ref22.get("value") : _ref22.value;
      };

      var mustConsume = function mustConsume(type) {
        var value = tryConsume(type);
        if (value !== undefined) return value;

        var _a = tokens._ES5ProxyType ? tokens.get(i) : tokens[i],
            nextType = _a._ES5ProxyType ? _a.get("type") : _a.type,
            index = _a._ES5ProxyType ? _a.get("index") : _a.index;

        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
      };

      var consumeText = function consumeText() {
        var result = "";
        var value; // tslint:disable-next-line

        while (value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
          result += value;
        }

        return result;
      };

      while (i < (tokens._ES5ProxyType ? tokens.get("length") : tokens.length)) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");

        if (name || pattern) {
          var prefix = char || "";

          if (__callKey1(prefixes, "indexOf", prefix) === -1) {
            path += prefix;
            prefix = "";
          }

          if (path) {
            result.push(path);
            path = "";
          }

          result.push({
            name: name || key++,
            prefix: prefix,
            suffix: "",
            pattern: pattern || defaultPattern,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }

        var value = char || tryConsume("ESCAPED_CHAR");

        if (value) {
          path += value;
          continue;
        }

        if (path) {
          result.push(path);
          path = "";
        }

        var open = tryConsume("OPEN");

        if (open) {
          var prefix = consumeText();
          var name_1 = tryConsume("NAME") || "";
          var pattern_1 = tryConsume("PATTERN") || "";
          var suffix = consumeText();
          mustConsume("CLOSE");
          result.push({
            name: name_1 || (pattern_1 ? key++ : ""),
            pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
            prefix: prefix,
            suffix: suffix,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }

        mustConsume("END");
      }

      return result;
    }
    /**
     * Compile a string to a template function for the path.
     */


    function compile(str, options) {
      return tokensToFunction(parse(str, options), options);
    }
    /**
     * Expose a method for transforming tokens into the path function.
     */


    function tokensToFunction(tokens, options) {
      if (options === void 0) {
        options = {};
      }

      var reFlags = flags(options);

      var _a = options._ES5ProxyType ? options.get("encode") : options.encode,
          encode = _a === void 0 ? function (x) {
        return x;
      } : _a,
          _b = options._ES5ProxyType ? options.get("validate") : options.validate,
          validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.


      var matches = __callKey1(tokens, "map", function (token) {
        if (_typeof(token) === "object") {
          return new RegExp("^(?:" + (token._ES5ProxyType ? token.get("pattern") : token.pattern) + ")$", reFlags);
        }
      });

      return function (data) {
        var path = "";

        for (var i = 0; i < (tokens._ES5ProxyType ? tokens.get("length") : tokens.length); i++) {
          var _token$name, _token$name2;

          var token = tokens._ES5ProxyType ? tokens.get(i) : tokens[i];

          if (typeof token === "string") {
            path += token;
            continue;
          }

          var value = data ? (_token$name = token._ES5ProxyType ? token.get("name") : token.name, _token$name2 = data._ES5ProxyType ? data.get(_token$name) : data[_token$name]) : undefined;
          var optional = (token._ES5ProxyType ? token.get("modifier") : token.modifier) === "?" || (token._ES5ProxyType ? token.get("modifier") : token.modifier) === "*";
          var repeat = (token._ES5ProxyType ? token.get("modifier") : token.modifier) === "*" || (token._ES5ProxyType ? token.get("modifier") : token.modifier) === "+";

          if (Array.compatIsArray(value)) {
            if (!repeat) {
              throw new TypeError("Expected \"" + (token._ES5ProxyType ? token.get("name") : token.name) + "\" to not repeat, but got an array");
            }

            if ((value._ES5ProxyType ? value.get("length") : value.length) === 0) {
              if (optional) continue;
              throw new TypeError("Expected \"" + (token._ES5ProxyType ? token.get("name") : token.name) + "\" to not be empty");
            }

            for (var j = 0; j < (value._ES5ProxyType ? value.get("length") : value.length); j++) {
              var segment = encode(value._ES5ProxyType ? value.get(j) : value[j], token);

              if (validate && !__callKey1(matches._ES5ProxyType ? matches.get(i) : matches[i], "test", segment)) {
                throw new TypeError("Expected all \"" + (token._ES5ProxyType ? token.get("name") : token.name) + "\" to match \"" + (token._ES5ProxyType ? token.get("pattern") : token.pattern) + "\", but got \"" + segment + "\"");
              }

              path += (token._ES5ProxyType ? token.get("prefix") : token.prefix) + segment + (token._ES5ProxyType ? token.get("suffix") : token.suffix);
            }

            continue;
          }

          if (typeof value === "string" || typeof value === "number") {
            var segment = encode(String(value), token);

            if (validate && !__callKey1(matches._ES5ProxyType ? matches.get(i) : matches[i], "test", segment)) {
              throw new TypeError("Expected \"" + (token._ES5ProxyType ? token.get("name") : token.name) + "\" to match \"" + (token._ES5ProxyType ? token.get("pattern") : token.pattern) + "\", but got \"" + segment + "\"");
            }

            path += (token._ES5ProxyType ? token.get("prefix") : token.prefix) + segment + (token._ES5ProxyType ? token.get("suffix") : token.suffix);
            continue;
          }

          if (optional) continue;
          var typeOfMessage = repeat ? "an array" : "a string";
          throw new TypeError("Expected \"" + (token._ES5ProxyType ? token.get("name") : token.name) + "\" to be " + typeOfMessage);
        }

        return path;
      };
    }
    /**
     * Escape a regular expression string.
     */


    function escapeString(str) {
      return __callKey2(str, "replace", /([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    /**
     * Get the flags for a regexp from the options.
     */


    function flags(options) {
      return options && (options._ES5ProxyType ? options.get("sensitive") : options.sensitive) ? "" : "i";
    }
    /**
     * Pull out keys from a regexp.
     */


    function regexpToRegexp(path, keys) {
      if (!keys) return path; // Use a negative lookahead to match only capturing groups.

      var groups = __callKey1(path._ES5ProxyType ? path.get("source") : path.source, "match", /\((?!\?)/g);

      if (groups) {
        for (var i = 0; i < (groups._ES5ProxyType ? groups.get("length") : groups.length); i++) {
          keys.push({
            name: i,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
          });
        }
      }

      return path;
    }
    /**
     * Transform an array into a regexp.
     */


    function arrayToRegexp(paths, keys, options) {
      var parts = __callKey1(paths, "map", function (path) {
        var _pathToRegexp, _source;

        return _pathToRegexp = pathToRegexp(path, keys, options), _source = _pathToRegexp._ES5ProxyType ? _pathToRegexp.get("source") : _pathToRegexp.source;
      });

      return new RegExp("(?:" + __callKey1(parts, "join", "|") + ")", flags(options));
    }
    /**
     * Create a path regexp from string input.
     */


    function stringToRegexp(path, keys, options) {
      return tokensToRegexp(parse(path, options), keys, options);
    }
    /**
     * Expose a function for taking tokens and returning a RegExp.
     */


    function tokensToRegexp(tokens, keys, options) {
      if (options === void 0) {
        options = {};
      }

      var _a = options._ES5ProxyType ? options.get("strict") : options.strict,
          strict = _a === void 0 ? false : _a,
          _b = options._ES5ProxyType ? options.get("start") : options.start,
          start = _b === void 0 ? true : _b,
          _c = options._ES5ProxyType ? options.get("end") : options.end,
          end = _c === void 0 ? true : _c,
          _d = options._ES5ProxyType ? options.get("encode") : options.encode,
          encode = _d === void 0 ? function (x) {
        return x;
      } : _d;

      var endsWith = "[" + escapeString((options._ES5ProxyType ? options.get("endsWith") : options.endsWith) || "") + "]|$";
      var delimiter = "[" + escapeString((options._ES5ProxyType ? options.get("delimiter") : options.delimiter) || "/#?") + "]";
      var route = start ? "^" : ""; // Iterate over the tokens and create our regexp string.

      for (var _i = 0, tokens_1 = tokens; _i < (tokens_1._ES5ProxyType ? tokens_1.get("length") : tokens_1.length); _i++) {
        var token = tokens_1._ES5ProxyType ? tokens_1.get(_i) : tokens_1[_i];

        if (typeof token === "string") {
          route += escapeString(encode(token));
        } else {
          var prefix = escapeString(encode(token._ES5ProxyType ? token.get("prefix") : token.prefix));
          var suffix = escapeString(encode(token._ES5ProxyType ? token.get("suffix") : token.suffix));

          if (token._ES5ProxyType ? token.get("pattern") : token.pattern) {
            if (keys) keys.push(token);

            if (prefix || suffix) {
              if ((token._ES5ProxyType ? token.get("modifier") : token.modifier) === "+" || (token._ES5ProxyType ? token.get("modifier") : token.modifier) === "*") {
                var mod = (token._ES5ProxyType ? token.get("modifier") : token.modifier) === "*" ? "?" : "";
                route += "(?:" + prefix + "((?:" + (token._ES5ProxyType ? token.get("pattern") : token.pattern) + ")(?:" + suffix + prefix + "(?:" + (token._ES5ProxyType ? token.get("pattern") : token.pattern) + "))*)" + suffix + ")" + mod;
              } else {
                route += "(?:" + prefix + "(" + (token._ES5ProxyType ? token.get("pattern") : token.pattern) + ")" + suffix + ")" + (token._ES5ProxyType ? token.get("modifier") : token.modifier);
              }
            } else {
              route += "(" + (token._ES5ProxyType ? token.get("pattern") : token.pattern) + ")" + (token._ES5ProxyType ? token.get("modifier") : token.modifier);
            }
          } else {
            route += "(?:" + prefix + suffix + ")" + (token._ES5ProxyType ? token.get("modifier") : token.modifier);
          }
        }
      }

      if (end) {
        if (!strict) route += delimiter + "?";
        route += !(options._ES5ProxyType ? options.get("endsWith") : options.endsWith) ? "$" : "(?=" + endsWith + ")";
      } else {
        var _ref23, _ref24, _ref25, _ref26;

        var endToken = (_ref23 = (tokens._ES5ProxyType ? tokens.get("length") : tokens.length) - 1, _ref24 = tokens._ES5ProxyType ? tokens.get(_ref23) : tokens[_ref23]);
        var isEndDelimited = typeof endToken === "string" ? __callKey1(delimiter, "indexOf", (_ref25 = (endToken._ES5ProxyType ? endToken.get("length") : endToken.length) - 1, _ref26 = endToken._ES5ProxyType ? endToken.get(_ref25) : endToken[_ref25])) > -1 : // tslint:disable-next-line
        endToken === undefined;

        if (!strict) {
          route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }

        if (!isEndDelimited) {
          route += "(?=" + delimiter + "|" + endsWith + ")";
        }
      }

      return new RegExp(route, flags(options));
    }
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     */


    function pathToRegexp(path, keys, options) {
      if (_instanceof(path, RegExp)) return regexpToRegexp(path, keys);
      if (Array.compatIsArray(path)) return arrayToRegexp(path, keys, options);
      return stringToRegexp(path, keys, options);
    }
    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */


    var pathToRegexp$1 = {
      compile: compile,
      pathToRegexp: pathToRegexp
    };
    var pathToRegexp$2 = registerComponent(pathToRegexp$1, {
      tmpl: _tmpl
    });

    /*
     * Provides a Router class. Extended by the HistoryRouter and composed by the child-router LWCs.
     * Pass in these properties to the constructor for customizing the router:
     *      - basePath
     *      - routes[]
     *      - node
     *      - caseSensitive
     * And optionally provide overrides for these methods:
     *      - handleNavigation(url | route, options)
     *      - getRouteFromUrl(url)
     *      - getUrlFromRoute(route)
     * And add hook listeners with:
     *      - addPreNavigate(function || [function, function, ...])
     *      - addPostNavigate(function || [function, function, ...])
     * The NavigationMixin and CurrentPageReference functionality is automatically handled/provided.
     */

    var Router =
    /*#__PURE__*/
    function (_NavNode) {
      _inherits(Router, _NavNode);

      // Relative base path for this router.
      // An array to hold all registered Route Definitions.
      // When true the path matching will be case sensitive.

      /** START: Internal navigation state variables */
      // The current matching path for this router, used by child to create its full ancestor base path (parent path match + base path).
      // The current matching info object: { route, data }. Used to hydrate navigation hook listeners.
      // Keep track of the last URL that was successfully processed. It is used to initialize lazily attached children.

      /** END: Internal navigation state variables */
      // Create an Observer to hold the current route and data.
      // Create filter chains for the pre and post hooks.

      /**
       * Create and configure the Router.
       *
       * @param {object} c - The router config object, all properties are optional
       * @param {string} c.basePath - This router's base path
       * @param {object[]} c.routes - Array of route definitions
       * @param {boolean} c.caseSensitive - True if path matching should be case sensitive
       * @param {function} c.handleNavigation - handleNavigation event handler override
       * @param {function} c.getRouteFromUrl - route => URL translation override
       * @param {function} c.getUrlFromRoute - URL => route translation override
       * @param {HTMLElement} node - DOM node to attach to
       */
      function Router() {
        var _this;

        var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

        _classCallCheck(this, Router);

        _this = _possibleConstructorReturn(this, __callKey2(_getPrototypeOf(Router), "call", this, node));

        __setKey(_this, "basePath", '');

        __setKey(_this, "routes", []);

        __setKey(_this, "caseSensitive", false);

        __setKey(_this, "pathMatch", '');

        __setKey(_this, "infoMatch", null);

        __setKey(_this, "currentUrl", null);

        __setKey(_this, "routeObservable", createObservable());

        __setKey(_this, "preFilters", createFilterChain());

        __setKey(_this, "postFilters", createFilterChain());

        __setKey(_this, "errorFilters", createFilterChain());

        __setKey(_this, "basePath", (c._ES5ProxyType ? c.get("basePath") : c.basePath) || '');

        __setKey(_this, "caseSensitive", (c._ES5ProxyType ? c.get("caseSensitive") : c.caseSensitive) === true ? true : false);

        __callKey1(_this, "parseRouteDefinitions", (c._ES5ProxyType ? c.get("routes") : c.routes) || []); // The translation layer overrides get the default implementation passed in.
        // Pass getRouteFromUrl() into custom handleNavigation functions.


        __setKey(_this, "getRouteFromUrl", __callKey3(_this, "_fallback", c._ES5ProxyType ? c.get("getRouteFromUrl") : c.getRouteFromUrl, _this._ES5ProxyType ? _this.get("defaultGetRouteFromUrl") : _this.defaultGetRouteFromUrl, __callKey1(_this._ES5ProxyType ? _this.get("defaultGetRouteFromUrl") : _this.defaultGetRouteFromUrl, "bind", _assertThisInitialized(_assertThisInitialized(_this)))));

        __setKey(_this, "getUrlFromRoute", __callKey3(_this, "_fallback", c._ES5ProxyType ? c.get("getUrlFromRoute") : c.getUrlFromRoute, _this._ES5ProxyType ? _this.get("defaultGetUrlFromRoute") : _this.defaultGetUrlFromRoute, __callKey1(_this._ES5ProxyType ? _this.get("defaultGetUrlFromRoute") : _this.defaultGetUrlFromRoute, "bind", _assertThisInitialized(_assertThisInitialized(_this)))));

        __setKey(_this, "handleEvent", __callKey3(_this, "_fallback", c._ES5ProxyType ? c.get("handleNavigation") : c.handleNavigation, function () {
          return true;
        }, __callKey1(_this._ES5ProxyType ? _this.get("getRouteFromUrl") : _this.getRouteFromUrl, "bind", _assertThisInitialized(_assertThisInitialized(_this)))));

        return _this;
      }
      /**
       * Parse the route definitions with path-to-regex functionality.
       *
       * @param {object[]} routeDefs - Array of route definitions
       * @example
       * {
       *      original: the user-defined route definition
       *      regex: regular expression based on the route definition path
       *      toPath: function which takes an object of parameters and creates a path
       *      params: an array of objects with info on each path parameter
       * }
       */


      _createClass(Router, [{
        key: "parseRouteDefinitions",
        value: function parseRouteDefinitions(routeDefs) {
          var _this2 = this;

          __setKey(this, "routes", __callKey1(routeDefs, "map", function (def) {
            invariant$2(def._ES5ProxyType ? def.get("path") : def.path, messages._ES5ProxyType ? messages.get("MISSING_PATH") : messages.MISSING_PATH);
            var params = [];

            var regex = __callKey3(pathToRegexp$2, "pathToRegexp", def._ES5ProxyType ? def.get("path") : def.path, params, {
              sensitive: _this2._ES5ProxyType ? _this2.get("caseSensitive") : _this2.caseSensitive,
              // True if this is a leaf route, and must match URLs exactly with no trailing segments.
              end: (def._ES5ProxyType ? def.get("exact") : def.exact) === false ? false : true
            });

            var toPath = __callKey2(pathToRegexp$2, "compile", def._ES5ProxyType ? def.get("path") : def.path, {
              encode: encodeURIComponent
            });

            return {
              original: def,
              regex: regex,
              params: params,
              toPath: toPath
            };
          }));
        }
        /***** Lifecycle *****/

        /**
         * Override to provide this router as a navigation context.
         */

      }, {
        key: "connect",
        value: function connect() {
          var _this3 = this;

          __callKey1(_get(_getPrototypeOf(Router._ES5ProxyType ? Router.get("prototype") : Router.prototype), "connect", this), "call", this);

          __setKey(this, "contextConnection", provideContext({
            navigate: function navigate(input, options) {
              return __callKey2(_this3, "navigate", input, options);
            },
            generateUrl: function generateUrl(route) {
              return __callKey1(_this3, "generateUrl", route);
            },
            subscribe: function subscribe(callback, replay) {
              return __callKey2(_this3, "subscribe", callback, replay);
            }
          }, this._ES5ProxyType ? this.get("node") : this.node, __callKey1(this._ES5ProxyType ? this.get("routes") : this.routes, "map", function (r) {
            return r._ES5ProxyType ? r.get("original") : r.original;
          })));
        }
        /**
         * Override to remove this router as a navigation context.
         */

      }, {
        key: "disconnect",
        value: function disconnect() {
          __callKey1(_get(_getPrototypeOf(Router._ES5ProxyType ? Router.get("prototype") : Router.prototype), "disconnect", this), "call", this);

          if (this._ES5ProxyType ? this.get("contextConnection") : this.contextConnection) {
            __callKey1(this._ES5ProxyType ? this.get("contextConnection") : this.contextConnection, "update", undefined);

            __callKey0(this._ES5ProxyType ? this.get("contextConnection") : this.contextConnection, "disconnect");
          }
        }
        /**
         * Add listeners to this router hook which run BEFORE a new URL is processed (root -> leaf).
         *
         * @param {object | object[]} filters
         */

      }, {
        key: "addPreNavigate",
        value: function addPreNavigate(filters) {
          __callKey1(this._ES5ProxyType ? this.get("preFilters") : this.preFilters, "add", filters);
        }
        /**
         * Add listeners to this router hook which run AFTER a new URL has been processed (root -> leaf).
         *
         * @param {object | object[]} filters
         */

      }, {
        key: "addPostNavigate",
        value: function addPostNavigate(filters) {
          __callKey1(this._ES5ProxyType ? this.get("postFilters") : this.postFilters, "add", filters);
        }
        /**
         * Add listeners to this router hook which run when there is an error navigating.
         *
         * @param {object | object[]} filters
         */

      }, {
        key: "addErrorNavigate",
        value: function addErrorNavigate(filters) {
          __callKey1(this._ES5ProxyType ? this.get("errorFilters") : this.errorFilters, "add", filters);
        }
        /***** URL <=> route translation default implementation *****/

        /**
         * This URL path prefix = parent path match + this base path.
         *
         * @returns {string}
         */

      }, {
        key: "defaultGetRouteFromUrl",

        /**
         * Default implementation: f(URL) -> { route: route, data: routeDef }
         * Remove the base URL before conversion.
         *
         * @param {string} url
         *
         * @returns {object} - { object: route, object: data }
         */
        value: function defaultGetRouteFromUrl(url) {
          // Process relative URLs (i.e.: remove any http*://*.*)
          url = getRelativeUrl(url); // The URL must start with the prefix to be eligible to match to a route definition.
          // If the prefix is not found, pass in [] for the route definitions -> fall back to a Simple Route.

          var hasPrefix = __callKey1(url, "indexOf", this._ES5ProxyType ? this.get("prefix") : this.prefix) === 0; // Pass in the rest of the URL for matching, without the prefix.

          var info = getRouteFromUrl(hasPrefix ? __callKey2(url, "replace", this._ES5ProxyType ? this.get("prefix") : this.prefix, '') : url, hasPrefix ? this._ES5ProxyType ? this.get("routes") : this.routes : []); // If the prefix was stripped off of a Simple Route, add it back on, so the path is absolute.

          var route = info._ES5ProxyType ? info.get("route") : info.route;

          if (hasPrefix && isSimpleRoute(route)) {
            var _attributes, _path;

            __setKey(route._ES5ProxyType ? route.get("attributes") : route.attributes, "path", __concat(__concat("", this._ES5ProxyType ? this.get("prefix") : this.prefix), (_attributes = route._ES5ProxyType ? route.get("attributes") : route.attributes, _path = _attributes._ES5ProxyType ? _attributes.get("path") : _attributes.path)));
          }

          return {
            route: route,
            data: info._ES5ProxyType ? info.get("data") : info.data
          };
        }
        /**
         * Default implementation: f(route) -> { url: url || null, data: routeDef }
         * Prefix the result with the parent's match and this router's base path, to return a full URL.
         *
         * @param {object} route - Route to translate into a URL
         *
         * @returns {object} - { string: url, object: data }
         */

      }, {
        key: "defaultGetUrlFromRoute",
        value: function defaultGetUrlFromRoute(route) {
          // If the route is Simple, the URL is absolute, so do not add the prefix.
          var prefix = isSimpleRoute(route) ? '' : this._ES5ProxyType ? this.get("prefix") : this.prefix;
          var info = getUrlFromRoute(route, this._ES5ProxyType ? this.get("routes") : this.routes);
          return {
            url: (info._ES5ProxyType ? info.get("url") : info.url) ? __concat(__concat("", prefix), info._ES5ProxyType ? info.get("url") : info.url) : null,
            data: info._ES5ProxyType ? info.get("data") : info.data
          };
        }
        /***** State change processing *****/

        /**
         * Override parent implementation.
         * Pass the current state down to any new children.
         *
         * @param {child} child - Child router
         */

      }, {
        key: "addChild",
        value: function () {
          var _addChild = _asyncToGenerator(
          /*#__PURE__*/
          __callKey1(_regeneratorRuntime, "mark", function _callee(child) {
            return __callKey3(_regeneratorRuntime, "wrap", function _callee$(_context) {
              while (1) {
                switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
                  case 0:
                    __callKey2(_get(_getPrototypeOf(Router._ES5ProxyType ? Router.get("prototype") : Router.prototype), "addChild", this), "call", this, child);

                    __setKey(_context, "t0", this._ES5ProxyType ? this.get("currentUrl") : this.currentUrl);

                    if (!(_context._ES5ProxyType ? _context.get("t0") : _context.t0)) {
                      __setKey(_context, "next", 6);

                      break;
                    }

                    __setKey(_context, "next", 5);

                    return __callKey1(child, "preProcess", this._ES5ProxyType ? this.get("currentUrl") : this.currentUrl);

                  case 5:
                    __setKey(_context, "t0", _context._ES5ProxyType ? _context.get("sent") : _context.sent);

                  case 6:
                    if (!(_context._ES5ProxyType ? _context.get("t0") : _context.t0)) {
                      __setKey(_context, "next", 8);

                      break;
                    }

                    __callKey1(child, "process", this._ES5ProxyType ? this.get("currentUrl") : this.currentUrl);

                  case 8:
                  case "end":
                    return __callKey0(_context, "stop");
                }
              }
            }, _callee, this);
          }));

          function addChild(_x) {
            return __callKey2(_addChild, "apply", this, arguments);
          }

          return addChild;
        }()
        /**
         * Process the current URL passed down by the parent router.
         * Stop propagation of the navigation event if any preNavigate filter returns false.
         *
         * Update the current path and route matches.
         * Update the observable to hold the new route.
         *
         * After processing, delegate to a child router, if it exists.
         *
         * @param {string} url - Relative URL string to process
         * @param {*} options - Navigation options (e.g. shouldReplace)
         *
         * @returns {boolean} - True if the processing was NOT blocked by a preNavigate listener
         */

      }, {
        key: "process",
        value: function () {
          var _process = _asyncToGenerator(
          /*#__PURE__*/
          __callKey1(_regeneratorRuntime, "mark", function _callee2(url, options) {
            var info, route, canContinue;
            return __callKey3(_regeneratorRuntime, "wrap", function _callee2$(_context2) {
              while (1) {
                switch (__setKey(_context2, "prev", _context2._ES5ProxyType ? _context2.get("next") : _context2.next)) {
                  case 0:
                    info = freeze$1(__callKey1(this, "getRouteFromUrl", url));
                    route = freeze$1(info._ES5ProxyType ? info.get("route") : info.route); // Run the root -> leaf chain of pre navigate filters, if this is the root.

                    __setKey(_context2, "t0", !(this._ES5ProxyType ? this.get("isRoot") : this.isRoot));

                    if (_context2._ES5ProxyType ? _context2.get("t0") : _context2.t0) {
                      __setKey(_context2, "next", 7);

                      break;
                    }

                    __setKey(_context2, "next", 6);

                    return __callKey2(this, "preProcess", url, info);

                  case 6:
                    __setKey(_context2, "t0", _context2._ES5ProxyType ? _context2.get("sent") : _context2.sent);

                  case 7:
                    canContinue = _context2._ES5ProxyType ? _context2.get("t0") : _context2.t0;

                    if (!(canContinue._ES5ProxyType ? canContinue.get("message") : canContinue.message)) {
                      __setKey(_context2, "next", 11);

                      break;
                    }

                    // If the pre navigate filters failed, an error message object is returned.
                    // Pass the errors, and return.
                    __callKey1(this, "processError", canContinue);

                    return __callKey2(_context2, "abrupt", "return", false);

                  case 11:
                    __setKey(_context2, "next", 13);

                    return __callKey1(this._ES5ProxyType ? this.get("postFilters") : this.postFilters, "compile", {
                      previous: this._ES5ProxyType ? this.get("infoMatch") : this.infoMatch,
                      current: info
                    });

                  case 13:
                    __setKey(this, "infoMatch", info);

                    __setKey(this, "currentUrl", url);

                    __callKey2(this._ES5ProxyType ? this.get("routeObservable") : this.routeObservable, "next", route, freeze$1(info._ES5ProxyType ? info.get("data") : info.data)); // Delegate to a child.


                    if (this._ES5ProxyType ? this.get("child") : this.child) {
                      __callKey2(this._ES5ProxyType ? this.get("child") : this.child, "process", url, options);
                    }

                    return __callKey2(_context2, "abrupt", "return", true);

                  case 18:
                  case "end":
                    return __callKey0(_context2, "stop");
                }
              }
            }, _callee2, this);
          }));

          function process(_x2, _x3) {
            return __callKey2(_process, "apply", this, arguments);
          }

          return process;
        }()
        /**
         * Run the preNavigate filters for this router.
         * After processing, delegate to a child router, if it exists.
         *
         * @param {string} url - Relative URL string to process,
         *                   cannot use a route since the processing is done in context
         * @param {object} info - { route, data }, where data is the route definition by default
         * @param {object} info.route - Route to process
         * @param {object} info.data - Additional data, route definition by default
         *
         * @returns {Promise<boolean>} - Resolves to true if successful
         */

      }, {
        key: "preProcess",
        value: function preProcess(url) {
          var _this4 = this,
              _this$getUrlFromRoute,
              _url,
              _parent,
              _pathMatch;

          var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : freeze$1(__callKey1(this, "getRouteFromUrl", url));
          var route = freeze$1(info._ES5ProxyType ? info.get("route") : info.route); // Check that the URL has a matching route, otherwise it is an error.

          if (route === null) {
            return Promise.resolve(generateMessageObject(messages._ES5ProxyType ? messages.get("MISSING_ROUTE") : messages.MISSING_ROUTE, [url]));
          } // Set this router's current matching path, Simple Routes pass on the parent match.


          __setKey(this, "pathMatch", !isSimpleRoute(route) ? getPathFromUrl((_this$getUrlFromRoute = __callKey1(this, "getUrlFromRoute", route), _url = _this$getUrlFromRoute._ES5ProxyType ? _this$getUrlFromRoute.get("url") : _this$getUrlFromRoute.url) || '') : (this._ES5ProxyType ? this.get("parent") : this.parent) ? (_parent = this._ES5ProxyType ? this.get("parent") : this.parent, _pathMatch = _parent._ES5ProxyType ? _parent.get("pathMatch") : _parent.pathMatch) : ''); // Compile this router's filters; continue with TRUE if there are no filters.


          var canGo = __callKey0(this._ES5ProxyType ? this.get("preFilters") : this.preFilters, "empty") ? Promise.resolve(true) : __callKey1(this._ES5ProxyType ? this.get("preFilters") : this.preFilters, "compile", {
            current: this._ES5ProxyType ? this.get("infoMatch") : this.infoMatch,
            next: info
          }); // If the filters pass, run its child's filters.

          return __callKey1(__callKey1(canGo, "then", function (canContinue) {
            return canContinue && (_this4._ES5ProxyType ? _this4.get("child") : _this4.child) ? __callKey1(_this4._ES5ProxyType ? _this4.get("child") : _this4.child, "preProcess", url) : canContinue;
          }) // Craft an error message, if the filters have returned false.
          , "then", function (canContinue) {
            return canContinue ? canContinue : generateMessageObject(messages._ES5ProxyType ? messages.get("PRENAV_FAILED") : messages.PRENAV_FAILED, [url]);
          });
        }
        /**
         * Run the errorNavigate filters for this router.
         * After processing, delegate to a child router, if it exists.
         *
         * @param {object} e - An error object to pass into the error hook listeners.
         */

      }, {
        key: "processError",
        value: function processError(e) {
          __callKey1(this._ES5ProxyType ? this.get("errorFilters") : this.errorFilters, "compile", e);

          if (this._ES5ProxyType ? this.get("child") : this.child) {
            __callKey1(this._ES5ProxyType ? this.get("child") : this.child, "processError", e);
          }
        }
        /***** lightning/navigation APIs *****/

        /**
         * lightning/navigation
         * Fire an event to send the navigation event up the DOM.
         * The root router will be the last to catch the event if it is not stopped.
         *
         * @param {string | object} input - URL string or route to navigate to
         * @param {*} options - Usually a boolean; when true the previous browser history
         *                    entry should be replaced by this one
         */

      }, {
        key: "navigate",
        value: function navigate(input, options) {
          var _this$getUrlFromRoute2, _url2;

          // Ensure there is a string URL to pass to the navigation event.
          var url = typeof input === 'string' ? input : (_this$getUrlFromRoute2 = __callKey1(this, "getUrlFromRoute", input), _url2 = _this$getUrlFromRoute2._ES5ProxyType ? _this$getUrlFromRoute2.get("url") : _this$getUrlFromRoute2.url); // Check that a given route has a matching URL, otherwise it is an error.
          // We check the route => url conversion in this receiving context.

          if (url === null) {
            __callKey1(this._ES5ProxyType ? this.get("root") : this.root, "processError", generateMessageObject(messages._ES5ProxyType ? messages.get("MISSING_URL") : messages.MISSING_URL, [(input._ES5ProxyType ? input.get("id") : input.id) || (input._ES5ProxyType ? input.get("type") : input.type)]));

            return;
          } // Fire event up the DOM with the original caller input


          __callKey1(this._ES5ProxyType ? this.get("node") : this.node, "dispatchEvent", new CustomEvent(NavNode$1._ES5ProxyType ? NavNode$1.get("navigationEvent") : NavNode$1.navigationEvent, {
            bubbles: true,
            composed: true,
            detail: {
              url: url,
              options: options,
              input: input
            }
          }));
        }
        /**
         * lightning/navigation
         * Generate a URL based on the given route.
         * Return a Promise containing the URL string.
         *
         * @param   {object} route - Route to generate a url for
         *
         * @returns {Promise<string>}
         */

      }, {
        key: "generateUrl",
        value: function generateUrl(route) {
          var info = __callKey1(this, "getUrlFromRoute", route);

          return Promise.resolve((info._ES5ProxyType ? info.get("url") : info.url) || '');
        }
        /**
         * lightning/navigation
         * Subscribe a callback to the Observable on the current route of this router.
         *
         * @param {function} callback - A callback function invoked when the navigation state changes
         *                     callback(route, routeDef)
         * @param {boolean} replay - Flag to determine if callback should be called with current route and data immediately
         */

      }, {
        key: "subscribe",
        value: function subscribe(callback, replay) {
          return __callKey2(this._ES5ProxyType ? this.get("routeObservable") : this.routeObservable, "subscribe", {
            next: function next(route, data) {
              return callback(route, data);
            }
          }, replay);
        }
      }, {
        key: "prefix",
        get: function get() {
          var _parent2, _pathMatch2;

          return __concat(__concat("", (this._ES5ProxyType ? this.get("parent") : this.parent) ? (_parent2 = this._ES5ProxyType ? this.get("parent") : this.parent, _pathMatch2 = _parent2._ES5ProxyType ? _parent2.get("pathMatch") : _parent2.pathMatch) : ''), this._ES5ProxyType ? this.get("basePath") : this.basePath);
        }
      }]);

      return Router;
    }(NavNode$1);

    registerDecorators(Router, {
      fields: ["basePath", "routes", "caseSensitive", "pathMatch", "infoMatch", "currentUrl", "routeObservable", "preFilters", "postFilters", "errorFilters"]
    });

    var Router$1 = registerComponent(Router, {
      tmpl: _tmpl
    });

    /*
     * Provides a Router rooted to the window, which controls the browser history by default.
     */

    var HistoryRouter =
    /*#__PURE__*/
    function (_Router) {
      _inherits(HistoryRouter, _Router);

      function HistoryRouter() {
        _classCallCheck(this, HistoryRouter);

        return _possibleConstructorReturn(this, __callKey2(_getPrototypeOf(HistoryRouter), "apply", this, arguments));
      }

      _createClass(HistoryRouter, [{
        key: "connect",

        /**
         * Override.
         * Initialize with the current route and listen to the popstate event for future changes.
         */
        value: function connect() {
          var _this = this,
              _location2,
              _href2;

          __callKey1(_get(_getPrototypeOf(HistoryRouter._ES5ProxyType ? HistoryRouter.get("prototype") : HistoryRouter.prototype), "connect", this), "call", this); // Subscribe to the Window.popstate event to listen for URL changes.


          __callKey2(window, "addEventListener", 'popstate', function () {
            var _location, _href;

            __callKey1(_this, "catchBrowserUpdate", getRelativeUrl((_location = document._ES5ProxyType ? document.get("location") : document.location, _href = _location._ES5ProxyType ? _location.get("href") : _location.href)));
          });

          __callKey1(this, "catchBrowserUpdate", getRelativeUrl((_location2 = document._ES5ProxyType ? document.get("location") : document.location, _href2 = _location2._ES5ProxyType ? _location2.get("href") : _location2.href)));
        }
        /***** Route Update *****/

        /**
         * Override.
         * Update the browser history if the preNavigate hooks.
         *
         * @param {string} url - The URL to go to
         * @param {boolean} shouldReplace - True if the current history state should be replaced
         * @param {boolean} updateHistory - True if the browser history should be updated with the new URL
         *
         * @returns {boolean} - True if the processing was NOT blocked by a preNavigate listener
         */

      }, {
        key: "process",
        value: function () {
          var _process = _asyncToGenerator(
          /*#__PURE__*/
          __callKey1(_regeneratorRuntime, "mark", function _callee(url, shouldReplace) {
            var updateHistory,
                canContinue,
                pathWithQuery,
                _args = arguments;
            return __callKey3(_regeneratorRuntime, "wrap", function _callee$(_context) {
              while (1) {
                switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
                  case 0:
                    updateHistory = (_args._ES5ProxyType ? _args.get("length") : _args.length) > 2 && (_args._ES5ProxyType ? _args.get(2) : _args[2]) !== undefined ? _args._ES5ProxyType ? _args.get(2) : _args[2] : true;

                    __setKey(_context, "next", 3);

                    return __callKey3(_get(_getPrototypeOf(HistoryRouter._ES5ProxyType ? HistoryRouter.get("prototype") : HistoryRouter.prototype), "process", this), "call", this, url, shouldReplace);

                  case 3:
                    canContinue = _context._ES5ProxyType ? _context.get("sent") : _context.sent;

                    if (canContinue && updateHistory) {
                      // Ensure the URL is basePath + a relative path + the query string.
                      pathWithQuery = __callKey1(url, "indexOf", this._ES5ProxyType ? this.get("basePath") : this.basePath) === 0 ? url : __concat(__concat("", this._ES5ProxyType ? this.get("basePath") : this.basePath), url); // Update the window history.

                      if (shouldReplace) {
                        replace(pathWithQuery);
                      } else {
                        set(pathWithQuery);
                      }
                    }

                    return __callKey2(_context, "abrupt", "return", canContinue);

                  case 6:
                  case "end":
                    return __callKey0(_context, "stop");
                }
              }
            }, _callee, this);
          }));

          function process(_x, _x2) {
            return __callKey2(_process, "apply", this, arguments);
          }

          return process;
        }()
        /**
         * Update the root route, and trickle down the router tree.
         * Redirect to use the base path, if it is missing.
         *
         * @param {string} url - The URL to go to
         */

      }, {
        key: "catchBrowserUpdate",
        value: function catchBrowserUpdate(url) {
          var baseMissing = (this._ES5ProxyType ? this.get("basePath") : this.basePath) && __callKey1(url, "indexOf", this._ES5ProxyType ? this.get("basePath") : this.basePath) !== 0;

          __callKey3(this, "process", __concat(__concat("", baseMissing ? this._ES5ProxyType ? this.get("basePath") : this.basePath : ''), url), baseMissing, baseMissing);
        }
      }]);

      return HistoryRouter;
    }(Router$1);

    var HistoryRouter$1 = registerComponent(HistoryRouter, {
      tmpl: _tmpl
    });

    /*
     * Provides programmatic routing capabilities.
     */
    // The application may create 1 root router at a time.

    var hasRoot = false;
    /**
     * Create a new navigation context, attach to the given node.
     * An application can only have ONE root router.
     *
     * @param {HTMLElement} - The DOM node where the navigation context should be established
     * @param {object} config - The router config object, all properties are optional
     * @param {string} config.basePath - This router's base path
     * @param {object[]} config.routes - Array of route definitions
     * @param {string} config.handleNavigation - handleNavigation event handler override
     * @param {string} config.getRouteFromUrl - route => URL translation override
     * @param {string} config.getUrlFromRoute - URL => route translation override
     * @param {boolean} config.noHistory - True if the Router should NOT manage the browser history
     * @param {boolean} config.caseSensitive - When true, the route definition path matching will be case sensitive.
     *
     *
     * @returns {object} - { addPreNavigate, addPostNavigate, addErrorNavigate, connect, disconnect }
     */

    function createNavigationContext(node) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Create a Router, or a HistoryRouter if noHistory is true.
      var newRouter = (config._ES5ProxyType ? config.get("noHistory") : config.noHistory) === true ? // Create a basic Router.
      new Router$1(config, node) : // HistoryRouters manage browser history.
      new HistoryRouter$1(config, node); // Return a subset of the new router's capabilities.

      var routerAPI = {
        /**
         * Surface the preNavigate hook register function.
         *
         * @param {function} listener - The preNavigate hook listener function
         * @returns {object} - This bag of Router functions, for chaining
         */
        addPreNavigate: function addPreNavigate(listener) {
          __callKey1(newRouter, "addPreNavigate", listener);

          return routerAPI;
        },

        /**
         * Surface the postNavigate hook register function.
         *
         * @param {function} listener - The postNavigate hook listener function
         * @returns {object} - This bag of Router functions, for chaining
         */
        addPostNavigate: function addPostNavigate(listener) {
          __callKey1(newRouter, "addPostNavigate", listener);

          return routerAPI;
        },

        /**
         * Surface the errorNavigate hook register function.
         *
         * @param {function} listener - The errorNavigate hook listener function
         * @returns {object} - This bag of Router functions, for chaining
         */
        addErrorNavigate: function addErrorNavigate(listener) {
          __callKey1(newRouter, "addErrorNavigate", listener);

          return routerAPI;
        },

        /**
         * Connect the root router if there isn't already one connected.
         */
        connect: function connect() {
          var _contextConnection, _id;

          // Connect and expose this router's navigation context.
          __callKey0(newRouter, "connect"); // If there is already a root router, the new router must be a child (have a parent).


          invariant$2(!hasRoot || !!(newRouter._ES5ProxyType ? newRouter.get("parent") : newRouter.parent), messages._ES5ProxyType ? messages.get("MULTIPLE_ROOTS") : messages.MULTIPLE_ROOTS);
          hasRoot = hasRoot || !(newRouter._ES5ProxyType ? newRouter.get("parent") : newRouter.parent);

          __setKey(routerAPI, "id", (_contextConnection = newRouter._ES5ProxyType ? newRouter.get("contextConnection") : newRouter.contextConnection, _id = _contextConnection._ES5ProxyType ? _contextConnection.get("id") : _contextConnection.id));
        },

        /**
         * Disconnect the router, and reset the root tracking variable.
         */
        disconnect: function disconnect() {
          __callKey0(newRouter, "disconnect");
        }
      }; // Return the public Router functions.

      return routerAPI;
    }
    /**
     * Create a new root Router, attach to the Window.
     * This is the public, programmitic API for root router creation.
     * An application can only have ONE root router.
     *
     * @param {object} config - The router config object
     *
     * @returns {object} - { addPreNavigate, addPostNavigate, addErrorNavigate, connect, disconnect }
     */

    function createRouter() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return createNavigationContext(window, config);
    }

    /**
     * Navigate programmatically.
     * The Promise used within is deliberately not returned.
     *
     * @param {HTMLElement} context - The navigation context
     * @param {object | string} loc - A route or URL for navigating
     * @param {*} options - Usually a boolean; when true the previous browser history
     *              entry should be replaced by this one
     */

    function navigate(context, loc, options) {
      var api = getNavigationContext(context);

      __callKey2(api, "navigate", loc, options);
    }
    /**
     * Generate a URL for the given route.
     *
     * @param {HTMLElement} context - The navigation context
     * @param {object} route - A route
     *
     * @returns {Promise<string>}
     */

    function generateUrl(context, route) {
      var api = getNavigationContext(context);
      return __callKey1(api, "generateUrl", route);
    }
    /**
     * Subscribe to navigation state changes.
     *
     * @param {HTMLElement} context - The navigation context
     * @param {function} callback - A callback function invoked when the navigation state changes
     *                     callback(route, routeDef)
     * @param {boolean} replay - Flag to determine if callback should be called with current route and data immediately
     */

    function subscribe(context, callback) {
      var replay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var api = getNavigationContext(context);
      return __callKey2(api, "subscribe", callback, replay);
    }

    var navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        navigate: navigate,
        generateUrl: generateUrl,
        subscribe: subscribe,
        NavigationContext: NavigationContext,
        provideContext: provideContext,
        createRouter: createRouter
    });

    var defaultRouteDef = __callKey1(routes, "find", function (route) {
      return route._ES5ProxyType ? route.get("isDefault") : route.isDefault;
    });

    var config = {
      basePath: basePath,
      caseSensitive: true,
      routes: routes,
      handleNavigation: handleNavigation,
      getRouteFromUrl: getRouteFromUrl$1,
      getUrlFromRoute: getUrlFromRoute$1
    }; // create, configure and start the router

    var router = __callKey1(__callKey1(createRouter(config), "addPreNavigate", isAuthorized), "addErrorNavigate", handleError);

    __callKey0(router, "connect");
    /**
     * When navigating to a standard__webPage typed route, open absolute URLs directly.
     * Then block propagation of the navigation event up the router tree.
     *
     * @param {object | string} route - The input to navigate(), could be a string URL or a route object
     */


    function handleNavigation(route) {
      if (isObject$3(route)) {
        var type = route._ES5ProxyType ? route.get("type") : route.type,
            _route$attributes = route._ES5ProxyType ? route.get("attributes") : route.attributes;

        _route$attributes = _route$attributes === void 0 ? {
          url: null
        } : _route$attributes;
        var url = _route$attributes._ES5ProxyType ? _route$attributes.get("url") : _route$attributes.url;

        if (type === 'standard__webPage' && isAbsoluteURL(url)) {
          __callKey1(window, "open", url);

          return false;
        }
      }

      return true;
    }
    /**
     * Override the default URL => route translation
     *
     * @param {string} url - A URL to transform into a route
     * @param {function} defaultImpl - The default implementation of the getRouteFromUrl function
     *
     * @returns {object} - { route: route object, data: route definition object }
     */


    function getRouteFromUrl$1(url, defaultImpl) {
      var _defaultImpl = defaultImpl(url),
          route = _defaultImpl._ES5ProxyType ? _defaultImpl.get("route") : _defaultImpl.route,
          data = _defaultImpl._ES5ProxyType ? _defaultImpl.get("data") : _defaultImpl.data; // Return the default route if no match is found for the URL


      if ((route._ES5ProxyType ? route.get("type") : route.type) === 'standard__simpleRoute') {
        data = defaultRouteDef;
      } // Move filterName attribute to state for on-core standard__objectPages


      if ((route._ES5ProxyType ? route.get("type") : route.type) === 'standard__objectPage' && __callKey1(data._ES5ProxyType ? data.get("path") : data.path, "includes", 'filterName')) {
        route = transferProperty(route, 'state', 'attributes', 'filterName', 'Default');
      } // Move attribute.term to state.term for on-core standard__search


      if ((route._ES5ProxyType ? route.get("type") : route.type) === 'standard__search' && __callKey1(data._ES5ProxyType ? data.get("path") : data.path, "includes", 'term')) {
        route = transferProperty(route, 'state', 'attributes', 'term', ' ');
      }

      return {
        route: route,
        data: data
      };
    }
    /**
     * Override the default route => URL translation
     *
     * @param {object} route - A route to transform into a URL, including the queryParams as 'state'
     * @param {function} defaultImpl - The default implementation of the getUrlFromRoute function
     *
     * @returns {object} - { url: string URL, data: route definition object }
     */


    function getUrlFromRoute$1() {
      var _defaultImpl2, _url, _defaultImpl3, _url2;

      var route = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultImpl = arguments.length > 1 ? arguments[1] : undefined;

      var _route = route,
          type = _route._ES5ProxyType ? _route.get("type") : _route.type,
          _route$attributes2 = _route._ES5ProxyType ? _route.get("attributes") : _route.attributes;

      _route$attributes2 = _route$attributes2 === void 0 ? {} : _route$attributes2;
      var url = _route$attributes2._ES5ProxyType ? _route$attributes2.get("url") : _route$attributes2.url; // Return URL directly from standard__webPage types

      if (type === 'standard__webPage') {
        return {
          url: url ? addBasePath(url) : null,
          data: null
        };
      } // Move filterName state to attributes for on-core standard__objectPages


      if (type === 'standard__objectPage' && !(_defaultImpl2 = defaultImpl(route), _url = _defaultImpl2._ES5ProxyType ? _defaultImpl2.get("url") : _defaultImpl2.url)) {
        route = transferProperty(route, 'attributes', 'state', 'filterName', 'Default');
      } // Move state.term to attributes.term for on-core standard__search


      if (type === 'standard__search' && !(_defaultImpl3 = defaultImpl(route), _url2 = _defaultImpl3._ES5ProxyType ? _defaultImpl3.get("url") : _defaultImpl3.url)) {
        route = transferProperty(route, 'attributes', 'state', 'term', ' ');
      }

      return defaultImpl(route);
    }
    /**
     * Is the current user allowed to open this route (page)
     * Public routes -> all users are allowed, Private routes -> only authenticated users
     *
     * If isPublic is not defined on routes -> isAuthorized will always return true
     * @param {object} obj - A transaction object
     * @param {object} obj.next - The information that is next in line for navigation
     * @param {object} obj.next.route - The next route
     * @param {object} obj.next.data - The next route definition
     *
     * @returns {boolean}
     */


    function isAuthorized() {
      return __callKey2(_isAuthorized, "apply", this, arguments);
    }
    /**
     * Handle any navigation error
     *
     * @param {object} error - An error message object
     * @param {string} error.code - An error code
     * @param {int} error.level - An error level
     * @param {string} error.message - An error message
     * @param {string} error.url - The destination URL for which the error occurred, or empty string if not applicable
     */


    function _isAuthorized() {
      _isAuthorized = _asyncToGenerator(
      /*#__PURE__*/
      __callKey1(_regeneratorRuntime, "mark", function _callee() {
        var _ref2,
            _ref2$next,
            route,
            data,
            url,
            _args = arguments;

        return __callKey2(_regeneratorRuntime, "wrap", function _callee$(_context) {
          while (1) {
            switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
              case 0:
                _ref2 = (_args._ES5ProxyType ? _args.get("length") : _args.length) > 0 && (_args._ES5ProxyType ? _args.get(0) : _args[0]) !== undefined ? _args._ES5ProxyType ? _args.get(0) : _args[0] : {}, _ref2$next = _ref2._ES5ProxyType ? _ref2.get("next") : _ref2.next;
                _ref2$next = _ref2$next === void 0 ? {} : _ref2$next;
                route = _ref2$next._ES5ProxyType ? _ref2$next.get("route") : _ref2$next.route, data = _ref2$next._ES5ProxyType ? _ref2$next.get("data") : _ref2$next.data;

                if (!(isGuest && __inKey(data, 'isPublic') && !(data._ES5ProxyType ? data.get("isPublic") : data.isPublic))) {
                  __setKey(_context, "next", 9);

                  break;
                }

                __setKey(_context, "next", 6);

                return generateUrl$1(route);

              case 6:
                url = _context._ES5ProxyType ? _context.get("sent") : _context.sent;

                if (url) {
                  __setKey(window._ES5ProxyType ? window.get("location") : window.location, "href", __concat("", url));
                }

                return __callKey2(_context, "abrupt", "return", false);

              case 9:
                return __callKey2(_context, "abrupt", "return", true);

              case 10:
              case "end":
                return __callKey0(_context, "stop");
            }
          }
        }, _callee);
      }));
      return __callKey2(_isAuthorized, "apply", this, arguments);
    }

    function handleError(_ref) {
      var code = _ref._ES5ProxyType ? _ref.get("code") : _ref.code,
          message = _ref._ES5ProxyType ? _ref.get("message") : _ref.message,
          url = _ref._ES5ProxyType ? _ref.get("url") : _ref.url;
      // if navigation fails, go to the Error page (aka the "default" route)
      navigate$1(defaultRouteDef);
      throw new Error(__concat(__concat(__concat("Routing error: (", code, ") "), message, " "), url));
    }
    /**
     * Check whether url is absolute url
     *
     * @param {string} url - the url
     */


    function isAbsoluteURL(url) {
      return __callKey1(new RegExp('^([a-z]+://|//)', 'i'), "test", url);
    }
    /**
     * Normalize a given absolute path with the base path.
     *
     * @param {string} url - A URL to be normalized
     */


    function addBasePath(url) {
      if (isAbsoluteURL(url)) {
        return url;
      }

      var baseMissing = basePath && url !== basePath && __callKey1(url, "indexOf", __concat("", basePath, "/")) !== 0;
      return baseMissing ? __concat(__concat("", basePath), url) : url;
    }
    /* Compose the routing APIs with this router's navigation context ID
           This way, Web Runtime API users do not need to know about navigation context
           APIs: navigate, generateUrl, subscribe            */

    /**
     * Navigate programmatically.
     *
     * @param {object | string} loc - A route or URL for navigating
     * @param {*} options - Usually a boolean; when true the previous browser history
     *              entry should be replaced by this one
     */


    function navigate$1(loc, options) {
      navigate(router._ES5ProxyType ? router.get("id") : router.id, loc, options);
    }
    /**
     * Generate a URL for the given route.
     *
     * @param {object} route - A route
     *
     * @returns {Promise<string>}
     */


    function generateUrl$1(route) {
      return generateUrl(router._ES5ProxyType ? router.get("id") : router.id, route);
    }
    /**
     * Subscribe to navigation state changes.
     *
     * @param {function} callback - A callback function invoked when the navigation state changes
     *                     callback(route, routeDef)
     * @param {boolean} replay - Flag to determine if callback should be called with current route and data immediately
     */


    function subscribe$1(callback) {
      var replay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      subscribe(router._ES5ProxyType ? router.get("id") : router.id, callback, replay);
    } // export select functions from this instance

    var routingService = /*#__PURE__*/Object.freeze({
        __proto__: null,
        navigate: navigate$1,
        generateUrl: generateUrl$1,
        subscribe: subscribe$1
    });

    var prefix = "/services/data/v49.0";
    var auraMethodToResourceReferenceMapping = {
      // Fetch standard field data, custom field data, and enrichment data for a single Product
      "CommerceCatalogController.getProductCategoryPath": {
        "urlPath": prefix + "/commerce/webstores/${webstoreId}/product-category-path/product-categories/${productCategoryId}",
        "urlPathParamNames": ["productCategoryId", "webstoreId"],
        "method": "GET"
      },
      // Fetch standard field data, custom field data, and enrichment data for a single Product
      "CommerceCatalogController.getProduct": {
        "urlPath": prefix + "/commerce/webstores/${webstoreId}/products/${productId}",
        "urlPathParamNames": ["productId", "webstoreId"],
        "method": "GET"
      },
      // Get the list price and buyer price for a product in the context of a Web Store for the given account and currency
      "CommerceStorePricingController.getProductPrice": {
        "urlPath": prefix + "/commerce/webstores/${webstoreId}/pricing/products/${productId}",
        "urlPathParamNames": ["productId", "webstoreId"],
        "method": "GET"
      },
      // Start a job to purge Missions activities for a user.
      "MissionsController.purgeUserMissionsActivities": {
        "urlPath": prefix + "/connect/communities/${communityId}/missions/activities/purge-job",
        "urlPathParamNames": ["communityId"],
        "method": "POST"
      },
      // Search for products in a webstore.
      "CommerceProductSearchController.productSearch": {
        "urlPath": prefix + "/commerce/webstores/${webstoreId}/search/product-search",
        "urlPathParamNames": ["webstoreId"],
        "inputRepresentation": "productSearchInput",
        "method": "POST"
      },
      // Get all the navigation menu items
      "NavigationMenuController.getCommunityNavigationMenu": {
        "urlPath": prefix + "/connect/communities/${communityId}/navigation-menu/navigation-menu-items",
        "urlPathParamNames": ["communityId"],
        "method": "GET"
      },
      // Retrieve a Quick Action layout.
      "ActionsController.getActionLayout": {
        "urlPath": prefix + "/ui-api/actions/layout/${actionApiName}",
        "urlPathParamNames": ["actionApiName"],
        "method": "GET"
      },
      // Retrieve presentation-ready action data about specific list-view listViewIds.
      "ActionsController.getListViewActions": {
        "urlPath": prefix + "/ui-api/actions/list-view/${listViewIds}",
        "urlPathParamNames": ["listViewIds"],
        "method": "GET"
      },
      // Retrieve presentation-ready action data about specific lookup objectApiNames.
      "ActionsController.getLookupActions": {
        "urlPath": prefix + "/ui-api/actions/lookup/${objectApiNames}",
        "urlPathParamNames": ["objectApiNames"],
        "method": "GET"
      },
      // Retrieve presentation-ready action data about specific mru-list objectApiNames.
      "ActionsController.getMRUListActions": {
        "urlPath": prefix + "/ui-api/actions/mru-list/${objectApiNames}",
        "urlPathParamNames": ["objectApiNames"],
        "method": "GET"
      },
      // Retrieve presentation-ready action data about specific recordId under the RecordEdit subcontext.
      "ActionsController.getRecordEditActions": {
        "urlPath": prefix + "/ui-api/actions/record/${recordIds}/record-edit",
        "urlPathParamNames": ["recordIds"],
        "method": "GET"
      },
      // Retrieve presentation-ready action data about specific recordIds.
      "ActionsController.getRecordActions": {
        "urlPath": prefix + "/ui-api/actions/record/${recordIds}",
        "urlPathParamNames": ["recordIds"],
        "method": "GET"
      },
      // Retrieve presentation-ready action data about specific recordId under the related-list-record relatedListRecordIds.
      "ActionsController.getRelatedListRecordActions": {
        "urlPath": prefix + "/ui-api/actions/record/${recordIds}/related-list-record/${relatedListRecordIds}",
        "urlPathParamNames": ["recordIds", "relatedListRecordIds"],
        "method": "GET"
      },
      // Retrieve presentation-ready action data about specific recordId for the RelatedList subcontexts relatedListIds.
      "ActionsController.getRelatedListActions": {
        "urlPath": prefix + "/ui-api/actions/record/${recordIds}/related-list/${relatedListIds}",
        "urlPathParamNames": ["recordIds", "relatedListIds"],
        "method": "GET"
      },
      // Retrieve lists for a given objectApiName.
      "ListUiController.getListsByObjectName": {
        "urlPath": prefix + "/ui-api/list-ui/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Retrieve list info.
      "ListUiController.getListInfoById": {
        "urlPath": prefix + "/ui-api/list-info/${listViewId}",
        "urlPathParamNames": ["listViewId"],
        "method": "GET"
      },
      // Retrieve list info.
      "ListUiController.getListInfoByName": {
        "urlPath": prefix + "/ui-api/list-info/${objectApiName}/${listViewApiName}",
        "urlPathParamNames": ["listViewApiName", "objectApiName"],
        "method": "GET"
      },
      // Returns record data to populate a list.
      "ListUiController.getListRecordsById": {
        "urlPath": prefix + "/ui-api/list-records/${listViewId}",
        "urlPathParamNames": ["listViewId"],
        "method": "GET"
      },
      // Returns record data to populate a list.
      "ListUiController.getListRecordsByName": {
        "urlPath": prefix + "/ui-api/list-records/${objectApiName}/${listViewApiName}",
        "urlPathParamNames": ["listViewApiName", "objectApiName"],
        "method": "GET"
      },
      // Retrieve list data and info.
      "ListUiController.getListUiById": {
        "urlPath": prefix + "/ui-api/list-ui/${listViewId}",
        "urlPathParamNames": ["listViewId"],
        "method": "GET"
      },
      // Retrieve list data and info.
      "ListUiController.getListUiByName": {
        "urlPath": prefix + "/ui-api/list-ui/${objectApiName}/${listViewApiName}",
        "urlPathParamNames": ["listViewApiName", "objectApiName"],
        "method": "GET"
      },
      // Returns record search results for the given lookup field.
      "LookupController.getLookupRecords": {
        "urlPath": prefix + "/ui-api/lookups/${objectApiName}/${fieldApiName}/${targetApiName}",
        "urlPathParamNames": ["fieldApiName", "objectApiName", "targetApiName"],
        "method": "GET"
      },
      // Retrieve MRU list info.
      "MruListUiController.getMruListInfo": {
        "urlPath": prefix + "/ui-api/mru-list-info/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Returns record data to populate an MRU list.
      "MruListUiController.getMruListRecords": {
        "urlPath": prefix + "/ui-api/mru-list-records/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Retrieve MRU list data and info.
      "MruListUiController.getMruListUi": {
        "urlPath": prefix + "/ui-api/mru-list-ui/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Retrieve presentation-ready metadata and data.
      "RecordUiController.getAggregateUi": {
        "urlPath": prefix + "/ui-api/aggregate-ui",
        "urlPathParamNames": [],
        "method": "GET"
      },
      // Executes multiple requests within a single request
      "RecordUiController.executeAggregateUi": {
        "urlPath": prefix + "/ui-api/aggregate-ui",
        "urlPathParamNames": [],
        "inputRepresentation": "input",
        "method": "POST"
      },
      // Retrieve record data for a list of recordIds.
      "RecordUiController.getRecordsWithFields": {
        "urlPath": prefix + "/ui-api/records/batch/${recordIds}",
        "urlPathParamNames": ["recordIds"],
        "method": "GET"
      },
      // Retrieve record data for a list of recordIds.
      "RecordUiController.getRecordsWithLayouts": {
        "urlPath": prefix + "/ui-api/records/batch/${recordIds}",
        "urlPathParamNames": ["recordIds"],
        "method": "GET"
      },
      // Get duplicate management configuration for a specific entity object
      "RecordUiController.getDedupeConfig": {
        "urlPath": prefix + "/ui-api/duplicates/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Retrieve a specific form by name.
      "RecordUiController.getFormByName": {
        "urlPath": prefix + "/ui-api/forms/${apiName}",
        "urlPathParamNames": ["apiName"],
        "method": "GET"
      },
      // Retrieve a specific layout.
      "RecordUiController.getLayout": {
        "urlPath": prefix + "/ui-api/layout/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Retrieve a specific layout's user state.
      "RecordUiController.getLayoutUserState": {
        "urlPath": prefix + "/ui-api/layout/${objectApiName}/user-state",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Update a specific layout's user state.
      "RecordUiController.updateLayoutUserState": {
        "urlPath": prefix + "/ui-api/layout/${objectApiName}/user-state",
        "urlPathParamNames": ["objectApiName"],
        "inputRepresentation": "userState",
        "method": "PATCH"
      },
      // Retrieve metadata about a list of objects.
      "RecordUiController.getObjectInfos": {
        "urlPath": prefix + "/ui-api/object-info/batch/${objectApiNames}",
        "urlPathParamNames": ["objectApiNames"],
        "method": "GET"
      },
      // Retrieve metadata about a specific object.
      "RecordUiController.getObjectInfo": {
        "urlPath": prefix + "/ui-api/object-info/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Returns the values for all picklist fields for a recordType
      "RecordUiController.getPicklistValuesByRecordType": {
        "urlPath": prefix + "/ui-api/object-info/${objectApiName}/picklist-values/${recordTypeId}",
        "urlPathParamNames": ["objectApiName", "recordTypeId"],
        "method": "GET"
      },
      // Returns the values for a specific picklist.
      "RecordUiController.getPicklistValues": {
        "urlPath": prefix + "/ui-api/object-info/${objectApiName}/picklist-values/${recordTypeId}/${fieldApiName}",
        "urlPathParamNames": ["fieldApiName", "objectApiName", "recordTypeId"],
        "method": "GET"
      },
      // Performs a predupe check on given a record.
      "RecordUiController.findDuplicates": {
        "urlPath": prefix + "/ui-api/predupe",
        "urlPathParamNames": [],
        "inputRepresentation": "recordInput",
        "method": "POST"
      },
      // Stores avatar association for specific records.
      "RecordUiController.postRecordAvatarAssociation": {
        "urlPath": prefix + "/ui-api/record-avatars/${recordId}/association",
        "urlPathParamNames": ["recordId"],
        "inputRepresentation": "input",
        "method": "POST"
      },
      // Retrieve avatar information about specific records.
      "RecordUiController.getRecordAvatars": {
        "urlPath": prefix + "/ui-api/record-avatars/batch/${recordIds}",
        "urlPathParamNames": ["recordIds"],
        "method": "GET"
      },
      // Retrieve default values for fields for cloning a record with optional record type.
      "RecordUiController.getRecordCloneDefaults": {
        "urlPath": prefix + "/ui-api/record-defaults/clone/${recordId}",
        "urlPathParamNames": ["recordId"],
        "method": "GET"
      },
      // Retrieve default values for fields for a new record of a particular object and optional record type.
      "RecordUiController.getRecordCreateDefaults": {
        "urlPath": prefix + "/ui-api/record-defaults/create/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Create a new record.
      "RecordUiController.createRecord": {
        "urlPath": prefix + "/ui-api/records",
        "urlPathParamNames": [],
        "inputRepresentation": "recordInput",
        "method": "POST"
      },
      // Delete record.
      "RecordUiController.deleteRecord": {
        "urlPath": prefix + "/ui-api/records/${recordId}",
        "urlPathParamNames": ["recordId"],
        "method": "DELETE"
      },
      // Retrieve record data.
      "RecordUiController.getRecordWithFields": {
        "urlPath": prefix + "/ui-api/records/${recordId}",
        "urlPathParamNames": ["recordId"],
        "method": "GET"
      },
      // Retrieve record data.
      "RecordUiController.getRecordWithLayouts": {
        "urlPath": prefix + "/ui-api/records/${recordId}",
        "urlPathParamNames": ["recordId"],
        "method": "GET"
      },
      // Update an existing record.
      "RecordUiController.updateRecord": {
        "urlPath": prefix + "/ui-api/records/${recordId}",
        "urlPathParamNames": ["recordId"],
        "inputRepresentation": "recordInput",
        "method": "PATCH"
      },
      // Retrieve default values for fields for cloning a record with optional record type.
      "RecordUiController.getRecordDefaultsTemplateClone": {
        "urlPath": prefix + "/ui-api/record-defaults/template/clone/${recordId}",
        "urlPathParamNames": ["recordId"],
        "method": "GET"
      },
      // Retrieve default values for fields for a new record of a particular object and optional record type without layouts.
      "RecordUiController.getRecordDefaultsTemplateForCreate": {
        "urlPath": prefix + "/ui-api/record-defaults/template/create/${objectApiName}",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Retrieve presentation-ready metadata and data about specific records.
      "RecordUiController.getRecordUis": {
        "urlPath": prefix + "/ui-api/record-ui/${recordIds}",
        "urlPathParamNames": ["recordIds"],
        "method": "GET"
      },
      // Retrieve metadata of validation rules for the given object
      "RecordUiController.getValidationRulesInfo": {
        "urlPath": prefix + "/ui-api/object-info/${objectApiName}/validation-rules-info",
        "urlPathParamNames": ["objectApiName"],
        "method": "GET"
      },
      // Retrieve a batch of related list info.
      "RelatedListUiController.getRelatedListInfoBatch": {
        "urlPath": prefix + "/ui-api/related-list-info/batch/${parentObjectApiName}/${relatedListNames}",
        "urlPathParamNames": ["parentObjectApiName", "relatedListNames"],
        "method": "GET"
      },
      // Retrieve collection of related list summaries.
      "RelatedListUiController.getRelatedListInfoCollection": {
        "urlPath": prefix + "/ui-api/related-list-info/${parentObjectApiName}",
        "urlPathParamNames": ["parentObjectApiName"],
        "method": "GET"
      },
      // Retrieve related info.
      "RelatedListUiController.getRelatedListInfo": {
        "urlPath": prefix + "/ui-api/related-list-info/${parentRecordId}/${relatedListId}",
        "urlPathParamNames": ["parentRecordId", "relatedListId"],
        "method": "GET"
      },
      // Retrieve related info.
      "RelatedListUiController.getRelatedListInfoByApiName": {
        "urlPath": prefix + "/ui-api/related-list-info/${parentObjectApiName}/${relatedListId}",
        "urlPathParamNames": ["parentObjectApiName", "relatedListId"],
        "method": "GET"
      },
      // Update user preferences on an existing related list.
      "RelatedListUiController.updateRelatedListInfoByApiName": {
        "urlPath": prefix + "/ui-api/related-list-info/${parentObjectApiName}/${relatedListId}",
        "urlPathParamNames": ["parentObjectApiName", "relatedListId"],
        "method": "PATCH"
      },
      // Retrieve a batch of record counts.
      "RelatedListUiController.getRelatedListsRecordCount": {
        "urlPath": prefix + "/ui-api/related-list-count/batch/${parentRecordId}/${relatedListNames}",
        "urlPathParamNames": ["parentRecordId", "relatedListNames"],
        "method": "GET"
      },
      // Retrieve record counts.
      "RelatedListUiController.getRelatedListRecordCount": {
        "urlPath": prefix + "/ui-api/related-list-count/${parentRecordId}/${relatedListName}",
        "urlPathParamNames": ["parentRecordId", "relatedListName"],
        "method": "GET"
      },
      // Returns a batch of record data to populate several related list.
      "RelatedListUiController.getRelatedListRecordsBatch": {
        "urlPath": prefix + "/ui-api/related-list-records/batch/${parentRecordId}/${relatedListIds}",
        "urlPathParamNames": ["parentRecordId", "relatedListIds"],
        "method": "GET"
      },
      // Returns record data to populate a related list.
      "RelatedListUiController.getRelatedListRecords": {
        "urlPath": prefix + "/ui-api/related-list-records/${parentRecordId}/${relatedListId}",
        "urlPathParamNames": ["parentRecordId", "relatedListId"],
        "method": "GET"
      }
    };
    function getResourceReferenceFromAuraMethod(auraMethod) {
      return auraMethodToResourceReferenceMapping._ES5ProxyType ? auraMethodToResourceReferenceMapping.get(auraMethod) : auraMethodToResourceReferenceMapping[auraMethod];
    }

    function _objectSpread$4(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$4(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$4(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }

    function apiCall(_x, _x2) {
      return __callKey2(_apiCall, "apply", this, arguments);
    }

    function _apiCall() {
      _apiCall = _asyncToGenerator(
      /*#__PURE__*/
      __callKey1(_regeneratorRuntime, "mark", function _callee(endpoint, params) {
        var _endpoint$split, _endpoint$split2, controller, action, uiApiReference;

        return __callKey2(_regeneratorRuntime, "wrap", function _callee$(_context) {
          while (1) {
            switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
              case 0:
                _endpoint$split = __callKey1(endpoint, "split", '.'), _endpoint$split2 = _slicedToArray(_endpoint$split, 2), controller = _endpoint$split2._ES5ProxyType ? _endpoint$split2.get(0) : _endpoint$split2[0], action = _endpoint$split2._ES5ProxyType ? _endpoint$split2.get(1) : _endpoint$split2[1]; // handle Apex calls

                if (!(controller === 'ApexActionController')) {
                  __setKey(_context, "next", 3);

                  break;
                }

                return __callKey2(_context, "abrupt", "return", handleApexAction(action, params));

              case 3:
                // handle UI API calls
                // get the UI API reference using the Aura controller and method name
                uiApiReference = getResourceReferenceFromAuraMethod(endpoint);

                if (!uiApiReference) {
                  __setKey(_context, "next", 6);

                  break;
                }

                return __callKey2(_context, "abrupt", "return", handleUiApiCall(uiApiReference, params));

              case 6:
                throw new Error(__concat(__concat("Unsupported controller action: ", controller, "."), action));

              case 7:
              case "end":
                return __callKey0(_context, "stop");
            }
          }
        }, _callee);
      }));
      return __callKey2(_apiCall, "apply", this, arguments);
    }

    function handleUiApiCall(_x3, _x4) {
      return __callKey2(_handleUiApiCall, "apply", this, arguments);
    }

    function _handleUiApiCall() {
      _handleUiApiCall = _asyncToGenerator(
      /*#__PURE__*/
      __callKey1(_regeneratorRuntime, "mark", function _callee2(_ref, params) {
        var urlPath, urlPathParamNames, method, inputRepresentation, remainingParams, path, body, response, data, error;
        return __callKey2(_regeneratorRuntime, "wrap", function _callee2$(_context2) {
          var _Object$compatKeys, _length;

          while (1) {
            switch (__setKey(_context2, "prev", _context2._ES5ProxyType ? _context2.get("next") : _context2.next)) {
              case 0:
                urlPath = _ref._ES5ProxyType ? _ref.get("urlPath") : _ref.urlPath, urlPathParamNames = _ref._ES5ProxyType ? _ref.get("urlPathParamNames") : _ref.urlPathParamNames, method = _ref._ES5ProxyType ? _ref.get("method") : _ref.method, inputRepresentation = _ref._ES5ProxyType ? _ref.get("inputRepresentation") : _ref.inputRepresentation;
                remainingParams = params && _objectSpread$4({}, params) || {}; // replace the path params

                path = __callKey2(urlPathParamNames, "reduce", function (currentPath, paramName) {
                  var value = remainingParams._ES5ProxyType ? remainingParams.get(paramName) : remainingParams[paramName];

                  __deleteKey(remainingParams, paramName);

                  return __callKey2(currentPath, "replace", __concat("${", paramName, "}"), encodeURIComponent(value));
                }, urlPath); // get the POST/PATCH body

                if ((method === 'POST' || method === 'PATCH') && (remainingParams._ES5ProxyType ? remainingParams.get(inputRepresentation) : remainingParams[inputRepresentation])) {
                  body = JSON.stringify(remainingParams._ES5ProxyType ? remainingParams.get(inputRepresentation) : remainingParams[inputRepresentation]);

                  __deleteKey(remainingParams, inputRepresentation);
                } // add the rest as query params


                if (_Object$compatKeys = Object.compatKeys(remainingParams), _length = _Object$compatKeys._ES5ProxyType ? _Object$compatKeys.get("length") : _Object$compatKeys.length) {
                  path += __concat("?", __callKey1(__callKey1(__callKey1(Object.compatEntries(remainingParams), "filter", function (_ref2) {
                    var _ref3 = _slicedToArray(_ref2, 2),
                        val = _ref3._ES5ProxyType ? _ref3.get(1) : _ref3[1];

                    return val !== undefined && val !== null && (!Array.compatIsArray(val) || (val._ES5ProxyType ? val.get("length") : val.length));
                  }), "map", function (_ref4) {
                    var _ref5 = _slicedToArray(_ref4, 2),
                        key = _ref5._ES5ProxyType ? _ref5.get(0) : _ref5[0],
                        val = _ref5._ES5ProxyType ? _ref5.get(1) : _ref5[1];

                    return __concat(__concat("", encodeURIComponent(key), "="), encodeURIComponent(val));
                  }), "join", '&'));
                } // fetch!


                __setKey(_context2, "next", 7);

                return fetch(path, {
                  method: method,
                  body: body
                });

              case 7:
                response = _context2._ES5ProxyType ? _context2.get("sent") : _context2.sent;

                if (!((response._ES5ProxyType ? response.get("status") : response.status) !== 204)) {
                  __setKey(_context2, "next", 12);

                  break;
                }

                __setKey(_context2, "next", 11);

                return __callKey0(response, "json");

              case 11:
                data = _context2._ES5ProxyType ? _context2.get("sent") : _context2.sent;

              case 12:
                if (response._ES5ProxyType ? response.get("ok") : response.ok) {
                  __setKey(_context2, "next", 15);

                  break;
                }

                error = {
                  status: response._ES5ProxyType ? response.get("status") : response.status,
                  data: _objectSpread$4({}, data._ES5ProxyType ? data.get(0) : data[0], {
                    statusCode: response._ES5ProxyType ? response.get("status") : response.status
                  })
                };
                throw error;

              case 15:
                return __callKey2(_context2, "abrupt", "return", data);

              case 16:
              case "end":
                return __callKey0(_context2, "stop");
            }
          }
        }, _callee2);
      }));
      return __callKey2(_handleUiApiCall, "apply", this, arguments);
    }

    function handleApexAction(_x5, _x6) {
      return __callKey2(_handleApexAction, "apply", this, arguments);
    }

    function _handleApexAction() {
      _handleApexAction = _asyncToGenerator(
      /*#__PURE__*/
      __callKey1(_regeneratorRuntime, "mark", function _callee3(action, params) {
        return __callKey2(_regeneratorRuntime, "wrap", function _callee3$(_context3) {
          while (1) {
            switch (__setKey(_context3, "prev", _context3._ES5ProxyType ? _context3.get("next") : _context3.next)) {
              case 0:
                if (!(action === 'execute')) {
                  __setKey(_context3, "next", 2);

                  break;
                }

                return __callKey2(_context3, "abrupt", "return", __callKey1(__callKey1(fetch(__concat("/apex/", action), {
                  method: 'POST',
                  body: JSON.stringify(params)
                }), "then", function (response) {
                  // we always resolve to a json... if there are errors, they
                  // are exposed and thrown from the error property
                  // see lds/transport-utils#createFetchResponse()
                  return (response._ES5ProxyType ? response.get("status") : response.status) !== 204 ? __callKey0(response, "json") : undefined;
                }), "then", function (response) {
                  var _error, _length2;

                  if (response && (response._ES5ProxyType ? response.get("error") : response.error) && (_error = response._ES5ProxyType ? response.get("error") : response.error, _length2 = _error._ES5ProxyType ? _error.get("length") : _error.length) > 0) {
                    var _error2, _;

                    throw _error2 = response._ES5ProxyType ? response.get("error") : response.error, _ = _error2._ES5ProxyType ? _error2.get(0) : _error2[0]; // eslint-disable-line no-throw-literal
                  }

                  return response;
                }));

              case 2:
                throw new Error(__concat("Unsupported Apex action: ", action));

              case 3:
              case "end":
                return __callKey0(_context3, "stop");
            }
          }
        }, _callee3);
      }));
      return __callKey2(_handleApexAction, "apply", this, arguments);
    }

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */

    var webruntimeAura = /*#__PURE__*/Object.freeze({
        __proto__: null,
        executeGlobalController: apiCall
    });

    function tmpl($api, $cmp, $slotset, $ctx) {
      _objectDestructuringEmpty($api);

      return [];
    }

    var _tmpl$1 = registerTemplate(tmpl);

    __setKey(tmpl, "stylesheets", []);

    __setKey(tmpl, "stylesheetTokens", {
      hostAttribute: "webruntime-app_app-host",
      shadowAttribute: "webruntime-app_app"
    });

    function _objectSpread$5(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$5(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$5(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }

    function sendError$1(payload) {
      var _window$location = window._ES5ProxyType ? window.get("location") : window.location,
          hostname = _window$location._ES5ProxyType ? _window$location.get("hostname") : _window$location.hostname,
          pathname = _window$location._ES5ProxyType ? _window$location.get("pathname") : _window$location.pathname;

      sendBeacon({
        path: ERRORS_PATH_PREFIX,
        payload: JSON.stringify(_objectSpread$5({}, payload, {
          location: {
            hostname: hostname,
            pathname: pathname
          }
        })),
        contentType: 'text/plain;charset=UTF-8'
      });
    }

    function reportError$1(_ref) {
      var subject = _ref._ES5ProxyType ? _ref.get("subject") : _ref.subject,
          error = _ref._ES5ProxyType ? _ref.get("error") : _ref.error,
          wcstack = _ref._ES5ProxyType ? _ref.get("wcstack") : _ref.wcstack;
      wcstack = wcstack || (error._ES5ProxyType ? error.get("wcstack") : error.wcstack);
      logError$1(subject, '\nerror: ', error, '\nwcstack:\n', wcstack);
      var message = error._ES5ProxyType ? error.get("message") : error.message,
          stack = error._ES5ProxyType ? error.get("stack") : error.stack;
      sendError$1({
        subject: subject,
        message: message,
        stack: stack,
        wcstack: wcstack
      });
    }

    function _objectSpread$6(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$6(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$6(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }

    var App =
    /*#__PURE__*/
    function (_LightningElement) {
      _inherits(App, _LightningElement);

      function App() {
        var _getPrototypeOf2, _getPrototypeOf3, _call;

        var _this;

        _classCallCheck(this, App);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          __setKey(args, _key, arguments[_key]);
        }

        _this = _possibleConstructorReturn(this, __callKey2((_getPrototypeOf3 = _getPrototypeOf2 = _getPrototypeOf(App), _call = _getPrototypeOf3._ES5ProxyType ? _getPrototypeOf3.get("call") : _getPrototypeOf3.call), "apply", _getPrototypeOf2, __concat([this], args)));

        __setKey(_this, "generatedTemplateHtml", _tmpl$1);

        __setKey(_this, "attributes", {});

        __setKey(_this, "routeParams", {});

        __setKey(_this, "themeLayout", void 0);

        __setKey(_this, "isInitialized", void 0);

        return _this;
      }
      /**
       * Subscribe to route changes
       */


      _createClass(App, [{
        key: "connectedCallback",
        value: function connectedCallback() {
          __setKey(this, "subscription", subscribe$1(__callKey1(this._ES5ProxyType ? this.get("setRoute") : this.setRoute, "bind", this)));
        }
      }, {
        key: "render",
        value: function render() {
          return this._ES5ProxyType ? this.get("generatedTemplateHtml") : this.generatedTemplateHtml;
        }
      }, {
        key: "renderedCallback",
        value: function renderedCallback() {
          if (this._ES5ProxyType ? this.get("isInitialized") : this.isInitialized) {
            return;
          }

          __setKey(this, "isInitialized", true);

          __callKey1(window._ES5ProxyType ? window.get("performance") : window.performance, "measure", __concat("", WEBRUNTIME_PREFIX, "-app-bootstrap"));
        }
      }, {
        key: "setRoute",
        value: function () {
          var _setRoute = _asyncToGenerator(
          /*#__PURE__*/
          __callKey1(_regeneratorRuntime, "mark", function _callee() {
            var _this2 = this;

            var _ref,
                _ref$attributes,
                attributes,
                _ref$state,
                state,
                _ref2,
                view,
                params,
                themeLayout,
                _args = arguments;

            return __callKey2(_regeneratorRuntime, "wrap", function _callee$(_context) {
              while (1) {
                switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
                  case 0:
                    _ref = (_args._ES5ProxyType ? _args.get("length") : _args.length) > 0 && (_args._ES5ProxyType ? _args.get(0) : _args[0]) !== undefined ? _args._ES5ProxyType ? _args.get(0) : _args[0] : {}, _ref$attributes = _ref._ES5ProxyType ? _ref.get("attributes") : _ref.attributes, attributes = _ref$attributes === void 0 ? {} : _ref$attributes, _ref$state = _ref._ES5ProxyType ? _ref.get("state") : _ref.state, state = _ref$state === void 0 ? {} : _ref$state;
                    _ref2 = (_args._ES5ProxyType ? _args.get("length") : _args.length) > 1 && (_args._ES5ProxyType ? _args.get(1) : _args[1]) !== undefined ? _args._ES5ProxyType ? _args.get(1) : _args[1] : {}, view = _ref2._ES5ProxyType ? _ref2.get("view") : _ref2.view;
                    params = _objectSpread$6({}, state, attributes);
                    themeLayout = viewToThemeLayoutMap._ES5ProxyType ? viewToThemeLayoutMap.get(view) : viewToThemeLayoutMap[view];

                    {
                      assert$1(themeLayout, __concat("No theme layout matching the \"", view, "\" view."));
                    } // fetch the template from registry, which will be cached


                    return __callKey2(_context, "abrupt", "return", __callKey1(__callKey1(__callKey1(loader.load(getViewModuleSpecifier(themeLayout)), "then", function (module) {
                      return module._ES5ProxyType ? module.get("default") : module.default;
                    }), "then", function (tmpl) {
                      if ((_this2._ES5ProxyType ? _this2.get("themeLayout") : _this2.themeLayout) !== themeLayout) {
                        __setKey(_this2, "generatedTemplateHtml", tmpl._ES5ProxyType ? tmpl.get("html") : tmpl.html);

                        __setKey(_this2, "themeLayout", themeLayout);
                      } // update the route params


                      __setKey(_this2, "routeParams", params);

                      __setKey(_this2, "attributes", __callKey1(tmpl, "attributes", _this2));

                      return _this2;
                    }), "catch", function (error) {
                      reportError$1({
                        subject: 'App.getTemplate error',
                        error: error
                      });
                    }));

                  case 6:
                  case "end":
                    return __callKey0(_context, "stop");
                }
              }
            }, _callee);
          }));

          function setRoute() {
            return __callKey2(_setRoute, "apply", this, arguments);
          }

          return setRoute;
        }()
      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (this._ES5ProxyType ? this.get("subscription") : this.subscription) {
            __callKey0(this._ES5ProxyType ? this.get("subscription") : this.subscription, "unsubscribe");
          }
        }
      }, {
        key: "errorCallback",
        value: function errorCallback(error, wcstack) {
          reportError$1({
            subject: 'app level error',
            error: error,
            wcstack: wcstack
          });
        }
      }]);

      return App;
    }(BaseLightningElement);

    registerDecorators(App, {
      fields: ["generatedTemplateHtml", "attributes", "routeParams", "themeLayout", "isInitialized"]
    });

    var App$1 = registerComponent(App, {
      tmpl: _tmpl$1
    });

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var auraStorage = {};

    function _objectSpread$7(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$7(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$7(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }
    /**
     * Services @wire(CurrentPageReference) requests.
     * Hooks up to an Observable from the current navigation context.
     *
     * @param {*} CurrentPageReference - Wire name
     * @param {WireEventTarget} target - Component target to listen to the wire
     */

    var CurrentPageReference = function CurrentPageReference() {
      throw new Error('Imperative use is not supported. Use @wire(CurrentPageReference)');
    }; // Declarative access: register a wire adapter factory for @wire(CurrentPageReference)


    register$1(CurrentPageReference, function (target) {
      var subscription; // Invoked when a component is connected. Subscribe to the stream from the current navigation context.

      __callKey2(target, "addEventListener", 'connect', function () {
        if (!subscription) {
          subscription = subscribe(getNavigationContextId(target, true), function (pageRef) {
            // Page References should have a 'type', but not an 'id'
            // Make a copy because the object from subscribe is frozen
            var pageRefCopy = _objectSpread$7({}, pageRef);

            __deleteKey(pageRefCopy, "id");

            __callKey1(target, "dispatchEvent", new ValueChangedEvent(pageRefCopy));
          });
        }
      }); // Invoked when a component is disconnected. Unsubscribe from the Observable.


      __callKey2(target, "addEventListener", 'disconnect', function () {
        if (subscription) {
          __callKey0(subscription, "unsubscribe");

          subscription = undefined;
        }
      });
    });

    /*
     * Exports the NavigationMixin and CurrentPageReference wire adapter.
     * Uses the navContextService to retrieve the current navigation context/node.
     */

    /**
     * Provides navigate() and generateUrl() functionality.
     * Here, navigate() can take either a route OR a string URL.
     * Functionality pulled in from the current navigation context.
     * Used by components as a Mixin to extend their own functionality.
     *
     * @param {HTMLElement} Base - A class instance
     */

    var Navigate = Symbol('Navigate');
    var GenerateUrl = Symbol('GenerateUrl');

    var NavigationMixin = function NavigationMixin(Base) {
      var _prototype, _dispatchEvent;

      invariant$2(typeof (_prototype = Base._ES5ProxyType ? Base.get("prototype") : Base.prototype, _dispatchEvent = _prototype._ES5ProxyType ? _prototype.get("dispatchEvent") : _prototype.dispatchEvent) === 'function', messages._ES5ProxyType ? messages.get("INVALID_MIXIN_CMP") : messages.INVALID_MIXIN_CMP, [Base]);
      return (
        /*#__PURE__*/
        function (_Base) {
          _inherits(_class, _Base);

          function _class() {
            _classCallCheck(this, _class);

            return _possibleConstructorReturn(this, __callKey2(_getPrototypeOf(_class), "apply", this, arguments));
          }

          _createClass(_class, [{
            key: Navigate,
            value: function value(
            /*object|string*/
            pageRef, options) {
              navigate(getNavigationContextId(this), pageRef, options);
            }
          }, {
            key: GenerateUrl,
            value: function value(
            /*object*/
            pageRef) {
              return generateUrl(getNavigationContextId(this), pageRef);
            }
          }]);

          return _class;
        }(Base)
      );
    };

    __setKey(NavigationMixin, "Navigate", Navigate);

    __setKey(NavigationMixin, "GenerateUrl", GenerateUrl);

    /**
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var lightningNavigation = {
      navigate: navigate,
      generateUrl: generateUrl,
      NavigationContext: NavigationContext,
      NavigationMixin: NavigationMixin,
      CurrentPageReference: CurrentPageReference
    };

    function stylesheet(hostSelector, shadowSelector, nativeShadow) {
      return "a" + shadowSelector + " {color: var(--webruntime-link-color);font-size: var(--webruntime-link-font-size);text-decoration: var(--webruntime-link-text-decoration);}\na:hover" + shadowSelector + ",a:active" + shadowSelector + " {color: var(--webruntime-link-color-active, var(--webruntime-link-color));font-size: var(--webruntime-link-font-size-active, var(--webruntime-link-font-size));text-decoration: var(--webruntime-link-text-decoration-active);}\n";
    }

    var _implicitStylesheets = [stylesheet];

    function tmpl$1($api, $cmp, $slotset, $ctx) {
      var api_slot = $api._ES5ProxyType ? $api.get("s") : $api.s,
          api_bind = $api._ES5ProxyType ? $api.get("b") : $api.b,
          api_element = $api._ES5ProxyType ? $api.get("h") : $api.h;

      var _m0 = $ctx._ES5ProxyType ? $ctx.get("_m0") : $ctx._m0;

      return [api_element("a", {
        attrs: {
          "href": $cmp._ES5ProxyType ? $cmp.get("path") : $cmp.path
        },
        key: 1,
        on: {
          "click": _m0 || __setKey($ctx, "_m0", api_bind($cmp._ES5ProxyType ? $cmp.get("handleClick") : $cmp.handleClick))
        }
      }, [api_slot("", {
        key: 0
      }, [], $slotset)])];
    }

    var _tmpl$2 = registerTemplate(tmpl$1);

    __setKey(tmpl$1, "slots", [""]);

    __setKey(tmpl$1, "stylesheets", []);

    if (_implicitStylesheets) {
      __callKey2((tmpl$1._ES5ProxyType ? tmpl$1.get("stylesheets") : tmpl$1.stylesheets).push, "apply", tmpl$1._ES5ProxyType ? tmpl$1.get("stylesheets") : tmpl$1.stylesheets, _implicitStylesheets);
    }

    __setKey(tmpl$1, "stylesheetTokens", {
      hostAttribute: "webruntime_navigation-link_link-host",
      shadowAttribute: "webruntime_navigation-link_link"
    });

    var Link =
    /*#__PURE__*/
    function (_LightningElement) {
      _inherits(Link, _LightningElement);

      function Link() {
        var _getPrototypeOf2, _getPrototypeOf3, _call;

        var _this;

        _classCallCheck(this, Link);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          __setKey(args, _key, arguments[_key]);
        }

        _this = _possibleConstructorReturn(this, __callKey2((_getPrototypeOf3 = _getPrototypeOf2 = _getPrototypeOf(Link), _call = _getPrototypeOf3._ES5ProxyType ? _getPrototypeOf3.get("call") : _getPrototypeOf3.call), "apply", _getPrototypeOf2, __concat([this], args)));

        __setKey(_this, "path", void 0);

        __setKey(_this, "route", void 0);

        __setKey(_this, "navContext", void 0);

        return _this;
      }
      /**
       * If no path was provided, generate one based on the route, if available.
       */


      _createClass(Link, [{
        key: "connectedCallback",
        value: function () {
          var _connectedCallback = _asyncToGenerator(
          /*#__PURE__*/
          __callKey1(_regeneratorRuntime, "mark", function _callee() {
            return __callKey3(_regeneratorRuntime, "wrap", function _callee$(_context) {
              while (1) {
                switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
                  case 0:
                    __setKey(this, "navContext", getNavigationContextId(this));

                    if (!(!(this._ES5ProxyType ? this.get("path") : this.path) && (this._ES5ProxyType ? this.get("route") : this.route))) {
                      __setKey(_context, "next", 5);

                      break;
                    }

                    __setKey(_context, "next", 4);

                    return generateUrl(this._ES5ProxyType ? this.get("navContext") : this.navContext, this._ES5ProxyType ? this.get("route") : this.route);

                  case 4:
                    __setKey(this, "path", _context._ES5ProxyType ? _context.get("sent") : _context.sent);

                  case 5:
                  case "end":
                    return __callKey0(_context, "stop");
                }
              }
            }, _callee, this);
          }));

          function connectedCallback() {
            return __callKey2(_connectedCallback, "apply", this, arguments);
          }

          return connectedCallback;
        }()
        /**
         * Use the mixin to navigate on link click.
         *
         * @param {Event} event - Click event
         */

      }, {
        key: "handleClick",
        value: function handleClick(event) {
          __callKey0(event, "preventDefault");

          navigate(this._ES5ProxyType ? this.get("navContext") : this.navContext, (this._ES5ProxyType ? this.get("route") : this.route) || (this._ES5ProxyType ? this.get("path") : this.path));
        }
      }]);

      return Link;
    }(BaseLightningElement);

    registerDecorators(Link, {
      publicProps: {
        path: {
          config: 0
        },
        route: {
          config: 0
        }
      },
      fields: ["navContext"]
    });

    var Link$1 = registerComponent(Link, {
      tmpl: _tmpl$2
    });

    function tmpl$2($api, $cmp, $slotset, $ctx) {
      _objectDestructuringEmpty($api);

      return [];
    }

    var _tmpl$3 = registerTemplate(tmpl$2);

    __setKey(tmpl$2, "stylesheets", []);

    __setKey(tmpl$2, "stylesheetTokens", {
      hostAttribute: "webruntime-routerContainer_routerContainer-host",
      shadowAttribute: "webruntime-routerContainer_routerContainer"
    });

    function _objectSpread$8(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? Object(arguments[i]) : {};
        var ownKeys = Object.compatKeys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = __concat(ownKeys, __callKey1(Object.getOwnPropertySymbols(source), "filter", function (sym) {
            var _Object$compatGetOwnP, _enumerable;

            return _Object$compatGetOwnP = Object.compatGetOwnPropertyDescriptor(source, sym), _enumerable = _Object$compatGetOwnP._ES5ProxyType ? _Object$compatGetOwnP.get("enumerable") : _Object$compatGetOwnP.enumerable;
          }));
        }

        __callKey1(ownKeys, "forEach", function (key) {
          _defineProperty$8(target, key, source._ES5ProxyType ? source.get(key) : source[key]);
        });
      }

      return target;
    }

    function _defineProperty$8(obj, key, value) {
      if (__inKey(obj, key)) {
        Object.compatDefineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        __setKey(obj, key, value);
      }

      return obj;
    }

    var RouterContainer =
    /*#__PURE__*/
    function (_LightningElement) {
      _inherits(RouterContainer, _LightningElement);

      function RouterContainer() {
        var _getPrototypeOf2, _getPrototypeOf3, _call;

        var _this;

        _classCallCheck(this, RouterContainer);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          __setKey(args, _key, arguments[_key]);
        }

        _this = _possibleConstructorReturn(this, __callKey2((_getPrototypeOf3 = _getPrototypeOf2 = _getPrototypeOf(RouterContainer), _call = _getPrototypeOf3._ES5ProxyType ? _getPrototypeOf3.get("call") : _getPrototypeOf3.call), "apply", _getPrototypeOf2, __concat([this], args)));

        __setKey(_this, "generatedTemplateHtml", _tmpl$3);

        __setKey(_this, "attributes", {});

        __setKey(_this, "routeParams", {});

        return _this;
      }
      /**
       * Subscribe to route changes
       */


      _createClass(RouterContainer, [{
        key: "connectedCallback",
        value: function connectedCallback() {
          __setKey(this, "subscription", subscribe$1(__callKey1(this._ES5ProxyType ? this.get("setRoute") : this.setRoute, "bind", this)));
        }
      }, {
        key: "render",
        value: function render() {
          return this._ES5ProxyType ? this.get("generatedTemplateHtml") : this.generatedTemplateHtml;
        }
      }, {
        key: "setRoute",
        value: function () {
          var _setRoute = _asyncToGenerator(
          /*#__PURE__*/
          __callKey1(_regeneratorRuntime, "mark", function _callee() {
            var _ref,
                _ref$attributes,
                attributes,
                _ref$state,
                state,
                _ref2,
                view,
                viewModuleSpecifier,
                module,
                template,
                _args = arguments;

            return __callKey4(_regeneratorRuntime, "wrap", function _callee$(_context) {
              while (1) {
                switch (__setKey(_context, "prev", _context._ES5ProxyType ? _context.get("next") : _context.next)) {
                  case 0:
                    _ref = (_args._ES5ProxyType ? _args.get("length") : _args.length) > 0 && (_args._ES5ProxyType ? _args.get(0) : _args[0]) !== undefined ? _args._ES5ProxyType ? _args.get(0) : _args[0] : {}, _ref$attributes = _ref._ES5ProxyType ? _ref.get("attributes") : _ref.attributes, attributes = _ref$attributes === void 0 ? {} : _ref$attributes, _ref$state = _ref._ES5ProxyType ? _ref.get("state") : _ref.state, state = _ref$state === void 0 ? {} : _ref$state;
                    _ref2 = (_args._ES5ProxyType ? _args.get("length") : _args.length) > 1 && (_args._ES5ProxyType ? _args.get(1) : _args[1]) !== undefined ? _args._ES5ProxyType ? _args.get(1) : _args[1] : {}, view = _ref2._ES5ProxyType ? _ref2.get("view") : _ref2.view;
                    viewModuleSpecifier = getViewModuleSpecifier(view); // load the new module and report any errors

                    __setKey(_context, "prev", 3);

                    // force a rerender of the template by "resetting" the template
                    // W-7462929: when routing to the same route, the component doesn't rerender
                    __setKey(this, "generatedTemplateHtml", _tmpl$3);

                    __setKey(_context, "next", 7);

                    return loader.load(viewModuleSpecifier);

                  case 7:
                    module = _context._ES5ProxyType ? _context.get("sent") : _context.sent;

                    __setKey(_context, "next", 13);

                    break;

                  case 10:
                    __setKey(_context, "prev", 10);

                    __setKey(_context, "t0", __callKey1(_context, "catch", 3));

                    reportError$1({
                      subject: 'routerContainer.getTemplate error',
                      error: _context._ES5ProxyType ? _context.get("t0") : _context.t0
                    });

                  case 13:
                    if (module) {
                      template = module._ES5ProxyType ? module.get("default") : module.default;

                      __setKey(this, "generatedTemplateHtml", template._ES5ProxyType ? template.get("html") : template.html); // set the route params for the template


                      __setKey(this, "routeParams", _objectSpread$8({}, state, attributes));

                      __setKey(this, "attributes", __callKey1(template, "attributes", this));
                    }

                  case 14:
                  case "end":
                    return __callKey0(_context, "stop");
                }
              }
            }, _callee, this, [[3, 10]]);
          }));

          function setRoute() {
            return __callKey2(_setRoute, "apply", this, arguments);
          }

          return setRoute;
        }()
      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (this._ES5ProxyType ? this.get("subscription") : this.subscription) {
            __callKey0(this._ES5ProxyType ? this.get("subscription") : this.subscription, "unsubscribe");
          }
        }
      }, {
        key: "errorCallback",
        value: function errorCallback(error, wcstack) {
          reportError$1({
            subject: 'router level error',
            error: error,
            wcstack: wcstack
          });
        }
      }]);

      return RouterContainer;
    }(BaseLightningElement);

    registerDecorators(RouterContainer, {
      fields: ["generatedTemplateHtml", "attributes", "routeParams"]
    });

    var RouterContainer$1 = registerComponent(RouterContainer, {
      tmpl: _tmpl$3
    });

    {
      // in compat mode, define a @salesforce/cssvars/customProperties module
      // as a function that will return the CSS variables values from the provided map
      // every time a new component is created
      loader.defineModules({
        '@salesforce/cssvars/customProperties': function salesforceCssvarsCustomProperties(customProperty, defaultValue) {
          return (props._ES5ProxyType ? props.get(customProperty) : props[customProperty]) || defaultValue || __concat(__concat("var(", customProperty), defaultValue ? __concat(", ", defaultValue) : '', ")");
        }
      });
    }

    loader.defineModules({
      'aura-instrumentation': auraInstrumentation,
      'aura-storage': auraStorage,
      'instrumentation/service': auraInstrumentation,
      'lightning/configProvider': lightningConfigProvider$1,
      'lightning/navigation': lightningNavigation,
      'webruntime_navigation/link': Link$1,
      'webruntime_navigation/navigation': navigation,
      'webruntime/routerContainer': RouterContainer$1,
      // needed for theme layouts
      'webruntime/routingService': routingService,
      'wire-service': wireService$1,
      aura: webruntimeAura,
      lwc: lwc,
      transport: transport
    }); // Register wire service

    __callKey1(wireService$1, "registerWireService", undefined ? undefined("register") : register);

    __callKey2(customElements, "define", 'webruntime-app', __callKey1(lwc, "buildCustomElementConstructor", App$1));

    __callKey1(window._ES5ProxyType ? window.get("performance") : window.performance, "measure", __concat("", WEBRUNTIME_PREFIX, "-framework-bootstrap"));

});
