"use strict";
/**
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const path_1 = __importDefault(require("path"));
const fs = __importStar(require("fs"));
const compose_middleware_1 = require("compose-middleware");
const express_1 = require("express");
const mkdirp_1 = __importDefault(require("mkdirp"));
const node_http_proxy_json_1 = __importDefault(require("node-http-proxy-json"));
const http_proxy_middleware_1 = __importDefault(require("http-proxy-middleware"));
require("colors");
const { log } = console;
function stripPrefix(str, prefix) {
    return (str && prefix && str.startsWith(prefix) && str.substring(prefix.length)) || str;
}
/**
 * A middleware to handle API calls.
 *
 * There's 2 modes:
 * - proxy calls to an external API endpoint and record the API calls response
 * - replay the previously recorded API calls
 *
 * Only GET calls are handled recorded and replayed.
 *
 * @public
 * @param {ApiConfig} config - The middleware config
 * @returns The Express middleware handling API calls
 */
function apiMiddleware(config) {
    const { apiEndpoint: target, apiEndpointHeaders, apiPathPrefix, onProxyReq: customOnProxyReq, pathRewrite, recordApiCalls, recordDir, } = config;
    const delegate = setupMiddlewares();
    function baseUrl(url) {
        const { protocol, host } = new URL(url);
        return `${protocol}//${host}`;
    }
    /**
     * Get the api URL from the given request, stripping the base path and API path prefix (${basePath}}/api) from the request original url
     */
    function apiUrl(req) {
        return stripBasePathAndApiPrefix(req.originalUrl);
    }
    /**
     * Get the file name from the specified base directory and url.
     *
     * We truncate the file name if needed in which case we include a hash or the url in it.
     */
    function fileFromUrl(url) {
        const urlHash = crypto_1.default
            .createHash('md5')
            .update(url)
            .digest('hex')
            .substring(0, 10);
        const basename = path_1.default.basename(url);
        // file name cannot be longer than 255 character
        const filename = `${basename.length <= 250 ? basename : `${basename.substring(0, 237)}...${urlHash}`}.json`;
        return path_1.default.resolve(recordDir, `./${path_1.default.dirname(url)}`, filename);
    }
    /**
     * Save the JSON response with the given url and body to disk.
     *
     * We replace the target endpoint base url by the given request referrer base url in the saved response.
     * Target endpoint is used in the UI API objectInfo iconUls and will likely not be available when we replay
     * the responses, which breaks the UI tests in the CI.
     */
    function saveResponse(req, url, body) {
        const file = fileFromUrl(url);
        mkdirp_1.default.sync(path_1.default.dirname(file));
        const bodyString = JSON.stringify(body, null, 4);
        if (req.headers && req.headers.referer) {
            fs.writeFileSync(file, bodyString.replace(baseUrl(target), baseUrl(req.headers.referer)));
        }
        else {
            fs.writeFileSync(file, bodyString);
        }
    }
    /**
     * Load the API call response with the given url from the specified directory.
     *
     * @returns the API call response, or null if the response cannot be found
     */
    function loadResponse(dir, url) {
        const file = fileFromUrl(url);
        if (fs.existsSync(file)) {
            const responseBody = fs.readFileSync(file, 'utf8');
            return JSON.parse(responseBody);
        }
        log(`Cannot find recorded response: ${file}`);
        return null;
    }
    /**
     * Returns a onProxyReq function that writes the request JSON body to the proxyReq.
     */
    function setHeadersOnProxyReq(headers) {
        return (headers &&
            (proxyReq => {
                headers.forEach(header => {
                    const [name, value] = header.split(':').map(s => s.trim());
                    proxyReq.setHeader(name, value);
                });
            }));
    }
    /**
     * Returns a onProxyReq function that writes the request JSON body to the proxyReq.
     */
    function writeBodyOnProxyReq() {
        return (proxyReq, req) => {
            if (req.body) {
                proxyReq.end(JSON.stringify(req.body));
            }
        };
    }
    function composeOnProxyReq(...onProxyReqs) {
        return (proxyReq, req, res) => {
            onProxyReqs
                .filter(onProxyReq => typeof onProxyReq === 'function')
                .forEach(onProxyReq => onProxyReq(proxyReq, req, res));
        };
    }
    /**
     * Returns a onProxyRes function that saves the proxyRes body to the given directory.
     */
    function recordOnProxyRes() {
        return (proxyRes, req, res) => {
            if (proxyRes.statusCode !== 200) {
                return;
            }
            if (req.method === 'GET') {
                node_http_proxy_json_1.default(res, proxyRes, body => {
                    saveResponse(req, apiUrl(req), body);
                    return body;
                });
            }
        };
    }
    /**
     * Returns a middleware function that will API GET calls by loading the response from the disk.
     */
    function replay() {
        return (req, res) => {
            if (req.method === 'GET') {
                const responseBody = loadResponse(recordDir, apiUrl(req));
                if (responseBody) {
                    res.contentType('application/json');
                    res.end(JSON.stringify(responseBody, null, 4));
                }
                else {
                    res.sendStatus(404);
                }
            }
            else {
                res.sendStatus(501);
            }
        };
    }
    /**
     * Remove the base path and Web Runtime API path prefix from the given path
     */
    function stripBasePathAndApiPrefix(localPath) {
        return stripPrefix(localPath, apiPathPrefix);
    }
    /**
     * Return a composed middleware built according to the given configuration
     */
    function setupMiddlewares() {
        if (target) {
            const options = {
                target,
                changeOrigin: true,
                logLevel: 'debug',
                secure: false,
                pathRewrite: pathRewrite || stripBasePathAndApiPrefix,
            };
            if (recordApiCalls) {
                // proxy and record
                return compose_middleware_1.compose([
                    express_1.json(),
                    http_proxy_middleware_1.default({
                        ...options,
                        onProxyReq: composeOnProxyReq(customOnProxyReq, setHeadersOnProxyReq(apiEndpointHeaders), writeBodyOnProxyReq()),
                        onProxyRes: recordOnProxyRes(),
                    }),
                ]);
            }
            // proxy only
            return http_proxy_middleware_1.default({
                ...options,
                onProxyReq: composeOnProxyReq(customOnProxyReq, setHeadersOnProxyReq(apiEndpointHeaders)),
            });
        }
        // replay recorded requests if not proxying target is specified
        return compose_middleware_1.compose([
            express_1.json(),
            replay(),
        ]);
    }
    return function webruntimeApi(req, res, next) {
        if (!req.originalUrl.startsWith(apiPathPrefix)) {
            // this is not an API call, delegate to next middleware in line
            return next();
        }
        return delegate(req, res, next);
    };
}
exports.apiMiddleware = apiMiddleware;
//# sourceMappingURL=api-middleware.js.map