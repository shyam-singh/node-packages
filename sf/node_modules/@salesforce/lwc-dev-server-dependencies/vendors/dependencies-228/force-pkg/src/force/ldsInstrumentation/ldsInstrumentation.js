/*  *******************************************************************************************
 *  ATTENTION!
 *  THIS IS A GENERATED FILE FROM https://github.com/salesforce/lds-lightning-platform
 *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
 *  Any changes made to this file in p4 will be automatically overwritten.
 *  *******************************************************************************************
 */
/* proxy-compat-disable */
import { counter, percentileHistogram, perfStart, perfEnd, registerCacheStats, timer, mark as mark$1, registerPlugin, registerPeriodicLogger, interaction, time, markStart, markEnd } from 'instrumentation/service';

const METRIC_KEY_OWNER = 'lds';
/**
 * Note: This implementation of Metric Keys is a workaround due to @salesforce imports not currently working within LDS context.
 * To be changed in the future if that is fixed. Approved by @relango from Instrumentation team.
 */
/**
 * W-6981216
 * Counter for overall LDS cache hits.
 * Note: This is also being recorded in AILTN logging.
 */
const CACHE_HIT_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'cache-hit-count' };
    },
};
/**
 * W-6981216
 * Counter for overall LDS cache hits.
 * Note: This is also being recorded in AILTN logging.
 */
const CACHE_MISS_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'cache-miss-count' };
    },
};
/**
 * W-7667066
 * This count represents the number of times getRecord() was invoked, but not including
 * executeAggregateUi calls.  It can be represented as the sum of the Aura Action invocations
 * GetRecordWithLayouts and GetRecordWithFields.
 */
const GET_RECORD_NORMAL_INVOKE_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-normal-invoke-count' };
    },
};
/**
 * W-7667066
 * This count represents the number of times getRecord() was invoked, with a large enough payload
 * that executeAggregateUi was used.
 */
const GET_RECORD_AGGREGATE_INVOKE_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-aggregate-invoke-count' };
    },
};
/**
 * W-7301684
 * Counter for when getRecordNotifyChange api calls are allowed through.
 */
const GET_RECORD_NOTIFY_CHANGE_ALLOW_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-notify-change-allow-count' };
    },
};
/**
 * W-7301684
 * Counter for when getRecordNotifyChange api calls are dropped/throttled.
 */
const GET_RECORD_NOTIFY_CHANGE_DROP_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-notify-change-drop-count' };
    },
};
/**
 * W-8110093
 * The number of fields that were requested on each @wire(getRecord) config that
 * was sent to the server. This value includes both fields and optionalFields. Note
 * that this metric does NOT include @wires that were satisfied with cached data.
 */
const GET_RECORD_CONFIG_FIELDS_PER_REQUEST = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-config-fields-per-request' };
    },
};
/**
 * W-8110093
 * The number of records that were requested on each @wire(getRecord) config that
 * was sent to the server. This value includes records specified in either fields or
 * optionalFields. Note that this metric does NOT include @wires that were satisfied
 * with cached data.
 */
const GET_RECORD_CONFIG_RECORDS_PER_REQUEST = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-config-records-per-request' };
    },
};
/**
 * W-8110093
 * The total number of fields that were included on each @wire(getRecord) that was
 * sent to the server. This value includes both fields and optionalFields from the
 * @wire config and fields that were added by the tracked fields logic.
 */
const GET_RECORD_TOTAL_FIELDS_PER_REQUEST = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-total-fields-per-request' };
    },
};
/**
 * W-8110093
 * The total number of records that were included on each @wire(getRecord) that was
 * sent to the server. This value includes records specified in both fields and
 * optionalFields from the @wire config and records that were added by the tracked
 * fields logic.
 */
const GET_RECORD_TOTAL_RECORDS_PER_REQUEST = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'get-record-total-records-per-request' };
    },
};
/**
 * W-8110093
 * The number of conflicting records that were detected during each record tree
 * ingestion. A value of 0 indicates that a record tree was ingested and no
 * conflicts were detected. E.g. if an Opportunity -> Account -> User record
 * tree is ingested and conflicts are detected on the Account and User records
 * this metric will be updated with a value of 2.
 */
const RECORD_MERGE_CONFLICTS = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'record-merge-conflicts' };
    },
};
/**
 * W-8110093
 * For each conflict detected during record ingestion, the distance of the
 * conflicting record from the root record that was being ingested. A distance
 * of 0 indicates that a conflict was detected on the root record itself. E.g.
 * if an Opportunity -> Account -> User record tree is being ingested and conflicts
 * are detected on the Account and User records this metric will be updated with
 * values of 1 (for the Account) and 2 (for the User).
 */
const RECORD_MERGE_CONFLICT_DEPTH = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'record-merge-conflict-depth' };
    },
};
/**
 * W-6981216
 * Timer to measure performance for LDS.storeBroadcast() method.
 */
const STORE_BROADCAST_DURATION = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'store-broadcast-duration' };
    },
};
/**
 * W-6981216
 * Timer to measure performance for LDS.storeIngest() method.
 */
const STORE_INGEST_DURATION = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'store-ingest-duration' };
    },
};
/**
 * W-6981216
 * Timer to measure performance for LDS.storeLookup() method.
 */
const STORE_LOOKUP_DURATION = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'store-lookup-duration' };
    },
};
/**
 * W-6981216
 * Counter for number of records in LDS store. Is updated by periodicLogger invocations.
 * Note: This is also being recorded in AILTN logging.
 */
const STORE_SIZE_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'store-size-count' };
    },
};
/**
 * W-6981216
 * Counter for number of LDS snapshot subscription. Is updated by periodicLogger invocations.
 * Note: This is also being recorded in AILTN logging.
 */
const STORE_SNAPSHOT_SUBSCRIPTIONS_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'store-snapshot-subscriptions-count' };
    },
};
/**
 * W-6981216
 * Counter for number of LDS watch subscriptions. Is updated by periodicLogger invocations.
 * Note: This is also being recorded in AILTN logging.
 */
const STORE_WATCH_SUBSCRIPTIONS_COUNT = {
    get() {
        return { owner: METRIC_KEY_OWNER, name: 'store-watch-subscriptions-count' };
    },
};

const { keys } = Object;
const { isArray } = Array;
const { stringify } = JSON;

/**
 * Inspired by https://www.npmjs.com/package/hashlru
 */
class LRUCache {
    constructor(limit) {
        this.oldCache = new Map();
        this.newCache = new Map();
        this.size = 0;
        this.limit = limit;
    }
    checkSize() {
        if (this.size >= this.limit) {
            this.size = 0;
            this.oldCache = this.newCache;
            this.newCache = new Map();
        }
    }
    get(key) {
        if (this.newCache.has(key)) {
            return this.newCache.get(key);
        }
        else if (this.oldCache.has(key)) {
            const value = this.oldCache.get(key);
            this.oldCache.delete(key);
            this.newCache.set(key, value);
            this.size += 1;
            this.checkSize();
            return value;
        }
        return undefined;
    }
    set(key, value) {
        if (this.newCache.has(key)) {
            this.newCache.set(key, value);
        }
        else {
            this.newCache.set(key, value);
            this.size += 1;
            this.checkSize();
        }
    }
}

/**
 * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
 * This is needed because insertion order for JSON.stringify(object) affects output:
 * JSON.stringify({a: 1, b: 2})
 *      "{"a":1,"b":2}"
 * JSON.stringify({b: 2, a: 1})
 *      "{"b":2,"a":1}"
 * Modified from the apex implementation to sort arrays non-destructively.
 * @param data Data to be JSON-stringified.
 * @returns JSON.stringified value with consistent ordering of keys.
 */
function stableJSONStringify(node) {
    // This is for Date values.
    if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
    }
    if (node === undefined) {
        return;
    }
    if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
    }
    if (typeof node !== 'object') {
        return stringify(node);
    }
    let i;
    let out;
    if (isArray(node)) {
        // copy any array before sorting so we don't mutate the object.
        // eslint-disable-next-line no-param-reassign
        node = node.slice(0).sort();
        out = '[';
        for (i = 0; i < node.length; i++) {
            if (i) {
                out += ',';
            }
            out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
    }
    if (node === null) {
        return 'null';
    }
    const keys$1 = keys(node).sort();
    out = '';
    for (i = 0; i < keys$1.length; i++) {
        const key = keys$1[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
            continue;
        }
        if (out) {
            out += ',';
        }
        out += stringify(key) + ':' + value;
    }
    return '{' + out + '}';
}

function sortedArrayString(value) {
    return value
        .slice(0)
        .sort()
        .join(',');
}
function getValue(value) {
    return isArray(value) ? sortedArrayString(value) : value;
}
function getLayoutConfigKey(config) {
    return `getLayout:${config.objectApiName}:${config.formFactor}:${config.layoutType}:${config.mode}:${config.recordTypeId}`;
}
function getLayoutUserStateConfigKey(config) {
    return `getLayoutUserState:${config.objectApiName}:${config.formFactor}:${config.layoutType}:${config.mode}:${config.recordTypeId}`;
}
function getListUiConfigKey(config) {
    return `getListUi:${config.listViewId}:${config.pageSize}`;
}
function getLookupRecordsConfigKey(config) {
    let requestParams = {};
    if (config.requestParams !== undefined) {
        requestParams = {
            dependentFieldBindings: config.requestParams.dependentFieldBindings,
            pageParam: config.requestParams.pageParam,
            pageSize: config.requestParams.pageSize,
            q: config.requestParams.q,
            searchType: config.requestParams.searchType,
            sourceRecordId: config.requestParams.sourceRecordId,
        };
    }
    if (typeof config.fieldApiName === 'string') {
        const idx = config.fieldApiName.indexOf('.');
        return `getLookupRecords:${config.fieldApiName.substring(0, idx)}:${config.fieldApiName.substring(idx + 1)}:${config.targetApiName}:${getValue(requestParams.dependentFieldBindings)}:${getValue(requestParams.pageParam)}:${getValue(requestParams.pageSize)}:${getValue(requestParams.q)}:${getValue(requestParams.searchType)}:${getValue(requestParams.sourceRecordId)}`;
    }
    else if (typeof config.fieldApiName === 'object') {
        return `getLookupRecords:${config.fieldApiName.objectApiName}:${config.fieldApiName.fieldApiName}:${config.targetApiName}:${getValue(requestParams.dependentFieldBindings)}:${getValue(requestParams.pageParam)}:${getValue(requestParams.pageSize)}:${getValue(requestParams.q)}:${getValue(requestParams.searchType)}:${getValue(requestParams.sourceRecordId)}`;
    }
    return 'getLookupRecords:invalidFieldApiNameConfig';
}
function getLookupActionsConfigKey(config) {
    return `getLookupActions:${getValue(config.objectApiNames)}:${getValue(config.actionTypes)}:${config.formFactor}:${getValue(config.sections)}`;
}
function getObjectInfoConfigKey(config) {
    return `getObjectInfo:${config.objectApiName}`;
}
function getPicklistValuesConfigKey(config) {
    if (typeof config.fieldApiName === 'string') {
        const idx = config.fieldApiName.indexOf('.');
        return `getPicklistValues:${config.fieldApiName.substring(0, idx)}:${config.fieldApiName.substring(idx + 1)}:${config.recordTypeId}`;
    }
    else if (typeof config.fieldApiName === 'object') {
        return `getPicklistValues:${config.fieldApiName.objectApiName}:${config.fieldApiName.fieldApiName}:${config.recordTypeId}`;
    }
    return 'getPicklistValues:invalidFieldApiNameConfig';
}
function getPicklistValuesByRecordTypeConfigKey(config) {
    return `getPicklistValuesByRecordType:${config.objectApiName}:${config.recordTypeId}`;
}
function getRecordAvatarsConfigKey(config) {
    return `getRecordAvatars:${getValue(config.recordIds)}:${config.formFactor}`;
}
function getRecordConfigKey(config) {
    return `getRecord:${config.recordId}:${getValue(config.fields)}:${getValue(config.optionalFields)}:${getValue(config.modes)}:${getValue(config.layoutTypes)}`;
}
function getRecordCreateDefaultsConfigKey(config) {
    return `getRecordCreateDefaults:${config.objectApiName}:${config.formFactor}:${config.recordTypeId}:${getValue(config.optionalFields)}`;
}
function getRecordUiConfigKey(config) {
    return `getRecordUi:${getValue(config.recordIds)}:${getValue(config.layoutTypes)}:${getValue(config.modes)}:${getValue(config.optionalFields)}`;
}

const RECORD_API_NAME_CHANGE_EVENT = 'record-api-name-change-event';
const INCOMING_WEAKETAG_0_KEY = 'incoming-weaketag-0';
const EXISTING_WEAKETAG_0_KEY = 'existing-weaketag-0';
const NAMESPACE = 'lds';
const STORE_STATS_MARK_NAME = 'store-stats';
const RUNTIME_PERF_MARK_NAME = 'runtime-perf';
const NETWORK_TRANSACTION_NAME = 'lds-network';
const ADAPTER_CACHE_HIT_COUNT_METRIC_NAME = 'cache-hit-count';
const ADAPTER_CACHE_HIT_DURATION_METRIC_NAME = 'cache-hit-duration';
const ADAPTER_CACHE_MISS_COUNT_METRIC_NAME = 'cache-miss-count';
const ADAPTER_CACHE_MISS_DURATION_METRIC_NAME = 'cache-miss-duration';
const RECORD_API_NAME_CHANGE_COUNT_METRIC_NAME = 'record-api-name-change-count';
const ADAPTER_CACHE_MISS_OUT_OF_TTL_DURATION_METRIC_NAME = 'cache-miss-out-of-ttl-duration';
const cacheHitMetric = counter(CACHE_HIT_COUNT);
const cacheMissMetric = counter(CACHE_MISS_COUNT);
const getRecordAggregateInvokeMetric = counter(GET_RECORD_AGGREGATE_INVOKE_COUNT);
const getRecordNormalInvokeMetric = counter(GET_RECORD_NORMAL_INVOKE_COUNT);
const getRecordNotifyChangeAllowMetric = counter(GET_RECORD_NOTIFY_CHANGE_ALLOW_COUNT);
const getRecordNotifyChangeDropMetric = counter(GET_RECORD_NOTIFY_CHANGE_DROP_COUNT);
const storeSizeMetric = percentileHistogram(STORE_SIZE_COUNT);
const storeWatchSubscriptionsMetric = percentileHistogram(STORE_WATCH_SUBSCRIPTIONS_COUNT);
const storeSnapshotSubscriptionsMetric = percentileHistogram(STORE_SNAPSHOT_SUBSCRIPTIONS_COUNT);
const getRecordConfigFieldsPerRequestMetric = percentileHistogram(GET_RECORD_CONFIG_FIELDS_PER_REQUEST);
const getRecordConfigRecordsPerRequestMetric = percentileHistogram(GET_RECORD_CONFIG_RECORDS_PER_REQUEST);
const getRecordTotalFieldsPerRequestMetric = percentileHistogram(GET_RECORD_TOTAL_FIELDS_PER_REQUEST);
const getRecordTotalRecordsPerRequestMetric = percentileHistogram(GET_RECORD_TOTAL_RECORDS_PER_REQUEST);
const recordMergeConflictsMetric = percentileHistogram(RECORD_MERGE_CONFLICTS);
const recordMergeConfictDepth = percentileHistogram(RECORD_MERGE_CONFLICT_DEPTH);
const wireAdapterMetricConfigs = {
    getLayout: {
        ttl: 900000,
        wireConfigKeyFn: getLayoutConfigKey,
    },
    getLayoutUserState: {
        ttl: 900000,
        wireConfigKeyFn: getLayoutUserStateConfigKey,
    },
    getListUi: {
        ttl: 900000,
        wireConfigKeyFn: getListUiConfigKey,
    },
    getLookupActions: {
        ttl: 300000,
        wireConfigKeyFn: getLookupActionsConfigKey,
    },
    getLookupRecords: {
        ttl: 30000,
        wireConfigKeyFn: getLookupRecordsConfigKey,
    },
    getObjectInfo: {
        ttl: 900000,
        wireConfigKeyFn: getObjectInfoConfigKey,
    },
    getPicklistValues: {
        ttl: 300000,
        wireConfigKeyFn: getPicklistValuesConfigKey,
    },
    getPicklistValuesByRecordType: {
        ttl: 300000,
        wireConfigKeyFn: getPicklistValuesByRecordTypeConfigKey,
    },
    getRecord: {
        ttl: 30000,
        wireConfigKeyFn: getRecordConfigKey,
    },
    getRecordAvatars: {
        ttl: 300000,
        wireConfigKeyFn: getRecordAvatarsConfigKey,
    },
    getRecordCreateDefaults: {
        ttl: 900000,
        wireConfigKeyFn: getRecordCreateDefaultsConfigKey,
    },
    getRecordUi: {
        ttl: 900000,
        wireConfigKeyFn: getRecordUiConfigKey,
    },
};
class Instrumentation {
    constructor() {
        this.recordApiNameChangeCounters = {};
        this.weakEtagZeroEvents = {};
        this.adapterCacheMisses = new LRUCache(250);
        if (window !== undefined && window.addEventListener) {
            window.addEventListener('beforeunload', () => {
                if (Object.keys(this.weakEtagZeroEvents).length > 0) {
                    perfStart(NETWORK_TRANSACTION_NAME);
                    perfEnd(NETWORK_TRANSACTION_NAME, this.weakEtagZeroEvents);
                }
            });
        }
    }
    /**
     * Instruments an existing adapter to log argus metrics and cache stats.
     * @param name The adapter name.
     * @param adapter The adapter function.
     * @param wireConfigKeyFn Optional function to transform wire configs to a unique key.
     * @returns The wrapped adapter.
     */
    instrumentAdapter(name, adapter) {
        const stats = registerLdsCacheStats(name);
        /**
         * W-6981216
         * Dynamically generated metric. Simple counter for cache hits by adapter name.
         */
        const cacheHitCountByAdapterMetric = counter(createMetricsKey(NAMESPACE, ADAPTER_CACHE_HIT_COUNT_METRIC_NAME, name));
        /**
         * W-7404607
         * Dynamically generated metric. Timer for cache hits by adapter name.
         */
        const cacheHitDurationByAdapterMetric = timer(createMetricsKey(NAMESPACE, ADAPTER_CACHE_HIT_DURATION_METRIC_NAME, name));
        /**
         * W-6981216
         * Dynamically generated metric. Simple counter for cache misses by adapter name.
         */
        const cacheMissCountByAdapterMetric = counter(createMetricsKey(NAMESPACE, ADAPTER_CACHE_MISS_COUNT_METRIC_NAME, name));
        /**
         * W-7404607
         * Dynamically generated metric. Timer for cache hits by adapter name.
         */
        const cacheMissDurationByAdapterMetric = timer(createMetricsKey(NAMESPACE, ADAPTER_CACHE_MISS_DURATION_METRIC_NAME, name));
        /**
         * W-7376275
         * Dynamically generated metric. Measures the amount of time it takes for LDS to get another cache miss on
         * a request we've made in the past.
         *
         * Request Record 1 -> Record 2 -> Back to Record 1 outside of TTL is an example of when this metric will fire.
         */
        const wireAdapterMetricConfig = wireAdapterMetricConfigs[name];
        const cacheMissOutOfTtlDurationByAdapterMetric = (wireAdapterMetricConfig && wireAdapterMetricConfig.ttl) !== undefined
            ? timer(createMetricsKey(NAMESPACE, ADAPTER_CACHE_MISS_OUT_OF_TTL_DURATION_METRIC_NAME, name))
            : undefined;
        const instrumentedAdapter = (config) => {
            const startTime = Date.now();
            const result = adapter(config);
            // In the case where the adapter returns a Snapshot it is constructed out of the store
            // (cache hit) whereas a Promise<Snapshot> indicates a network request (cache miss).
            //
            // Note: we can't do a plain instanceof check for a promise here since the Promise may
            // originate from another javascript realm (for example: in jest test). Instead we use a
            // duck-typing approach by checking is the result has a then property.
            //
            // For adapters without persistent store:
            //  - total cache hit ratio:
            //      [in-memory cache hit count] / ([in-memory cache hit count] + [in-memory cache miss count])
            // For adapters with persistent store:
            //  - in-memory cache hit ratio:
            //      [in-memory cache hit count] / ([in-memory cache hit count] + [in-memory cache miss count])
            //  - total cache hit ratio:
            //      ([in-memory cache hit count] + [store cache hit count]) / ([in-memory cache hit count] + [in-memory cache miss count])
            // if result === null then config is insufficient/invalid so do not log
            if (result !== null && 'then' in result) {
                result.then((_snapshot) => {
                    timerMetricAddDuration(cacheMissDurationByAdapterMetric, Date.now() - startTime);
                });
                stats.logMisses();
                cacheMissMetric.increment(1);
                cacheMissCountByAdapterMetric.increment(1);
                if (cacheMissOutOfTtlDurationByAdapterMetric !== undefined) {
                    this.logAdapterCacheMissOutOfTtlDuration(config, cacheMissOutOfTtlDurationByAdapterMetric, Date.now(), wireAdapterMetricConfig.ttl, wireAdapterMetricConfig.wireConfigKeyFn);
                }
            }
            else if (result !== null) {
                stats.logHits();
                cacheHitMetric.increment(1);
                cacheHitCountByAdapterMetric.increment(1);
                timerMetricAddDuration(cacheHitDurationByAdapterMetric, Date.now() - startTime);
            }
            return result;
        };
        // Set the name property on the function for debugging purposes.
        Object.defineProperty(instrumentedAdapter, 'name', { value: name + '__instrumented' });
        return instrumentedAdapter;
    }
    /**
     * Logs when adapter requests come in. If we have subsequent cache misses on a given config, above its TTL then log the duration to metrics.
     * Backed by an LRU Cache implementation to prevent too many record entries from being stored in-memory.
     * @param config The config passed into wire adapter.
     * @param name The wire adapter name.
     * @param metric The argus timer metric for tracking cache miss durations.
     * @param currentCacheMissTimestamp Timestamp for when the request was made.
     * @param ttl TTL for the wire adapter.
     * @param wireConfigKeyFn Optional function to transform wire configs to a unique key. Otherwise, defaults to use stableJSONStringify().
     */
    logAdapterCacheMissOutOfTtlDuration(config, metric, currentCacheMissTimestamp, ttl, wireConfigKeyFn) {
        const configKey = wireConfigKeyFn
            ? wireConfigKeyFn(config)
            : stableJSONStringify(config);
        const existingCacheMissTimestamp = this.adapterCacheMisses.get(configKey);
        this.adapterCacheMisses.set(configKey, currentCacheMissTimestamp);
        if (existingCacheMissTimestamp !== undefined) {
            const duration = currentCacheMissTimestamp - existingCacheMissTimestamp;
            if (duration > ttl) {
                metric.addDuration(duration);
            }
        }
    }
    /**
     * Add a network transaction to the metrics service.
     * Injected to LDS for network handling instrumentation.
     *
     * @param context The transaction context.
     */
    instrumentNetwork(context) {
        if (this.isWeakETagEvent(context)) {
            this.aggregateWeakETagEvents(context);
        }
        else if (this.isRecordApiNameChangeEvent(context)) {
            this.incrementRecordApiNameChangeCount(context);
        }
        else if (this.isGetRecordMetrics(context)) {
            this.updateGetRecordMetrics(context);
        }
        else if (this.isRecordMergeConflictsMetrics(context)) {
            this.updateRecordMergeConflictsMetrics(context);
        }
        else {
            perfStart(NETWORK_TRANSACTION_NAME);
            perfEnd(NETWORK_TRANSACTION_NAME, context);
        }
    }
    /**
     * Indicates if context is a GetRecordMetrics
     * @param context The transaction context.
     * @returns Whether or not this is a GetRecordMetrics.
     */
    isGetRecordMetrics(context) {
        return context.configRecords !== undefined;
    }
    /**
     * Returns whether or not this is a recordApiNameChangeEvent.
     * @param context The transaction context.
     * @returns Whether or not this is a recordApiNameChangeEvent.
     */
    isRecordApiNameChangeEvent(context) {
        return context[RECORD_API_NAME_CHANGE_EVENT] === true;
    }
    /**
     * Indicates if context is a RecordConflictsMetrics
     * @param context The transaction context.
     * @returns Whether or not this is a RecordConflictsMetrics.
     */
    isRecordMergeConflictsMetrics(context) {
        return context.conflictDepths !== undefined;
    }
    /**
     * Returns via duck-typing whether or not this is a weakETagZeroEvent.
     * @param context The transaction context.
     * @returns Whether or not this is a weakETagZeroEvent.
     */
    isWeakETagEvent(context) {
        return (typeof context[EXISTING_WEAKETAG_0_KEY] === 'boolean' &&
            typeof context[INCOMING_WEAKETAG_0_KEY] === 'boolean');
    }
    /**
     * Parses and aggregates weakETagZero events to be sent in summarized log line.
     * @param context The transaction context.
     */
    aggregateWeakETagEvents(context) {
        const { apiName } = context;
        const key = 'weaketag-0-' + apiName;
        if (this.weakEtagZeroEvents[key] === undefined) {
            this.weakEtagZeroEvents[key] = {
                [EXISTING_WEAKETAG_0_KEY]: 0,
                [INCOMING_WEAKETAG_0_KEY]: 0,
            };
        }
        if (context[EXISTING_WEAKETAG_0_KEY] !== undefined) {
            this.weakEtagZeroEvents[key][EXISTING_WEAKETAG_0_KEY] += 1;
        }
        if (context[INCOMING_WEAKETAG_0_KEY] !== undefined) {
            this.weakEtagZeroEvents[key][INCOMING_WEAKETAG_0_KEY] += 1;
        }
    }
    /**
     * W-7801618
     * Counter for occurrences where the incoming record to be merged has a different apiName.
     * Dynamically generated metric, stored in an {@link RecordApiNameChangeCounters} object.
     *
     * @param context The transaction context.
     *
     * Note: Short-lived metric candidate, remove at the end of 230
     */
    incrementRecordApiNameChangeCount(context) {
        const { existingApiName: apiName } = context;
        let apiNameChangeCounter = this.recordApiNameChangeCounters[apiName];
        if (apiNameChangeCounter === undefined) {
            apiNameChangeCounter = counter(createMetricsKey(NAMESPACE, RECORD_API_NAME_CHANGE_COUNT_METRIC_NAME, apiName));
            this.recordApiNameChangeCounters[apiName] = apiNameChangeCounter;
        }
        apiNameChangeCounter.increment(1);
    }
    updateGetRecordMetrics(metrics) {
        getRecordConfigRecordsPerRequestMetric.update(metrics.configRecords);
        getRecordConfigFieldsPerRequestMetric.update(metrics.configFields);
        getRecordTotalRecordsPerRequestMetric.update(metrics.totalRecords);
        getRecordTotalFieldsPerRequestMetric.update(metrics.totalFields);
        mark('countRecordsAndFields', { duration: metrics.duration });
    }
    updateRecordMergeConflictsMetrics(metrics) {
        recordMergeConflictsMetric.update(metrics.conflictDepths.length);
        for (let i = 0; i < metrics.conflictDepths.length; ++i) {
            recordMergeConfictDepth.update(metrics.conflictDepths[i]);
        }
    }
}
/**
 * Aura Metrics Service plugin in charge of aggregating all the LDS performance marks before they
 * get sent to the server. All the marks are summed by operation type and the aggregated result
 * is then stored an a new mark.
 */
const markAggregatorPlugin = {
    name: NAMESPACE,
    enabled: true,
    initialize() {
        /* noop */
    },
    postProcess(marks) {
        const postProcessedMarks = [];
        let shouldLogAggregated = false;
        const startTs = {};
        const aggregated = {};
        for (let i = 0, len = marks.length; i < len; i++) {
            const mark = marks[i];
            const { name, phase, ts } = mark;
            if (phase === 'start') {
                startTs[name] = ts;
            }
            else if (phase === 'end') {
                if (aggregated[name] === undefined) {
                    aggregated[name] = 0;
                }
                shouldLogAggregated = true;
                aggregated[name] += ts - startTs[name];
            }
            else {
                postProcessedMarks.push(mark);
            }
        }
        if (shouldLogAggregated) {
            postProcessedMarks.push({
                ns: NAMESPACE,
                name: RUNTIME_PERF_MARK_NAME,
                phase: 'stamp',
                ts: time(),
                context: aggregated,
            });
        }
        return postProcessedMarks;
    },
};
function instrumentMethod(obj, methods) {
    for (let i = 0, len = methods.length; i < len; i++) {
        const method = methods[i];
        const methodName = method.methodName;
        const originalMethod = obj[methodName];
        const methodTimer = timer(method.metricKey);
        obj[methodName] = function (...args) {
            markStart(NAMESPACE, methodName);
            const startTime = Date.now();
            const res = originalMethod.call(this, ...args);
            timerMetricAddDuration(methodTimer, Date.now() - startTime);
            markEnd(NAMESPACE, methodName);
            return res;
        };
    }
}
function createMetricsKey(owner, name, unit) {
    let metricName = name;
    if (unit) {
        metricName = metricName + '.' + unit;
    }
    return {
        get() {
            return { owner: owner, name: metricName };
        },
    };
}
function timerMetricAddDuration(timer, duration) {
    // Guard against negative values since it causes error to be thrown by MetricsService
    if (duration >= 0) {
        timer.addDuration(duration);
    }
}
function getStoreStats(store) {
    const { records, snapshotSubscriptions, watchSubscriptions } = store;
    const recordCount = keys(records).length;
    const snapshotSubscriptionCount = keys(snapshotSubscriptions).length;
    const watchSubscriptionCount = keys(watchSubscriptions).length;
    const subscriptionCount = snapshotSubscriptionCount + watchSubscriptionCount;
    return {
        recordCount,
        subscriptionCount,
        snapshotSubscriptionCount,
        watchSubscriptionCount,
    };
}
/**
 * Add a mark to the metrics service.
 *
 * @param name The mark name.
 * @param content The mark content.
 */
function mark(name, content) {
    mark$1(NAMESPACE, name, content);
}
/**
 * Create a new instrumentation cache stats and return it.
 *
 * @param name The cache logger name.
 */
function registerLdsCacheStats(name) {
    return registerCacheStats(`${NAMESPACE}:${name}`);
}
/**
 * Initialize the instrumentation and instrument the LDS instance and the Store.
 *
 * @param lds The LDS to instrument.
 * @param store The Store to instrument.
 */
function setupInstrumentation(lds, store) {
    registerPlugin({
        name: NAMESPACE,
        plugin: markAggregatorPlugin,
    });
    instrumentMethod(lds, [
        { methodName: 'storeBroadcast', metricKey: STORE_BROADCAST_DURATION },
        { methodName: 'storeIngest', metricKey: STORE_INGEST_DURATION },
        { methodName: 'storeLookup', metricKey: STORE_LOOKUP_DURATION },
    ]);
    registerPeriodicLogger(NAMESPACE, () => {
        const storeStats = getStoreStats(store);
        mark$1(NAMESPACE, STORE_STATS_MARK_NAME, storeStats);
        storeSizeMetric.update(storeStats.recordCount);
        storeSnapshotSubscriptionsMetric.update(storeStats.snapshotSubscriptionCount);
        storeWatchSubscriptionsMetric.update(storeStats.watchSubscriptionCount);
    });
}
function incrementGetRecordNormalInvokeCount() {
    getRecordNormalInvokeMetric.increment(1);
}
function incrementGetRecordAggregateInvokeCount() {
    getRecordAggregateInvokeMetric.increment(1);
}
function incrementGetRecordNotifyChangeAllowCount() {
    getRecordNotifyChangeAllowMetric.increment(1);
}
function incrementGetRecordNotifyChangeDropCount() {
    getRecordNotifyChangeDropMetric.increment(1);
}
/**
 * Note: locator.scope is set to 'force_record' in order for the instrumentation gate to work, which will
 * disable all crud operations if it is on.
 * @param eventSource - Source of the logging event.
 * @param attributes - Free form object of attributes to log.
 */
function logCRUDLightningInteraction(eventSource, attributes) {
    interaction(eventSource, 'force_record', null, eventSource, 'crud', attributes);
}
const instrumentation = new Instrumentation();

export { Instrumentation, incrementGetRecordAggregateInvokeCount, incrementGetRecordNormalInvokeCount, incrementGetRecordNotifyChangeAllowCount, incrementGetRecordNotifyChangeDropCount, instrumentation, logCRUDLightningInteraction, mark, registerLdsCacheStats, setupInstrumentation, timerMetricAddDuration };
