/*  *******************************************************************************************
 *  ATTENTION!
 *  THIS IS A GENERATED FILE FROM https://github.com/salesforce/lds-lightning-platform
 *  If you would like to contribute to LDS, please follow the steps outlined in the git repo.
 *  Any changes made to this file in p4 will be automatically overwritten.
 *  *******************************************************************************************
 */
/* proxy-compat-disable */
import { createWireAdapterConstructor, createLDSAdapter } from 'force/ldsBindings';
export { refresh } from 'force/ldsBindings';
import { incrementGetRecordNotifyChangeAllowCount, incrementGetRecordNotifyChangeDropCount } from 'force/ldsInstrumentation';
export { createRecordInputFilteredByEditedFields, generateRecordInputForCreate, generateRecordInputForUpdate, getFieldDisplayValue, getFieldValue, getRecordInput } from './uiapi-static-functions';

/**
 * Limit the frequency and the duration that a function is invoked.
 *
 * @param invokeLimit The frequency a function could be invoked.
 * @param timeLimit The duration a function could be invoked with the rate limit, in milliseconds.
 * @param fn The function to be invoked.
 * @param options Extra options for instrumentation, logging, or bookkeeping purposes.
 * @returns The wrapped rate limited function.
 */
function throttle(invokeLimit, timeLimit, fn, options) {
    if (invokeLimit <= 0 || timeLimit <= 0) {
        throw new Error('only supports throttling with positive invokeLimit and timeLimit');
    }
    let invokeCount = 0;
    let time = Date.now();
    const allowFunction = options && options.allowFunction ? options.allowFunction : () => { };
    const dropFunction = options && options.dropFunction ? options.dropFunction : () => { };
    return (...args) => {
        const calledTime = Date.now();
        if (calledTime - time <= timeLimit) {
            if (invokeCount < invokeLimit) {
                invokeCount += 1;
                allowFunction();
                return fn(...args);
            }
            else {
                dropFunction();
            }
        }
        else {
            time = calledTime;
            invokeCount = 1;
            allowFunction();
            return fn(...args);
        }
    };
}

const { hasOwnProperty: ObjectPrototypeHasOwnProperty } = Object.prototype;
const { keys: ObjectKeys, freeze: ObjectFreeze } = Object;
const { stringify: JSONStringify } = JSON;
const { isArray: ArrayIsArray } = Array;
const { push: ArrayPrototypePush } = Array.prototype;
function isPromise(value) {
    return value.then !== undefined;
}
/**
 * Validates an adapter config is well-formed.
 * @param config The config to validate.
 * @param adapter The adapter validation configuration.
 * @param oneOf The keys the config must contain at least one of.
 * @throws A TypeError if config doesn't satisfy the adapter's config validation.
 */
function validateConfig(config, adapter, oneOf) {
    const { displayName } = adapter;
    const { required, optional, unsupported } = adapter.parameters;
    if (config === undefined ||
        required.every(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify ${required.sort().join(', ')}`);
    }
    if (oneOf && oneOf.some(req => ObjectPrototypeHasOwnProperty.call(config, req)) === false) {
        throw new TypeError(`adapter ${displayName} configuration must specify one of ${oneOf.sort().join(', ')}`);
    }
    if (unsupported !== undefined &&
        unsupported.some(req => ObjectPrototypeHasOwnProperty.call(config, req))) {
        throw new TypeError(`adapter ${displayName} does not yet support ${unsupported.sort().join(', ')}`);
    }
    const supported = required.concat(optional);
    if (ObjectKeys(config).some(key => !supported.includes(key))) {
        throw new TypeError(`adapter ${displayName} configuration supports only ${supported.sort().join(', ')}`);
    }
}
function untrustedIsObject(untrusted) {
    return typeof untrusted === 'object' && untrusted !== null && ArrayIsArray(untrusted) === false;
}
function areRequiredParametersPresent(config, configPropertyNames) {
    return configPropertyNames.parameters.required.every(req => req in config);
}
function refreshable(adapter, resolve) {
    return (config) => {
        const result = adapter(config);
        if (result === null) {
            return result;
        }
        if (isPromise(result)) {
            return result.then(snapshot => {
                snapshot.refresh = {
                    config,
                    resolve,
                };
                return snapshot;
            });
        }
        result.refresh = {
            config,
            resolve,
        };
        return result;
    };
}
const SNAPSHOT_STATE_UNFULFILLED = 'Unfulfilled';
const snapshotRefreshOptions = {
    headers: {
        'Cache-Control': 'no-cache',
    },
};
/**
 * A deterministic JSON stringify implementation. Heavily adapted from https://github.com/epoberezkin/fast-json-stable-stringify.
 * This is needed because insertion order for JSON.stringify(object) affects output:
 * JSON.stringify({a: 1, b: 2})
 *      "{"a":1,"b":2}"
 * JSON.stringify({b: 2, a: 1})
 *      "{"b":2,"a":1}"
 * @param data Data to be JSON-stringified.
 * @returns JSON.stringified value with consistent ordering of keys.
 */
function stableJSONStringify(node) {
    // This is for Date values.
    if (node && node.toJSON && typeof node.toJSON === 'function') {
        // eslint-disable-next-line no-param-reassign
        node = node.toJSON();
    }
    if (node === undefined) {
        return;
    }
    if (typeof node === 'number') {
        return isFinite(node) ? '' + node : 'null';
    }
    if (typeof node !== 'object') {
        return JSONStringify(node);
    }
    let i;
    let out;
    if (ArrayIsArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
            if (i) {
                out += ',';
            }
            out += stableJSONStringify(node[i]) || 'null';
        }
        return out + ']';
    }
    if (node === null) {
        return 'null';
    }
    const keys = ObjectKeys(node).sort();
    out = '';
    for (i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = stableJSONStringify(node[key]);
        if (!value) {
            continue;
        }
        if (out) {
            out += ',';
        }
        out += JSONStringify(key) + ':' + value;
    }
    return '{' + out + '}';
}
function getFetchResponseStatusText(status) {
    switch (status) {
        case 200:
            return 'OK';
        case 304:
            return 'Not Modified';
        case 404:
            return 'Not Found';
        case 400:
            return 'Bad Request';
        case 500:
            return 'Server Error';
        default:
            return `Unexpected HTTP Status Code: ${status}`;
    }
}
const keyPrefix = 'UiApi::';

const { freeze: ObjectFreeze$1, keys: ObjectKeys$1 } = Object;
const { isArray: ArrayIsArray$1 } = Array;
const { stringify: JSONStrinify } = JSON;
function equalsArray(a, b, equalsItem) {
    const aLength = a.length;
    const bLength = b.length;
    if (aLength !== bLength) {
        return false;
    }
    for (let i = 0; i < aLength; i++) {
        if (equalsItem(a[i], b[i]) === false) {
            return false;
        }
    }
    return true;
}
function equalsObject(a, b, equalsProp) {
    const aKeys = ObjectKeys$1(a).sort();
    const bKeys = ObjectKeys$1(b).sort();
    const aKeysLength = aKeys.length;
    const bKeysLength = bKeys.length;
    if (aKeysLength !== bKeysLength) {
        return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
        const key = aKeys[i];
        if (key !== bKeys[i]) {
            return false;
        }
        if (equalsProp(a[key], b[key]) === false) {
            return false;
        }
    }
    return true;
}
function deepFreeze(value) {
    // No need to freeze primitives
    if (typeof value !== 'object' || value === null) {
        return;
    }
    if (ArrayIsArray$1(value)) {
        for (let i = 0, len = value.length; i < len; i += 1) {
            deepFreeze(value[i]);
        }
    }
    else {
        const keys = ObjectKeys$1(value);
        for (let i = 0, len = keys.length; i < len; i += 1) {
            deepFreeze(value[keys[i]]);
        }
    }
    ObjectFreeze$1(value);
}
function createLink(ref) {
    return {
        __ref: ref,
    };
}

function validate(obj, path = 'ListColumnRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select = function ListColumnRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'fieldApiName',
                kind: 'Scalar',
            },
            {
                name: 'label',
                kind: 'Scalar',
            },
            {
                name: 'sortable',
                kind: 'Scalar',
            }
        ]
    };
};

function validate$1(obj, path = 'ListFilterByInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_operandLabels = obj.operandLabels;
        const path_operandLabels = path + '.operandLabels';
        if (!ArrayIsArray$1(obj_operandLabels)) {
            return new TypeError('Expected "array" but received "' + typeof obj_operandLabels + '" (at "' + path_operandLabels + '")');
        }
        for (let i = 0; i < obj_operandLabels.length; i++) {
            const obj_operandLabels_item = obj_operandLabels[i];
            const path_operandLabels_item = path_operandLabels + '[' + i + ']';
            if (typeof obj_operandLabels_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_operandLabels_item + '" (at "' + path_operandLabels_item + '")');
            }
        }
        const obj_operator = obj.operator;
        const path_operator = path + '.operator';
        if (typeof obj_operator !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operator + '" (at "' + path_operator + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$1 = function ListFilterByInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'fieldApiName',
                kind: 'Scalar',
            },
            {
                name: 'label',
                kind: 'Scalar',
            },
            {
                name: 'operandLabels',
                kind: 'Scalar',
                plural: true,
            },
            {
                name: 'operator',
                kind: 'Scalar',
            }
        ]
    };
};
function deepFreeze$1(input) {
    const input_operandLabels = input.operandLabels;
    ObjectFreeze$1(input_operandLabels);
    ObjectFreeze$1(input);
}

function validate$2(obj, path = 'ListOrderByInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_isAscending = obj.isAscending;
        const path_isAscending = path + '.isAscending';
        if (typeof obj_isAscending !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isAscending + '" (at "' + path_isAscending + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$2 = function ListOrderByInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'fieldApiName',
                kind: 'Scalar',
            },
            {
                name: 'isAscending',
                kind: 'Scalar',
            },
            {
                name: 'label',
                kind: 'Scalar',
            }
        ]
    };
};
function deepFreeze$2(input) {
    ObjectFreeze$1(input);
}

function validate$3(obj, path = 'ListUserPreferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_columnWidths = obj.columnWidths;
        const path_columnWidths = path + '.columnWidths';
        if (typeof obj_columnWidths !== 'object' || ArrayIsArray$1(obj_columnWidths) || obj_columnWidths === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_columnWidths + '" (at "' + path_columnWidths + '")');
        }
        const obj_columnWidths_keys = ObjectKeys$1(obj_columnWidths);
        for (let i = 0; i < obj_columnWidths_keys.length; i++) {
            const key = obj_columnWidths_keys[i];
            const obj_columnWidths_prop = obj_columnWidths[key];
            const path_columnWidths_prop = path_columnWidths + '["' + key + '"]';
            if (typeof obj_columnWidths_prop !== 'number' || (typeof obj_columnWidths_prop === 'number' && Math.floor(obj_columnWidths_prop) !== obj_columnWidths_prop)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_columnWidths_prop + '" (at "' + path_columnWidths_prop + '")');
            }
        }
        const obj_columnWrap = obj.columnWrap;
        const path_columnWrap = path + '.columnWrap';
        if (typeof obj_columnWrap !== 'object' || ArrayIsArray$1(obj_columnWrap) || obj_columnWrap === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_columnWrap + '" (at "' + path_columnWrap + '")');
        }
        const obj_columnWrap_keys = ObjectKeys$1(obj_columnWrap);
        for (let i = 0; i < obj_columnWrap_keys.length; i++) {
            const key = obj_columnWrap_keys[i];
            const obj_columnWrap_prop = obj_columnWrap[key];
            const path_columnWrap_prop = path_columnWrap + '["' + key + '"]';
            if (typeof obj_columnWrap_prop !== 'boolean') {
                return new TypeError('Expected "boolean" but received "' + typeof obj_columnWrap_prop + '" (at "' + path_columnWrap_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$3 = function ListUserPreferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'columnWidths',
                kind: 'Scalar',
                map: true,
            },
            {
                name: 'columnWrap',
                kind: 'Scalar',
                map: true,
            }
        ]
    };
};
function deepFreeze$3(input) {
    const input_columnWidths = input.columnWidths;
    const input_columnWidths_keys = Object.keys(input_columnWidths);
    const input_columnWidths_length = input_columnWidths_keys.length;
    for (let i = 0; i < input_columnWidths_length; i++) {
        const key = input_columnWidths_keys[i];
    }
    ObjectFreeze$1(input_columnWidths);
    const input_columnWrap = input.columnWrap;
    const input_columnWrap_keys = Object.keys(input_columnWrap);
    const input_columnWrap_length = input_columnWrap_keys.length;
    for (let i = 0; i < input_columnWrap_length; i++) {
        const key = input_columnWrap_keys[i];
    }
    ObjectFreeze$1(input_columnWrap);
    ObjectFreeze$1(input);
}

function validate$4(obj, path = 'ListReferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_listViewApiName = obj.listViewApiName;
        const path_listViewApiName = path + '.listViewApiName';
        let obj_listViewApiName_union0 = null;
        const obj_listViewApiName_union0_error = (() => {
            if (typeof obj_listViewApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union0_error != null) {
            obj_listViewApiName_union0 = obj_listViewApiName_union0_error.message;
        }
        let obj_listViewApiName_union1 = null;
        const obj_listViewApiName_union1_error = (() => {
            if (obj_listViewApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union1_error != null) {
            obj_listViewApiName_union1 = obj_listViewApiName_union1_error.message;
        }
        if (obj_listViewApiName_union0 && obj_listViewApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_listViewApiName + '")';
            message += '\n' + obj_listViewApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_listViewApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder(config) {
    return keyPrefix + 'ListReferenceRepresentation:' + (config.id === null ? '' : config.id);
}
function keyBuilderFromType(object) {
    const keyParams = {
        id: object.id
    };
    return keyBuilder(keyParams);
}
function normalize(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$4 = function ListReferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'id',
                kind: 'Scalar',
            },
            {
                name: 'listViewApiName',
                kind: 'Scalar',
            },
            {
                name: 'objectApiName',
                kind: 'Scalar',
            },
            {
                name: 'type',
                kind: 'Scalar',
            }
        ]
    };
};
function equals(existing, incoming) {
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_listViewApiName = existing.listViewApiName;
    const incoming_listViewApiName = incoming.listViewApiName;
    if (!(existing_listViewApiName === incoming_listViewApiName)) {
        return false;
    }
    return true;
}
const ingest = function ListReferenceRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$4(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType(input);
    let incomingRecord = normalize(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$5(obj, path = 'ListInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_cloneable = obj.cloneable;
        const path_cloneable = path + '.cloneable';
        if (typeof obj_cloneable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_cloneable + '" (at "' + path_cloneable + '")');
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_displayColumns = obj.displayColumns;
        const path_displayColumns = path + '.displayColumns';
        if (!ArrayIsArray$1(obj_displayColumns)) {
            return new TypeError('Expected "array" but received "' + typeof obj_displayColumns + '" (at "' + path_displayColumns + '")');
        }
        for (let i = 0; i < obj_displayColumns.length; i++) {
            const obj_displayColumns_item = obj_displayColumns[i];
            const path_displayColumns_item = path_displayColumns + '[' + i + ']';
            const referenceListColumnRepresentationValidationError = validate(obj_displayColumns_item, path_displayColumns_item);
            if (referenceListColumnRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ListColumnRepresentation (at "' + path_displayColumns_item + '")\n';
                message += referenceListColumnRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_filterLogicString = obj.filterLogicString;
        const path_filterLogicString = path + '.filterLogicString';
        let obj_filterLogicString_union0 = null;
        const obj_filterLogicString_union0_error = (() => {
            if (typeof obj_filterLogicString !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
            }
        })();
        if (obj_filterLogicString_union0_error != null) {
            obj_filterLogicString_union0 = obj_filterLogicString_union0_error.message;
        }
        let obj_filterLogicString_union1 = null;
        const obj_filterLogicString_union1_error = (() => {
            if (obj_filterLogicString !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
            }
        })();
        if (obj_filterLogicString_union1_error != null) {
            obj_filterLogicString_union1 = obj_filterLogicString_union1_error.message;
        }
        if (obj_filterLogicString_union0 && obj_filterLogicString_union1) {
            let message = 'Object doesn\'t match union (at "' + path_filterLogicString + '")';
            message += '\n' + obj_filterLogicString_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_filterLogicString_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_filteredByInfo = obj.filteredByInfo;
        const path_filteredByInfo = path + '.filteredByInfo';
        if (!ArrayIsArray$1(obj_filteredByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_filteredByInfo + '" (at "' + path_filteredByInfo + '")');
        }
        for (let i = 0; i < obj_filteredByInfo.length; i++) {
            const obj_filteredByInfo_item = obj_filteredByInfo[i];
            const path_filteredByInfo_item = path_filteredByInfo + '[' + i + ']';
            const referenceListFilterByInfoRepresentationValidationError = validate$1(obj_filteredByInfo_item, path_filteredByInfo_item);
            if (referenceListFilterByInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ListFilterByInfoRepresentation (at "' + path_filteredByInfo_item + '")\n';
                message += referenceListFilterByInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        if (typeof obj_listReference !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_listReference + '" (at "' + path_listReference + '")');
        }
        const obj_orderedByInfo = obj.orderedByInfo;
        const path_orderedByInfo = path + '.orderedByInfo';
        if (!ArrayIsArray$1(obj_orderedByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_orderedByInfo + '" (at "' + path_orderedByInfo + '")');
        }
        for (let i = 0; i < obj_orderedByInfo.length; i++) {
            const obj_orderedByInfo_item = obj_orderedByInfo[i];
            const path_orderedByInfo_item = path_orderedByInfo + '[' + i + ']';
            const referenceListOrderByInfoRepresentationValidationError = validate$2(obj_orderedByInfo_item, path_orderedByInfo_item);
            if (referenceListOrderByInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedByInfo_item + '")\n';
                message += referenceListOrderByInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
        const obj_userPreferences = obj.userPreferences;
        const path_userPreferences = path + '.userPreferences';
        const referenceListUserPreferenceRepresentationValidationError = validate$3(obj_userPreferences, path_userPreferences);
        if (referenceListUserPreferenceRepresentationValidationError !== null) {
            let message = 'Object doesn\'t match ListUserPreferenceRepresentation (at "' + path_userPreferences + '")\n';
            message += referenceListUserPreferenceRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_visibility = obj.visibility;
        const path_visibility = path + '.visibility';
        if (typeof obj_visibility !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_visibility + '" (at "' + path_visibility + '")');
        }
        const obj_visibilityEditable = obj.visibilityEditable;
        const path_visibilityEditable = path + '.visibilityEditable';
        if (typeof obj_visibilityEditable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_visibilityEditable + '" (at "' + path_visibilityEditable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$1(config) {
    return keyPrefix + 'ListInfoRepresentation:' + (config.listViewApiName === null ? '' : config.listViewApiName) + ':' + config.objectApiName + ':' + config.type;
}
function keyBuilderFromType$1(object) {
    const keyParams = {
        listViewApiName: object.listReference.listViewApiName,
        objectApiName: object.listReference.objectApiName,
        type: object.listReference.type
    };
    return keyBuilder$1(keyParams);
}
function normalize$1(input, existing, path, lds, store, timestamp) {
    const input_listReference = input.listReference;
    const input_listReference_id = path.fullPath + '__listReference';
    input.listReference = ingest(input_listReference, {
        fullPath: input_listReference_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store);
    return input;
}
const select$5 = function ListInfoRepresentationSelect() {
    const { selections: ListColumnRepresentation__selections, opaque: ListColumnRepresentation__opaque, } = select();
    const { selections: ListFilterByInfoRepresentation__selections, opaque: ListFilterByInfoRepresentation__opaque, } = select$1();
    const { selections: ListOrderByInfoRepresentation__selections, opaque: ListOrderByInfoRepresentation__opaque, } = select$2();
    const { selections: ListUserPreferenceRepresentation__selections, opaque: ListUserPreferenceRepresentation__opaque, } = select$3();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'cloneable',
                kind: 'Scalar',
            },
            {
                name: 'createable',
                kind: 'Scalar',
            },
            {
                name: 'deletable',
                kind: 'Scalar',
            },
            {
                name: 'displayColumns',
                kind: 'Object',
                plural: true,
                selections: ListColumnRepresentation__selections
            },
            {
                name: 'filterLogicString',
                kind: 'Scalar',
            },
            {
                name: 'filteredByInfo',
                kind: 'Object',
                plural: true,
                selections: ListFilterByInfoRepresentation__selections
            },
            {
                name: 'label',
                kind: 'Scalar',
            },
            {
                name: 'listReference',
                kind: 'Link',
                fragment: select$4()
            },
            {
                name: 'orderedByInfo',
                kind: 'Object',
                plural: true,
                selections: ListOrderByInfoRepresentation__selections
            },
            {
                name: 'updateable',
                kind: 'Scalar',
            },
            {
                name: 'userPreferences',
                kind: 'Object',
                selections: ListUserPreferenceRepresentation__selections
            },
            {
                name: 'visibility',
                kind: 'Scalar',
            },
            {
                name: 'visibilityEditable',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$1(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
const ingest$1 = function ListInfoRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$5(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$1(input);
    let incomingRecord = normalize$1(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$1(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$6(obj, path = 'RecordTypeInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_available = obj.available;
        const path_available = path + '.available';
        if (typeof obj_available !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_available + '" (at "' + path_available + '")');
        }
        const obj_defaultRecordTypeMapping = obj.defaultRecordTypeMapping;
        const path_defaultRecordTypeMapping = path + '.defaultRecordTypeMapping';
        if (typeof obj_defaultRecordTypeMapping !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_defaultRecordTypeMapping + '" (at "' + path_defaultRecordTypeMapping + '")');
        }
        const obj_master = obj.master;
        const path_master = path + '.master';
        if (typeof obj_master !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_master + '" (at "' + path_master + '")');
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function equals$2(existing, incoming) {
    const existing_available = existing.available;
    const incoming_available = incoming.available;
    if (!(existing_available === incoming_available)) {
        return false;
    }
    const existing_defaultRecordTypeMapping = existing.defaultRecordTypeMapping;
    const incoming_defaultRecordTypeMapping = incoming.defaultRecordTypeMapping;
    if (!(existing_defaultRecordTypeMapping === incoming_defaultRecordTypeMapping)) {
        return false;
    }
    const existing_master = existing.master;
    const incoming_master = incoming.master;
    if (!(existing_master === incoming_master)) {
        return false;
    }
    const existing_name = existing.name;
    const incoming_name = incoming.name;
    if (!(existing_name === incoming_name)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
function deepFreeze$4(input) {
    ObjectFreeze$1(input);
}

function validate$7(obj, path = 'RecordCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        let obj_currentPageToken_union0 = null;
        const obj_currentPageToken_union0_error = (() => {
            if (typeof obj_currentPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
            }
        })();
        if (obj_currentPageToken_union0_error != null) {
            obj_currentPageToken_union0 = obj_currentPageToken_union0_error.message;
        }
        let obj_currentPageToken_union1 = null;
        const obj_currentPageToken_union1_error = (() => {
            if (obj_currentPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
            }
        })();
        if (obj_currentPageToken_union1_error != null) {
            obj_currentPageToken_union1 = obj_currentPageToken_union1_error.message;
        }
        if (obj_currentPageToken_union0 && obj_currentPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_currentPageToken + '")';
            message += '\n' + obj_currentPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_currentPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray$1(obj_records)) {
            return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
            const obj_records_item = obj_records[i];
            const path_records_item = path_records + '[' + i + ']';
            if (typeof obj_records_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$2(input, existing, path, lds, store, timestamp) {
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$4(input_records_item, {
            fullPath: input_records_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$3(existing, incoming) {
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
            return false;
        }
    });
    if (equals_records_items === false) {
        return false;
    }
    return true;
}
const ingest$2 = function RecordCollectionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$7(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$2(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$3(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 120000);
    return createLink(key);
};

function validate$8(obj, path = 'FieldValueRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_displayValue = obj.displayValue;
        const path_displayValue = path + '.displayValue';
        let obj_displayValue_union0 = null;
        const obj_displayValue_union0_error = (() => {
            if (typeof obj_displayValue !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_displayValue + '" (at "' + path_displayValue + '")');
            }
        })();
        if (obj_displayValue_union0_error != null) {
            obj_displayValue_union0 = obj_displayValue_union0_error.message;
        }
        let obj_displayValue_union1 = null;
        const obj_displayValue_union1_error = (() => {
            if (obj_displayValue !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_displayValue + '" (at "' + path_displayValue + '")');
            }
        })();
        if (obj_displayValue_union1_error != null) {
            obj_displayValue_union1 = obj_displayValue_union1_error.message;
        }
        if (obj_displayValue_union0 && obj_displayValue_union1) {
            let message = 'Object doesn\'t match union (at "' + path_displayValue + '")';
            message += '\n' + obj_displayValue_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_displayValue_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        let obj_value_union0 = null;
        const obj_value_union0_error = (() => {
            if (typeof obj_value !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union0_error != null) {
            obj_value_union0 = obj_value_union0_error.message;
        }
        let obj_value_union1 = null;
        const obj_value_union1_error = (() => {
            if (typeof obj_value !== 'boolean') {
                return new TypeError('Expected "boolean" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union1_error != null) {
            obj_value_union1 = obj_value_union1_error.message;
        }
        let obj_value_union2 = null;
        const obj_value_union2_error = (() => {
            if (typeof obj_value !== 'number') {
                return new TypeError('Expected "number" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union2_error != null) {
            obj_value_union2 = obj_value_union2_error.message;
        }
        let obj_value_union3 = null;
        const obj_value_union3_error = (() => {
            if (typeof obj_value !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union3_error != null) {
            obj_value_union3 = obj_value_union3_error.message;
        }
        let obj_value_union4 = null;
        const obj_value_union4_error = (() => {
            if (obj_value !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_value + '" (at "' + path_value + '")');
            }
        })();
        if (obj_value_union4_error != null) {
            obj_value_union4 = obj_value_union4_error.message;
        }
        if (obj_value_union0 && obj_value_union1 && obj_value_union2 && obj_value_union3 && obj_value_union4) {
            let message = 'Object doesn\'t match union (at "' + path_value + '")';
            message += '\n' + obj_value_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union1.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union2.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union3.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_value_union4.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$3(input, existing, path, lds, store, timestamp) {
    const input_value = input.value;
    const input_value_id = path.fullPath + '__value';
    if (input_value !== null && typeof input_value === 'object') {
        input.value = ingest$4(input_value, {
            fullPath: input_value_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$4(existing, incoming) {
    const existing_displayValue = existing.displayValue;
    const incoming_displayValue = incoming.displayValue;
    if (!(existing_displayValue === incoming_displayValue)) {
        return false;
    }
    const existing_value = existing.value;
    const incoming_value = incoming.value;
    if (!(existing_value === incoming_value
        || (existing_value != null &&
            incoming_value != null &&
            existing_value.__ref != null &&
            incoming_value.__ref != null &&
            existing_value.__ref === incoming_value.__ref))) {
        return false;
    }
    return true;
}

function merge(existing, incoming, _lds, path) {
    if (existing === undefined) {
        return incoming;
    }
    // TODO: (W-7164913) remove once UISDK is done with a long term fix.
    // Temporary fix for the issue that non-null displayValue gets replaced by null.
    // If displayValue and value are both null, it means the field is empty.
    if (incoming.displayValue === null &&
        incoming.value !== null &&
        existing.displayValue !== null) {
        incoming.displayValue = existing.displayValue;
    }
    const { value } = incoming;
    if (value === null || value.__ref === undefined) {
        // Parent will never be null this field only exists in the context of a RecordRep.
        const parent = path.parent;
        // It may happen that a parent.exists is null, this is the case when the same field is
        // ingested multiple times in the same ingestion cycle. For example: when the same record
        // is present multiple time in the ingested payload.
        if (parent.existing === undefined) {
            return incoming;
        }
        const existingVersion = parent.existing.weakEtag;
        const incomingVersion = parent.data.weakEtag;
        if (existingVersion > incomingVersion) {
            return existing;
        }
    }
    return incoming;
}

const ingest$3 = function FieldValueRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$8(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$3(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    incomingRecord = merge(existingRecord, incomingRecord, lds, path);
    if (existingRecord === undefined || equals$4(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

const TTL = 30000;
function validate$9(obj, path = 'RecordRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (typeof obj_childRelationships !== 'object' || ArrayIsArray$1(obj_childRelationships) || obj_childRelationships === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        const obj_childRelationships_keys = ObjectKeys$1(obj_childRelationships);
        for (let i = 0; i < obj_childRelationships_keys.length; i++) {
            const key = obj_childRelationships_keys[i];
            const obj_childRelationships_prop = obj_childRelationships[key];
            const path_childRelationships_prop = path_childRelationships + '["' + key + '"]';
            if (typeof obj_childRelationships_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_childRelationships_prop + '" (at "' + path_childRelationships_prop + '")');
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_lastModifiedById = obj.lastModifiedById;
        const path_lastModifiedById = path + '.lastModifiedById';
        let obj_lastModifiedById_union0 = null;
        const obj_lastModifiedById_union0_error = (() => {
            if (typeof obj_lastModifiedById !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union0_error != null) {
            obj_lastModifiedById_union0 = obj_lastModifiedById_union0_error.message;
        }
        let obj_lastModifiedById_union1 = null;
        const obj_lastModifiedById_union1_error = (() => {
            if (obj_lastModifiedById !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union1_error != null) {
            obj_lastModifiedById_union1 = obj_lastModifiedById_union1_error.message;
        }
        if (obj_lastModifiedById_union0 && obj_lastModifiedById_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedById + '")';
            message += '\n' + obj_lastModifiedById_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedById_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        let obj_lastModifiedDate_union0 = null;
        const obj_lastModifiedDate_union0_error = (() => {
            if (typeof obj_lastModifiedDate !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union0_error != null) {
            obj_lastModifiedDate_union0 = obj_lastModifiedDate_union0_error.message;
        }
        let obj_lastModifiedDate_union1 = null;
        const obj_lastModifiedDate_union1_error = (() => {
            if (obj_lastModifiedDate !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union1_error != null) {
            obj_lastModifiedDate_union1 = obj_lastModifiedDate_union1_error.message;
        }
        if (obj_lastModifiedDate_union0 && obj_lastModifiedDate_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedDate + '")';
            message += '\n' + obj_lastModifiedDate_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedDate_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeInfo = obj.recordTypeInfo;
        const path_recordTypeInfo = path + '.recordTypeInfo';
        let obj_recordTypeInfo_union0 = null;
        const obj_recordTypeInfo_union0_error = (() => {
            const referenceRecordTypeInfoRepresentationValidationError = validate$6(obj_recordTypeInfo, path_recordTypeInfo);
            if (referenceRecordTypeInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfo + '")\n';
                message += referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_recordTypeInfo_union0_error != null) {
            obj_recordTypeInfo_union0 = obj_recordTypeInfo_union0_error.message;
        }
        let obj_recordTypeInfo_union1 = null;
        const obj_recordTypeInfo_union1_error = (() => {
            if (obj_recordTypeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeInfo + '" (at "' + path_recordTypeInfo + '")');
            }
        })();
        if (obj_recordTypeInfo_union1_error != null) {
            obj_recordTypeInfo_union1 = obj_recordTypeInfo_union1_error.message;
        }
        if (obj_recordTypeInfo_union0 && obj_recordTypeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeInfo + '")';
            message += '\n' + obj_recordTypeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_systemModstamp = obj.systemModstamp;
        const path_systemModstamp = path + '.systemModstamp';
        let obj_systemModstamp_union0 = null;
        const obj_systemModstamp_union0_error = (() => {
            if (typeof obj_systemModstamp !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union0_error != null) {
            obj_systemModstamp_union0 = obj_systemModstamp_union0_error.message;
        }
        let obj_systemModstamp_union1 = null;
        const obj_systemModstamp_union1_error = (() => {
            if (obj_systemModstamp !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union1_error != null) {
            obj_systemModstamp_union1 = obj_systemModstamp_union1_error.message;
        }
        if (obj_systemModstamp_union0 && obj_systemModstamp_union1) {
            let message = 'Object doesn\'t match union (at "' + path_systemModstamp + '")';
            message += '\n' + obj_systemModstamp_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_systemModstamp_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_weakEtag = obj.weakEtag;
        const path_weakEtag = path + '.weakEtag';
        if (typeof obj_weakEtag !== 'number' || (typeof obj_weakEtag === 'number' && Math.floor(obj_weakEtag) !== obj_weakEtag)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_weakEtag + '" (at "' + path_weakEtag + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$2(config) {
    return keyPrefix + 'RecordRepresentation:' + config.recordId;
}
function keyBuilderFromType$2(object) {
    const keyParams = {
        recordId: object.id
    };
    return keyBuilder$2(keyParams);
}
function normalize$4(input, existing, path, lds, store, timestamp) {
    const input_childRelationships = input.childRelationships;
    const input_childRelationships_id = path.fullPath + '__childRelationships';
    const input_childRelationships_keys = Object.keys(input_childRelationships);
    const input_childRelationships_length = input_childRelationships_keys.length;
    for (let i = 0; i < input_childRelationships_length; i++) {
        const key = input_childRelationships_keys[i];
        const input_childRelationships_prop = input_childRelationships[key];
        const input_childRelationships_prop_id = input_childRelationships_id + '__' + key;
        input_childRelationships[key] = ingest$2(input_childRelationships_prop, {
            fullPath: input_childRelationships_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_fields = input.fields;
    const input_fields_id = path.fullPath + '__fields';
    const input_fields_keys = Object.keys(input_fields);
    const input_fields_length = input_fields_keys.length;
    for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        const input_fields_prop_id = input_fields_id + '__' + key;
        input_fields[key] = ingest$3(input_fields_prop, {
            fullPath: input_fields_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$5(existing, incoming) {
    const existing_weakEtag = existing.weakEtag;
    const incoming_weakEtag = incoming.weakEtag;
    if (!(existing_weakEtag === incoming_weakEtag)) {
        return false;
    }
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_childRelationships = existing.childRelationships;
    const incoming_childRelationships = incoming.childRelationships;
    const equals_childRelationships_props = equalsObject(existing_childRelationships, incoming_childRelationships, (existing_childRelationships_prop, incoming_childRelationships_prop) => {
        if (!(existing_childRelationships_prop.__ref === incoming_childRelationships_prop.__ref)) {
            return false;
        }
    });
    if (equals_childRelationships_props === false) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_lastModifiedById = existing.lastModifiedById;
    const incoming_lastModifiedById = incoming.lastModifiedById;
    if (!(existing_lastModifiedById === incoming_lastModifiedById)) {
        return false;
    }
    const existing_lastModifiedDate = existing.lastModifiedDate;
    const incoming_lastModifiedDate = incoming.lastModifiedDate;
    if (!(existing_lastModifiedDate === incoming_lastModifiedDate)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    const existing_recordTypeInfo = existing.recordTypeInfo;
    const incoming_recordTypeInfo = incoming.recordTypeInfo;
    if (!(existing_recordTypeInfo === incoming_recordTypeInfo
        || (existing_recordTypeInfo != null &&
            incoming_recordTypeInfo != null &&
            equals$2(existing_recordTypeInfo, incoming_recordTypeInfo)))) {
        return false;
    }
    const existing_systemModstamp = existing.systemModstamp;
    const incoming_systemModstamp = incoming.systemModstamp;
    if (!(existing_systemModstamp === incoming_systemModstamp)) {
        return false;
    }
    return true;
}

function keyBuilder$3(params) {
    return keyBuilder$2({
        recordId: params.urlParams.recordId
    });
}
function createResourceRequest(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$4,
        headers,
    };
}

const { assign, create, freeze, keys } = Object;
const { hasOwnProperty } = Object.prototype;
const { split, endsWith } = String.prototype;
const { isArray } = Array;
const { concat, filter, push, reduce } = Array.prototype;
const { parse, stringify } = JSON;

function isString(value) {
    return typeof value === 'string';
}
/**
 * @param value The array to inspect.
 * @returns True if the array is non-empty and contains only non-empty strings.
 */
function isArrayOfNonEmptyStrings(value) {
    if (value.length === 0) {
        return false;
    }
    return value.every(v => isString(v) && v.trim().length > 0);
}
/**
 * @param value The array to dedupe
 * @returns An array without duplicates.
 */
function dedupe(value) {
    const result = {};
    for (let i = 0, len = value.length; i < len; i += 1) {
        result[value[i]] = true;
    }
    return keys(result);
}
/**
 * @param source The array of string to filter
 * @param compare The array to filter against
 * @returns An array with values from source that do not exist in compare
 * If the "compare" array is empty, "source" array itself is returned, not a shallow copy
 */
function difference(source, compare) {
    const { length: sourceLength } = source;
    const { length: compareLength } = compare;
    if (sourceLength === 0 || source === compare) {
        return [];
    }
    if (compareLength === 0) {
        return source;
    }
    // Put all the values from "compare" into a map
    // This should be faster than doing an indexOf for every string in source
    const map = {};
    for (let i = 0; i < compareLength; i += 1) {
        map[compare[i]] = true;
    }
    const strings = [];
    for (let i = 0; i < sourceLength; i += 1) {
        const string = source[i];
        if (map[string] === undefined) {
            strings.push(string);
        }
    }
    return strings;
}

function isFieldId(unknown) {
    if (typeof unknown !== 'object' || unknown === null) {
        return false;
    }
    const value = unknown;
    return isString(value.objectApiName) && isString(value.fieldApiName);
}
function stringToFieldId(fieldApiName) {
    const split = fieldApiName.split('.');
    if (process.env.NODE_ENV !== 'production') {
        if (split.length === 1) {
            // object api name must non-empty
            throw new TypeError('Value does not include an object API name.');
        }
    }
    return {
        objectApiName: split[0],
        fieldApiName: split[1],
    };
}
function getFieldId(value) {
    if (isFieldId(value)) {
        return value;
    }
    return stringToFieldId(value);
}

/**
 * Returns the field API name, qualified with an object name if possible.
 * @param value The value from which to get the qualified field API name.
 * @return The qualified field API name.
 */
function getFieldApiName(value) {
    // Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if (isString(value)) {
        const trimmed = value.trim();
        if (trimmed.length > 0) {
            return trimmed;
        }
    }
    else if (isFieldId(value)) {
        return value.objectApiName + '.' + value.fieldApiName;
    }
    return undefined;
}

/**
 * The master record type id.
 */
const MASTER_RECORD_TYPE_ID = '012000000000000AAA';

/**
 * A set of the string names of known ui-api supported entities.
 * Source: ui-uisdk-connect-impl-object-whitelist.yaml
 */
const UIAPI_SUPPORTED_ENTITY_API_NAMES = {
    Account: true,
    AccountBrand: true,
    AccountContactRelation: true,
    AccountForecast: true,
    AccountForecastPeriodMetric: true,
    AccountParticipant: true,
    AccountPartner: true,
    AccountProductForecast: true,
    AccountProductPeriodForecast: true,
    AccountTeamMember: true,
    AcctMgrPeriodicTargetDstr: true,
    AcctMgrTarget: true,
    AcctMgrTargetDstr: true,
    ActionCadence: true,
    ActionPlanItem: true,
    ActionPlanTemplate: true,
    ActionPlanTemplateItem: true,
    ActionPlanTemplateItemValue: true,
    ActionPlanTemplateVersion: true,
    ActivationTarget: true,
    Address: true,
    AssessmentIndDefinedValue: true,
    AssessmentIndValue: true,
    AssessmentIndicatorDefinition: true,
    AssessmentTask: true,
    AssessmentTaskContentDocument: true,
    AssessmentTaskOrder: true,
    Asset: true,
    AssetRelationship: true,
    AssetStatePeriod: true,
    AssetWarranty: true,
    AssignedResource: true,
    AttachedContentNote: true,
    AuthorizedInsuranceLine: true,
    Award: true,
    BCEntityPermission: true,
    BCEntityPermissionSet: true,
    BCFieldPermission: true,
    BCParticipant: true,
    BCParticipantAccess: true,
    BCPermissionSet: true,
    BCRecordAccess: true,
    BCRecordAccessApproval: true,
    BCRelatedParticipant: true,
    BasicDataRecord: true,
    BlockchainAppMember: true,
    BlockchainApplication: true,
    BlockchainEntity: true,
    BlockchainField: true,
    BlockchainMember: true,
    BusinessLicense: true,
    BusinessLicenseApplication: true,
    BusinessMilestone: true,
    BusinessProfile: true,
    Campaign: true,
    CampaignMember: true,
    CareBarrier: true,
    CareBarrierType: true,
    CarePgmProvHealthcareProvider: true,
    CareProgram: true,
    CareProgramEnrollee: true,
    CareRegisteredDevice: true,
    Case: true,
    Claim: true,
    ClaimCase: true,
    ClaimItem: true,
    ClaimParticipant: true,
    Contact: true,
    ContactEncounter: true,
    ContactEncounterParticipant: true,
    ContactRequest: true,
    ContentDocument: true,
    ContentNote: true,
    ContentVersion: true,
    ContentWorkspace: true,
    Contract: true,
    ContractContactRole: true,
    ContractLineItem: true,
    CoverageType: true,
    Crisis: true,
    CustomerProperty: true,
    DeleteEvent: true,
    DigitalSignature: true,
    DistributorAuthorization: true,
    ElectronicMediaGroup: true,
    Employee: true,
    EmployeeAsset: true,
    EmployeeContact: true,
    EmployeeJob: true,
    EmployeeJobPosition: true,
    EmployeeOrganization: true,
    Entitlement: true,
    EntityArchivingSetup: true,
    EntityMilestone: true,
    EnvironmentHubMember: true,
    Examination: true,
    Expense: true,
    ExpenseReport: true,
    ExpenseReportEntry: true,
    FtestZosUiPrototypeChild1: true,
    FtestZosUiPrototypeChild2: true,
    FtestZosUiPrototypeParent: true,
    HealthCareDiagnosis: true,
    HealthCareProcedure: true,
    HealthcareProvider: true,
    IdentityDocument: true,
    Image: true,
    Individual: true,
    IndividualCrisisAssessment: true,
    InspectionAssessmentInd: true,
    InspectionType: true,
    InsuranceClaimAsset: true,
    InsurancePolicy: true,
    InsurancePolicyAsset: true,
    InsurancePolicyCoverage: true,
    InsurancePolicyMemberAsset: true,
    InsurancePolicyParticipant: true,
    InsuranceProfile: true,
    InternalOrganizationUnit: true,
    JobFamily: true,
    JobPosition: true,
    JobProfile: true,
    KnowledgeArticleVersion: true,
    Lead: true,
    LegalEntity: true,
    LicensingRequest: true,
    ListEmail: true,
    Location: true,
    LocationWaitlist: true,
    LocationWaitlistedParty: true,
    LoyaltyProgram: true,
    LoyaltyProgramCurrency: true,
    LoyaltyProgramMember: true,
    LoyaltyProgramPartner: true,
    LoyaltyTier: true,
    LoyaltyTierGroup: true,
    MaintenanceAsset: true,
    MaintenancePlan: true,
    MaintenanceWorkRule: true,
    MarketSegment: true,
    MarketSegmentActivation: true,
    MarketingAction: true,
    MarketingResource: true,
    Note: true,
    OccupationLicenseApplication: true,
    OperatingHours: true,
    Opportunity: true,
    OpportunityLineItem: true,
    OpportunityLineItemSchedule: true,
    OpportunityParticipant: true,
    OpportunityPartner: true,
    OpportunityTeamMember: true,
    Order: true,
    OrderItem: true,
    OrderItemSummaryChange: true,
    OrderSummary: true,
    OrgMetric: true,
    OrgMetricScanResult: true,
    OrgMetricScanSummary: true,
    Partner: true,
    PersonAccount: true,
    PersonEducation: true,
    PersonEmployment: true,
    PersonExamination: true,
    PersonLifeEvent: true,
    PgmRebateTypBnftMapping: true,
    PreliminaryApplicationRef: true,
    PriceAdjustmentSchedule: true,
    Pricebook2: true,
    PricebookEntry: true,
    Producer: true,
    ProducerPolicyAssignment: true,
    Product2: true,
    Product2DataTranslation: true,
    ProductAttribute: true,
    ProductAttributeSet: true,
    ProductAttributeSetItem: true,
    ProductAttributeSetProduct: true,
    ProductCategoryDataTranslation: true,
    ProductCategoryMedia: true,
    ProductCoverage: true,
    ProductMedia: true,
    ProductTransfer: true,
    ProductWarrantyTerm: true,
    ProgramRebateTypPayoutSrc: true,
    ProgramRebateType: true,
    ProgramRebateTypeBenefit: true,
    ProgramRebateTypeFilter: true,
    ProgramRebateTypePayout: true,
    Promotion: true,
    PublicComplaint: true,
    Quote: true,
    QuoteDocument: true,
    QuoteLineItem: true,
    RebateMemberProductAggregate: true,
    RebatePayment: true,
    RebatePayoutAdjustment: true,
    RebateProgram: true,
    RebateProgramMember: true,
    RebateProgramMemberPayout: true,
    RebateProgramPayoutPeriod: true,
    RecordAction: true,
    RecordType: true,
    RecordsetFilterCriteria: true,
    RecordsetFilterCriteriaRule: true,
    RegulatoryAuthority: true,
    RegulatoryCode: true,
    RegulatoryCodeAssessmentInd: true,
    RegulatoryCodeViolation: true,
    ResidentialLoanApplication: true,
    ResourceAbsence: true,
    ResourcePreference: true,
    RetailStore: true,
    RetailVisitKpi: true,
    ReturnOrder: true,
    ReturnOrderLineItem: true,
    SalesAgreement: true,
    SalesAgreementProduct: true,
    SalesAgreementProductSchedule: true,
    SecuritiesHolding: true,
    ServiceAppointment: true,
    ServiceContract: true,
    ServiceCrew: true,
    ServiceCrewMember: true,
    ServiceResource: true,
    ServiceResourceCapacity: true,
    ServiceResourceSkill: true,
    ServiceTerritory: true,
    ServiceTerritoryLocation: true,
    ServiceTerritoryMember: true,
    SetupAssistantStep: true,
    Shift: true,
    ShiftPattern: true,
    Shipment: true,
    SignatureTask: true,
    SignatureTaskLineItem: true,
    SkillRequirement: true,
    SocialPost: true,
    SurveyInvitation: true,
    SurveyResponse: true,
    SurveySubject: true,
    Tenant: true,
    TimeSheet: true,
    TimeSheetEntry: true,
    TimeSlot: true,
    TrainingCourseParticipant: true,
    TrnCourse: true,
    UsageEntitlement: true,
    UsageEntitlementPeriod: true,
    User: true,
    ViolationEnforcementAction: true,
    ViolationType: true,
    Visit: true,
    VisitedParty: true,
    Visitor: true,
    VoiceCall: true,
    WarrantyTerm: true,
    WaveAutoInstallRequest: true,
    WebStoreSearchProdSettings: true,
    WorkContract: true,
    WorkOrder: true,
    WorkOrderLineItem: true,
    WorkPlan: true,
    WorkPlanSelectionRule: true,
    WorkPlanTemplate: true,
    WorkPlanTemplateEntry: true,
    WorkStep: true,
    WorkStepTemplate: true,
    WorkType: true,
    WorkerCompCoverageClass: true,
};

const MAX_RECORD_DEPTH = 5;
const FIELD_SEPARATOR = '.';
const API_NAME_SELECTION = {
    kind: 'Scalar',
    name: 'apiName',
};
const CHILD_RELATIONSHIP_SELECTION = {
    // We don't support RecordRep.childRelationships because it has a nasty
    // degenerate case of multiple pages of child records
    kind: 'Object',
    name: 'childRelationships',
};
const ID_SELECTION = {
    kind: 'Scalar',
    name: 'id',
};
const LAST_MODIFIED_BY_ID_SELECTION = {
    kind: 'Scalar',
    name: 'lastModifiedById',
};
const LAST_MODIFIED_BY_DATE_SELECTION = {
    kind: 'Scalar',
    name: 'lastModifiedDate',
};
const RECORD_TYPE_ID_SELECTION = {
    kind: 'Scalar',
    name: 'recordTypeId',
};
const RECORD_TYPE_INFO_SELECTION = {
    kind: 'Object',
    name: 'recordTypeInfo',
    nullable: true,
    selections: [
        {
            kind: 'Scalar',
            name: 'available',
        },
        {
            kind: 'Scalar',
            name: 'defaultRecordTypeMapping',
        },
        {
            kind: 'Scalar',
            name: 'master',
        },
        {
            kind: 'Scalar',
            name: 'name',
        },
        {
            kind: 'Scalar',
            name: 'recordTypeId',
        },
    ],
};
const SYSTEM_MODSTAMP_SELECTION = {
    kind: 'Scalar',
    name: 'systemModstamp',
};
const DISPLAY_VALUE_SELECTION = {
    kind: 'Scalar',
    name: 'displayValue',
};
const SCALAR_VALUE_SELECTION = {
    kind: 'Scalar',
    name: 'value',
};
const FIELDS_SELECTION = {
    kind: 'Object',
    name: 'fields',
};
function isSpanningRecord(fieldValue) {
    return fieldValue !== null && typeof fieldValue === 'object';
}
function insertFieldsIntoTrie(root, fields, optional) {
    for (let i = 0, len = fields.length; i < len; i++) {
        const field = fields[i].split(FIELD_SEPARATOR);
        let current = root;
        for (let j = 1, len = field.length; j < len && j <= MAX_RECORD_DEPTH + 1; j++) {
            const fieldName = field[j];
            let next = current.children[fieldName];
            if (next === undefined) {
                // A field is scalar only if it is the last field name in the field.
                const scalar = j === len - 1;
                // LDS restricts the numbers of fields that can be traversed to MAX_RECORD_DEPTH,
                // however we still denormalize fields at MAX_RECORD_DEPTH + 1, only if they are
                // scalar fields.
                if (j <= MAX_RECORD_DEPTH || scalar === true) {
                    // We now know that there are children fields, so we can mark the parent
                    // as not a scalar
                    current.scalar = false;
                    next = {
                        name: fieldName,
                        scalar,
                        optional,
                        children: {},
                    };
                    current.children[fieldName] = next;
                }
            }
            current = next;
        }
    }
}
function convertTrieToSelection(fieldDefinition) {
    const fieldsSelection = [];
    const { children } = fieldDefinition;
    const childrenKeys = keys(children);
    for (let i = 0, len = childrenKeys.length; i < len; i += 1) {
        const childKey = childrenKeys[i];
        const childFieldDefinition = children[childKey];
        let fieldValueSelection;
        if (childFieldDefinition.scalar === true) {
            fieldValueSelection = SCALAR_VALUE_SELECTION;
        }
        else {
            fieldValueSelection = {
                kind: 'Link',
                name: 'value',
                nullable: true,
                fragment: {
                    kind: 'Fragment',
                    private: ['eTag', 'weakEtag'],
                    selections: convertTrieToSelection(childFieldDefinition),
                },
            };
        }
        const fieldSelection = {
            kind: 'Link',
            name: childFieldDefinition.name,
            required: childFieldDefinition.optional === true ? false : undefined,
            fragment: {
                kind: 'Fragment',
                private: [],
                selections: [DISPLAY_VALUE_SELECTION, fieldValueSelection],
            },
        };
        push.call(fieldsSelection, fieldSelection);
    }
    return [
        API_NAME_SELECTION,
        CHILD_RELATIONSHIP_SELECTION,
        ID_SELECTION,
        LAST_MODIFIED_BY_ID_SELECTION,
        LAST_MODIFIED_BY_DATE_SELECTION,
        RECORD_TYPE_ID_SELECTION,
        RECORD_TYPE_INFO_SELECTION,
        SYSTEM_MODSTAMP_SELECTION,
        {
            kind: 'Object',
            name: FIELDS_SELECTION.name,
            selections: fieldsSelection,
        },
    ];
}
/**
 * Convert a list of fields and optional fields into RecordRepresentation its equivalent
 * selection.
 */
function buildSelectionFromFields(fields, optionalFields = []) {
    const root = {
        name: '<root>',
        optional: false,
        scalar: false,
        children: {},
    };
    insertFieldsIntoTrie(root, fields, false);
    insertFieldsIntoTrie(root, optionalFields, true);
    return convertTrieToSelection(root);
}
/**
 * Convert a RecordRepresentationLike into its equivalent selection.
 */
function buildSelectionFromRecord(record) {
    const fieldsSelection = [];
    const { fields } = record;
    const fieldNames = keys(fields);
    for (let i = 0, len = fieldNames.length; i < len; i++) {
        const fieldName = fieldNames[i];
        const { value: fieldValue } = fields[fieldName];
        let fieldValueSelection = SCALAR_VALUE_SELECTION;
        if (isSpanningRecord(fieldValue)) {
            fieldValueSelection = {
                kind: 'Link',
                name: 'value',
                nullable: true,
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: buildSelectionFromRecord(fieldValue),
                },
            };
        }
        const fieldSelection = {
            kind: 'Link',
            name: fieldName,
            required: undefined,
            fragment: {
                kind: 'Fragment',
                private: [],
                selections: [DISPLAY_VALUE_SELECTION, fieldValueSelection],
            },
        };
        push.call(fieldsSelection, fieldSelection);
    }
    return [
        API_NAME_SELECTION,
        CHILD_RELATIONSHIP_SELECTION,
        ID_SELECTION,
        LAST_MODIFIED_BY_ID_SELECTION,
        LAST_MODIFIED_BY_DATE_SELECTION,
        RECORD_TYPE_ID_SELECTION,
        RECORD_TYPE_INFO_SELECTION,
        SYSTEM_MODSTAMP_SELECTION,
        {
            kind: 'Object',
            name: FIELDS_SELECTION.name,
            selections: fieldsSelection,
        },
    ];
}
function extractRecordFieldsRecursively(record) {
    const fields = [];
    const fieldNames = keys(record.fields);
    for (let i = 0, len = fieldNames.length; i < len; i++) {
        const fieldName = fieldNames[i];
        const { value: fieldValue } = record.fields[fieldName];
        if (isSpanningRecord(fieldValue)) {
            const spanningRecordFields = extractRecordFieldsRecursively(fieldValue);
            for (let j = 0, len = spanningRecordFields.length; j < len; j++) {
                spanningRecordFields[j] = `${fieldName}.${spanningRecordFields[j]}`;
            }
            push.apply(fields, spanningRecordFields);
        }
        else {
            push.call(fields, fieldName);
        }
    }
    return fields;
}
/**
 * Returns a list of fields for a RecordRepresentationLike.
 *
 * TODO W-6900271 - Remove this function once getRelatedList don't depend on it anymore. Always prefer
 * generating a selection out of a record, than convert a record to a field list and back to a
 * selection.
 */
function extractRecordFields(record) {
    const { apiName } = record;
    const fields = extractRecordFieldsRecursively(record);
    for (let i = 0, len = fields.length; i < len; i++) {
        fields[i] = `${apiName}.${fields[i]}`;
    }
    return fields;
}

const CUSTOM_API_NAME_SUFFIX = '__c';
const CUSTOM_RELATIONSHIP_FIELD_SUFFIX = '__r';
function isGraphNode(node) {
    return node !== null && node.type === 'Node';
}
function extractTrackedFields(node, parentFieldName, fieldsList = [], visitedRecordIds = {}, depth = 0) {
    // Filter Error and null nodes
    if (!isGraphNode(node) || depth > MAX_RECORD_DEPTH) {
        return [];
    }
    const recordId = node.data.id;
    // Stop the traversal if the key has already been visited, since the fields for this record
    // have already been gathered at this point.
    if (hasOwnProperty.call(visitedRecordIds, recordId)) {
        return fieldsList;
    }
    // The visitedRecordIds object passed to the spanning record is a copy of the original
    // visitedRecordIds + the current record id, since we want to detect circular references within
    // a given path.
    let spanningVisitedRecordIds = {
        ...visitedRecordIds,
        [recordId]: true,
    };
    const fields = node.object('fields');
    const keys = fields.keys();
    for (let i = 0, len = keys.length; i < len; i += 1) {
        const key = keys[i];
        const fieldValueRep = fields.link(key);
        const fieldName = `${parentFieldName}.${key}`;
        if (fieldValueRep.isMissing()) {
            push.call(fieldsList, fieldName);
            continue;
        }
        const field = fieldValueRep.follow();
        // Filter Error and null nodes
        if (!isGraphNode(field)) {
            continue;
        }
        if (field.isScalar('value') === false) {
            const spanning = field
                .link('value')
                .follow();
            extractTrackedFields(spanning, fieldName, fieldsList, spanningVisitedRecordIds, depth + 1);
        }
        else {
            const state = fieldValueRep.linkData();
            if (state !== undefined) {
                const { fields } = state;
                for (let s = 0, len = fields.length; s < len; s += 1) {
                    const childFieldName = fields[s];
                    push.call(fieldsList, `${fieldName}.${childFieldName}`);
                }
            }
            else {
                push.call(fieldsList, fieldName);
            }
        }
    }
    return fieldsList;
}
function extractTrackedFieldsToTrie(node, root, visitedRecordIds = {}, depth = 0) {
    // Filter Error and null nodes
    if (!isGraphNode(node)) {
        return;
    }
    const recordId = node.data.id;
    // Stop the traversal if the key has already been visited, since the fields for this record
    // have already been gathered at this point.
    if (hasOwnProperty.call(visitedRecordIds, recordId)) {
        return;
    }
    // The visitedRecordIds object passed to the spanning record is a copy of the original
    // visitedRecordIds + the current record id, since we want to detect circular references within
    // a given path.
    let spanningVisitedRecordIds = {
        ...visitedRecordIds,
        [recordId]: true,
    };
    const fields = node.object('fields');
    const keys$1 = fields.keys();
    let current = root;
    for (let i = 0, len = keys$1.length; i < len; i += 1) {
        const key = keys$1[i];
        const fieldValueRep = fields.link(key);
        let next = current.children[key];
        if (next === undefined) {
            next = {
                name: key,
                children: {},
            };
            if (fieldValueRep.isMissing()) {
                current.children[key] = next;
                continue;
            }
            const field = fieldValueRep.follow();
            // Filter Error and null nodes
            if (!isGraphNode(field)) {
                continue;
            }
            if (field.isScalar('value') === false) {
                if (depth + 1 > MAX_RECORD_DEPTH) {
                    continue;
                }
                const spanning = field
                    .link('value')
                    .follow();
                extractTrackedFieldsToTrie(spanning, next, spanningVisitedRecordIds, depth + 1);
                if (keys(next.children).length > 0) {
                    current.children[key] = next;
                }
                else {
                    continue;
                }
            }
            else {
                const state = fieldValueRep.linkData();
                if (state !== undefined) {
                    const { fields } = state;
                    for (let s = 0, len = fields.length; s < len; s += 1) {
                        const childFieldName = fields[s];
                        next.children[childFieldName] = {
                            name: childFieldName,
                            children: {},
                        };
                    }
                }
                else if (depth === MAX_RECORD_DEPTH &&
                    field.scalar('value') === null &&
                    isLookupFieldKey(key, fields) === true) {
                    // When this is max depth and the field's value is null,
                    // it needs to check the key to see if this is a lookup field.
                    continue;
                }
            }
            current.children[key] = next;
        }
    }
}
function isLookupFieldKey(key, fields) {
    return (endsWith.call(key, CUSTOM_RELATIONSHIP_FIELD_SUFFIX) ||
        (endsWith.call(key, CUSTOM_API_NAME_SUFFIX) === false &&
            fields.data[`${key}Id`] !== undefined));
}
function convertTrieToFields(root) {
    const childKeys = keys(root.children);
    if (childKeys.length === 0) {
        return [root.name];
    }
    return reduce.call(childKeys, (acc, cur) => concat.call(acc, convertTrieToFields(root.children[cur]).map(i => `${root.name}.${i}`)), []);
}
/**
 * Traverses 3 parallel RecordFieldTrie structures, accumulating field and record metrics along the way.
 *
 * @param required trie of required fields from config
 * @param optional trie of optional fields from config
 * @param tracked trie of tracked fields we added
 * @param metrics accumulated metrics
 */
function countRecordsAndFields(required, optional, tracked, metrics) {
    const requiredChildren = required === undefined ? {} : required.children;
    const optionalChildren = optional === undefined ? {} : optional.children;
    const trackedChildren = tracked === undefined ? {} : tracked.children;
    const childNames = [
        ...keys(requiredChildren),
        ...keys(optionalChildren),
        ...keys(trackedChildren),
    ];
    // if any of the tries have children then this must be a record
    if (childNames.length > 0) {
        ++metrics.totalRecords;
        // see if this record was part of config
        if (required !== undefined || optional !== undefined) {
            ++metrics.configRecords;
        }
        // keep track of which children tries have already been processed
        const processed = {};
        for (let i = 0; i < childNames.length; ++i) {
            const childName = childNames[i];
            if (processed[childName]) {
                continue;
            }
            processed[childName] = true;
            countRecordsAndFields(requiredChildren[childName], optionalChildren[childName], trackedChildren[childName], metrics);
        }
    }
    // if none of the tries has any children then this must be a field
    else {
        ++metrics.totalFields;
        // see if this field came from config
        if (required !== undefined || optional !== undefined) {
            ++metrics.configFields;
        }
    }
}
function logMetrics(lds, required, optional, tracked) {
    const metrics = {
        configRecords: 0,
        configFields: 0,
        totalRecords: 0,
        totalFields: 0,
        duration: 0,
    };
    const start = Date.now();
    countRecordsAndFields(required, optional, tracked, metrics);
    metrics.duration = Date.now() - start;
    lds.instrument(() => metrics);
}
// merge all nodes in Trie B into Trie A
function mergeFieldsTries(rootA, rootB) {
    const rootAchildren = rootA.children;
    const rootBchildren = rootB.children;
    const childBKeys = keys(rootBchildren);
    for (let i = 0, len = childBKeys.length; i < len; i++) {
        const childBKey = childBKeys[i];
        if (rootAchildren[childBKey] === undefined) {
            rootAchildren[childBKey] = rootBchildren[childBKey];
        }
        else {
            mergeFieldsTries(rootAchildren[childBKey], rootBchildren[childBKey]);
        }
    }
}
/**
 * Examines the store and augments the set of optional fields for a record request with
 * fields already present in the store.
 *
 * @param lds LDS
 * @param recordId record id
 * @param optionalFieldsFromConfig optional fields from the wire config
 * @param requiredFieldsFromConfig required fields from the wire config
 * @param logMetricsCallback This is a temporary parameter to let this function return a
 *     callback that can be invoked to log metrics about the tracked fields. It would be
 *     more correct to include it in the return value, but that would require updating
 *     every caller of this function then updating them again in a few releases when
 *     the metrics are removed. When there are tracked fields metrics to be logged
 *     this function will set logMetricsCallback[0] to point to a function that will
 *     compute and log the metrics. The function accepts the required fields from the
 *     config as its only parameter. It is up to the caller to decide if/when to invoke
 *     this function. Note that if the record is not in the cache there are no tracked
 *     fields metrics to log and the logMetricsCallback array is unchanged.
 */
function getTrackedFields(lds, recordId, optionalFieldsFromConfig, logMetricsCallback) {
    const key = keyBuilder$2({
        recordId,
    });
    const optionalFieldsList = optionalFieldsFromConfig === undefined ? [] : [...optionalFieldsFromConfig];
    const graphNode = lds.getNode(key);
    if (!isGraphNode(graphNode)) {
        // would be more correct to log metrics about the required and optional fields, but not worth the effort
        return optionalFieldsList;
    }
    const name = graphNode.scalar('apiName');
    const trackedFieldsTrie = {
        name,
        children: {},
    };
    extractTrackedFieldsToTrie(graphNode, trackedFieldsTrie);
    const optionalFieldsFromConfigTrie = {
        name,
        children: {},
    };
    insertFieldsIntoTrie(optionalFieldsFromConfigTrie, optionalFieldsList);
    if (logMetricsCallback !== undefined) {
        logMetricsCallback[0] = (requiredFieldsFromConfig) => {
            const requiredFieldsFromConfigTrie = {
                name,
                children: {},
            };
            insertFieldsIntoTrie(requiredFieldsFromConfigTrie, requiredFieldsFromConfig === undefined ? [] : requiredFieldsFromConfig);
            logMetrics(lds, requiredFieldsFromConfigTrie, optionalFieldsFromConfigTrie, trackedFieldsTrie);
        };
    }
    mergeFieldsTries(trackedFieldsTrie, optionalFieldsFromConfigTrie);
    return convertTrieToFields(trackedFieldsTrie).sort();
}
function getRecordTypeId(record) {
    return record.recordTypeId === null ? MASTER_RECORD_TYPE_ID : record.recordTypeId;
}
// This function traverses through a record and marks missing
// optional fields as "missing"
function markMissingOptionalFields(record, optionalFields) {
    if (!isGraphNode(record)) {
        return;
    }
    const apiName = record.scalar('apiName');
    for (let a = 0, aLen = optionalFields.length; a < aLen; a++) {
        const parts = optionalFields[a].split('.');
        if (parts[0] === apiName) {
            _markMissingPath(record, parts.slice(1));
        }
    }
}
function markNulledOutPath(record, path) {
    if (!isGraphNode(record)) {
        return;
    }
    const fieldValueRepresentation = record.object('fields');
    const fieldName = path.shift();
    if (fieldValueRepresentation.isUndefined(fieldName)) {
        return;
    }
    const link = fieldValueRepresentation.link(fieldName);
    const resolved = link.follow();
    if (isGraphNode(resolved) && resolved.isScalar('value') && path.length > 0) {
        const linkState = link.linkData();
        const fields = linkState === undefined ? [] : linkState.fields;
        link.writeLinkData({
            fields: dedupe([...fields, path.join('.')]),
        });
    }
}
function markNulledOutRequiredFields(record, fields) {
    if (!isGraphNode(record)) {
        return;
    }
    const apiName = record.scalar('apiName');
    for (let a = 0, aLen = fields.length; a < aLen; a++) {
        const parts = fields[a].split('.');
        if (parts[0] === apiName) {
            markNulledOutPath(record, parts.slice(1));
        }
    }
}
function _markMissingPath(record, path) {
    // Filter out Error and null nodes
    if (!isGraphNode(record)) {
        return;
    }
    const fieldValueRepresentation = record.object('fields');
    const fieldName = path.shift();
    if (fieldValueRepresentation.isUndefined(fieldName) === true) {
        // TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
        // an undefined/non-present __ref if isMissing is present
        fieldValueRepresentation.write(fieldName, {
            __ref: undefined,
            isMissing: true,
        });
        return;
    }
    const link = fieldValueRepresentation.link(fieldName);
    if (link.isPending()) {
        // TODO W-6900046 - remove cast, make RecordRepresentationNormalized['fields'] accept
        // an undefined/non-present __ref if isMissing is present
        fieldValueRepresentation.write(fieldName, {
            __ref: undefined,
            isMissing: true,
        });
    }
    else if (path.length > 0 && link.isMissing() === false) {
        const fieldValue = link.follow();
        // Filter out Error and null nodes
        if (!isGraphNode(fieldValue)) {
            return;
        }
        // if value is not a scalar, follow the link and mark it as missing
        if (fieldValue.isScalar('value') === false) {
            _markMissingPath(fieldValue
                .link('value')
                .follow(), path);
        }
    }
}
/**
 * Tells you if an objectApiName is supported by UI API or not.
 * Note: LDS does not currently support all the entities, the list is limited to UI API supported entities
 * @param objectApiName the object API name from a record.
 * @return True if the provided objectApiName is supported in UI API.
 */
function isSupportedEntity(objectApiName) {
    return (UIAPI_SUPPORTED_ENTITY_API_NAMES[objectApiName] === true ||
        endsWith.call(objectApiName, CUSTOM_API_NAME_SUFFIX));
}
/** Return true if a >= b */
function isSuperset(a, b) {
    if (b.length > a.length) {
        return false;
    }
    const aMap = {};
    // Put all keys from subset into a map
    // so we don't have to use subset.includes which will be slow
    for (let i = 0, len = a.length; i < len; i += 1) {
        aMap[a[i]] = true;
    }
    for (let i = 0, len = b.length; i < len; i += 1) {
        if (aMap[b[i]] === undefined) {
            return false;
        }
    }
    return true;
}
/** return true if a and b start with the same root name and a contains all nodes in b */
function isSuperRecordFieldTrie(a, b) {
    if (a.name !== b.name) {
        return false;
    }
    const childrenA = a.children;
    const childrenB = b.children;
    const childKeysA = keys(childrenA);
    const childKeysB = keys(childrenB);
    const childKeysBLength = childKeysB.length;
    if (childKeysBLength > childKeysA.length) {
        return false;
    }
    let ret = true;
    for (let i = 0; i < childKeysBLength; i++) {
        const childBKey = childKeysB[i];
        const childA = childrenA[childBKey];
        if (childA === undefined) {
            return false;
        }
        ret = ret && isSuperRecordFieldTrie(childA, childrenB[childBKey]);
    }
    return ret;
}
/**
 * A simple class to keep track of conflicts detected while ingesting a tree of
 * records.
 */
class IngestionMetrics {
    /**
     * Only called by startCollection method. External callers should use that instead.
     */
    constructor() {
        this.depth = -1;
        this.conflictDepths = [];
    }
    /**
     * Start collecting metrics.
     */
    static startCollection() {
        IngestionMetrics.singleton = new IngestionMetrics();
    }
    /**
     * Log any metrics collected and stop collection.
     *
     * @param lds LDS
     */
    static stopCollection(lds) {
        if (IngestionMetrics.singleton) {
            lds.instrument(() => ({
                conflictDepths: IngestionMetrics.singleton.conflictDepths,
            }));
            IngestionMetrics.singleton = undefined;
        }
    }
    /**
     * Increment the record depth.
     */
    static incrementDepth() {
        if (IngestionMetrics.singleton) {
            ++IngestionMetrics.singleton.depth;
        }
    }
    /**
     * Decrement the record depth.
     */
    static decrementDepth() {
        if (IngestionMetrics.singleton) {
            --IngestionMetrics.singleton.depth;
        }
    }
    /**
     * Indicate that a record conflict was detected.
     */
    static conflict() {
        if (IngestionMetrics.singleton) {
            push.call(IngestionMetrics.singleton.conflictDepths, IngestionMetrics.singleton.depth);
        }
    }
}

function fulfill(existing, incoming) {
    // early out if incoming isn't a request only for fields and optionalFields
    const { queryParams, headers, basePath, baseUri } = incoming;
    const { basePath: existingBasePath, baseUri: existingBaseUri, headers: existingHeaders, } = existing;
    const path = `${baseUri}${basePath}`;
    const existingPath = `${existingBasePath}${existingBaseUri}`;
    if (queryParams.layoutTypes !== undefined) {
        return false;
    }
    if (existingPath !== path) {
        return false;
    }
    const headersKeys = keys(headers);
    const headersKeyLength = headersKeys.length;
    if (headersKeyLength !== keys(existingHeaders).length) {
        return false;
    }
    for (let i = 0, len = headersKeyLength; i < len; i++) {
        let key = headersKeys[i];
        if (headers[key] !== existingHeaders[key]) {
            return false;
        }
    }
    // TODO W-6900100 - handle when incoming.fields are only in existing.optionalFields, and
    // existing's response doesn't include those fields. We need to detect this then
    // re-issue the request to get the relevant error response.
    const existingFieldsUnion = unionFields(existing.queryParams.fields, existing.queryParams.optionalFields);
    const incomingFieldsUnion = unionFields(queryParams.fields, queryParams.optionalFields);
    return isSuperset(existingFieldsUnion, incomingFieldsUnion);
}
function unionFields(fields, optionalFields) {
    const fieldsArray = isArray(fields) ? fields : [];
    const optionalFieldsArray = isArray(optionalFields) ? optionalFields : [];
    return [...fieldsArray, ...optionalFieldsArray];
}

const createResourceRequest$1 = function getUiApiRecordsByRecordIdCreateResourceRequest(config) {
    return {
        ...createResourceRequest(config),
        fulfill: fulfill,
    };
};

const RECORD_ID_DECODER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456';
/**
 * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
 * @param value A 15- or 18-char record id.
 * @returns An 18-char record id, and throws error if an invalid record id was provided.
 */
function getRecordId18(value) {
    if (!isString(value)) {
        return undefined;
    }
    else if (value.length === 18) {
        return value;
    }
    else if (value.length === 15) {
        // Add the 3 character suffix
        let recordId = value;
        for (let offset = 0; offset < 15; offset += 5) {
            let decodeValue = 0;
            for (let bit = 0; bit < 5; bit++) {
                const c = value[offset + bit];
                if (c >= 'A' && c <= 'Z') {
                    decodeValue += 1 << bit;
                }
            }
            recordId += RECORD_ID_DECODER[decodeValue];
        }
        return recordId;
    }
    return undefined;
}

/**
 * Returns the field API name.
 * @param value The value from which to get the field API name.
 * @returns The field API name.
 */
function getFieldApiNamesArray(value) {
    const valueArray = isArray(value) ? value : [value];
    const array = [];
    for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getFieldApiName(item);
        if (apiName === undefined) {
            return undefined;
        }
        push.call(array, apiName);
    }
    if (array.length === 0) {
        return undefined;
    }
    return dedupe(array).sort();
}

function toSortedStringArray(value) {
    const valueArray = isArray(value) ? value : [value];
    if (valueArray.length !== 0 && isArrayOfNonEmptyStrings(valueArray)) {
        return dedupe(valueArray).sort();
    }
    return undefined;
}

const oneOfConfigPropertiesIdentifier = [
    'layoutTypes',
    'fields',
    'optionalFields'
];
function createResourceParams(config) {
    return {
        urlParams: {
            recordId: config.recordId
        },
        queryParams: {
            childRelationships: config.childRelationships, fields: config.fields, forms: config.forms, layoutTypes: config.layoutTypes, modes: config.modes, optionalFields: config.optionalFields, pageSize: config.pageSize, updateMru: config.updateMru
        }
    };
}
function coerceConfig(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    const childRelationships = config.childRelationships;
    if (childRelationships !== undefined) {
        coercedConfig.childRelationships = childRelationships;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const forms = config.forms;
    if (forms !== undefined) {
        coercedConfig.forms = forms;
    }
    const layoutTypes = toSortedStringArray(config.layoutTypes);
    if (layoutTypes !== undefined) {
        coercedConfig.layoutTypes = layoutTypes;
    }
    const modes = toSortedStringArray(config.modes);
    if (modes !== undefined) {
        coercedConfig.modes = modes;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const updateMru = config.updateMru;
    if (updateMru !== undefined) {
        coercedConfig.updateMru = updateMru;
    }
    return coercedConfig;
}
function typeCheckConfig(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_childRelationships = untrustedConfig.childRelationships;
    if (ArrayIsArray(untrustedConfig_childRelationships)) {
        const untrustedConfig_childRelationships_array = [];
        for (let i = 0, arrayLength = untrustedConfig_childRelationships.length; i < arrayLength; i++) {
            const untrustedConfig_childRelationships_item = untrustedConfig_childRelationships[i];
            if (typeof untrustedConfig_childRelationships_item === 'string') {
                untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);
            }
        }
        config.childRelationships = untrustedConfig_childRelationships_array;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_forms = untrustedConfig.forms;
    if (ArrayIsArray(untrustedConfig_forms)) {
        const untrustedConfig_forms_array = [];
        for (let i = 0, arrayLength = untrustedConfig_forms.length; i < arrayLength; i++) {
            const untrustedConfig_forms_item = untrustedConfig_forms[i];
            if (typeof untrustedConfig_forms_item === 'string') {
                untrustedConfig_forms_array.push(untrustedConfig_forms_item);
            }
        }
        config.forms = untrustedConfig_forms_array;
    }
    const untrustedConfig_layoutTypes = untrustedConfig.layoutTypes;
    if (ArrayIsArray(untrustedConfig_layoutTypes)) {
        const untrustedConfig_layoutTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_layoutTypes.length; i < arrayLength; i++) {
            const untrustedConfig_layoutTypes_item = untrustedConfig_layoutTypes[i];
            if (typeof untrustedConfig_layoutTypes_item === 'string') {
                untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);
            }
        }
        config.layoutTypes = untrustedConfig_layoutTypes_array;
    }
    const untrustedConfig_modes = untrustedConfig.modes;
    if (ArrayIsArray(untrustedConfig_modes)) {
        const untrustedConfig_modes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_modes.length; i < arrayLength; i++) {
            const untrustedConfig_modes_item = untrustedConfig_modes[i];
            if (typeof untrustedConfig_modes_item === 'string') {
                untrustedConfig_modes_array.push(untrustedConfig_modes_item);
            }
        }
        config.modes = untrustedConfig_modes_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_updateMru = untrustedConfig.updateMru;
    if (typeof untrustedConfig_updateMru === 'boolean') {
        config.updateMru = untrustedConfig_updateMru;
    }
    return config;
}
function validateAdapterConfig(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames, oneOfConfigPropertiesIdentifier);
    }
    const coercedConfig = coerceConfig(untrustedConfig);
    const config = typeCheckConfig(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    if (config.layoutTypes === undefined &&
        config.fields === undefined &&
        config.optionalFields === undefined) {
        return null;
    }
    return config;
}

function isFulfilledSnapshot(snapshot) {
    return snapshot.state === 'Fulfilled';
}
function isUnfulfilledSnapshot(snapshot) {
    return snapshot.state === 'Unfulfilled';
}
function isErrorSnapshot(snapshot) {
    return snapshot.state === 'Error';
}

function buildRecordSelector(recordId, fields, optionalFields) {
    return {
        recordId: keyBuilder$2({ recordId }),
        node: {
            kind: 'Fragment',
            private: ['eTag', 'weakEtag'],
            selections: buildSelectionFromFields(fields, optionalFields),
        },
        variables: {},
    };
}
function buildSnapshotRefresh(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot(lds, config),
    };
}
function prepareRequest(lds, config) {
    const { recordId, fields } = config;
    // Should this go into the coersion logic?
    const logTrackedFieldsMetrics = Math.random() < 0.01 ? [] : undefined;
    const allTrackedFields = getTrackedFields(lds, recordId, config.optionalFields, logTrackedFieldsMetrics);
    const optionalFields = fields === undefined ? allTrackedFields : difference(allTrackedFields, fields);
    const params = createResourceParams({
        recordId,
        fields,
        optionalFields: optionalFields.length > 0 ? optionalFields : undefined,
    });
    const request = createResourceRequest$1(params);
    const key = keyBuilder$3(params);
    return {
        request,
        key,
        allTrackedFields,
        logTrackedFieldsMetrics: logTrackedFieldsMetrics !== undefined ? logTrackedFieldsMetrics[0] : undefined,
    };
}
function onResourceSuccess(lds, config, key, allTrackedFields, request, response) {
    const { body } = response;
    const fields = config.fields === undefined ? [] : config.fields;
    const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
    IngestionMetrics.startCollection();
    try {
        lds.storeIngest(key, request, body);
    }
    finally {
        IngestionMetrics.stopCollection(lds);
    }
    const recordNode = lds.getNode(key);
    markNulledOutRequiredFields(recordNode, [...fields, ...optionalFields]);
    markMissingOptionalFields(recordNode, allTrackedFields);
    lds.storeBroadcast();
    return lds.storeLookup(buildRecordSelector(config.recordId, fields, optionalFields), buildSnapshotRefresh(lds, config));
}
function onResourceError(lds, config, key, err) {
    lds.storeIngestFetchResponse(key, err, TTL);
    lds.storeBroadcast();
    return lds.errorSnapshot(err, buildSnapshotRefresh(lds, config));
}
function buildNetworkSnapshot(lds, config) {
    const { request, key, allTrackedFields, logTrackedFieldsMetrics } = prepareRequest(lds, config);
    const promise = lds.dispatchResourceRequest(request).then(response => {
        return onResourceSuccess(lds, config, key, allTrackedFields, request, response);
    }, (err) => {
        return onResourceError(lds, config, key, err);
    });
    // compute/log field metrics in parallel with the network request
    if (logTrackedFieldsMetrics) {
        logTrackedFieldsMetrics(config.fields);
    }
    return promise;
}
function resolveUnfulfilledSnapshot(lds, config, snapshot) {
    const { request, key, allTrackedFields, logTrackedFieldsMetrics } = prepareRequest(lds, config);
    const promise = lds.resolveUnfulfilledSnapshot(request, snapshot).then(response => {
        return onResourceSuccess(lds, config, key, allTrackedFields, request, response);
    }, (err) => {
        return onResourceError(lds, config, key, err);
    });
    // compute/log field metrics in parallel with the network request
    if (logTrackedFieldsMetrics) {
        logTrackedFieldsMetrics(config.fields);
    }
    return promise;
}
// used by getRecordLayoutType#refresh
function buildInMemorySnapshot(lds, config, refresh) {
    const fields = config.fields === undefined ? [] : config.fields;
    const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
    const sel = buildRecordSelector(config.recordId, fields, optionalFields);
    return lds.storeLookup(sel, refresh ? refresh : buildSnapshotRefresh(lds, config));
}
function getRecordByFields(lds, config) {
    const snapshot = buildInMemorySnapshot(lds, config);
    if (lds.snapshotDataAvailable(snapshot)) {
        return snapshot;
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot(lds, config, snapshot);
    }
    return buildNetworkSnapshot(lds, config);
}

const INCOMING_WEAKETAG_0_KEY = 'incoming-weaketag-0';
const EXISTING_WEAKETAG_0_KEY = 'existing-weaketag-0';
const RECORD_API_NAME_CHANGE_EVENT = 'record-api-name-change-event';
// This function sets fields that we are refreshing to pending
// These values will go into the store
function mergePendingFields(newRecord, oldRecord) {
    // TODO W-6900046 - avoid casting to any by updating
    // RecordRepresentationNormalized['fields'] to include `pending:true` property
    const mergedFields = { ...newRecord.fields };
    const merged = { ...newRecord, fields: mergedFields };
    const existingFields = keys(oldRecord.fields);
    for (let i = 0, len = existingFields.length; i < len; i += 1) {
        const spanningFieldName = existingFields[i];
        if (newRecord.fields[spanningFieldName] === undefined) {
            // TODO W-6900046 - fix above casting issue so we're not stuffing arbitrary things
            // into RecordRepresentationNormalized['fields']
            mergedFields[spanningFieldName] = {
                __ref: undefined,
                pending: true,
            };
        }
    }
    return merged;
}
// This method gets called
// when incoming record has a higher version
// than the record that is currently in the store
function mergeAndRefreshHigherVersionRecord(lds, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot) {
    // If the higher version (incoming) does not contain a superset of fields as existing
    // then we need to refresh to get updated versions of fields in existing
    if (isSuperRecordFieldTrie(incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot) ===
        false) {
        // If this is an unsupported entity, do NOT attempt to go to the network
        // Simply merge what we have and move on
        if (isSupportedEntity(incoming.apiName) === false) {
            return mergeRecordFields(incoming, existing);
        }
        buildNetworkSnapshot(lds, {
            recordId: incoming.id,
            optionalFields: convertTrieToFields(incomingTrackedFieldsTrieRoot),
        });
        // We want to mark fields in the store as pending
        // Because we don't want to emit any data to components
        return mergePendingFields(incoming, existing);
    }
    return incoming;
}
// This method gets called
// when incoming record has a lower version
// than the record that is currently in the store
function mergeAndRefreshLowerVersionRecord(lds, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot) {
    // If the higher version (existing) does not have a superset of fields as incoming
    // then we need to refresh to get updated versions of fields on incoming
    if (isSuperRecordFieldTrie(existingTrackedFieldsTrieRoot, incomingTrackedFieldsTrieRoot) ===
        false) {
        // If this is an unsupported entity, do NOT attempt to go to the network
        // Simply merge what we have and move on
        if (isSupportedEntity(incoming.apiName) === false) {
            return mergeRecordFields(existing, incoming);
        }
        const merged = mergePendingFields(existing, incoming);
        buildNetworkSnapshot(lds, {
            recordId: incoming.id,
            optionalFields: convertTrieToFields(incomingTrackedFieldsTrieRoot),
        });
        return merged;
    }
    return existing;
}
function mergeRecordConflict(lds, incoming, existing) {
    const incomingNode = lds.wrapNormalizedGraphNode(incoming);
    const existingNode = lds.wrapNormalizedGraphNode(existing);
    const incomingTrackedFieldsTrieRoot = {
        name: incoming.apiName,
        children: {},
    };
    const existingTrackedFieldsTrieRoot = {
        name: existing.apiName,
        children: {},
    };
    extractTrackedFieldsToTrie(incomingNode, incomingTrackedFieldsTrieRoot);
    extractTrackedFieldsToTrie(existingNode, existingTrackedFieldsTrieRoot);
    if (incoming.weakEtag > existing.weakEtag) {
        return mergeAndRefreshHigherVersionRecord(lds, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot);
    }
    return mergeAndRefreshLowerVersionRecord(lds, incoming, existing, incomingTrackedFieldsTrieRoot, existingTrackedFieldsTrieRoot);
}
function getNotNull(recordAValue, recordBValue) {
    return recordAValue === null ? recordBValue : recordAValue;
}
function mergeRecordFields(recordA, recordB) {
    const lastModifiedDate = getNotNull(recordA.lastModifiedDate, recordB.lastModifiedDate);
    const lastModifiedById = getNotNull(recordA.lastModifiedById, recordB.lastModifiedById);
    const systemModstamp = getNotNull(recordA.systemModstamp, recordB.systemModstamp);
    return {
        ...recordA,
        fields: {
            ...recordB.fields,
            ...recordA.fields,
        },
        lastModifiedDate,
        lastModifiedById,
        systemModstamp,
    };
}
function isErrorEntry(entry) {
    return entry.__type === 'error';
}
/**
 * Merges an incoming normalized record with the copy already in the store.
 *
 * @param existing normalized record already in the store
 * @param incoming incoming record, normalized
 * @param lds LDS engine
 * @param _path ?
 * @param conflict callback function to be invoked if the two records conflict
 * @returns reconciled representation of the record
 */
function merge$1(existing, incoming, lds, _path, conflictCallback) {
    if (existing === undefined || isErrorEntry(existing)) {
        return incoming;
    }
    // recordTypeId may get changed based on record state.
    // Evicts all dependencies from store.
    if (incoming.recordTypeId !== existing.recordTypeId) {
        const recordDepKey = depenpendencyKeyBuilder({ recordId: existing.id });
        const node = lds.getNode(recordDepKey);
        if (isGraphNode(node)) {
            const dependencies = node.retrieve();
            if (dependencies !== null) {
                const depKeys = keys(dependencies);
                for (let i = 0, len = depKeys.length; i < len; i++) {
                    lds.storeEvict(depKeys[i]);
                }
            }
        }
    }
    // TODO - handle merging of records that change apiName
    // if (existing.apiName !== incoming.apiName) {
    //     if (process.env.NODE_ENV === 'production') {
    //         lds.log(`API Name changed from ${existing.apiName} to ${incoming.apiName}`);
    //     } else {
    //         throw new Error('API Name cannot be different for merging records.');
    //     }
    // }
    // Adding instrumentation to see how frequently this occurs
    if (existing.apiName !== incoming.apiName) {
        const paramsBuilder = () => {
            return {
                [RECORD_API_NAME_CHANGE_EVENT]: true,
                existingApiName: existing.apiName,
                incomingApiName: incoming.apiName,
            };
        };
        lds.instrument(paramsBuilder);
    }
    const incomingWeakEtag = incoming.weakEtag;
    const existingWeakEtag = existing.weakEtag;
    if (incomingWeakEtag === 0 || existingWeakEtag === 0) {
        const paramsBuilder = () => {
            return {
                [INCOMING_WEAKETAG_0_KEY]: incomingWeakEtag === 0,
                [EXISTING_WEAKETAG_0_KEY]: existingWeakEtag === 0,
                apiName: incoming.apiName,
            };
        };
        lds.instrument(paramsBuilder);
    }
    // TODO W-6900085 - UIAPI returns weakEtag=0 when the record is >2 levels nested. For now
    // we treat the record as mergeable.
    if (incomingWeakEtag !== 0 && existingWeakEtag !== 0 && incomingWeakEtag !== existingWeakEtag) {
        if (conflictCallback !== undefined) {
            conflictCallback();
        }
        return mergeRecordConflict(lds, incoming, existing);
    }
    return mergeRecordFields(incoming, existing);
}
function depenpendencyKeyBuilder(config) {
    return `UiApi::RecordRepresentationDependency:${config.recordId}`;
}

const VIEW_ENTITY_API_NAME = 'Name';
const VIEW_ENTITY_KEY_PREFIX = `${keyPrefix}RecordViewEntityRepresentation:${VIEW_ENTITY_API_NAME}:`;
const keyBuilderFromType$3 = function RecordRepresentationKeyBuilderFromType(object) {
    const { apiName, id } = object;
    if (apiName === VIEW_ENTITY_API_NAME) {
        return VIEW_ENTITY_KEY_PREFIX + id;
    }
    return keyBuilderFromType$2(object);
};
const ingest$4 = function RecordRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$9(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$3(input);
    let existingRecord, incomingRecord;
    try {
        IngestionMetrics.incrementDepth();
        incomingRecord = normalize$4(input, store.records[key], {
            fullPath: key,
            parent: path.parent,
        }, lds, store, timestamp);
        existingRecord = store.records[key];
        incomingRecord = merge$1(existingRecord, incomingRecord, lds, path, IngestionMetrics.conflict);
    }
    finally {
        IngestionMetrics.decrementDepth();
    }
    if (existingRecord === undefined || equals$5(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 30000);
    return createLink(key);
};

function validate$a(obj, path = 'ListRecordCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray$1(obj_fields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
            const obj_fields_item = obj_fields[i];
            const path_fields_item = path_fields + '[' + i + ']';
            if (typeof obj_fields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
            }
        }
        const obj_listInfoETag = obj.listInfoETag;
        const path_listInfoETag = path + '.listInfoETag';
        if (typeof obj_listInfoETag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        if (typeof obj_listReference !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_listReference + '" (at "' + path_listReference + '")');
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_optionalFields = obj.optionalFields;
        const path_optionalFields = path + '.optionalFields';
        if (!ArrayIsArray$1(obj_optionalFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
        }
        for (let i = 0; i < obj_optionalFields.length; i++) {
            const obj_optionalFields_item = obj_optionalFields[i];
            const path_optionalFields_item = path_optionalFields + '[' + i + ']';
            if (typeof obj_optionalFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
            }
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || (typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray$1(obj_records)) {
            return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
            const obj_records_item = obj_records[i];
            const path_records_item = path_records + '[' + i + ']';
            if (typeof obj_records_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
            }
        }
        const obj_sortBy = obj.sortBy;
        const path_sortBy = path + '.sortBy';
        let obj_sortBy_union0 = null;
        const obj_sortBy_union0_error = (() => {
            if (!ArrayIsArray$1(obj_sortBy)) {
                return new TypeError('Expected "array" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
            }
            for (let i = 0; i < obj_sortBy.length; i++) {
                const obj_sortBy_item = obj_sortBy[i];
                const path_sortBy_item = path_sortBy + '[' + i + ']';
                if (typeof obj_sortBy_item !== 'string') {
                    return new TypeError('Expected "string" but received "' + typeof obj_sortBy_item + '" (at "' + path_sortBy_item + '")');
                }
            }
        })();
        if (obj_sortBy_union0_error != null) {
            obj_sortBy_union0 = obj_sortBy_union0_error.message;
        }
        let obj_sortBy_union1 = null;
        const obj_sortBy_union1_error = (() => {
            if (obj_sortBy !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
            }
        })();
        if (obj_sortBy_union1_error != null) {
            obj_sortBy_union1 = obj_sortBy_union1_error.message;
        }
        if (obj_sortBy_union0 && obj_sortBy_union1) {
            let message = 'Object doesn\'t match union (at "' + path_sortBy + '")';
            message += '\n' + obj_sortBy_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_sortBy_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$4(config) {
    return keyPrefix + 'ListRecordCollectionRepresentation:' + config.listViewId + ':' + (config.sortBy === null ? '' : '[' + config.sortBy.join(',') + ']');
}
function keyBuilderFromType$4(object) {
    const keyParams = {
        listViewId: object.listInfoETag,
        sortBy: object.sortBy
    };
    return keyBuilder$4(keyParams);
}
function paginationKeyBuilder(config) {
    return keyBuilder$4(config) + '__pagination';
}
function normalize$5(input, existing, path, lds, store, timestamp) {
    const input_listReference = input.listReference;
    const input_listReference_id = path.fullPath + '__listReference';
    input.listReference = ingest(input_listReference, {
        fullPath: input_listReference_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store);
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$4(input_records_item, {
            fullPath: input_records_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$6(existing, incoming) {
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_pageSize = existing.pageSize;
    const incoming_pageSize = incoming.pageSize;
    if (!(existing_pageSize === incoming_pageSize)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_listInfoETag = existing.listInfoETag;
    const incoming_listInfoETag = incoming.listInfoETag;
    if (!(existing_listInfoETag === incoming_listInfoETag)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_items = equalsArray(existing_fields, incoming_fields, (existing_fields_item, incoming_fields_item) => {
        if (!(existing_fields_item === incoming_fields_item)) {
            return false;
        }
    });
    if (equals_fields_items === false) {
        return false;
    }
    const existing_listReference = existing.listReference;
    const incoming_listReference = incoming.listReference;
    if (!(existing_listReference.__ref === incoming_listReference.__ref)) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_optionalFields = existing.optionalFields;
    const incoming_optionalFields = incoming.optionalFields;
    const equals_optionalFields_items = equalsArray(existing_optionalFields, incoming_optionalFields, (existing_optionalFields_item, incoming_optionalFields_item) => {
        if (!(existing_optionalFields_item === incoming_optionalFields_item)) {
            return false;
        }
    });
    if (equals_optionalFields_items === false) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
            return false;
        }
    });
    if (equals_records_items === false) {
        return false;
    }
    const existing_sortBy = existing.sortBy;
    const incoming_sortBy = incoming.sortBy;
    if (!((() => {
        if (existing_sortBy === null || incoming_sortBy === null) {
            return existing_sortBy === incoming_sortBy;
        }
        const equals_sortBy_items = equalsArray(existing_sortBy, incoming_sortBy, (existing_sortBy_item, incoming_sortBy_item) => {
            if (!(existing_sortBy_item === incoming_sortBy_item)) {
                return false;
            }
        });
        if (equals_sortBy_items === false) {
            return false;
        }
    })())) {
        return false;
    }
    return true;
}
const ingest$5 = function ListRecordCollectionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$a(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$4(input);
    let incomingRecord = normalize$5(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    const paginationKey = paginationKeyBuilder({
        listViewId: input.listInfoETag,
        sortBy: input.sortBy,
    });
    const { isPastEnd, offsetFor, save, setEnd, setToken } = lds.pagination(paginationKey);
    const currentOffset = offsetFor(input.currentPageToken);
    if (process.env.NODE_ENV !== 'production') {
        if (currentOffset === undefined ||
            (existingRecord &&
                existingRecord.records.length < currentOffset)) {
            throw new RangeError("currentPageToken value " + input.currentPageToken + " not recognized");
        }
    }
    const nextOffset = currentOffset + input.count;
    if (input.nextPageToken) {
        setToken(input.nextPageToken, nextOffset);
        if (isPastEnd(nextOffset)) {
            setEnd(undefined);
        }
    }
    else {
        setEnd(nextOffset);
    }
    if (input.previousPageToken) {
        // TODO - need request's pageSize to ingest previousPageToken at end of list
        if (input.nextPageToken) {
            setToken(input.previousPageToken, currentOffset - input.count);
        }
    }
    save();
    if (existingRecord) {
        incomingRecord.currentPageUrl = existingRecord.currentPageUrl;
        // TODO: needs optimization
        incomingRecord.records = [
            ...existingRecord.records.slice(0, currentOffset),
            ...incomingRecord.records,
            ...(input.nextPageToken ?
                existingRecord.records.slice(nextOffset) :
                []),
        ];
    }
    if (existingRecord === undefined || equals$6(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$b(obj, path = 'ListUiRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_info = obj.info;
        const path_info = path + '.info';
        if (typeof obj_info !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_info + '" (at "' + path_info + '")');
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (typeof obj_records !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$5(config) {
    return keyPrefix + 'ListUiRepresentation:' + (config.listViewApiName === null ? '' : config.listViewApiName) + ':' + config.objectApiName + ':' + config.type + ':' + (config.sortBy === null ? '' : '[' + config.sortBy.join(',') + ']');
}
function keyBuilderFromType$5(object) {
    const keyParams = {
        listViewApiName: object.info.listReference.listViewApiName,
        objectApiName: object.info.listReference.objectApiName,
        type: object.info.listReference.type,
        sortBy: object.records.sortBy
    };
    return keyBuilder$5(keyParams);
}
function normalize$6(input, existing, path, lds, store, timestamp) {
    const input_info = input.info;
    const input_info_id = path.fullPath + '__info';
    input.info = ingest$1(input_info, {
        fullPath: input_info_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store);
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    input.records = ingest$5(input_records, {
        fullPath: input_records_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$7(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_info = existing.info;
    const incoming_info = incoming.info;
    if (!(existing_info.__ref === incoming_info.__ref)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    if (!(existing_records.__ref === incoming_records.__ref)) {
        return false;
    }
    return true;
}
const ingest$6 = function ListUiRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$b(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$5(input);
    let incomingRecord = normalize$6(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$7(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function createResourceRequest$2(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$6,
        headers,
    };
}

function isObjectId(unknown) {
    if (typeof unknown !== 'object' || unknown === null) {
        return false;
    }
    return isString(unknown.objectApiName);
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getObjectApiName(value) {
    // Note: tightening validation logic changes behavior from userland getting
    // a server-provided error to the adapter noop'ing. In 224 we decided to not
    // change the behavior.
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed.length > 0) {
            return trimmed;
        }
    }
    else if (isObjectId(value)) {
        return value.objectApiName.trim();
    }
    return undefined;
}

const getListUiByApiName_ConfigPropertyNames = {
    displayName: 'getListUiByApiName',
    parameters: {
        required: ['listViewApiName', 'objectApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function coerceConfig$1(config) {
    const coercedConfig = {};
    const listViewApiName = config.listViewApiName;
    if (listViewApiName !== undefined) {
        coercedConfig.listViewApiName = listViewApiName;
    }
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const sortBy = getFieldApiNamesArray(config.sortBy);
    if (sortBy !== undefined) {
        coercedConfig.sortBy = sortBy;
    }
    return coercedConfig;
}
function typeCheckConfig$1(untrustedConfig) {
    const config = {};
    const untrustedConfig_listViewApiName = untrustedConfig.listViewApiName;
    if (typeof untrustedConfig_listViewApiName === 'string') {
        config.listViewApiName = untrustedConfig_listViewApiName;
    }
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$1(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$1(untrustedConfig);
    const config = typeCheckConfig$1(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function createResourceRequest$3(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.listViewId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$6,
        headers,
    };
}

const getListUiByListViewId_ConfigPropertyNames = {
    displayName: 'getListUiByListViewId',
    parameters: {
        required: ['listViewId'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function coerceConfig$2(config) {
    const coercedConfig = {};
    const listViewId = config.listViewId;
    if (listViewId !== undefined) {
        coercedConfig.listViewId = listViewId;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const sortBy = getFieldApiNamesArray(config.sortBy);
    if (sortBy !== undefined) {
        coercedConfig.sortBy = sortBy;
    }
    return coercedConfig;
}
function typeCheckConfig$2(untrustedConfig) {
    const config = {};
    const untrustedConfig_listViewId = untrustedConfig.listViewId;
    if (typeof untrustedConfig_listViewId === 'string') {
        config.listViewId = untrustedConfig_listViewId;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$2(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$2(untrustedConfig);
    const config = typeCheckConfig$2(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function createResourceRequest$4(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/list-records/' + config.urlParams.listViewId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$5,
        headers,
    };
}

function createResourceRequest$5(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/list-records/' + config.urlParams.objectApiName + '/' + config.urlParams.listViewApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$5,
        headers,
    };
}

const listReferences = {
    byId: {},
    byApiNames: {},
};
/**
 * Adds a list reference so it can be retrieved with #getListReference later.
 *
 * @param listRef list refenence
 */
function addListReference(listRef) {
    if (listRef.id) {
        listReferences.byId[listRef.id] = listRef;
    }
    listReferences.byApiNames[`${listRef.objectApiName}:${listRef.listViewApiName}`] = listRef;
}
/**
 * Returns a list reference from the store if it's present.
 *
 * @param query list view to look for
 * @param lds LDS
 */
function getListReference(query) {
    return query.listViewId
        ? listReferences.byId[query.listViewId]
        : listReferences.byApiNames[`${query.objectApiName}:${query.listViewApiName}`];
}
/**
 * Reader selections to copy a list info
 */
const LIST_INFO_SELECTIONS = select$5().selections;
/**
 * List info private memebers
 */
const LIST_INFO_PRIVATES = select$5().private;
const LIST_INFO_SELECTIONS_ETAG = [
    ...LIST_INFO_SELECTIONS,
    { kind: 'Scalar', name: 'eTag' },
];
/**
 * Retrieves the list info corresponding to the specified list reference from the store.
 *
 * @param listRef list reference
 * @param lds LDS
 */
function getListInfo(listRef, lds) {
    const key = keyBuilder$1(listRef);
    const lookupResult = lds.storeLookup({
        recordId: key,
        node: { kind: 'Fragment', selections: LIST_INFO_SELECTIONS_ETAG, private: [] },
        variables: {},
    });
    if (isFulfilledSnapshot(lookupResult)) {
        return lookupResult.data;
    }
}
const serverDefaults = {};
/**
 * Update the default values based on a server response.
 *
 * @param config getListUi config
 * @param serverResponse ListUiRepresentation from the server
 */
function addServerDefaults(config, serverResponse) {
    const key = `${serverResponse.info.listReference.objectApiName}:${serverResponse.info.listReference.listViewApiName}`;
    let defaults = serverDefaults[key] || (serverDefaults[key] = {});
    if (config.sortBy === undefined && serverResponse.records.sortBy !== null) {
        defaults.sortBy = serverResponse.records.sortBy;
    }
}
/**
 * Returns default values observed on previous requests for a list.
 *
 * @param config getListUi config
 * @returns defaults from previous requests for this list, or {} if no defaults are known
 */
function getServerDefaults(config) {
    const listRef = getListReference(config);
    if (listRef === undefined) {
        return {};
    }
    const key = `${listRef.objectApiName}:${listRef.listViewApiName}`;
    return serverDefaults[key] || {};
}
// Logic to deal with fields on the list view. This would be reasonably straightforward
// except that the server sometimes adds 5 well-known fields to every record & nested
// record in its responses.
// hardcoded fields that the server adds
const DEFAULT_SERVER_FIELDS = [
    'CreatedDate',
    'Id',
    'LastModifiedById',
    'LastModifiedDate',
    'SystemModstamp',
];
/**
 * Adds default fields for every record referenced in a given field name. E.g. if field
 * is "Opportunity.Account.Name" then add default fields "Opportunity.CreatedDate",
 * "Opportunity.Id", ..., "Opportunity.Account.CreatedDate", "Opportunity.Account.Id", ... .
 *
 * @param field explicitly included field
 * @param defaultFields fields object to be updated with the fields that the server will
 *    implicitly add
 */
function addDefaultFields(field, defaultFields) {
    const fieldParts = field.split('.');
    for (let i = 1; i < fieldParts.length; ++i) {
        const fieldPrefix = fieldParts.slice(0, i).join('.');
        for (let j = 0; j < DEFAULT_SERVER_FIELDS.length; ++j) {
            defaultFields[`${fieldPrefix}.${DEFAULT_SERVER_FIELDS[j]}`] = true;
        }
    }
}
/**
 * Indicates if a RecordRepresntation contains a specified field.
 *
 * @param record record
 * @param field field to check for, split on '.'s, with the leading object api name omitted.
 *    E.g. if searching an Opportunity for "Opportunity.Account.Name" this parameter should
 *    be ['Account','Name'].
 */
function recordContainsField(record, field) {
    // make sure it looks like a record and the first piece of the field path has a value
    if (!record ||
        !record.fields ||
        !record.fields[field[0]] ||
        record.fields[field[0]].value === undefined) {
        return false;
    }
    // recurse if nested record
    else if (field.length > 1) {
        return recordContainsField(record.fields[field[0]].value, field.slice(1));
    }
    // found it
    return true;
}
function listFields(lds, { fields = [], optionalFields = [], sortBy, }, listInfo) {
    const { displayColumns, listReference: { objectApiName }, } = listInfo;
    let fields_ = {}, optionalFields_ = {}, defaultFields_ = {};
    // all the fields in the list info are required
    for (let i = 0, len = displayColumns.length; i < len; ++i) {
        const qualifiedField = `${objectApiName}.${displayColumns[i].fieldApiName}`;
        fields_[qualifiedField] = true;
        addDefaultFields(qualifiedField, defaultFields_);
    }
    // required fields from the component
    for (let i = 0, len = fields.length; i < len; ++i) {
        const qualifiedField = fields[i].startsWith(`${objectApiName}.`)
            ? fields[i]
            : `${objectApiName}.${fields[i]}`;
        if (!fields_[qualifiedField]) {
            fields_[qualifiedField] = true;
            addDefaultFields(qualifiedField, defaultFields_);
        }
    }
    // optional fields from the component
    for (let i = 0, len = optionalFields.length; i < len; ++i) {
        const qualifiedField = optionalFields[i].startsWith(`${objectApiName}.`)
            ? optionalFields[i]
            : `${objectApiName}.${optionalFields[i]}`;
        if (!fields_[qualifiedField]) {
            optionalFields_[qualifiedField] = true;
            addDefaultFields(qualifiedField, defaultFields_);
        }
    }
    const key = keyBuilder$4({
        listViewId: listInfo.eTag,
        sortBy: sortBy || null,
    }) + '__fieldstatus';
    const node = lds.getNode(key);
    const defaultServerFieldStatus = isGraphNode(node)
        ? node.retrieve()
        : { missingFields: { ...defaultFields_ } };
    return {
        getRecordSelectionFieldSets() {
            const optionalPlusDefaultFields = { ...optionalFields_ };
            const fields = keys(defaultFields_);
            for (let i = 0; i < fields.length; ++i) {
                const field = fields[i];
                if (!fields_[field] && !defaultServerFieldStatus.missingFields[field]) {
                    optionalPlusDefaultFields[field] = true;
                }
            }
            return [keys(fields_).sort(), keys(optionalPlusDefaultFields).sort()];
        },
        processRecords(records) {
            const { missingFields } = defaultServerFieldStatus;
            const fields = keys(missingFields);
            for (let i = 0; i < fields.length; ++i) {
                const field = fields[i], splitField = field.split('.').slice(1);
                for (let i = 0; i < records.length; ++i) {
                    if (recordContainsField(records[i], splitField)) {
                        delete missingFields[field];
                        break;
                    }
                }
            }
            lds.storePublish(key, defaultServerFieldStatus);
            // snapshots do not subscribe to this key, so no need to broadcast
            return this;
        },
    };
}

function paginatedDataCustomReader(key, selection, record, data, variables, reader) {
    const nonCustomSelection = {
        name: selection.name,
        plural: true,
        pageToken: selection.pageToken,
        pageSize: selection.pageSize,
        tokenDataKey: selection.tokenDataKey,
    };
    if (record[selection.name] && record[selection.name][0] && record[selection.name][0].__ref) {
        nonCustomSelection.kind = 'Link';
        nonCustomSelection.fragment = {
            kind: 'Fragment',
            selections: selection.selections,
        };
        reader.readPluralLink(key, nonCustomSelection, record, data);
    }
    else {
        nonCustomSelection.kind = 'Object';
        nonCustomSelection.selections = selection.selections;
        reader.readPluralObject(key, nonCustomSelection, record, data);
    }
    const pagination = reader.pagination(selection.tokenDataKey);
    variables.__pageSize = selection.pageSize;
    const currentOffset = pagination.offsetFor(selection.pageToken);
    const nextOffset = currentOffset + selection.pageSize;
    const previousOffset = currentOffset - selection.pageSize;
    // count
    variables.count = data[selection.name].length;
    // current/next/previousPageToken
    variables.currentPageToken = selection.pageToken || pagination.defaultToken();
    const nextPageToken = pagination.isPastEnd(nextOffset) ? null : pagination.tokenFor(nextOffset);
    if (nextPageToken !== undefined) {
        variables.nextPageToken = nextPageToken;
    }
    const previousPageToken = previousOffset < 0 ? null : pagination.tokenFor(previousOffset);
    if (previousPageToken !== undefined) {
        variables.previousPageToken = previousPageToken;
    }
    // current/next/previousPageUrls cannot be generated until we have a template url
}
function variablesCustomReader(key, selection, record, data, variables, reader) {
    reader.readScalar(selection.name, variables, data);
}
function urlCustomReader(key, selection, record, data, variables, reader) {
    let urlProp = selection.name;
    let tokenProp = `${urlProp.substring(0, urlProp.indexOf('Url'))}Token`;
    if (variables[tokenProp]) {
        // currentPageUrl should never be empty so use that as the template
        variables[urlProp] = record.currentPageUrl
            .replace(/pageToken=[^&]+/, `pageToken=${variables[tokenProp]}`)
            .replace(/pageSize=\d+/, `pageSize=${variables.__pageSize}`);
    }
    else if (variables[tokenProp] === null) {
        variables[urlProp] = null;
    }
    reader.readScalar(selection.name, variables, data);
}
/**
 * Constructs a PathSelection[] to have Reader correctly populate paginated data
 * and metadata in a Snapshot. The metadata is assumed to follow the standard
 * UI API naming conventions: count, currentPageToken, currentPageUrl,
 * nextPageToken, nextPageUrl, previousPageToken, and previousPageUrl.
 *
 * @param config.name name of the field containing the paginated data
 * @param config.pageSize number of items to be included
 * @param config.pageToken token corresponding to starting offset
 * @param config.selections PathSelection[] to apply to each item
 * @param config.tokenDataKey store key of the pagination data
 * @returns PathSelection[] to populate the paginated data and associated metadata
 */
function pathSelectionsFor(config) {
    return [
        {
            kind: 'Custom',
            name: config.name,
            pageToken: config.pageToken,
            pageSize: config.pageSize,
            plural: true,
            reader: paginatedDataCustomReader,
            selections: config.selections,
            tokenDataKey: config.tokenDataKey,
        },
        {
            kind: 'Custom',
            name: 'count',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'currentPageToken',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'currentPageUrl',
            reader: urlCustomReader,
        },
        {
            kind: 'Custom',
            name: 'nextPageToken',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'nextPageUrl',
            reader: urlCustomReader,
        },
        {
            kind: 'Custom',
            name: 'previousPageToken',
            reader: variablesCustomReader,
        },
        {
            kind: 'Custom',
            name: 'previousPageUrl',
            reader: urlCustomReader,
        },
    ];
}
/**
 * Returns a PathSelection that injects a predetermined value at the specified name.
 *
 * @param config.name key associated with the value
 * @param config.value value to be injected
 */
function staticValuePathSelection(config) {
    return {
        kind: 'Custom',
        name: config.name,
        reader: (key, _selection, _record, data, _variables, _reader) => {
            data[key] = config.value;
        },
    };
}
/**
 * Examines a set of paginated data & metadata from an UnfulfilledSnapshot and computes a
 * pageToken and pageSize that will minimize the amount of data requested while still
 * satisfying the original request.
 *
 * @param config.name name of the field within data that contains the items
 * @param conifg.data paginated data/metadata from an UnfulfilledSnapshot
 * @param config.pageSize requested pageSize
 * @param config.pagination pagination data/functions from engine
 * @returns pageToken & pageSize to fill in the missing data
 */
function minimizeRequest(config) {
    // the only way to handle missing current or previous token is to ask for the full set of requested records
    if (!config.data || !config.data[config.name] || config.data.previousPageToken === undefined) {
        return {
            pageSize: config.pageSize,
            pageToken: config.pageToken,
        };
    }
    else {
        // compute the offset of the last record that was found
        const pageTokenOffset = config.pagination.offsetFor(config.data.currentPageToken);
        const lastFoundOffset = pageTokenOffset + config.data[config.name].length;
        // backup to the nearest offset for which we have a token
        const [newToken, newOffset] = config.pagination.tokenForAtMost(lastFoundOffset);
        // recompute pageToken and pageSize for query based on new starting token
        return {
            pageSize: pageTokenOffset - newOffset + config.pageSize,
            pageToken: newToken,
        };
    }
}

function validate$c(obj, path = 'ListViewSummaryRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_listUiUrl = obj.listUiUrl;
        const path_listUiUrl = path + '.listUiUrl';
        if (typeof obj_listUiUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_listUiUrl + '" (at "' + path_listUiUrl + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$6 = function ListViewSummaryRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar',
            },
            {
                name: 'id',
                kind: 'Scalar',
            },
            {
                name: 'label',
                kind: 'Scalar',
            },
            {
                name: 'listUiUrl',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$8(existing, incoming) {
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_label = existing.label;
    const incoming_label = incoming.label;
    if (!(existing_label === incoming_label)) {
        return false;
    }
    const existing_listUiUrl = existing.listUiUrl;
    const incoming_listUiUrl = incoming.listUiUrl;
    if (!(existing_listUiUrl === incoming_listUiUrl)) {
        return false;
    }
    return true;
}

function validate$d(obj, path = 'ListViewSummaryCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_lists = obj.lists;
        const path_lists = path + '.lists';
        if (!ArrayIsArray$1(obj_lists)) {
            return new TypeError('Expected "array" but received "' + typeof obj_lists + '" (at "' + path_lists + '")');
        }
        for (let i = 0; i < obj_lists.length; i++) {
            const obj_lists_item = obj_lists[i];
            const path_lists_item = path_lists + '[' + i + ']';
            const referenceListViewSummaryRepresentationValidationError = validate$c(obj_lists_item, path_lists_item);
            if (referenceListViewSummaryRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ListViewSummaryRepresentation (at "' + path_lists_item + '")\n';
                message += referenceListViewSummaryRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        if (typeof obj_pageSize !== 'number' || (typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_queryString = obj.queryString;
        const path_queryString = path + '.queryString';
        let obj_queryString_union0 = null;
        const obj_queryString_union0_error = (() => {
            if (typeof obj_queryString !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
            }
        })();
        if (obj_queryString_union0_error != null) {
            obj_queryString_union0 = obj_queryString_union0_error.message;
        }
        let obj_queryString_union1 = null;
        const obj_queryString_union1_error = (() => {
            if (obj_queryString !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_queryString + '" (at "' + path_queryString + '")');
            }
        })();
        if (obj_queryString_union1_error != null) {
            obj_queryString_union1 = obj_queryString_union1_error.message;
        }
        if (obj_queryString_union0 && obj_queryString_union1) {
            let message = 'Object doesn\'t match union (at "' + path_queryString + '")';
            message += '\n' + obj_queryString_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_queryString_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recentListsOnly = obj.recentListsOnly;
        const path_recentListsOnly = path + '.recentListsOnly';
        if (typeof obj_recentListsOnly !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_recentListsOnly + '" (at "' + path_recentListsOnly + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$6(config) {
    return keyPrefix + 'ListViewSummaryCollectionRepresentation:' + config.objectApiName + ':' + (config.queryString === null ? '' : config.queryString) + ':' + config.recentListsOnly;
}
function keyBuilderFromType$6(object) {
    const keyParams = {
        objectApiName: object.objectApiName,
        queryString: object.queryString,
        recentListsOnly: object.recentListsOnly
    };
    return keyBuilder$6(keyParams);
}
function paginationKeyBuilder$1(config) {
    return keyBuilder$6(config) + '__pagination';
}
function normalize$7(input, existing, path, lds, store, timestamp) {
    return input;
}
function equals$9(existing, incoming) {
    const existing_recentListsOnly = existing.recentListsOnly;
    const incoming_recentListsOnly = incoming.recentListsOnly;
    if (!(existing_recentListsOnly === incoming_recentListsOnly)) {
        return false;
    }
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_pageSize = existing.pageSize;
    const incoming_pageSize = incoming.pageSize;
    if (!(existing_pageSize === incoming_pageSize)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_lists = existing.lists;
    const incoming_lists = incoming.lists;
    const equals_lists_items = equalsArray(existing_lists, incoming_lists, (existing_lists_item, incoming_lists_item) => {
        if (!(equals$8(existing_lists_item, incoming_lists_item))) {
            return false;
        }
    });
    if (equals_lists_items === false) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_queryString = existing.queryString;
    const incoming_queryString = incoming.queryString;
    if (!(existing_queryString === incoming_queryString)) {
        return false;
    }
    return true;
}
const ingest$7 = function ListViewSummaryCollectionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$d(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$6(input);
    let incomingRecord = normalize$7(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    const paginationKey = paginationKeyBuilder$1({
        objectApiName: input.objectApiName,
        queryString: input.queryString,
        recentListsOnly: input.recentListsOnly,
    });
    const { isPastEnd, offsetFor, save, setEnd, setToken } = lds.pagination(paginationKey);
    const currentOffset = offsetFor(input.currentPageToken);
    if (process.env.NODE_ENV !== 'production') {
        if (currentOffset === undefined ||
            (existingRecord &&
                existingRecord.lists.length < currentOffset)) {
            throw new RangeError("currentPageToken value " + input.currentPageToken + " not recognized");
        }
    }
    const nextOffset = currentOffset + input.count;
    if (input.nextPageToken) {
        setToken(input.nextPageToken, nextOffset);
        if (isPastEnd(nextOffset)) {
            setEnd(undefined);
        }
    }
    else {
        setEnd(nextOffset);
    }
    if (input.previousPageToken) {
        // TODO - need request's pageSize to ingest previousPageToken at end of list
        if (input.nextPageToken) {
            setToken(input.previousPageToken, currentOffset - input.count);
        }
    }
    save();
    if (existingRecord) {
        incomingRecord.currentPageUrl = existingRecord.currentPageUrl;
        // TODO: needs optimization
        incomingRecord.lists = [
            ...existingRecord.lists.slice(0, currentOffset),
            ...incomingRecord.lists,
            ...(input.nextPageToken ?
                existingRecord.lists.slice(nextOffset) :
                []),
        ];
    }
    if (existingRecord === undefined || equals$9(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function keyBuilder$7(params) {
    return keyBuilder$6({
        objectApiName: params.urlParams.objectApiName,
        queryString: params.queryParams.q || null,
        recentListsOnly: params.queryParams.recentListsOnly || false
    });
}
function createResourceRequest$6(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/list-ui/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$7,
        headers,
    };
}

const getListViewSummaryCollection_ConfigPropertyNames = {
    displayName: 'getListViewSummaryCollection',
    parameters: {
        required: ['objectApiName'],
        optional: ['pageSize', 'pageToken', 'q', 'recentListsOnly']
    }
};
function createResourceParams$1(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            pageSize: config.pageSize, pageToken: config.pageToken, q: config.q, recentListsOnly: config.recentListsOnly
        }
    };
}
function coerceConfig$3(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const q = config.q;
    if (q !== undefined) {
        coercedConfig.q = q;
    }
    const recentListsOnly = config.recentListsOnly;
    if (recentListsOnly !== undefined) {
        coercedConfig.recentListsOnly = recentListsOnly;
    }
    return coercedConfig;
}
function typeCheckConfig$3(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_q = untrustedConfig.q;
    if (typeof untrustedConfig_q === 'string') {
        config.q = untrustedConfig_q;
    }
    const untrustedConfig_recentListsOnly = untrustedConfig.recentListsOnly;
    if (typeof untrustedConfig_recentListsOnly === 'boolean') {
        config.recentListsOnly = untrustedConfig_recentListsOnly;
    }
    return config;
}
function validateAdapterConfig$3(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$3(untrustedConfig);
    const config = typeCheckConfig$3(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

// TODO RAML - this more properly goes in the generated resource files
const DEFAULT_PAGE_SIZE = 20;
const LISTVIEWSUMMARY_PATH_SELECTIONS = select$6().selections;
function buildListViewSummaryCollectionFragment(config) {
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            ...pathSelectionsFor({
                name: 'lists',
                selections: LISTVIEWSUMMARY_PATH_SELECTIONS,
                pageSize: config.pageSize || DEFAULT_PAGE_SIZE,
                pageToken: config.pageToken,
                tokenDataKey: paginationKeyBuilder$1({
                    objectApiName: config.objectApiName,
                    queryString: config.q === undefined ? null : config.q,
                    recentListsOnly: config.recentListsOnly === undefined ? false : config.recentListsOnly,
                }),
            }),
            {
                kind: 'Scalar',
                name: 'objectApiName',
            },
            staticValuePathSelection({
                name: 'pageSize',
                value: config.pageSize === undefined ? DEFAULT_PAGE_SIZE : config.pageSize,
            }),
            {
                kind: 'Scalar',
                name: 'queryString',
            },
            {
                kind: 'Scalar',
                name: 'recentListsOnly',
            },
        ],
    };
}
function buildRefreshSnapshot(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$1(lds, config),
    };
}
function buildInMemorySnapshot$1(lds, config) {
    const selector = {
        recordId: keyBuilder$7(createResourceParams$1(config)),
        node: buildListViewSummaryCollectionFragment(config),
        variables: {},
    };
    return lds.storeLookup(selector, buildRefreshSnapshot(lds, config));
}
function prepareRequest$1(lds, config, resourceParams, snapshot) {
    const request = createResourceRequest$6(resourceParams);
    if (snapshot) {
        // compute the minimum number of records we need to request
        const { pageSize, pageToken } = minimizeRequest({
            data: snapshot.data,
            name: 'lists',
            pageSize: config.pageSize || DEFAULT_PAGE_SIZE,
            pageToken: config.pageToken,
            pagination: lds.pagination(paginationKeyBuilder$1({
                objectApiName: config.objectApiName,
                queryString: config.q === undefined ? null : config.q,
                recentListsOnly: config.recentListsOnly === undefined ? false : config.recentListsOnly,
            })),
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE || request.queryParams.pageSize !== undefined) {
            request.queryParams.pageSize = pageSize;
        }
        if (pageToken || request.queryParams.pageToken !== undefined) {
            request.queryParams.pageToken = pageToken;
        }
    }
    return request;
}
function onResourceSuccess$1(lds, config, request, key, response) {
    const { body } = response;
    lds.storeIngest(key, request, body);
    lds.storeBroadcast();
    return buildInMemorySnapshot$1(lds, config);
}
function onResourceError$1(lds, config, key, error) {
    lds.storeIngestFetchResponse(key, error);
    lds.storeBroadcast();
    return lds.errorSnapshot(error, buildRefreshSnapshot(lds, config));
}
function resolveUnfulfilledSnapshot$1(lds, config, snapshot) {
    const resourceParams = createResourceParams$1(config);
    const key = keyBuilder$7(resourceParams);
    const request = prepareRequest$1(lds, config, resourceParams, snapshot);
    return lds
        .resolveUnfulfilledSnapshot(request, snapshot)
        .then((resp) => {
        return onResourceSuccess$1(lds, config, request, key, resp);
    }, (error) => {
        return onResourceError$1(lds, config, key, error);
    });
}
function buildNetworkSnapshot$1(lds, config, snapshot) {
    const resourceParams = createResourceParams$1(config);
    const key = keyBuilder$7(resourceParams);
    const request = prepareRequest$1(lds, config, resourceParams, snapshot);
    return lds.dispatchResourceRequest(request).then((resp) => {
        return onResourceSuccess$1(lds, config, request, key, resp);
    }, (error) => {
        return onResourceError$1(lds, config, key, error);
    });
}
const factory = (lds) => function getListViewSummaryCollection(untrustedConfig) {
    const config = validateAdapterConfig$3(untrustedConfig, getListViewSummaryCollection_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$1(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot)) {
        return cacheSnapshot;
    }
    if (isUnfulfilledSnapshot(cacheSnapshot)) {
        return resolveUnfulfilledSnapshot$1(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$1(lds, config, cacheSnapshot);
};

function keyBuilder$8(params) {
    return keyBuilder$5({
        listViewApiName: null,
        objectApiName: params.urlParams.objectApiName,
        type: "mru",
        sortBy: params.queryParams.sortBy || null
    });
}
function createResourceRequest$7(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/mru-list-ui/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$6,
        headers,
    };
}

const getMruListUi_ConfigPropertyNames = {
    displayName: 'getMruListUi',
    parameters: {
        required: ['objectApiName'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function createResourceParams$2(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            fields: config.fields, optionalFields: config.optionalFields, pageSize: config.pageSize, pageToken: config.pageToken, sortBy: config.sortBy
        }
    };
}
function coerceConfig$4(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const fields = getFieldApiNamesArray(config.fields);
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const pageToken = config.pageToken;
    if (pageToken !== undefined) {
        coercedConfig.pageToken = pageToken;
    }
    const sortBy = getFieldApiNamesArray(config.sortBy);
    if (sortBy !== undefined) {
        coercedConfig.sortBy = sortBy;
    }
    return coercedConfig;
}
function typeCheckConfig$4(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$4(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$4(untrustedConfig);
    const config = typeCheckConfig$4(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function createResourceRequest$8(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/mru-list-records/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$5,
        headers,
    };
}

const LIST_REFERENCE_SELECTIONS = select$4();
// TODO RAML - this more properly goes in the generated resource files
const DEFAULT_PAGE_SIZE$1 = 50;
// make local copies of the adapter configs so we can ignore other getListUi config parameters to match
// lds222 behavior
const getMruListUi_ConfigPropertyNames_augmented = {
    ...getMruListUi_ConfigPropertyNames,
    parameters: {
        ...getMruListUi_ConfigPropertyNames.parameters,
        optional: [
            ...getMruListUi_ConfigPropertyNames.parameters.optional,
            'listViewApiName',
            'listViewId',
        ],
    },
};
function buildListUiFragment(config, listInfo, fields) {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                kind: 'Link',
                name: 'info',
                fragment: {
                    kind: 'Fragment',
                    private: LIST_INFO_PRIVATES,
                    selections: LIST_INFO_SELECTIONS,
                },
            },
            {
                kind: 'Link',
                name: 'records',
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: [
                        ...pathSelectionsFor({
                            name: 'records',
                            pageSize: config.pageSize || DEFAULT_PAGE_SIZE$1,
                            pageToken: config.pageToken,
                            selections: buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),
                            tokenDataKey: paginationKeyBuilder({
                                listViewId: listInfo.eTag,
                                sortBy: config.sortBy === undefined ? null : config.sortBy,
                            }),
                        }),
                        {
                            kind: 'Scalar',
                            name: 'fields',
                            plural: true,
                        },
                        {
                            kind: 'Scalar',
                            name: 'listInfoETag',
                        },
                        {
                            kind: 'Link',
                            name: 'listReference',
                            fragment: LIST_REFERENCE_SELECTIONS,
                        },
                        {
                            kind: 'Scalar',
                            name: 'optionalFields',
                            plural: true,
                        },
                        staticValuePathSelection({
                            name: 'pageSize',
                            value: config.pageSize === undefined ? DEFAULT_PAGE_SIZE$1 : config.pageSize,
                        }),
                        {
                            // TODO - check type; re-verify after sortBy added to key
                            kind: 'Scalar',
                            name: 'sortBy',
                        },
                    ],
                },
            },
        ],
    };
}
function buildSnapshotRefresh$1(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot_getMruListUi(lds, config),
    };
}
function buildInMemorySnapshot$2(lds, config, listInfo, fields) {
    const listFields_ = fields || listFields(lds, config, listInfo);
    const resourceParams = createResourceParams$2(config);
    const selector = {
        recordId: keyBuilder$8(resourceParams),
        node: buildListUiFragment(config, listInfo, listFields_),
        variables: {},
    };
    return lds.storeLookup(selector, buildSnapshotRefresh$1(lds, config));
}
/**
 * Builds, sends, and processes the result of a mru-list-ui request, ignoring any cached
 * data for the list.
 *
 * @param lds LDS engine
 * @param config wire config
 */
function buildNetworkSnapshot_getMruListUi(lds, config) {
    const params = createResourceParams$2(config);
    const request = createResourceRequest$7(params);
    return lds.dispatchResourceRequest(request).then(response => {
        const { body } = response;
        const listInfo = body.info;
        // server returns sortBy in csv format
        if (body.records.sortBy) {
            body.records.sortBy = body.records.sortBy.split(',');
        }
        const listUiKey = keyBuilder$5({
            ...listInfo.listReference,
            sortBy: body.records.sortBy,
        });
        // grab relevant bits before ingest destroys the structure
        const fields = listFields(lds, config, listInfo);
        fields.processRecords(body.records.records);
        // build the selector while the list info is still easily accessible
        const fragment = buildListUiFragment(config, listInfo, fields);
        lds.storeIngest(listUiKey, request, body);
        lds.storeBroadcast();
        return lds.storeLookup({
            recordId: listUiKey,
            node: fragment,
            variables: {},
        }, buildSnapshotRefresh$1(lds, config));
    }, (err) => {
        return lds.errorSnapshot(err, buildSnapshotRefresh$1(lds, config));
    });
}
function buildNetworkSnapshot_getMruListRecords(lds, config, listInfo, snapshot) {
    const { fields, optionalFields, pageSize, pageToken, sortBy } = config;
    const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy,
    };
    const request = createResourceRequest$8({
        urlParams: {
            objectApiName: config.objectApiName,
        },
        queryParams,
    });
    if (snapshot) {
        // compute the minimum number of records we need to request
        const { pageSize, pageToken } = minimizeRequest({
            data: snapshot.data ? snapshot.data.records : null,
            name: 'records',
            pageSize: config.pageSize || DEFAULT_PAGE_SIZE$1,
            pageToken: config.pageToken,
            pagination: lds.pagination(paginationKeyBuilder({
                listViewId: listInfo.eTag,
                sortBy: config.sortBy === undefined ? null : config.sortBy,
            })),
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE$1 || request.queryParams.pageSize !== undefined) {
            request.queryParams.pageSize = pageSize;
        }
        if (pageToken !== undefined || request.queryParams.pageToken !== undefined) {
            request.queryParams.pageToken = pageToken;
        }
    }
    return lds.dispatchResourceRequest(request).then(response => {
        const { body } = response;
        const { listInfoETag } = body;
        // fall back to mru-list-ui if list view has changed
        if (listInfoETag !== listInfo.eTag) {
            return buildNetworkSnapshot_getMruListUi(lds, config);
        }
        // server returns sortBy in csv format
        if (body.sortBy) {
            body.sortBy = body.sortBy.split(',');
        }
        const fields = listFields(lds, config, listInfo).processRecords(body.records);
        lds.storeIngest(keyBuilder$4({
            listViewId: listInfoETag,
            sortBy: body.sortBy,
        }), request, body);
        lds.storeBroadcast();
        return buildInMemorySnapshot$2(lds, config, listInfo, fields);
    }, (err) => {
        lds.storeIngestFetchResponse(keyBuilder$5({
            ...listInfo.listReference,
            sortBy: config.sortBy === undefined ? null : config.sortBy,
        }), err);
        lds.storeBroadcast();
        return lds.errorSnapshot(err, buildSnapshotRefresh$1(lds, config));
    });
}
const factory$1 = (lds) => function getMruListUi(untrustedConfig) {
    const config = validateAdapterConfig$4(untrustedConfig, getMruListUi_ConfigPropertyNames_augmented);
    if (config === null) {
        return null;
    }
    // try to get a list reference and a list info for the list; this should come back
    // non-null if we have the list info cached
    const listInfo = getListInfo({
        id: null,
        listViewApiName: null,
        objectApiName: config.objectApiName,
        type: 'mru',
    }, lds);
    // no list info means it's not in the cache - make a full list-ui request
    if (!listInfo) {
        return buildNetworkSnapshot_getMruListUi(lds, config);
    }
    // with the list info we can construct the full selector and try to get the
    // list ui from the store
    const snapshot = buildInMemorySnapshot$2(lds, config, listInfo);
    // if the list ui was not found in the store then
    // make a full list-ui request
    if (!snapshot.data) {
        return buildNetworkSnapshot_getMruListUi(lds, config);
    }
    if (lds.snapshotDataAvailable(snapshot)) {
        // cache hit :partyparrot:
        return snapshot;
    }
    // we *should* only be missing records and/or tokens at this point; send a list-records
    // request to fill them in
    return buildNetworkSnapshot_getMruListRecords(lds, config, listInfo, snapshot);
};

const LIST_REFERENCE_SELECTIONS$1 = select$4();
// TODO RAML - this more properly goes in the generated resource files
const DEFAULT_PAGE_SIZE$2 = 50;
// make local copies of the adapter configs so we can have them ignore each other's config parameters
// to match lds222 behavior
const getListUiByApiName_ConfigPropertyNames_augmented = {
    ...getListUiByApiName_ConfigPropertyNames,
    parameters: {
        ...getListUiByApiName_ConfigPropertyNames.parameters,
        optional: [...getListUiByApiName_ConfigPropertyNames.parameters.optional, 'listViewId'],
    },
};
const getListUiByListViewId_ConfigPropertyNames_augmented = {
    ...getListUiByListViewId_ConfigPropertyNames,
    parameters: {
        ...getListUiByListViewId_ConfigPropertyNames.parameters,
        optional: [
            ...getListUiByListViewId_ConfigPropertyNames.parameters.optional,
            'listViewApiName',
            'objectApiName',
        ],
    },
};
function getSortBy(config) {
    if (config.sortBy !== undefined) {
        return config.sortBy;
    }
    const defaults = getServerDefaults(config);
    if (defaults.sortBy !== undefined) {
        return defaults.sortBy;
    }
    return null;
}
function buildListUiFragment$1(config, listInfo, fields) {
    const defaultedConfig = { ...getServerDefaults(config), ...config };
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            {
                kind: 'Link',
                name: 'info',
                fragment: {
                    kind: 'Fragment',
                    private: LIST_INFO_PRIVATES,
                    selections: LIST_INFO_SELECTIONS,
                },
            },
            {
                kind: 'Link',
                name: 'records',
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: [
                        ...pathSelectionsFor({
                            name: 'records',
                            pageSize: defaultedConfig.pageSize || DEFAULT_PAGE_SIZE$2,
                            pageToken: defaultedConfig.pageToken,
                            selections: buildSelectionFromFields(...fields.getRecordSelectionFieldSets()),
                            tokenDataKey: paginationKeyBuilder({
                                listViewId: listInfo.eTag,
                                sortBy: defaultedConfig.sortBy === undefined
                                    ? null
                                    : defaultedConfig.sortBy,
                            }),
                        }),
                        {
                            kind: 'Scalar',
                            name: 'fields',
                            plural: true,
                        },
                        {
                            kind: 'Scalar',
                            name: 'listInfoETag',
                        },
                        {
                            kind: 'Link',
                            name: 'listReference',
                            fragment: LIST_REFERENCE_SELECTIONS$1,
                        },
                        {
                            kind: 'Scalar',
                            name: 'optionalFields',
                            plural: true,
                        },
                        staticValuePathSelection({
                            name: 'pageSize',
                            value: defaultedConfig.pageSize === undefined
                                ? DEFAULT_PAGE_SIZE$2
                                : defaultedConfig.pageSize,
                        }),
                        {
                            kind: 'Scalar',
                            name: 'sortBy',
                            plural: true,
                        },
                    ],
                },
            },
        ],
    };
}
function buildInMemorySnapshot$3(lds, config, listInfo, fields) {
    const listUiKey = keyBuilder$5({
        ...listInfo.listReference,
        sortBy: getSortBy(config),
    });
    const listFields_ = fields || listFields(lds, config, listInfo);
    const selector = {
        recordId: listUiKey,
        node: buildListUiFragment$1(config, listInfo, listFields_),
        variables: {},
    };
    return lds.storeLookup(selector, buildSnapshotRefresh$2(lds, config));
}
function buildSnapshotRefresh$2(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot_getListUi(lds, config),
    };
}
function prepareRequest_getListUi(config) {
    const { fields, optionalFields, pageSize, pageToken, sortBy } = config;
    const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy,
    };
    let request;
    if (isGetListUiByApiNameConfig(config)) {
        request = createResourceRequest$2({
            urlParams: {
                listViewApiName: config.listViewApiName,
                objectApiName: config.objectApiName,
            },
            queryParams,
        });
    }
    else if (isGetListUiByListViewIdConfig(config)) {
        request = createResourceRequest$3({
            urlParams: { listViewId: config.listViewId },
            queryParams,
        });
    }
    else {
        throw new Error('unrecognized config');
    }
    return request;
}
function onResourceSuccess_getListUi(lds, config, request, response) {
    const { body } = response, listInfo = body.info, { listReference } = listInfo;
    // response might have records.sortBy in csv format
    const sortBy = body.records.sortBy;
    if (sortBy && typeof sortBy === 'string') {
        body.records.sortBy = sortBy.split(',');
    }
    const listUiKey = keyBuilder$5({
        ...listReference,
        sortBy: body.records.sortBy,
    });
    // grab relevant bits before ingest destroys the structure
    const fields = listFields(lds, config, listInfo);
    fields.processRecords(body.records.records);
    // remember the id/name of this list
    addListReference(listReference);
    // remember any default values that the server filled in
    addServerDefaults(config, body);
    // build the selector while the list info is still easily accessible
    const fragment = buildListUiFragment$1(config, listInfo, fields);
    lds.storeIngest(listUiKey, request, body);
    lds.storeBroadcast();
    return lds.storeLookup({
        recordId: listUiKey,
        node: fragment,
        variables: {},
    }, buildSnapshotRefresh$2(lds, config));
}
function onResourceError_getListUi(lds, config, err) {
    return lds.errorSnapshot(err, buildSnapshotRefresh$2(lds, config));
}
function resolveUnfulfilledSnapshot_getListUi(lds, config, snapshot) {
    const request = prepareRequest_getListUi(config);
    return lds.resolveUnfulfilledSnapshot(request, snapshot).then(response => {
        return onResourceSuccess_getListUi(lds, config, request, response);
    }, (err) => {
        return onResourceError_getListUi(lds, config, err);
    });
}
/**
 * Builds, sends, and processes the result of a list-ui request, ignoring any cached
 * data for the list view.
 *
 * @param lds LDS engine
 * @param config wire config
 */
function buildNetworkSnapshot_getListUi(lds, config) {
    const request = prepareRequest_getListUi(config);
    return lds.dispatchResourceRequest(request).then(response => {
        return onResourceSuccess_getListUi(lds, config, request, response);
    }, (err) => {
        return onResourceError_getListUi(lds, config, err);
    });
}
function prepareRequest_getListRecords(lds, config, listInfo, snapshot) {
    const { fields, optionalFields, pageSize, pageToken, sortBy } = config;
    const queryParams = {
        fields,
        optionalFields,
        pageSize,
        pageToken,
        sortBy,
    };
    let request;
    if (isGetListUiByApiNameConfig(config)) {
        request = createResourceRequest$5({
            urlParams: {
                listViewApiName: config.listViewApiName,
                objectApiName: config.objectApiName,
            },
            queryParams,
        });
    }
    else if (isGetListUiByListViewIdConfig(config)) {
        request = createResourceRequest$4({
            urlParams: { listViewId: config.listViewId },
            queryParams,
        });
    }
    else {
        throw new Error('how did MRU config get here?');
    }
    if (snapshot) {
        // compute the minimum number of records we need to request
        const { pageSize, pageToken } = minimizeRequest({
            data: snapshot.data ? snapshot.data.records : null,
            name: 'records',
            pageSize: config.pageSize || DEFAULT_PAGE_SIZE$2,
            pageToken: config.pageToken,
            pagination: lds.pagination(paginationKeyBuilder({
                listViewId: listInfo.eTag,
                sortBy: getSortBy(config),
            })),
        });
        // update request, but don't harden default values unless they were already present
        if (pageSize !== DEFAULT_PAGE_SIZE$2 || request.queryParams.pageSize !== undefined) {
            request.queryParams.pageSize = pageSize;
        }
        if (pageToken || request.queryParams.pageToken !== undefined) {
            request.queryParams.pageToken = pageToken;
        }
    }
    return request;
}
function onResourceSuccess_getListRecords(lds, config, request, listInfo, response) {
    const { body } = response;
    const { listInfoETag } = body;
    // fall back to list-ui if list view has changed
    if (listInfoETag !== listInfo.eTag) {
        return buildNetworkSnapshot_getListUi(lds, config);
    }
    // response might have records.sortBy in csv format
    const { sortBy } = body;
    if (sortBy && typeof sortBy === 'string') {
        body.sortBy = sortBy.split(',');
    }
    const fields = listFields(lds, config, listInfo).processRecords(body.records);
    lds.storeIngest(keyBuilder$4({
        listViewId: listInfoETag,
        sortBy: body.sortBy,
    }), request, body);
    lds.storeBroadcast();
    return buildInMemorySnapshot$3(lds, config, listInfo, fields);
}
function onResourceError_getListRecords(lds, config, listInfo, err) {
    lds.storeIngestFetchResponse(keyBuilder$5({
        ...listInfo.listReference,
        sortBy: getSortBy(config),
    }), err);
    lds.storeBroadcast();
    return lds.errorSnapshot(err);
}
function resolveUnfulfilledSnapshot_getListRecords(lds, config, listInfo, snapshot) {
    const request = prepareRequest_getListRecords(lds, config, listInfo, snapshot);
    return lds
        .resolveUnfulfilledSnapshot(request, snapshot)
        .then(response => {
        return onResourceSuccess_getListRecords(lds, config, request, listInfo, response);
    }, (err) => {
        return onResourceError_getListRecords(lds, config, listInfo, err);
    });
}
function buildNetworkSnapshot_getListRecords(lds, config, listInfo, snapshot) {
    const request = prepareRequest_getListRecords(lds, config, listInfo, snapshot);
    return lds.dispatchResourceRequest(request).then(response => {
        return onResourceSuccess_getListRecords(lds, config, request, listInfo, response);
    }, (err) => {
        return onResourceError_getListRecords(lds, config, listInfo, err);
    });
}
// functions to discern config variations
function isGetListUiByApiNameConfig(config) {
    return config.listViewApiName !== undefined;
}
function looksLikeGetListUiByApiNameConfig(untrustedConfig) {
    return (untrustedIsObject(untrustedConfig) &&
        untrustedConfig.objectApiName &&
        untrustedConfig.listViewApiName);
}
function isGetListUiByListViewIdConfig(config) {
    return !!config.listViewId;
}
function looksLikeGetListUiByListViewIdConfig(untrustedConfig) {
    return (untrustedIsObject(untrustedConfig) &&
        untrustedConfig.listViewId);
}
function looksLikeGetListViewSummaryCollectionConfig(untrustedConfig) {
    return (untrustedIsObject(untrustedConfig) &&
        untrustedConfig.objectApiName &&
        !untrustedConfig.listViewId &&
        !untrustedConfig.listViewApiName);
}
function looksLikeGetMruListUiConfig(untrustedConfig) {
    // the MRU symbol is a carryover hack from 222 and doesn't show up in any
    // of the generated config types, so we cast to any in order to check for it
    return untrustedIsObject(untrustedConfig) && untrustedConfig.listViewApiName === MRU;
}
function validateGetListUiConfig(untrustedConfig) {
    return looksLikeGetListUiByApiNameConfig(untrustedConfig)
        ? validateAdapterConfig$1(untrustedConfig, getListUiByApiName_ConfigPropertyNames_augmented)
        : looksLikeGetListUiByListViewIdConfig(untrustedConfig)
            ? validateAdapterConfig$2(untrustedConfig, getListUiByListViewId_ConfigPropertyNames_augmented)
            : null;
}
// the listViewApiName value to pass to getListUi() to request the MRU list
const MRU = Symbol.for('MRU');
const factory$2 = (lds) => {
    // adapter implementation for getListUiBy*
    const listUiAdapter = (untrustedConfig) => {
        const config = validateGetListUiConfig(untrustedConfig);
        if (config === null) {
            return null;
        }
        // try to get a list reference and a list info for the list; this should come back
        // non-null if we have the list info cached
        const listRef = getListReference(config);
        const listInfo = listRef && getListInfo(listRef, lds);
        // no list info means it's not in the cache - make a full list-ui request
        if (!listInfo) {
            return buildNetworkSnapshot_getListUi(lds, config);
        }
        // with the list info we can construct the full selector and try to get the
        // list ui from the store
        const snapshot = buildInMemorySnapshot$3(lds, config, listInfo);
        // if the list ui was not found in the store then
        // make a full list-ui request
        if (!snapshot.data) {
            if (isUnfulfilledSnapshot(snapshot)) {
                return resolveUnfulfilledSnapshot_getListUi(lds, config, snapshot);
            }
            return buildNetworkSnapshot_getListUi(lds, config);
        }
        if (lds.snapshotDataAvailable(snapshot)) {
            // cache hit :partyparrot:
            return snapshot;
        }
        // we *should* only be missing records and/or tokens at this point; send a list-records
        // request to fill them in
        if (isUnfulfilledSnapshot(snapshot)) {
            return resolveUnfulfilledSnapshot_getListRecords(lds, config, listInfo, snapshot);
        }
        return buildNetworkSnapshot_getListRecords(lds, config, listInfo, snapshot);
    };
    let listViewSummaryCollectionAdapter = null;
    let mruAdapter = null;
    // delegate to various other adapter based on what config looks like; note that the adapters
    // we delegate to are responsible for returning refreshable results
    return function (untrustedConfig) {
        // if the MRU symbol is there then just return the getMruListUi adapter
        if (looksLikeGetMruListUiConfig(untrustedConfig)) {
            if (mruAdapter === null) {
                mruAdapter = factory$1(lds);
            }
            // the symbol in the listViewApiName is just a hack so we can recognize the request as MRU
            const mruConfig = { ...untrustedConfig };
            delete mruConfig.listViewApiName;
            return mruAdapter(mruConfig);
        }
        // if config has objectApiName but no listViewId or listViewApiName then hand off
        // to listViewSummaryCollectionAdapter
        if (looksLikeGetListViewSummaryCollectionConfig(untrustedConfig)) {
            if (listViewSummaryCollectionAdapter === null) {
                listViewSummaryCollectionAdapter = factory(lds);
            }
            return listViewSummaryCollectionAdapter(untrustedConfig);
        }
        // see if config looks like a listViewId or listViewApiName request
        if (looksLikeGetListUiByApiNameConfig(untrustedConfig) ||
            looksLikeGetListUiByListViewIdConfig(untrustedConfig)) {
            return listUiAdapter(untrustedConfig);
        }
        return null;
    };
};

function validate$e(obj, path = 'ChildRelationshipRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_childObjectApiName = obj.childObjectApiName;
        const path_childObjectApiName = path + '.childObjectApiName';
        if (typeof obj_childObjectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_childObjectApiName + '" (at "' + path_childObjectApiName + '")');
        }
        const obj_fieldName = obj.fieldName;
        const path_fieldName = path + '.fieldName';
        if (typeof obj_fieldName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldName + '" (at "' + path_fieldName + '")');
        }
        const obj_junctionIdListNames = obj.junctionIdListNames;
        const path_junctionIdListNames = path + '.junctionIdListNames';
        if (!ArrayIsArray$1(obj_junctionIdListNames)) {
            return new TypeError('Expected "array" but received "' + typeof obj_junctionIdListNames + '" (at "' + path_junctionIdListNames + '")');
        }
        for (let i = 0; i < obj_junctionIdListNames.length; i++) {
            const obj_junctionIdListNames_item = obj_junctionIdListNames[i];
            const path_junctionIdListNames_item = path_junctionIdListNames + '[' + i + ']';
            if (typeof obj_junctionIdListNames_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_junctionIdListNames_item + '" (at "' + path_junctionIdListNames_item + '")');
            }
        }
        const obj_junctionReferenceTo = obj.junctionReferenceTo;
        const path_junctionReferenceTo = path + '.junctionReferenceTo';
        if (!ArrayIsArray$1(obj_junctionReferenceTo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_junctionReferenceTo + '" (at "' + path_junctionReferenceTo + '")');
        }
        for (let i = 0; i < obj_junctionReferenceTo.length; i++) {
            const obj_junctionReferenceTo_item = obj_junctionReferenceTo[i];
            const path_junctionReferenceTo_item = path_junctionReferenceTo + '[' + i + ']';
            if (typeof obj_junctionReferenceTo_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_junctionReferenceTo_item + '" (at "' + path_junctionReferenceTo_item + '")');
            }
        }
        const obj_relationshipName = obj.relationshipName;
        const path_relationshipName = path + '.relationshipName';
        if (typeof obj_relationshipName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$5(input) {
    const input_junctionIdListNames = input.junctionIdListNames;
    ObjectFreeze$1(input_junctionIdListNames);
    const input_junctionReferenceTo = input.junctionReferenceTo;
    ObjectFreeze$1(input_junctionReferenceTo);
    ObjectFreeze$1(input);
}

function validate$f(obj, path = 'FilteredLookupInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_controllingFields = obj.controllingFields;
        const path_controllingFields = path + '.controllingFields';
        if (!ArrayIsArray$1(obj_controllingFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_controllingFields + '" (at "' + path_controllingFields + '")');
        }
        for (let i = 0; i < obj_controllingFields.length; i++) {
            const obj_controllingFields_item = obj_controllingFields[i];
            const path_controllingFields_item = path_controllingFields + '[' + i + ']';
            if (typeof obj_controllingFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_controllingFields_item + '" (at "' + path_controllingFields_item + '")');
            }
        }
        const obj_dependent = obj.dependent;
        const path_dependent = path + '.dependent';
        if (typeof obj_dependent !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_dependent + '" (at "' + path_dependent + '")');
        }
        const obj_optionalFilter = obj.optionalFilter;
        const path_optionalFilter = path + '.optionalFilter';
        if (typeof obj_optionalFilter !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_optionalFilter + '" (at "' + path_optionalFilter + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$6(input) {
    const input_controllingFields = input.controllingFields;
    ObjectFreeze$1(input_controllingFields);
    ObjectFreeze$1(input);
}

function validate$g(obj, path = 'ReferenceToInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_nameFields = obj.nameFields;
        const path_nameFields = path + '.nameFields';
        if (!ArrayIsArray$1(obj_nameFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_nameFields + '" (at "' + path_nameFields + '")');
        }
        for (let i = 0; i < obj_nameFields.length; i++) {
            const obj_nameFields_item = obj_nameFields[i];
            const path_nameFields_item = path_nameFields + '[' + i + ']';
            if (typeof obj_nameFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nameFields_item + '" (at "' + path_nameFields_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$7(input) {
    const input_nameFields = input.nameFields;
    ObjectFreeze$1(input_nameFields);
    ObjectFreeze$1(input);
}

function validate$h(obj, path = 'FieldRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_calculated = obj.calculated;
        const path_calculated = path + '.calculated';
        if (typeof obj_calculated !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_calculated + '" (at "' + path_calculated + '")');
        }
        const obj_compound = obj.compound;
        const path_compound = path + '.compound';
        if (typeof obj_compound !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_compound + '" (at "' + path_compound + '")');
        }
        const obj_compoundComponentName = obj.compoundComponentName;
        const path_compoundComponentName = path + '.compoundComponentName';
        let obj_compoundComponentName_union0 = null;
        const obj_compoundComponentName_union0_error = (() => {
            if (typeof obj_compoundComponentName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_compoundComponentName + '" (at "' + path_compoundComponentName + '")');
            }
        })();
        if (obj_compoundComponentName_union0_error != null) {
            obj_compoundComponentName_union0 = obj_compoundComponentName_union0_error.message;
        }
        let obj_compoundComponentName_union1 = null;
        const obj_compoundComponentName_union1_error = (() => {
            if (obj_compoundComponentName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_compoundComponentName + '" (at "' + path_compoundComponentName + '")');
            }
        })();
        if (obj_compoundComponentName_union1_error != null) {
            obj_compoundComponentName_union1 = obj_compoundComponentName_union1_error.message;
        }
        if (obj_compoundComponentName_union0 && obj_compoundComponentName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_compoundComponentName + '")';
            message += '\n' + obj_compoundComponentName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_compoundComponentName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_compoundFieldName = obj.compoundFieldName;
        const path_compoundFieldName = path + '.compoundFieldName';
        let obj_compoundFieldName_union0 = null;
        const obj_compoundFieldName_union0_error = (() => {
            if (typeof obj_compoundFieldName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_compoundFieldName + '" (at "' + path_compoundFieldName + '")');
            }
        })();
        if (obj_compoundFieldName_union0_error != null) {
            obj_compoundFieldName_union0 = obj_compoundFieldName_union0_error.message;
        }
        let obj_compoundFieldName_union1 = null;
        const obj_compoundFieldName_union1_error = (() => {
            if (obj_compoundFieldName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_compoundFieldName + '" (at "' + path_compoundFieldName + '")');
            }
        })();
        if (obj_compoundFieldName_union1_error != null) {
            obj_compoundFieldName_union1 = obj_compoundFieldName_union1_error.message;
        }
        if (obj_compoundFieldName_union0 && obj_compoundFieldName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_compoundFieldName + '")';
            message += '\n' + obj_compoundFieldName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_compoundFieldName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_controllerName = obj.controllerName;
        const path_controllerName = path + '.controllerName';
        let obj_controllerName_union0 = null;
        const obj_controllerName_union0_error = (() => {
            if (typeof obj_controllerName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_controllerName + '" (at "' + path_controllerName + '")');
            }
        })();
        if (obj_controllerName_union0_error != null) {
            obj_controllerName_union0 = obj_controllerName_union0_error.message;
        }
        let obj_controllerName_union1 = null;
        const obj_controllerName_union1_error = (() => {
            if (obj_controllerName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_controllerName + '" (at "' + path_controllerName + '")');
            }
        })();
        if (obj_controllerName_union1_error != null) {
            obj_controllerName_union1 = obj_controllerName_union1_error.message;
        }
        if (obj_controllerName_union0 && obj_controllerName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_controllerName + '")';
            message += '\n' + obj_controllerName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_controllerName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_controllingFields = obj.controllingFields;
        const path_controllingFields = path + '.controllingFields';
        if (!ArrayIsArray$1(obj_controllingFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_controllingFields + '" (at "' + path_controllingFields + '")');
        }
        for (let i = 0; i < obj_controllingFields.length; i++) {
            const obj_controllingFields_item = obj_controllingFields[i];
            const path_controllingFields_item = path_controllingFields + '[' + i + ']';
            if (typeof obj_controllingFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_controllingFields_item + '" (at "' + path_controllingFields_item + '")');
            }
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_dataType = obj.dataType;
        const path_dataType = path + '.dataType';
        if (typeof obj_dataType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_dataType + '" (at "' + path_dataType + '")');
        }
        const obj_extraTypeInfo = obj.extraTypeInfo;
        const path_extraTypeInfo = path + '.extraTypeInfo';
        let obj_extraTypeInfo_union0 = null;
        const obj_extraTypeInfo_union0_error = (() => {
            if (typeof obj_extraTypeInfo !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_extraTypeInfo + '" (at "' + path_extraTypeInfo + '")');
            }
        })();
        if (obj_extraTypeInfo_union0_error != null) {
            obj_extraTypeInfo_union0 = obj_extraTypeInfo_union0_error.message;
        }
        let obj_extraTypeInfo_union1 = null;
        const obj_extraTypeInfo_union1_error = (() => {
            if (obj_extraTypeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_extraTypeInfo + '" (at "' + path_extraTypeInfo + '")');
            }
        })();
        if (obj_extraTypeInfo_union1_error != null) {
            obj_extraTypeInfo_union1 = obj_extraTypeInfo_union1_error.message;
        }
        if (obj_extraTypeInfo_union0 && obj_extraTypeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_extraTypeInfo + '")';
            message += '\n' + obj_extraTypeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_extraTypeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_filterable = obj.filterable;
        const path_filterable = path + '.filterable';
        if (typeof obj_filterable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_filterable + '" (at "' + path_filterable + '")');
        }
        const obj_filteredLookupInfo = obj.filteredLookupInfo;
        const path_filteredLookupInfo = path + '.filteredLookupInfo';
        let obj_filteredLookupInfo_union0 = null;
        const obj_filteredLookupInfo_union0_error = (() => {
            const referenceFilteredLookupInfoRepresentationValidationError = validate$f(obj_filteredLookupInfo, path_filteredLookupInfo);
            if (referenceFilteredLookupInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match FilteredLookupInfoRepresentation (at "' + path_filteredLookupInfo + '")\n';
                message += referenceFilteredLookupInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_filteredLookupInfo_union0_error != null) {
            obj_filteredLookupInfo_union0 = obj_filteredLookupInfo_union0_error.message;
        }
        let obj_filteredLookupInfo_union1 = null;
        const obj_filteredLookupInfo_union1_error = (() => {
            if (obj_filteredLookupInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_filteredLookupInfo + '" (at "' + path_filteredLookupInfo + '")');
            }
        })();
        if (obj_filteredLookupInfo_union1_error != null) {
            obj_filteredLookupInfo_union1 = obj_filteredLookupInfo_union1_error.message;
        }
        if (obj_filteredLookupInfo_union0 && obj_filteredLookupInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_filteredLookupInfo + '")';
            message += '\n' + obj_filteredLookupInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_filteredLookupInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_highScaleNumber = obj.highScaleNumber;
        const path_highScaleNumber = path + '.highScaleNumber';
        if (typeof obj_highScaleNumber !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_highScaleNumber + '" (at "' + path_highScaleNumber + '")');
        }
        const obj_htmlFormatted = obj.htmlFormatted;
        const path_htmlFormatted = path + '.htmlFormatted';
        if (typeof obj_htmlFormatted !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_htmlFormatted + '" (at "' + path_htmlFormatted + '")');
        }
        const obj_inlineHelpText = obj.inlineHelpText;
        const path_inlineHelpText = path + '.inlineHelpText';
        let obj_inlineHelpText_union0 = null;
        const obj_inlineHelpText_union0_error = (() => {
            if (typeof obj_inlineHelpText !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_inlineHelpText + '" (at "' + path_inlineHelpText + '")');
            }
        })();
        if (obj_inlineHelpText_union0_error != null) {
            obj_inlineHelpText_union0 = obj_inlineHelpText_union0_error.message;
        }
        let obj_inlineHelpText_union1 = null;
        const obj_inlineHelpText_union1_error = (() => {
            if (obj_inlineHelpText !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_inlineHelpText + '" (at "' + path_inlineHelpText + '")');
            }
        })();
        if (obj_inlineHelpText_union1_error != null) {
            obj_inlineHelpText_union1 = obj_inlineHelpText_union1_error.message;
        }
        if (obj_inlineHelpText_union0 && obj_inlineHelpText_union1) {
            let message = 'Object doesn\'t match union (at "' + path_inlineHelpText + '")';
            message += '\n' + obj_inlineHelpText_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_inlineHelpText_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_length = obj.length;
        const path_length = path + '.length';
        if (typeof obj_length !== 'number' || (typeof obj_length === 'number' && Math.floor(obj_length) !== obj_length)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_length + '" (at "' + path_length + '")');
        }
        const obj_nameField = obj.nameField;
        const path_nameField = path + '.nameField';
        if (typeof obj_nameField !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_nameField + '" (at "' + path_nameField + '")');
        }
        const obj_polymorphicForeignKey = obj.polymorphicForeignKey;
        const path_polymorphicForeignKey = path + '.polymorphicForeignKey';
        if (typeof obj_polymorphicForeignKey !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_polymorphicForeignKey + '" (at "' + path_polymorphicForeignKey + '")');
        }
        const obj_precision = obj.precision;
        const path_precision = path + '.precision';
        if (typeof obj_precision !== 'number' || (typeof obj_precision === 'number' && Math.floor(obj_precision) !== obj_precision)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_precision + '" (at "' + path_precision + '")');
        }
        const obj_reference = obj.reference;
        const path_reference = path + '.reference';
        if (typeof obj_reference !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_reference + '" (at "' + path_reference + '")');
        }
        const obj_referenceTargetField = obj.referenceTargetField;
        const path_referenceTargetField = path + '.referenceTargetField';
        let obj_referenceTargetField_union0 = null;
        const obj_referenceTargetField_union0_error = (() => {
            if (typeof obj_referenceTargetField !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_referenceTargetField + '" (at "' + path_referenceTargetField + '")');
            }
        })();
        if (obj_referenceTargetField_union0_error != null) {
            obj_referenceTargetField_union0 = obj_referenceTargetField_union0_error.message;
        }
        let obj_referenceTargetField_union1 = null;
        const obj_referenceTargetField_union1_error = (() => {
            if (obj_referenceTargetField !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_referenceTargetField + '" (at "' + path_referenceTargetField + '")');
            }
        })();
        if (obj_referenceTargetField_union1_error != null) {
            obj_referenceTargetField_union1 = obj_referenceTargetField_union1_error.message;
        }
        if (obj_referenceTargetField_union0 && obj_referenceTargetField_union1) {
            let message = 'Object doesn\'t match union (at "' + path_referenceTargetField + '")';
            message += '\n' + obj_referenceTargetField_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_referenceTargetField_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_referenceToInfos = obj.referenceToInfos;
        const path_referenceToInfos = path + '.referenceToInfos';
        if (!ArrayIsArray$1(obj_referenceToInfos)) {
            return new TypeError('Expected "array" but received "' + typeof obj_referenceToInfos + '" (at "' + path_referenceToInfos + '")');
        }
        for (let i = 0; i < obj_referenceToInfos.length; i++) {
            const obj_referenceToInfos_item = obj_referenceToInfos[i];
            const path_referenceToInfos_item = path_referenceToInfos + '[' + i + ']';
            const referenceReferenceToInfoRepresentationValidationError = validate$g(obj_referenceToInfos_item, path_referenceToInfos_item);
            if (referenceReferenceToInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ReferenceToInfoRepresentation (at "' + path_referenceToInfos_item + '")\n';
                message += referenceReferenceToInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_relationshipName = obj.relationshipName;
        const path_relationshipName = path + '.relationshipName';
        let obj_relationshipName_union0 = null;
        const obj_relationshipName_union0_error = (() => {
            if (typeof obj_relationshipName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
            }
        })();
        if (obj_relationshipName_union0_error != null) {
            obj_relationshipName_union0 = obj_relationshipName_union0_error.message;
        }
        let obj_relationshipName_union1 = null;
        const obj_relationshipName_union1_error = (() => {
            if (obj_relationshipName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relationshipName + '" (at "' + path_relationshipName + '")');
            }
        })();
        if (obj_relationshipName_union1_error != null) {
            obj_relationshipName_union1 = obj_relationshipName_union1_error.message;
        }
        if (obj_relationshipName_union0 && obj_relationshipName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relationshipName + '")';
            message += '\n' + obj_relationshipName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relationshipName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_required = obj.required;
        const path_required = path + '.required';
        if (typeof obj_required !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_required + '" (at "' + path_required + '")');
        }
        const obj_scale = obj.scale;
        const path_scale = path + '.scale';
        if (typeof obj_scale !== 'number' || (typeof obj_scale === 'number' && Math.floor(obj_scale) !== obj_scale)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_scale + '" (at "' + path_scale + '")');
        }
        const obj_searchPrefilterable = obj.searchPrefilterable;
        const path_searchPrefilterable = path + '.searchPrefilterable';
        if (typeof obj_searchPrefilterable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_searchPrefilterable + '" (at "' + path_searchPrefilterable + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
        const obj_unique = obj.unique;
        const path_unique = path + '.unique';
        if (typeof obj_unique !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_unique + '" (at "' + path_unique + '")');
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$8(input) {
    const input_controllingFields = input.controllingFields;
    ObjectFreeze$1(input_controllingFields);
    const input_filteredLookupInfo = input.filteredLookupInfo;
    if (input_filteredLookupInfo !== null && typeof input_filteredLookupInfo === 'object') {
        deepFreeze$6(input_filteredLookupInfo);
    }
    const input_referenceToInfos = input.referenceToInfos;
    for (let i = 0; i < input_referenceToInfos.length; i++) {
        const input_referenceToInfos_item = input_referenceToInfos[i];
        deepFreeze$7(input_referenceToInfos_item);
    }
    ObjectFreeze$1(input_referenceToInfos);
    ObjectFreeze$1(input);
}

function validate$i(obj, path = 'ThemeInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_color = obj.color;
        const path_color = path + '.color';
        if (typeof obj_color !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_color + '" (at "' + path_color + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
            if (typeof obj_iconUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union0_error != null) {
            obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
            if (obj_iconUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union1_error != null) {
            obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
            message += '\n' + obj_iconUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_iconUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$9(input) {
    ObjectFreeze$1(input);
}

const TTL$1 = 900000;
function validate$j(obj, path = 'ObjectInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_associateEntityType = obj.associateEntityType;
        const path_associateEntityType = path + '.associateEntityType';
        let obj_associateEntityType_union0 = null;
        const obj_associateEntityType_union0_error = (() => {
            if (typeof obj_associateEntityType !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_associateEntityType + '" (at "' + path_associateEntityType + '")');
            }
        })();
        if (obj_associateEntityType_union0_error != null) {
            obj_associateEntityType_union0 = obj_associateEntityType_union0_error.message;
        }
        let obj_associateEntityType_union1 = null;
        const obj_associateEntityType_union1_error = (() => {
            if (obj_associateEntityType !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_associateEntityType + '" (at "' + path_associateEntityType + '")');
            }
        })();
        if (obj_associateEntityType_union1_error != null) {
            obj_associateEntityType_union1 = obj_associateEntityType_union1_error.message;
        }
        if (obj_associateEntityType_union0 && obj_associateEntityType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_associateEntityType + '")';
            message += '\n' + obj_associateEntityType_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_associateEntityType_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_associateParentEntity = obj.associateParentEntity;
        const path_associateParentEntity = path + '.associateParentEntity';
        let obj_associateParentEntity_union0 = null;
        const obj_associateParentEntity_union0_error = (() => {
            if (typeof obj_associateParentEntity !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_associateParentEntity + '" (at "' + path_associateParentEntity + '")');
            }
        })();
        if (obj_associateParentEntity_union0_error != null) {
            obj_associateParentEntity_union0 = obj_associateParentEntity_union0_error.message;
        }
        let obj_associateParentEntity_union1 = null;
        const obj_associateParentEntity_union1_error = (() => {
            if (obj_associateParentEntity !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_associateParentEntity + '" (at "' + path_associateParentEntity + '")');
            }
        })();
        if (obj_associateParentEntity_union1_error != null) {
            obj_associateParentEntity_union1 = obj_associateParentEntity_union1_error.message;
        }
        if (obj_associateParentEntity_union0 && obj_associateParentEntity_union1) {
            let message = 'Object doesn\'t match union (at "' + path_associateParentEntity + '")';
            message += '\n' + obj_associateParentEntity_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_associateParentEntity_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (!ArrayIsArray$1(obj_childRelationships)) {
            return new TypeError('Expected "array" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        for (let i = 0; i < obj_childRelationships.length; i++) {
            const obj_childRelationships_item = obj_childRelationships[i];
            const path_childRelationships_item = path_childRelationships + '[' + i + ']';
            const referenceChildRelationshipRepresentationValidationError = validate$e(obj_childRelationships_item, path_childRelationships_item);
            if (referenceChildRelationshipRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ChildRelationshipRepresentation (at "' + path_childRelationships_item + '")\n';
                message += referenceChildRelationshipRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_defaultRecordTypeId = obj.defaultRecordTypeId;
        const path_defaultRecordTypeId = path + '.defaultRecordTypeId';
        let obj_defaultRecordTypeId_union0 = null;
        const obj_defaultRecordTypeId_union0_error = (() => {
            if (typeof obj_defaultRecordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_defaultRecordTypeId + '" (at "' + path_defaultRecordTypeId + '")');
            }
        })();
        if (obj_defaultRecordTypeId_union0_error != null) {
            obj_defaultRecordTypeId_union0 = obj_defaultRecordTypeId_union0_error.message;
        }
        let obj_defaultRecordTypeId_union1 = null;
        const obj_defaultRecordTypeId_union1_error = (() => {
            if (obj_defaultRecordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_defaultRecordTypeId + '" (at "' + path_defaultRecordTypeId + '")');
            }
        })();
        if (obj_defaultRecordTypeId_union1_error != null) {
            obj_defaultRecordTypeId_union1 = obj_defaultRecordTypeId_union1_error.message;
        }
        if (obj_defaultRecordTypeId_union0 && obj_defaultRecordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_defaultRecordTypeId + '")';
            message += '\n' + obj_defaultRecordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_defaultRecordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_dependentFields = obj.dependentFields;
        const path_dependentFields = path + '.dependentFields';
        if (typeof obj_dependentFields !== 'object' || ArrayIsArray$1(obj_dependentFields) || obj_dependentFields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_dependentFields + '" (at "' + path_dependentFields + '")');
        }
        const obj_dependentFields_keys = ObjectKeys$1(obj_dependentFields);
        for (let i = 0; i < obj_dependentFields_keys.length; i++) {
            const key = obj_dependentFields_keys[i];
            const obj_dependentFields_prop = obj_dependentFields[key];
            const path_dependentFields_prop = path_dependentFields + '["' + key + '"]';
            if (typeof obj_dependentFields_prop !== 'object' || ArrayIsArray$1(obj_dependentFields_prop) || obj_dependentFields_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_dependentFields_prop + '" (at "' + path_dependentFields_prop + '")');
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_feedEnabled = obj.feedEnabled;
        const path_feedEnabled = path + '.feedEnabled';
        if (typeof obj_feedEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_feedEnabled + '" (at "' + path_feedEnabled + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            const referenceFieldRepresentationValidationError = validate$h(obj_fields_prop, path_fields_prop);
            if (referenceFieldRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match FieldRepresentation (at "' + path_fields_prop + '")\n';
                message += referenceFieldRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_keyPrefix = obj.keyPrefix;
        const path_keyPrefix = path + '.keyPrefix';
        let obj_keyPrefix_union0 = null;
        const obj_keyPrefix_union0_error = (() => {
            if (typeof obj_keyPrefix !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union0_error != null) {
            obj_keyPrefix_union0 = obj_keyPrefix_union0_error.message;
        }
        let obj_keyPrefix_union1 = null;
        const obj_keyPrefix_union1_error = (() => {
            if (obj_keyPrefix !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union1_error != null) {
            obj_keyPrefix_union1 = obj_keyPrefix_union1_error.message;
        }
        if (obj_keyPrefix_union0 && obj_keyPrefix_union1) {
            let message = 'Object doesn\'t match union (at "' + path_keyPrefix + '")';
            message += '\n' + obj_keyPrefix_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_keyPrefix_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_labelPlural = obj.labelPlural;
        const path_labelPlural = path + '.labelPlural';
        if (typeof obj_labelPlural !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_labelPlural + '" (at "' + path_labelPlural + '")');
        }
        const obj_layoutable = obj.layoutable;
        const path_layoutable = path + '.layoutable';
        if (typeof obj_layoutable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_layoutable + '" (at "' + path_layoutable + '")');
        }
        const obj_mruEnabled = obj.mruEnabled;
        const path_mruEnabled = path + '.mruEnabled';
        if (typeof obj_mruEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_mruEnabled + '" (at "' + path_mruEnabled + '")');
        }
        const obj_nameFields = obj.nameFields;
        const path_nameFields = path + '.nameFields';
        if (!ArrayIsArray$1(obj_nameFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_nameFields + '" (at "' + path_nameFields + '")');
        }
        for (let i = 0; i < obj_nameFields.length; i++) {
            const obj_nameFields_item = obj_nameFields[i];
            const path_nameFields_item = path_nameFields + '[' + i + ']';
            if (typeof obj_nameFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nameFields_item + '" (at "' + path_nameFields_item + '")');
            }
        }
        const obj_queryable = obj.queryable;
        const path_queryable = path + '.queryable';
        if (typeof obj_queryable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_queryable + '" (at "' + path_queryable + '")');
        }
        const obj_recordTypeInfos = obj.recordTypeInfos;
        const path_recordTypeInfos = path + '.recordTypeInfos';
        if (typeof obj_recordTypeInfos !== 'object' || ArrayIsArray$1(obj_recordTypeInfos) || obj_recordTypeInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_recordTypeInfos + '" (at "' + path_recordTypeInfos + '")');
        }
        const obj_recordTypeInfos_keys = ObjectKeys$1(obj_recordTypeInfos);
        for (let i = 0; i < obj_recordTypeInfos_keys.length; i++) {
            const key = obj_recordTypeInfos_keys[i];
            const obj_recordTypeInfos_prop = obj_recordTypeInfos[key];
            const path_recordTypeInfos_prop = path_recordTypeInfos + '["' + key + '"]';
            const referenceRecordTypeInfoRepresentationValidationError = validate$6(obj_recordTypeInfos_prop, path_recordTypeInfos_prop);
            if (referenceRecordTypeInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfos_prop + '")\n';
                message += referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_searchable = obj.searchable;
        const path_searchable = path + '.searchable';
        if (typeof obj_searchable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_searchable + '" (at "' + path_searchable + '")');
        }
        const obj_themeInfo = obj.themeInfo;
        const path_themeInfo = path + '.themeInfo';
        let obj_themeInfo_union0 = null;
        const obj_themeInfo_union0_error = (() => {
            const referenceThemeInfoRepresentationValidationError = validate$i(obj_themeInfo, path_themeInfo);
            if (referenceThemeInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ThemeInfoRepresentation (at "' + path_themeInfo + '")\n';
                message += referenceThemeInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_themeInfo_union0_error != null) {
            obj_themeInfo_union0 = obj_themeInfo_union0_error.message;
        }
        let obj_themeInfo_union1 = null;
        const obj_themeInfo_union1_error = (() => {
            if (obj_themeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_themeInfo + '" (at "' + path_themeInfo + '")');
            }
        })();
        if (obj_themeInfo_union1_error != null) {
            obj_themeInfo_union1 = obj_themeInfo_union1_error.message;
        }
        if (obj_themeInfo_union0 && obj_themeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_themeInfo + '")';
            message += '\n' + obj_themeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_themeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$9(config) {
    return keyPrefix + 'ObjectInfoRepresentation:' + config.apiName;
}
function keyBuilderFromType$7(object) {
    const keyParams = {
        apiName: object.apiName
    };
    return keyBuilder$9(keyParams);
}
function normalize$8(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$7 = function ObjectInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar'
            },
            {
                name: 'associateEntityType',
                kind: 'Scalar'
            },
            {
                name: 'associateParentEntity',
                kind: 'Scalar'
            },
            {
                name: 'childRelationships',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'createable',
                kind: 'Scalar'
            },
            {
                name: 'custom',
                kind: 'Scalar'
            },
            {
                name: 'defaultRecordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'deletable',
                kind: 'Scalar'
            },
            {
                name: 'dependentFields',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'feedEnabled',
                kind: 'Scalar'
            },
            {
                name: 'fields',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'keyPrefix',
                kind: 'Scalar'
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'labelPlural',
                kind: 'Scalar'
            },
            {
                name: 'layoutable',
                kind: 'Scalar'
            },
            {
                name: 'mruEnabled',
                kind: 'Scalar'
            },
            {
                name: 'nameFields',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'queryable',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeInfos',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'searchable',
                kind: 'Scalar'
            },
            {
                name: 'themeInfo',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'updateable',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$a(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
function deepFreeze$a(input) {
    const input_childRelationships = input.childRelationships;
    for (let i = 0; i < input_childRelationships.length; i++) {
        const input_childRelationships_item = input_childRelationships[i];
        deepFreeze$5(input_childRelationships_item);
    }
    ObjectFreeze$1(input_childRelationships);
    const input_dependentFields = input.dependentFields;
    const input_dependentFields_keys = Object.keys(input_dependentFields);
    const input_dependentFields_length = input_dependentFields_keys.length;
    for (let i = 0; i < input_dependentFields_length; i++) {
        const key = input_dependentFields_keys[i];
        const input_dependentFields_prop = input_dependentFields[key];
        ObjectFreeze$1(input_dependentFields_prop);
    }
    ObjectFreeze$1(input_dependentFields);
    const input_fields = input.fields;
    const input_fields_keys = Object.keys(input_fields);
    const input_fields_length = input_fields_keys.length;
    for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        deepFreeze$8(input_fields_prop);
    }
    ObjectFreeze$1(input_fields);
    const input_nameFields = input.nameFields;
    ObjectFreeze$1(input_nameFields);
    const input_recordTypeInfos = input.recordTypeInfos;
    const input_recordTypeInfos_keys = Object.keys(input_recordTypeInfos);
    const input_recordTypeInfos_length = input_recordTypeInfos_keys.length;
    for (let i = 0; i < input_recordTypeInfos_length; i++) {
        const key = input_recordTypeInfos_keys[i];
        const input_recordTypeInfos_prop = input_recordTypeInfos[key];
        deepFreeze$4(input_recordTypeInfos_prop);
    }
    ObjectFreeze$1(input_recordTypeInfos);
    const input_themeInfo = input.themeInfo;
    if (input_themeInfo !== null && typeof input_themeInfo === 'object') {
        deepFreeze$9(input_themeInfo);
    }
    ObjectFreeze$1(input);
}
const ingest$8 = function ObjectInfoRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$j(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$7(input);
    let incomingRecord = normalize$8(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    deepFreeze$a(input);
    if (existingRecord === undefined || equals$a(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function select$8(lds, params) {
    return select$7();
}
function keyBuilder$a(params) {
    return keyBuilder$9({
        apiName: params.urlParams.objectApiName
    });
}
function ingestSuccess(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$a(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$8(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$a(params);
    lds.storeIngestFetchResponse(key, error, TTL$1);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$9(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: ingest$8,
        headers,
    };
}

const adapterName = 'getObjectInfo';
const getObjectInfo_ConfigPropertyNames = {
    displayName: 'getObjectInfo',
    parameters: {
        required: ['objectApiName'],
        optional: []
    }
};
function createResourceParams$3(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        }
    };
}
function coerceConfig$5(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    return coercedConfig;
}
function typeCheckConfig$5(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    return config;
}
function validateAdapterConfig$5(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$5(untrustedConfig);
    const config = typeCheckConfig$5(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$4(lds, config) {
    const resourceParams = createResourceParams$3(config);
    const selector = {
        recordId: keyBuilder$a(resourceParams),
        node: select$8(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$2(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$2(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError(lds, config, resourceParams, response) {
    const snapshot = ingestError(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$2(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$2(lds, config, override) {
    const resourceParams = createResourceParams$3(config);
    const request = createResourceRequest$9(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$2(lds, config, snapshot) {
    const resourceParams = createResourceParams$3(config);
    const request = createResourceRequest$9(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError(lds, config, resourceParams, response);
    });
}
const getObjectInfoAdapterFactory = (lds) => function getObjectInfo(untrustedConfig) {
    const config = validateAdapterConfig$5(untrustedConfig, getObjectInfo_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$4(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$2(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$2(lds, config);
};

var DiscriminatorValues;
(function (DiscriminatorValues) {
    DiscriminatorValues["EmptySpace"] = "EmptySpace";
    DiscriminatorValues["ReportChart"] = "ReportChart";
    DiscriminatorValues["VisualforcePage"] = "VisualforcePage";
    DiscriminatorValues["Canvas"] = "Canvas";
    DiscriminatorValues["Field"] = "Field";
    DiscriminatorValues["CustomLink"] = "CustomLink";
})(DiscriminatorValues || (DiscriminatorValues = {}));
function validate$k(obj, path = 'AbstractRecordLayoutComponentRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        let obj_apiName_union0 = null;
        const obj_apiName_union0_error = (() => {
            if (typeof obj_apiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
        })();
        if (obj_apiName_union0_error != null) {
            obj_apiName_union0 = obj_apiName_union0_error.message;
        }
        let obj_apiName_union1 = null;
        const obj_apiName_union1_error = (() => {
            if (obj_apiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
            }
        })();
        if (obj_apiName_union1_error != null) {
            obj_apiName_union1 = obj_apiName_union1_error.message;
        }
        if (obj_apiName_union0 && obj_apiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_apiName + '")';
            message += '\n' + obj_apiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_apiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_componentType = obj.componentType;
        const path_componentType = path + '.componentType';
        if (typeof obj_componentType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_componentType + '" (at "' + path_componentType + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$b(input) {
    ObjectFreeze$1(input);
}

function validate$l(obj, path = 'RecordLayoutItemRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_editableForNew = obj.editableForNew;
        const path_editableForNew = path + '.editableForNew';
        if (typeof obj_editableForNew !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_editableForNew + '" (at "' + path_editableForNew + '")');
        }
        const obj_editableForUpdate = obj.editableForUpdate;
        const path_editableForUpdate = path + '.editableForUpdate';
        if (typeof obj_editableForUpdate !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_editableForUpdate + '" (at "' + path_editableForUpdate + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_layoutComponents = obj.layoutComponents;
        const path_layoutComponents = path + '.layoutComponents';
        if (!ArrayIsArray$1(obj_layoutComponents)) {
            return new TypeError('Expected "array" but received "' + typeof obj_layoutComponents + '" (at "' + path_layoutComponents + '")');
        }
        for (let i = 0; i < obj_layoutComponents.length; i++) {
            const obj_layoutComponents_item = obj_layoutComponents[i];
            const path_layoutComponents_item = path_layoutComponents + '[' + i + ']';
            const referenceAbstractRecordLayoutComponentRepresentationValidationError = validate$k(obj_layoutComponents_item, path_layoutComponents_item);
            if (referenceAbstractRecordLayoutComponentRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match AbstractRecordLayoutComponentRepresentation (at "' + path_layoutComponents_item + '")\n';
                message += referenceAbstractRecordLayoutComponentRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_lookupIdApiName = obj.lookupIdApiName;
        const path_lookupIdApiName = path + '.lookupIdApiName';
        let obj_lookupIdApiName_union0 = null;
        const obj_lookupIdApiName_union0_error = (() => {
            if (typeof obj_lookupIdApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lookupIdApiName + '" (at "' + path_lookupIdApiName + '")');
            }
        })();
        if (obj_lookupIdApiName_union0_error != null) {
            obj_lookupIdApiName_union0 = obj_lookupIdApiName_union0_error.message;
        }
        let obj_lookupIdApiName_union1 = null;
        const obj_lookupIdApiName_union1_error = (() => {
            if (obj_lookupIdApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lookupIdApiName + '" (at "' + path_lookupIdApiName + '")');
            }
        })();
        if (obj_lookupIdApiName_union1_error != null) {
            obj_lookupIdApiName_union1 = obj_lookupIdApiName_union1_error.message;
        }
        if (obj_lookupIdApiName_union0 && obj_lookupIdApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lookupIdApiName + '")';
            message += '\n' + obj_lookupIdApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lookupIdApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_required = obj.required;
        const path_required = path + '.required';
        if (typeof obj_required !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_required + '" (at "' + path_required + '")');
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$c(input) {
    const input_layoutComponents = input.layoutComponents;
    for (let i = 0; i < input_layoutComponents.length; i++) {
        const input_layoutComponents_item = input_layoutComponents[i];
        deepFreeze$b(input_layoutComponents_item);
    }
    ObjectFreeze$1(input_layoutComponents);
    ObjectFreeze$1(input);
}

function validate$m(obj, path = 'RecordLayoutRowRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_layoutItems = obj.layoutItems;
        const path_layoutItems = path + '.layoutItems';
        if (!ArrayIsArray$1(obj_layoutItems)) {
            return new TypeError('Expected "array" but received "' + typeof obj_layoutItems + '" (at "' + path_layoutItems + '")');
        }
        for (let i = 0; i < obj_layoutItems.length; i++) {
            const obj_layoutItems_item = obj_layoutItems[i];
            const path_layoutItems_item = path_layoutItems + '[' + i + ']';
            const referenceRecordLayoutItemRepresentationValidationError = validate$l(obj_layoutItems_item, path_layoutItems_item);
            if (referenceRecordLayoutItemRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutItemRepresentation (at "' + path_layoutItems_item + '")\n';
                message += referenceRecordLayoutItemRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$d(input) {
    const input_layoutItems = input.layoutItems;
    for (let i = 0; i < input_layoutItems.length; i++) {
        const input_layoutItems_item = input_layoutItems[i];
        deepFreeze$c(input_layoutItems_item);
    }
    ObjectFreeze$1(input_layoutItems);
    ObjectFreeze$1(input);
}

function validate$n(obj, path = 'RecordLayoutSectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_collapsible = obj.collapsible;
        const path_collapsible = path + '.collapsible';
        if (typeof obj_collapsible !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_collapsible + '" (at "' + path_collapsible + '")');
        }
        const obj_columns = obj.columns;
        const path_columns = path + '.columns';
        if (typeof obj_columns !== 'number' || (typeof obj_columns === 'number' && Math.floor(obj_columns) !== obj_columns)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_columns + '" (at "' + path_columns + '")');
        }
        const obj_heading = obj.heading;
        const path_heading = path + '.heading';
        let obj_heading_union0 = null;
        const obj_heading_union0_error = (() => {
            if (typeof obj_heading !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_heading + '" (at "' + path_heading + '")');
            }
        })();
        if (obj_heading_union0_error != null) {
            obj_heading_union0 = obj_heading_union0_error.message;
        }
        let obj_heading_union1 = null;
        const obj_heading_union1_error = (() => {
            if (obj_heading !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_heading + '" (at "' + path_heading + '")');
            }
        })();
        if (obj_heading_union1_error != null) {
            obj_heading_union1 = obj_heading_union1_error.message;
        }
        if (obj_heading_union0 && obj_heading_union1) {
            let message = 'Object doesn\'t match union (at "' + path_heading + '")';
            message += '\n' + obj_heading_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_heading_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_layoutRows = obj.layoutRows;
        const path_layoutRows = path + '.layoutRows';
        if (!ArrayIsArray$1(obj_layoutRows)) {
            return new TypeError('Expected "array" but received "' + typeof obj_layoutRows + '" (at "' + path_layoutRows + '")');
        }
        for (let i = 0; i < obj_layoutRows.length; i++) {
            const obj_layoutRows_item = obj_layoutRows[i];
            const path_layoutRows_item = path_layoutRows + '[' + i + ']';
            const referenceRecordLayoutRowRepresentationValidationError = validate$m(obj_layoutRows_item, path_layoutRows_item);
            if (referenceRecordLayoutRowRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutRowRepresentation (at "' + path_layoutRows_item + '")\n';
                message += referenceRecordLayoutRowRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_rows = obj.rows;
        const path_rows = path + '.rows';
        if (typeof obj_rows !== 'number' || (typeof obj_rows === 'number' && Math.floor(obj_rows) !== obj_rows)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_rows + '" (at "' + path_rows + '")');
        }
        const obj_useHeading = obj.useHeading;
        const path_useHeading = path + '.useHeading';
        if (typeof obj_useHeading !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_useHeading + '" (at "' + path_useHeading + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$e(input) {
    const input_layoutRows = input.layoutRows;
    for (let i = 0; i < input_layoutRows.length; i++) {
        const input_layoutRows_item = input_layoutRows[i];
        deepFreeze$d(input_layoutRows_item);
    }
    ObjectFreeze$1(input_layoutRows);
    ObjectFreeze$1(input);
}

function validate$o(obj, path = 'RecordLayoutRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_layoutType = obj.layoutType;
        const path_layoutType = path + '.layoutType';
        if (typeof obj_layoutType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_layoutType + '" (at "' + path_layoutType + '")');
        }
        const obj_mode = obj.mode;
        const path_mode = path + '.mode';
        if (typeof obj_mode !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_mode + '" (at "' + path_mode + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
        const obj_sections = obj.sections;
        const path_sections = path + '.sections';
        if (!ArrayIsArray$1(obj_sections)) {
            return new TypeError('Expected "array" but received "' + typeof obj_sections + '" (at "' + path_sections + '")');
        }
        for (let i = 0; i < obj_sections.length; i++) {
            const obj_sections_item = obj_sections[i];
            const path_sections_item = path_sections + '[' + i + ']';
            const referenceRecordLayoutSectionRepresentationValidationError = validate$n(obj_sections_item, path_sections_item);
            if (referenceRecordLayoutSectionRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutSectionRepresentation (at "' + path_sections_item + '")\n';
                message += referenceRecordLayoutSectionRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$b(config) {
    return keyPrefix + 'RecordLayoutRepresentation:' + config.recordTypeId + ':' + config.objectApiName + ':' + config.layoutType + ':' + config.mode;
}
function keyBuilderFromType$8(object) {
    const keyParams = {
        recordTypeId: object.recordTypeId,
        objectApiName: object.objectApiName,
        layoutType: object.layoutType,
        mode: object.mode
    };
    return keyBuilder$b(keyParams);
}
function normalize$9(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$9 = function RecordLayoutRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'layoutType',
                kind: 'Scalar'
            },
            {
                name: 'mode',
                kind: 'Scalar'
            },
            {
                name: 'objectApiName',
                kind: 'Scalar'
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'sections',
                kind: 'Object',
                opaque: true
            }
        ]
    };
};
function equals$b(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
function deepFreeze$f(input) {
    const input_sections = input.sections;
    for (let i = 0; i < input_sections.length; i++) {
        const input_sections_item = input_sections[i];
        deepFreeze$e(input_sections_item);
    }
    ObjectFreeze$1(input_sections);
    ObjectFreeze$1(input);
}
const ingest$9 = function RecordLayoutRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$o(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$8(input);
    let incomingRecord = normalize$9(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    deepFreeze$f(input);
    if (existingRecord === undefined || equals$b(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

var LayoutMode;
(function (LayoutMode) {
    LayoutMode["View"] = "View";
    LayoutMode["Edit"] = "Edit";
    LayoutMode["Create"] = "Create";
})(LayoutMode || (LayoutMode = {}));

const FIELD_ID = 'Id';
const FIELD_NAME = 'Name';
const COMPONENT_TYPE_FIELD = 'Field';
function isFieldAReferenceWithRelationshipName(objectInfo, fieldApiName) {
    const field = objectInfo.fields[fieldApiName];
    if (field === undefined) {
        return false;
    }
    // TODO - can reference===true and relationshipName===null?
    return field.reference === true && field.relationshipName !== null;
}
function getRelationshipName(objectInfo, fieldApiName) {
    // TODO RAML - fix typing so isFieldAReferenceWithRelationshipName enables calling this without `relationshipName!`
    return objectInfo.fields[fieldApiName].relationshipName;
}
function getNameField(objectInfo, fieldApiName) {
    // TODO - this logic is adopted from lds222. It searches
    // ObjectInfoRep.ReferenceToInfoRep[].nameFields[]:
    // 1. If any of the arrays are empty returns `Name`
    // 2. If `Name` is found in any array position then returns it
    // 2. Else returns ObjectInfoRep.ReferenceToInfoRep[0].nameFields[0]
    // Rationale for this is unclear and needs clarification.
    const referenceToInfos = objectInfo.fields[fieldApiName].referenceToInfos;
    if (referenceToInfos.length < 1) {
        return FIELD_NAME;
    }
    const firstReferenceNameFields = referenceToInfos[0].nameFields;
    if (firstReferenceNameFields.length < 1) {
        return FIELD_NAME;
    }
    for (let a = 0, alen = referenceToInfos.length; a < alen; a++) {
        const nameFields = referenceToInfos[a].nameFields;
        for (let b = 0, blen = nameFields.length; b < blen; b++) {
            const nameField = nameFields[b];
            if (nameField === FIELD_NAME) {
                return nameField;
            }
        }
    }
    return firstReferenceNameFields[0];
}
function getQualifiedFieldApiNamesFromLayout(layout, objectInfo) {
    const qualifiedFieldNames = [];
    for (let a = 0, alen = layout.sections.length; a < alen; a++) {
        const section = layout.sections[a];
        for (let b = 0, blen = section.layoutRows.length; b < blen; b++) {
            const row = section.layoutRows[b];
            for (let c = 0, clen = row.layoutItems.length; c < clen; c++) {
                const item = row.layoutItems[c];
                for (let d = 0, dlen = item.layoutComponents.length; d < dlen; d++) {
                    const component = item.layoutComponents[d];
                    const { apiName } = component;
                    if (apiName && component.componentType === COMPONENT_TYPE_FIELD) {
                        if (isFieldAReferenceWithRelationshipName(objectInfo, apiName)) {
                            const relationshipFieldApiName = getRelationshipName(objectInfo, apiName);
                            // By default, include the "Id" field on spanning records that are on the layout.
                            qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${FIELD_ID}`);
                            const nameField = getNameField(objectInfo, apiName);
                            qualifiedFieldNames.push(`${objectInfo.apiName}.${relationshipFieldApiName}.${nameField}`);
                        }
                        qualifiedFieldNames.push(`${objectInfo.apiName}.${component.apiName}`);
                    }
                }
            }
        }
    }
    return qualifiedFieldNames;
}

function validate$p(obj, path = 'RecordLayoutSectionUserStateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_collapsed = obj.collapsed;
        const path_collapsed = path + '.collapsed';
        if (typeof obj_collapsed !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_collapsed + '" (at "' + path_collapsed + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$g(input) {
    ObjectFreeze$1(input);
}

function validate$q(obj, path = 'RecordLayoutUserStateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_sectionUserStates = obj.sectionUserStates;
        const path_sectionUserStates = path + '.sectionUserStates';
        if (typeof obj_sectionUserStates !== 'object' || ArrayIsArray$1(obj_sectionUserStates) || obj_sectionUserStates === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_sectionUserStates + '" (at "' + path_sectionUserStates + '")');
        }
        const obj_sectionUserStates_keys = ObjectKeys$1(obj_sectionUserStates);
        for (let i = 0; i < obj_sectionUserStates_keys.length; i++) {
            const key = obj_sectionUserStates_keys[i];
            const obj_sectionUserStates_prop = obj_sectionUserStates[key];
            const path_sectionUserStates_prop = path_sectionUserStates + '["' + key + '"]';
            const referenceRecordLayoutSectionUserStateRepresentationValidationError = validate$p(obj_sectionUserStates_prop, path_sectionUserStates_prop);
            if (referenceRecordLayoutSectionUserStateRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RecordLayoutSectionUserStateRepresentation (at "' + path_sectionUserStates_prop + '")\n';
                message += referenceRecordLayoutSectionUserStateRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        if (typeof obj_recordTypeId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
        }
        const obj_layoutType = obj.layoutType;
        const path_layoutType = path + '.layoutType';
        if (typeof obj_layoutType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_layoutType + '" (at "' + path_layoutType + '")');
        }
        const obj_mode = obj.mode;
        const path_mode = path + '.mode';
        if (typeof obj_mode !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_mode + '" (at "' + path_mode + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$c(config) {
    return keyPrefix + 'RecordLayoutUserStateRepresentation:' + config.recordTypeId + ':' + config.apiName + ':' + config.layoutType + ':' + config.mode;
}
function keyBuilderFromType$9(object) {
    const keyParams = {
        recordTypeId: object.recordTypeId,
        apiName: object.apiName,
        layoutType: object.layoutType,
        mode: object.mode
    };
    return keyBuilder$c(keyParams);
}
function normalize$a(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$a = function RecordLayoutUserStateRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'apiName',
            'recordTypeId',
            'layoutType',
            'mode'
        ],
        selections: [
            {
                name: 'id',
                kind: 'Scalar'
            },
            {
                name: 'sectionUserStates',
                kind: 'Object',
                opaque: true
            }
        ]
    };
};
function equals$c(existing, incoming) {
    if (JSONStrinify(incoming) !== JSONStrinify(existing)) {
        return false;
    }
    return true;
}
function deepFreeze$h(input) {
    const input_sectionUserStates = input.sectionUserStates;
    const input_sectionUserStates_keys = Object.keys(input_sectionUserStates);
    const input_sectionUserStates_length = input_sectionUserStates_keys.length;
    for (let i = 0; i < input_sectionUserStates_length; i++) {
        const key = input_sectionUserStates_keys[i];
        const input_sectionUserStates_prop = input_sectionUserStates[key];
        deepFreeze$g(input_sectionUserStates_prop);
    }
    ObjectFreeze$1(input_sectionUserStates);
    ObjectFreeze$1(input);
}
const ingest$a = function RecordLayoutUserStateRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$q(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$9(input);
    let incomingRecord = normalize$a(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    deepFreeze$h(input);
    if (existingRecord === undefined || equals$c(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

const TTL$2 = 900000;
function validate$r(obj, path = 'RecordUiRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_layoutUserStates = obj.layoutUserStates;
        const path_layoutUserStates = path + '.layoutUserStates';
        if (typeof obj_layoutUserStates !== 'object' || ArrayIsArray$1(obj_layoutUserStates) || obj_layoutUserStates === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_layoutUserStates + '" (at "' + path_layoutUserStates + '")');
        }
        const obj_layoutUserStates_keys = ObjectKeys$1(obj_layoutUserStates);
        for (let i = 0; i < obj_layoutUserStates_keys.length; i++) {
            const key = obj_layoutUserStates_keys[i];
            const obj_layoutUserStates_prop = obj_layoutUserStates[key];
            const path_layoutUserStates_prop = path_layoutUserStates + '["' + key + '"]';
            if (typeof obj_layoutUserStates_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_layoutUserStates_prop + '" (at "' + path_layoutUserStates_prop + '")');
            }
        }
        const obj_layouts = obj.layouts;
        const path_layouts = path + '.layouts';
        if (typeof obj_layouts !== 'object' || ArrayIsArray$1(obj_layouts) || obj_layouts === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_layouts + '" (at "' + path_layouts + '")');
        }
        const obj_layouts_keys = ObjectKeys$1(obj_layouts);
        for (let i = 0; i < obj_layouts_keys.length; i++) {
            const key = obj_layouts_keys[i];
            const obj_layouts_prop = obj_layouts[key];
            const path_layouts_prop = path_layouts + '["' + key + '"]';
            if (typeof obj_layouts_prop !== 'object' || ArrayIsArray$1(obj_layouts_prop) || obj_layouts_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop + '" (at "' + path_layouts_prop + '")');
            }
            const obj_layouts_prop_keys = ObjectKeys$1(obj_layouts_prop);
            for (let i = 0; i < obj_layouts_prop_keys.length; i++) {
                const key = obj_layouts_prop_keys[i];
                const obj_layouts_prop_prop = obj_layouts_prop[key];
                const path_layouts_prop_prop = path_layouts_prop + '["' + key + '"]';
                if (typeof obj_layouts_prop_prop !== 'object' || ArrayIsArray$1(obj_layouts_prop_prop) || obj_layouts_prop_prop === null) {
                    return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop + '" (at "' + path_layouts_prop_prop + '")');
                }
                const obj_layouts_prop_prop_keys = ObjectKeys$1(obj_layouts_prop_prop);
                for (let i = 0; i < obj_layouts_prop_prop_keys.length; i++) {
                    const key = obj_layouts_prop_prop_keys[i];
                    const obj_layouts_prop_prop_prop = obj_layouts_prop_prop[key];
                    const path_layouts_prop_prop_prop = path_layouts_prop_prop + '["' + key + '"]';
                    if (typeof obj_layouts_prop_prop_prop !== 'object' || ArrayIsArray$1(obj_layouts_prop_prop_prop) || obj_layouts_prop_prop_prop === null) {
                        return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop_prop + '" (at "' + path_layouts_prop_prop_prop + '")');
                    }
                    const obj_layouts_prop_prop_prop_keys = ObjectKeys$1(obj_layouts_prop_prop_prop);
                    for (let i = 0; i < obj_layouts_prop_prop_prop_keys.length; i++) {
                        const key = obj_layouts_prop_prop_prop_keys[i];
                        const obj_layouts_prop_prop_prop_prop = obj_layouts_prop_prop_prop[key];
                        const path_layouts_prop_prop_prop_prop = path_layouts_prop_prop_prop + '["' + key + '"]';
                        if (typeof obj_layouts_prop_prop_prop_prop !== 'object') {
                            return new TypeError('Expected "object" but received "' + typeof obj_layouts_prop_prop_prop_prop + '" (at "' + path_layouts_prop_prop_prop_prop + '")');
                        }
                    }
                }
            }
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (typeof obj_records !== 'object' || ArrayIsArray$1(obj_records) || obj_records === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        const obj_records_keys = ObjectKeys$1(obj_records);
        for (let i = 0; i < obj_records_keys.length; i++) {
            const key = obj_records_keys[i];
            const obj_records_prop = obj_records[key];
            const path_records_prop = path_records + '["' + key + '"]';
            if (typeof obj_records_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_prop + '" (at "' + path_records_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$b(input, existing, path, lds, store, timestamp) {
    const input_layoutUserStates = input.layoutUserStates;
    const input_layoutUserStates_id = path.fullPath + '__layoutUserStates';
    const input_layoutUserStates_keys = Object.keys(input_layoutUserStates);
    const input_layoutUserStates_length = input_layoutUserStates_keys.length;
    for (let i = 0; i < input_layoutUserStates_length; i++) {
        const key = input_layoutUserStates_keys[i];
        const input_layoutUserStates_prop = input_layoutUserStates[key];
        const input_layoutUserStates_prop_id = input_layoutUserStates_id + '__' + key;
        input_layoutUserStates[key] = ingest$a(input_layoutUserStates_prop, {
            fullPath: input_layoutUserStates_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_layouts = input.layouts;
    const input_layouts_id = path.fullPath + '__layouts';
    const input_layouts_keys = Object.keys(input_layouts);
    const input_layouts_length = input_layouts_keys.length;
    for (let i = 0; i < input_layouts_length; i++) {
        const key = input_layouts_keys[i];
        const input_layouts_prop = input_layouts[key];
        const input_layouts_prop_id = input_layouts_id + '__' + key;
        const input_layouts_prop_keys = Object.keys(input_layouts_prop);
        const input_layouts_prop_length = input_layouts_prop_keys.length;
        for (let i = 0; i < input_layouts_prop_length; i++) {
            const key = input_layouts_prop_keys[i];
            const input_layouts_prop_prop = input_layouts_prop[key];
            const input_layouts_prop_prop_id = input_layouts_prop_id + '__' + key;
            const input_layouts_prop_prop_keys = Object.keys(input_layouts_prop_prop);
            const input_layouts_prop_prop_length = input_layouts_prop_prop_keys.length;
            for (let i = 0; i < input_layouts_prop_prop_length; i++) {
                const key = input_layouts_prop_prop_keys[i];
                const input_layouts_prop_prop_prop = input_layouts_prop_prop[key];
                const input_layouts_prop_prop_prop_id = input_layouts_prop_prop_id + '__' + key;
                const input_layouts_prop_prop_prop_keys = Object.keys(input_layouts_prop_prop_prop);
                const input_layouts_prop_prop_prop_length = input_layouts_prop_prop_prop_keys.length;
                for (let i = 0; i < input_layouts_prop_prop_prop_length; i++) {
                    const key = input_layouts_prop_prop_prop_keys[i];
                    const input_layouts_prop_prop_prop_prop = input_layouts_prop_prop_prop[key];
                    const input_layouts_prop_prop_prop_prop_id = input_layouts_prop_prop_prop_id + '__' + key;
                    input_layouts_prop_prop_prop[key] = ingest$9(input_layouts_prop_prop_prop_prop, {
                        fullPath: input_layouts_prop_prop_prop_prop_id,
                        parent: {
                            data: input,
                            key: path.fullPath,
                            existing: existing,
                        }
                    }, lds, store, timestamp);
                }
            }
        }
    }
    const input_objectInfos = input.objectInfos;
    const input_objectInfos_id = path.fullPath + '__objectInfos';
    const input_objectInfos_keys = Object.keys(input_objectInfos);
    const input_objectInfos_length = input_objectInfos_keys.length;
    for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$8(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    const input_records_keys = Object.keys(input_records);
    const input_records_length = input_records_keys.length;
    for (let i = 0; i < input_records_length; i++) {
        const key = input_records_keys[i];
        const input_records_prop = input_records[key];
        const input_records_prop_id = input_records_id + '__' + key;
        input_records[key] = ingest$4(input_records_prop, {
            fullPath: input_records_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$d(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_layoutUserStates = existing.layoutUserStates;
    const incoming_layoutUserStates = incoming.layoutUserStates;
    const equals_layoutUserStates_props = equalsObject(existing_layoutUserStates, incoming_layoutUserStates, (existing_layoutUserStates_prop, incoming_layoutUserStates_prop) => {
        if (!(existing_layoutUserStates_prop.__ref === incoming_layoutUserStates_prop.__ref)) {
            return false;
        }
    });
    if (equals_layoutUserStates_props === false) {
        return false;
    }
    const existing_layouts = existing.layouts;
    const incoming_layouts = incoming.layouts;
    const equals_layouts_props = equalsObject(existing_layouts, incoming_layouts, (existing_layouts_prop, incoming_layouts_prop) => {
        const equals_layouts_props = equalsObject(existing_layouts_prop, incoming_layouts_prop, (existing_layouts_prop_prop, incoming_layouts_prop_prop) => {
            const equals_layouts_props = equalsObject(existing_layouts_prop_prop, incoming_layouts_prop_prop, (existing_layouts_prop_prop_prop, incoming_layouts_prop_prop_prop) => {
                const equals_layouts_props = equalsObject(existing_layouts_prop_prop_prop, incoming_layouts_prop_prop_prop, (existing_layouts_prop_prop_prop_prop, incoming_layouts_prop_prop_prop_prop) => {
                    if (!(existing_layouts_prop_prop_prop_prop.__ref === incoming_layouts_prop_prop_prop_prop.__ref)) {
                        return false;
                    }
                });
                if (equals_layouts_props === false) {
                    return false;
                }
            });
            if (equals_layouts_props === false) {
                return false;
            }
        });
        if (equals_layouts_props === false) {
            return false;
        }
    });
    if (equals_layouts_props === false) {
        return false;
    }
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_props = equalsObject(existing_records, incoming_records, (existing_records_prop, incoming_records_prop) => {
        if (!(existing_records_prop.__ref === incoming_records_prop.__ref)) {
            return false;
        }
    });
    if (equals_records_props === false) {
        return false;
    }
    return true;
}
const ingest$b = function RecordUiRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$r(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$b(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$d(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function createResourceRequest$a(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/record-ui/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$b,
        headers,
    };
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getRecordId18Array(value) {
    const valueArray = isArray(value) ? value : [value];
    const array = [];
    for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getRecordId18(item);
        if (apiName === undefined) {
            return undefined;
        }
        push.call(array, apiName);
    }
    if (array.length === 0) {
        return undefined;
    }
    return dedupe(array).sort();
}

function coerceConfig$6(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const childRelationships = config.childRelationships;
    if (childRelationships !== undefined) {
        coercedConfig.childRelationships = childRelationships;
    }
    const formFactor = config.formFactor;
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const layoutTypes = toSortedStringArray(config.layoutTypes);
    if (layoutTypes !== undefined) {
        coercedConfig.layoutTypes = layoutTypes;
    }
    const modes = toSortedStringArray(config.modes);
    if (modes !== undefined) {
        coercedConfig.modes = modes;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const updateMru = config.updateMru;
    if (updateMru !== undefined) {
        coercedConfig.updateMru = updateMru;
    }
    return coercedConfig;
}
function typeCheckConfig$6(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_childRelationships = untrustedConfig.childRelationships;
    if (ArrayIsArray(untrustedConfig_childRelationships)) {
        const untrustedConfig_childRelationships_array = [];
        for (let i = 0, arrayLength = untrustedConfig_childRelationships.length; i < arrayLength; i++) {
            const untrustedConfig_childRelationships_item = untrustedConfig_childRelationships[i];
            if (typeof untrustedConfig_childRelationships_item === 'string') {
                untrustedConfig_childRelationships_array.push(untrustedConfig_childRelationships_item);
            }
        }
        config.childRelationships = untrustedConfig_childRelationships_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_layoutTypes = untrustedConfig.layoutTypes;
    if (ArrayIsArray(untrustedConfig_layoutTypes)) {
        const untrustedConfig_layoutTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_layoutTypes.length; i < arrayLength; i++) {
            const untrustedConfig_layoutTypes_item = untrustedConfig_layoutTypes[i];
            if (typeof untrustedConfig_layoutTypes_item === 'string') {
                untrustedConfig_layoutTypes_array.push(untrustedConfig_layoutTypes_item);
            }
        }
        config.layoutTypes = untrustedConfig_layoutTypes_array;
    }
    const untrustedConfig_modes = untrustedConfig.modes;
    if (ArrayIsArray(untrustedConfig_modes)) {
        const untrustedConfig_modes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_modes.length; i < arrayLength; i++) {
            const untrustedConfig_modes_item = untrustedConfig_modes[i];
            if (typeof untrustedConfig_modes_item === 'string') {
                untrustedConfig_modes_array.push(untrustedConfig_modes_item);
            }
        }
        config.modes = untrustedConfig_modes_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_updateMru = untrustedConfig.updateMru;
    if (typeof untrustedConfig_updateMru === 'boolean') {
        config.updateMru = untrustedConfig_updateMru;
    }
    return config;
}
function validateAdapterConfig$6(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$6(untrustedConfig);
    const config = typeCheckConfig$6(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const layoutSelections = select$9();
const objectInfoPathSelection = select$7();
const layoutUserStatePathSelector = select$a();
function buildRecordUiSelector(recordDefs, layoutTypes, modes, recordOptionalFields) {
    const layoutTypeSelections = [];
    for (let i = 0, len = layoutTypes.length; i < len; i += 1) {
        const layoutType = layoutTypes[i];
        const modeSelections = [];
        const sel = {
            kind: 'Object',
            name: layoutType,
            selections: modeSelections,
        };
        for (let m = 0; m < modes.length; m += 1) {
            const mode = modes[m];
            const modeSel = {
                kind: 'Link',
                name: mode,
                fragment: layoutSelections,
            };
            push.call(modeSelections, modeSel);
        }
        push.call(layoutTypeSelections, sel);
    }
    const recordLayoutSelections = [];
    const recordSelections = [];
    for (let i = 0, len = recordDefs.length; i < len; i += 1) {
        const { recordId, recordData } = recordDefs[i];
        push.call(recordLayoutSelections, {
            kind: 'Object',
            name: recordData.apiName,
            required: false,
            map: true,
            selections: layoutTypeSelections,
        });
        const optionalFields = recordOptionalFields[recordId];
        const fields = extractRecordFields(recordData);
        push.call(recordSelections, {
            kind: 'Link',
            name: recordId,
            fragment: {
                kind: 'Fragment',
                selections: buildSelectionFromFields(fields, optionalFields),
                private: ['eTag', 'weakEtag'],
            },
        });
    }
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            {
                kind: 'Link',
                name: 'layoutUserStates',
                map: true,
                fragment: layoutUserStatePathSelector,
            },
            {
                kind: 'Object',
                name: 'layouts',
                selections: recordLayoutSelections,
            },
            {
                kind: 'Link',
                name: 'objectInfos',
                map: true,
                fragment: objectInfoPathSelection,
            },
            {
                name: 'records',
                kind: 'Object',
                selections: recordSelections,
            },
        ],
    };
}

function getMissingRecordLookupFields(record, objectInfo) {
    const lookupFields = {};
    const { apiName, fields: recordFields } = record;
    const { fields: objectInfoFields } = objectInfo;
    const objectInfoFieldNames = keys(objectInfoFields);
    for (let i = 0, len = objectInfoFieldNames.length; i < len; i += 1) {
        const fieldName = objectInfoFieldNames[i];
        const field = objectInfoFields[fieldName];
        const { relationshipName } = field;
        if (relationshipName === null) {
            continue;
        }
        const recordFieldValue = recordFields[relationshipName];
        // Only interested in record fields that are present and that are null
        if (recordFieldValue === undefined || recordFieldValue.value !== null) {
            continue;
        }
        // Include the Id field. Ex: Opportunity.Account.Id, Opportunity.relation1__r.Id
        const idFieldName = `${apiName}.${relationshipName}.Id`;
        lookupFields[idFieldName] = true;
        const nameField = `${apiName}.${relationshipName}.${getNameField(objectInfo, fieldName)}`;
        lookupFields[nameField] = true;
    }
    return keys(lookupFields);
}
function getRecordUiMissingRecordLookupFields(recordUi) {
    const { records, objectInfos } = recordUi;
    const recordLookupFields = {};
    const recordIds = keys(records);
    for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordData = records[recordId];
        const { apiName } = recordData;
        const objectInfo = objectInfos[apiName];
        recordLookupFields[recordId] = getMissingRecordLookupFields(recordData, objectInfo);
    }
    return recordLookupFields;
}

// Custom adapter config due to `unsupported` items
const GET_RECORDUI_ADAPTER_CONFIG = {
    displayName: 'getRecordUi',
    parameters: {
        required: ['recordIds', 'layoutTypes', 'modes'],
        optional: ['optionalFields'],
        unsupported: [
            'formFactor',
            'childRelationships',
            'pageSize',
            'updateMru',
        ],
    },
};
function eachLayout(recordUi, cb) {
    const { layouts } = recordUi;
    const layoutApiNames = keys(layouts);
    for (let a = 0, len = layoutApiNames.length; a < len; a += 1) {
        const apiName = layoutApiNames[a];
        const apiNameData = layouts[apiName];
        const recordTypeIds = keys(apiNameData);
        for (let b = 0, recordTypeIdsLen = recordTypeIds.length; b < recordTypeIdsLen; b += 1) {
            const recordTypeId = recordTypeIds[b];
            const recordTypeData = apiNameData[recordTypeId];
            const layoutTypes = keys(recordTypeData);
            for (let c = 0, layoutTypesLen = layoutTypes.length; c < layoutTypesLen; c += 1) {
                const layoutType = layoutTypes[c];
                const layoutTypeData = recordTypeData[layoutType];
                const modes = keys(layoutTypeData);
                for (let d = 0, modesLen = modes.length; d < modesLen; d += 1) {
                    const mode = modes[d];
                    const layout = layoutTypeData[mode];
                    cb(apiName, recordTypeId, layout);
                }
            }
        }
    }
}
function collectRecordDefs(resp, recordIds) {
    const recordDefs = [];
    for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordId = recordIds[i];
        const recordData = resp.records[recordId];
        push.call(recordDefs, {
            recordId,
            recordData,
            recordTypeId: getRecordTypeId(recordData),
        });
    }
    return recordDefs;
}
function keyBuilder$d(recordIds, layoutTypes, modes, optionalFields) {
    const joinedRecordIds = recordIds.sort().join(',');
    const joinedOptionalFields = optionalFields.sort().join(',');
    const joinedLayoutTypes = layoutTypes.sort().join(',');
    const joinedModes = modes.sort().join(',');
    return `${keyPrefix}RecordUiRepresentation:${joinedRecordIds}:${joinedLayoutTypes}:${joinedModes}:${joinedOptionalFields}`;
}
function buildSnapshotRefresh$3(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$3(lds, config),
    };
}
function buildInMemorySnapshot$5(lds, config) {
    const { recordIds, layoutTypes, modes, optionalFields } = config;
    // TODO: a better hash function for config -> configKey
    const configKey = stringify(config);
    // check to see if we see the selector (config) before
    const selectorNode = getSelectorNode(lds, configKey);
    // if we do, return the same snapshot instance by calling storeLookupMemoize
    if (selectorNode !== null) {
        const cacheData = lds.storeLookupMemoize(selectorNode, buildSnapshotRefresh$3(lds, config));
        // CACHE HIT
        if (lds.snapshotDataAvailable(cacheData)) {
            return cacheData;
        }
    }
    const key = keyBuilder$d(recordIds, layoutTypes, modes, optionalFields);
    const cachedSelectorKey = `${key}__selector`;
    const cacheSel = lds.storeLookup({
        recordId: cachedSelectorKey,
        node: {
            kind: 'Fragment',
            private: [],
            opaque: true,
        },
        variables: {},
    });
    if (isFulfilledSnapshot(cacheSel)) {
        const cachedSelector = cacheSel.data;
        // publish the selector instance for later getNode check
        lds.storePublish(configKey, cachedSelector);
        const cacheData = lds.storeLookupMemoize(cachedSelector, buildSnapshotRefresh$3(lds, config));
        // CACHE HIT
        if (lds.snapshotDataAvailable(cacheData)) {
            return cacheData;
        }
    }
    return null;
}
function markRecordUiNulledOutLookupFields(recordLookupFields, recordNodes) {
    for (let i = 0, len = recordNodes.length; i < len; i++) {
        const recordId = recordNodes[i].data.id;
        if (recordLookupFields[recordId] !== undefined) {
            markNulledOutRequiredFields(recordNodes[i], recordLookupFields[recordId]);
        }
    }
}
function markRecordUiOptionalFields(optionalFields, recordLookupFields, recordNodes) {
    for (let i = 0, len = recordNodes.length; i < len; i++) {
        const recordId = recordNodes[i].data.id;
        if (optionalFields.length > 0 || recordLookupFields[recordId] !== undefined) {
            markMissingOptionalFields(recordNodes[i], [
                ...optionalFields,
                ...recordLookupFields[recordId],
            ]);
        }
    }
}
function getSelectorNode(lds, key) {
    const selectorNode = lds.getNode(key);
    if (selectorNode !== null) {
        return selectorNode.retrieve();
    }
    return null;
}
function buildNetworkSnapshot$3(lds, config) {
    const { recordIds, layoutTypes, modes, optionalFields } = config;
    // TODO: a better hash function for config -> configKey
    const configKey = stringify(config);
    const key = keyBuilder$d(recordIds, layoutTypes, modes, optionalFields);
    const resourceRequest = createResourceRequest$a({
        urlParams: {
            recordIds,
        },
        queryParams: {
            layoutTypes,
            modes,
            optionalFields: dedupe(optionalFields).sort(),
        },
    });
    return lds.dispatchResourceRequest(resourceRequest).then(response => {
        const { body } = response;
        // TODO fix API so we don't have to augment the response with request details in order
        // to support refresh. these are never emitted out per (private).
        eachLayout(body, (apiName, recordTypeId, layout) => {
            if (layout.id === null) {
                return;
            }
            const layoutUserState = body.layoutUserStates[layout.id];
            // Temporary hack since we can't match keys from getLayoutUserState response
            // to record ui's layout users states.
            if (layoutUserState === undefined) {
                return;
            }
            layoutUserState.apiName = apiName;
            layoutUserState.recordTypeId = recordTypeId;
            layoutUserState.mode = layout.mode;
            layoutUserState.layoutType = layout.layoutType;
        });
        const cachedSelectorKey = `${key}__selector`;
        const recordLookupFields = getRecordUiMissingRecordLookupFields(body);
        const selPath = buildRecordUiSelector(collectRecordDefs(body, recordIds), layoutTypes, modes, recordLookupFields);
        const sel = {
            recordId: key,
            node: selPath,
            variables: {},
        };
        lds.storePublish(cachedSelectorKey, sel);
        lds.storeIngest(key, resourceRequest, body);
        // During ingestion, only valid records are stored.
        const recordNodes = [];
        const validRecordIds = [];
        for (let i = 0, len = recordIds.length; i < len; i += 1) {
            const recordId = recordIds[i];
            const recordKey = keyBuilder$2({ recordId });
            const node = lds.getNode(recordKey);
            if (isGraphNode(node)) {
                recordNodes.push(node);
                validRecordIds.push(recordId);
            }
        }
        markRecordUiNulledOutLookupFields(recordLookupFields, recordNodes);
        markRecordUiOptionalFields(optionalFields, recordLookupFields, recordNodes);
        lds.storeBroadcast();
        lds.storePublish(configKey, sel);
        publishDependencies(lds, validRecordIds, [key, cachedSelectorKey, configKey]);
        return lds.storeLookupMemoize(sel, buildSnapshotRefresh$3(lds, config));
    }, (err) => {
        lds.storeIngestFetchResponse(key, err, TTL$2);
        lds.storeBroadcast();
        const { status } = err;
        if (status === 404) {
            const sel = {
                recordId: key,
                node: {
                    kind: 'Fragment',
                    private: [],
                    opaque: true,
                },
                variables: {},
            };
            lds.storePublish(configKey, sel);
            return lds.storeLookupMemoize(sel, buildSnapshotRefresh$3(lds, config));
        }
        return lds.errorSnapshot(err, buildSnapshotRefresh$3(lds, config));
    });
}
function publishDependencies(lds, recordIds, depKeys) {
    for (let i = 0, len = recordIds.length; i < len; i += 1) {
        const recordDepKey = depenpendencyKeyBuilder({ recordId: recordIds[i] });
        const dependencies = create(null);
        for (let j = 0, len = depKeys.length; j < len; j++) {
            dependencies[depKeys[j]] = true;
        }
        const node = lds.getNode(recordDepKey);
        if (isGraphNode(node)) {
            const recordDeps = node.retrieve();
            assign(dependencies, recordDeps);
        }
        lds.storePublish(recordDepKey, dependencies);
    }
}
function coerceConfigWithDefaults(untrustedConfig) {
    const config = validateAdapterConfig$6(untrustedConfig, GET_RECORDUI_ADAPTER_CONFIG);
    if (config === null) {
        return null;
    }
    const { layoutTypes, modes } = config;
    // custom config validation
    if (layoutTypes === undefined || modes === undefined) {
        return null;
    }
    return {
        ...config,
        layoutTypes: layoutTypes,
        modes: modes,
        optionalFields: config.optionalFields === undefined ? [] : config.optionalFields,
    };
}
const factory$3 = (lds) => function getRecordUi(untrustedConfig) {
    // standard config validation and coercion
    const config = coerceConfigWithDefaults(untrustedConfig);
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$5(lds, config);
    if (cacheSnapshot !== null) {
        return cacheSnapshot;
    }
    return buildNetworkSnapshot$3(lds, config);
};

const DEFAULT_MODE = LayoutMode.View;
const layoutSelections$1 = select$9();
function buildSnapshotRefresh$4(lds, config) {
    return {
        config,
        resolve: () => refresh(lds, config),
    };
}
function refresh(lds, config) {
    const { recordId, layoutTypes, modes: configModes, optionalFields: configOptionalFields, } = config;
    const modes = configModes === undefined ? [DEFAULT_MODE] : configModes;
    const optionalFields = configOptionalFields === undefined ? [] : configOptionalFields;
    const recordUiConfig = {
        recordIds: [recordId],
        layoutTypes,
        modes,
        optionalFields,
    };
    return buildNetworkSnapshot$3(lds, recordUiConfig).then(snapshot => {
        const refresh = buildSnapshotRefresh$4(lds, config);
        if (isErrorSnapshot(snapshot)) {
            return lds.errorSnapshot(snapshot.error, refresh);
        }
        if (isUnfulfilledSnapshot(snapshot)) {
            throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys(snapshot.missingPaths)}`);
        }
        const { layoutMap, objectInfo } = getLayoutMapAndObjectInfo(recordId, snapshot.data);
        const fields = getFieldsFromLayoutMap(layoutMap, objectInfo);
        return buildInMemorySnapshot(lds, {
            recordId,
            fields,
            modes,
        }, refresh);
    });
}
// Makes a request directly to /record-ui/{recordIds}
function fetchRecordLayout(lds, refresh, recordId, layoutTypes, modes, optionalFields) {
    const recordUiConfig = {
        recordIds: [recordId],
        layoutTypes,
        modes,
        optionalFields,
    };
    const recordUiAdapter = factory$3(lds);
    const recordUiSnapshotOrPromise = recordUiAdapter(recordUiConfig);
    if (isPromise$1(recordUiSnapshotOrPromise)) {
        return recordUiSnapshotOrPromise.then(snapshot => {
            return processRecordUiRepresentation(lds, refresh, recordId, modes, snapshot);
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        if (recordUiSnapshotOrPromise === null) {
            throw new Error('RecordUi adapter synchronously resolved with a null snapshot');
        }
    }
    return processRecordUiRepresentation(lds, refresh, recordId, modes, recordUiSnapshotOrPromise);
}
function getLayoutMapAndObjectInfo(recordId, data) {
    const { objectInfos, layouts, records } = data;
    const record = records[recordId];
    const { apiName } = record;
    const objectInfo = objectInfos[apiName];
    const recordTypeId = getRecordTypeId(record);
    const layoutMap = layouts[apiName][recordTypeId];
    return {
        layoutMap,
        objectInfo,
    };
}
function processRecordUiRepresentation(lds, refresh, recordId, modes, snapshot) {
    if (isErrorSnapshot(snapshot)) {
        return lds.errorSnapshot(snapshot.error, refresh);
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        throw new Error(`RecordUi adapter resolved with a snapshot with missing data, missingPaths: ${keys(snapshot.missingPaths)}`);
    }
    const { layoutMap, objectInfo } = getLayoutMapAndObjectInfo(recordId, snapshot.data);
    return getRecord(lds, refresh, recordId, layoutMap, objectInfo);
}
function isPromise$1(value) {
    // check for Thenable due to test frameworks using custom Promise impls
    return value !== null && value.then !== undefined;
}
function lookupObjectInfo(lds, apiName) {
    const snapshot = buildInMemorySnapshot$4(lds, { objectApiName: apiName });
    if (lds.snapshotDataAvailable(snapshot)) {
        if (!isErrorSnapshot(snapshot) && snapshot.data !== undefined) {
            return snapshot.data;
        }
    }
    return null;
}
function lookupLayouts(lds, apiName, recordTypeId, layoutTypes, modes) {
    const map = {};
    for (let i = 0; i < layoutTypes.length; i += 1) {
        const layoutType = layoutTypes[i];
        let layoutMap = map[layoutType];
        if (layoutMap === undefined) {
            layoutMap = map[layoutType] = {};
        }
        for (let m = 0; m < modes.length; m += 1) {
            const mode = modes[m];
            const key = keyBuilder$b({
                objectApiName: apiName,
                recordTypeId,
                layoutType,
                mode,
            });
            const snapshot = lds.storeLookup({
                recordId: key,
                node: layoutSelections$1,
                variables: {},
            });
            // Cache hit
            if (lds.snapshotDataAvailable(snapshot) && !isErrorSnapshot(snapshot)) {
                layoutMap[mode] = snapshot.data;
            }
            else {
                return null;
            }
        }
    }
    return map;
}
const recordLayoutFragmentSelector = [
    {
        name: 'apiName',
        kind: 'Scalar',
    },
    {
        name: 'recordTypeId',
        kind: 'Scalar',
    },
];
function getFieldsFromLayoutMap(layoutMap, objectInfo) {
    let fields = [];
    const layoutTypes = Object.keys(layoutMap);
    for (let i = 0, layoutTypesLen = layoutTypes.length; i < layoutTypesLen; i += 1) {
        const layoutType = layoutTypes[i];
        const modesMap = layoutMap[layoutType];
        const modes = Object.keys(modesMap);
        for (let m = 0, modesLen = modes.length; m < modesLen; m += 1) {
            const mode = modes[m];
            const modeKeys = getQualifiedFieldApiNamesFromLayout(modesMap[mode], objectInfo);
            fields = fields.concat(modeKeys);
        }
    }
    return dedupe(fields).sort();
}
function getRecord(lds, refresh, recordId, layoutMap, objectInfo) {
    const fields = getFieldsFromLayoutMap(layoutMap, objectInfo);
    // We know what fields we need so delegate to getRecordByFields
    // This should be a cache hit because we just fetched the record-ui
    const recordSnapshotOrPromise = getRecordByFields(lds, {
        recordId,
        fields,
    });
    // attach a record layout refresh
    if (isPromise$1(recordSnapshotOrPromise)) {
        recordSnapshotOrPromise.then(snapshot => {
            snapshot.refresh = refresh;
            return snapshot;
        });
    }
    else {
        recordSnapshotOrPromise.refresh = refresh;
    }
    return recordSnapshotOrPromise;
}
function getRecordLayoutType(lds, config) {
    const { recordId, layoutTypes, modes: configModes, optionalFields } = config;
    const modes = configModes === undefined ? [DEFAULT_MODE] : configModes;
    const storeKey = keyBuilder$2({ recordId });
    const recordSnapshot = lds.storeLookup({
        recordId: storeKey,
        node: {
            kind: 'Fragment',
            private: [],
            selections: recordLayoutFragmentSelector,
        },
        variables: {},
    });
    const refresh = buildSnapshotRefresh$4(lds, config);
    // If we haven't seen the record then go to the server
    if (!lds.snapshotDataAvailable(recordSnapshot) || recordSnapshot.data === undefined) {
        return fetchRecordLayout(lds, refresh, recordId, layoutTypes, modes, optionalFields);
    }
    const record = recordSnapshot.data;
    const { apiName } = record;
    const objectInfo = lookupObjectInfo(lds, apiName);
    // If we do not have object info in cache, call record-ui endpoint directly
    if (objectInfo === null) {
        return fetchRecordLayout(lds, refresh, recordId, layoutTypes, modes, optionalFields);
    }
    const recordTypeId = getRecordTypeId(record);
    const layoutMap = lookupLayouts(lds, apiName, recordTypeId, layoutTypes, modes);
    // It takes one xhr per layout to load so if there are missing layouts
    // give up and call record-ui endpoint directly
    if (layoutMap === null) {
        return fetchRecordLayout(lds, refresh, recordId, layoutTypes, modes, optionalFields);
    }
    return getRecord(lds, refresh, recordId, layoutMap, objectInfo);
}

// Custom adapter config due to `unsupported` items
const GET_RECORD_ADAPTER_CONFIG = {
    displayName: 'getRecord',
    parameters: {
        required: ['recordId'],
        optional: ['fields', 'layoutTypes', 'modes', 'optionalFields'],
        unsupported: [
            'childRelationships',
            'pageSize',
            'updateMru',
        ],
    },
};
function hasLayoutTypes(config) {
    return 'layoutTypes' in config;
}
function hasFieldsOrOptionalFields(config) {
    return 'fields' in config || 'optionalFields' in config;
}
function createResourceRequestFromRepresentation(representation, optionalFields) {
    const config = {
        urlParams: {
            recordId: representation.id,
        },
        queryParams: {
            optionalFields,
        },
    };
    return createResourceRequest$1(config);
}
// TODO: this should probably be code generated in RecordRepresentation
function coerceKeyParams(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    return coercedConfig;
}
const NOTIFY_CHANGE_NETWORK_KEY = 'notify-change-network';
const notifyChangeNetworkRejectInstrumentParamBuilder = () => {
    return {
        [NOTIFY_CHANGE_NETWORK_KEY]: 'error',
    };
};
const notifyChangeFactory = (lds) => {
    return function getUiApiRecordsByRecordIdNotifyChange(configs) {
        for (let i = 0, len = configs.length; i < len; i++) {
            // build key from input
            const coercedConfig = coerceKeyParams(configs[i]);
            const key = keyBuilder$2(coercedConfig);
            // lookup GraphNode from store
            const node = lds.getNode(key);
            if (node === null || node.type === 'Error') {
                continue;
            }
            // retrieve data (Representation) from GraphNode and use createResourceRequestFromRepresentation to build refresh resource request from Representation
            const representation = node.retrieve();
            const optionalFields = getTrackedFields(lds, representation.id);
            const refreshRequest = createResourceRequestFromRepresentation(representation, optionalFields);
            const existingWeakEtag = representation.weakEtag;
            // dispatch resource request, then ingest and broadcast
            lds.dispatchResourceRequest(refreshRequest).then(response => {
                const { body } = response;
                lds.storeIngest(key, refreshRequest, body);
                const recordNode = lds.getNode(key);
                markMissingOptionalFields(recordNode, optionalFields);
                lds.storeBroadcast();
                const notifyChangeNetworkResolveInstrumentParamBuilder = () => {
                    return {
                        [NOTIFY_CHANGE_NETWORK_KEY]: existingWeakEtag !== body.weakEtag,
                    };
                };
                lds.instrument(notifyChangeNetworkResolveInstrumentParamBuilder);
            }, (error) => {
                lds.storeIngestFetchResponse(key, error, TTL);
                lds.storeBroadcast();
                lds.instrument(notifyChangeNetworkRejectInstrumentParamBuilder);
            });
        }
    };
};
const factory$4 = (lds) => function getRecord(untrustedConfig) {
    // standard config validation and coercion
    const config = validateAdapterConfig(untrustedConfig, GET_RECORD_ADAPTER_CONFIG);
    if (config === null) {
        return null;
    }
    if (hasLayoutTypes(config)) {
        return getRecordLayoutType(lds, config);
    }
    else if (hasFieldsOrOptionalFields(config)) {
        return getRecordByFields(lds, config);
    }
    return null;
};

function validate$s(obj, path = 'PlatformActionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionListContext = obj.actionListContext;
        const path_actionListContext = path + '.actionListContext';
        if (typeof obj_actionListContext !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionListContext + '" (at "' + path_actionListContext + '")');
        }
        const obj_actionTarget = obj.actionTarget;
        const path_actionTarget = path + '.actionTarget';
        let obj_actionTarget_union0 = null;
        const obj_actionTarget_union0_error = (() => {
            if (typeof obj_actionTarget !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_actionTarget + '" (at "' + path_actionTarget + '")');
            }
        })();
        if (obj_actionTarget_union0_error != null) {
            obj_actionTarget_union0 = obj_actionTarget_union0_error.message;
        }
        let obj_actionTarget_union1 = null;
        const obj_actionTarget_union1_error = (() => {
            if (obj_actionTarget !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_actionTarget + '" (at "' + path_actionTarget + '")');
            }
        })();
        if (obj_actionTarget_union1_error != null) {
            obj_actionTarget_union1 = obj_actionTarget_union1_error.message;
        }
        if (obj_actionTarget_union0 && obj_actionTarget_union1) {
            let message = 'Object doesn\'t match union (at "' + path_actionTarget + '")';
            message += '\n' + obj_actionTarget_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_actionTarget_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_actionTargetType = obj.actionTargetType;
        const path_actionTargetType = path + '.actionTargetType';
        let obj_actionTargetType_union0 = null;
        const obj_actionTargetType_union0_error = (() => {
            if (typeof obj_actionTargetType !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_actionTargetType + '" (at "' + path_actionTargetType + '")');
            }
        })();
        if (obj_actionTargetType_union0_error != null) {
            obj_actionTargetType_union0 = obj_actionTargetType_union0_error.message;
        }
        let obj_actionTargetType_union1 = null;
        const obj_actionTargetType_union1_error = (() => {
            if (obj_actionTargetType !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_actionTargetType + '" (at "' + path_actionTargetType + '")');
            }
        })();
        if (obj_actionTargetType_union1_error != null) {
            obj_actionTargetType_union1 = obj_actionTargetType_union1_error.message;
        }
        if (obj_actionTargetType_union0 && obj_actionTargetType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_actionTargetType + '")';
            message += '\n' + obj_actionTargetType_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_actionTargetType_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_externalId = obj.externalId;
        const path_externalId = path + '.externalId';
        if (typeof obj_externalId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_externalId + '" (at "' + path_externalId + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
            if (typeof obj_iconUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union0_error != null) {
            obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
            if (obj_iconUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union1_error != null) {
            obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
            message += '\n' + obj_iconUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_iconUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (typeof obj_id !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_isMassAction = obj.isMassAction;
        const path_isMassAction = path + '.isMassAction';
        if (typeof obj_isMassAction !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_isMassAction + '" (at "' + path_isMassAction + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_primaryColor = obj.primaryColor;
        const path_primaryColor = path + '.primaryColor';
        let obj_primaryColor_union0 = null;
        const obj_primaryColor_union0_error = (() => {
            if (typeof obj_primaryColor !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_primaryColor + '" (at "' + path_primaryColor + '")');
            }
        })();
        if (obj_primaryColor_union0_error != null) {
            obj_primaryColor_union0 = obj_primaryColor_union0_error.message;
        }
        let obj_primaryColor_union1 = null;
        const obj_primaryColor_union1_error = (() => {
            if (obj_primaryColor !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_primaryColor + '" (at "' + path_primaryColor + '")');
            }
        })();
        if (obj_primaryColor_union1_error != null) {
            obj_primaryColor_union1 = obj_primaryColor_union1_error.message;
        }
        if (obj_primaryColor_union0 && obj_primaryColor_union1) {
            let message = 'Object doesn\'t match union (at "' + path_primaryColor + '")';
            message += '\n' + obj_primaryColor_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_primaryColor_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedListRecordId = obj.relatedListRecordId;
        const path_relatedListRecordId = path + '.relatedListRecordId';
        let obj_relatedListRecordId_union0 = null;
        const obj_relatedListRecordId_union0_error = (() => {
            if (typeof obj_relatedListRecordId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relatedListRecordId + '" (at "' + path_relatedListRecordId + '")');
            }
        })();
        if (obj_relatedListRecordId_union0_error != null) {
            obj_relatedListRecordId_union0 = obj_relatedListRecordId_union0_error.message;
        }
        let obj_relatedListRecordId_union1 = null;
        const obj_relatedListRecordId_union1_error = (() => {
            if (obj_relatedListRecordId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relatedListRecordId + '" (at "' + path_relatedListRecordId + '")');
            }
        })();
        if (obj_relatedListRecordId_union1_error != null) {
            obj_relatedListRecordId_union1 = obj_relatedListRecordId_union1_error.message;
        }
        if (obj_relatedListRecordId_union0 && obj_relatedListRecordId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relatedListRecordId + '")';
            message += '\n' + obj_relatedListRecordId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relatedListRecordId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedSourceObject = obj.relatedSourceObject;
        const path_relatedSourceObject = path + '.relatedSourceObject';
        let obj_relatedSourceObject_union0 = null;
        const obj_relatedSourceObject_union0_error = (() => {
            if (typeof obj_relatedSourceObject !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relatedSourceObject + '" (at "' + path_relatedSourceObject + '")');
            }
        })();
        if (obj_relatedSourceObject_union0_error != null) {
            obj_relatedSourceObject_union0 = obj_relatedSourceObject_union0_error.message;
        }
        let obj_relatedSourceObject_union1 = null;
        const obj_relatedSourceObject_union1_error = (() => {
            if (obj_relatedSourceObject !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relatedSourceObject + '" (at "' + path_relatedSourceObject + '")');
            }
        })();
        if (obj_relatedSourceObject_union1_error != null) {
            obj_relatedSourceObject_union1 = obj_relatedSourceObject_union1_error.message;
        }
        if (obj_relatedSourceObject_union0 && obj_relatedSourceObject_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relatedSourceObject + '")';
            message += '\n' + obj_relatedSourceObject_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relatedSourceObject_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_section = obj.section;
        const path_section = path + '.section';
        let obj_section_union0 = null;
        const obj_section_union0_error = (() => {
            if (typeof obj_section !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_section + '" (at "' + path_section + '")');
            }
        })();
        if (obj_section_union0_error != null) {
            obj_section_union0 = obj_section_union0_error.message;
        }
        let obj_section_union1 = null;
        const obj_section_union1_error = (() => {
            if (obj_section !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_section + '" (at "' + path_section + '")');
            }
        })();
        if (obj_section_union1_error != null) {
            obj_section_union1 = obj_section_union1_error.message;
        }
        if (obj_section_union0 && obj_section_union1) {
            let message = 'Object doesn\'t match union (at "' + path_section + '")';
            message += '\n' + obj_section_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_section_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_sourceObject = obj.sourceObject;
        const path_sourceObject = path + '.sourceObject';
        if (typeof obj_sourceObject !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_sourceObject + '" (at "' + path_sourceObject + '")');
        }
        const obj_subtype = obj.subtype;
        const path_subtype = path + '.subtype';
        let obj_subtype_union0 = null;
        const obj_subtype_union0_error = (() => {
            if (typeof obj_subtype !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_subtype + '" (at "' + path_subtype + '")');
            }
        })();
        if (obj_subtype_union0_error != null) {
            obj_subtype_union0 = obj_subtype_union0_error.message;
        }
        let obj_subtype_union1 = null;
        const obj_subtype_union1_error = (() => {
            if (obj_subtype !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_subtype + '" (at "' + path_subtype + '")');
            }
        })();
        if (obj_subtype_union1_error != null) {
            obj_subtype_union1 = obj_subtype_union1_error.message;
        }
        if (obj_subtype_union0 && obj_subtype_union1) {
            let message = 'Object doesn\'t match union (at "' + path_subtype + '")';
            message += '\n' + obj_subtype_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_subtype_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_targetObject = obj.targetObject;
        const path_targetObject = path + '.targetObject';
        let obj_targetObject_union0 = null;
        const obj_targetObject_union0_error = (() => {
            if (typeof obj_targetObject !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_targetObject + '" (at "' + path_targetObject + '")');
            }
        })();
        if (obj_targetObject_union0_error != null) {
            obj_targetObject_union0 = obj_targetObject_union0_error.message;
        }
        let obj_targetObject_union1 = null;
        const obj_targetObject_union1_error = (() => {
            if (obj_targetObject !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_targetObject + '" (at "' + path_targetObject + '")');
            }
        })();
        if (obj_targetObject_union1_error != null) {
            obj_targetObject_union1 = obj_targetObject_union1_error.message;
        }
        if (obj_targetObject_union0 && obj_targetObject_union1) {
            let message = 'Object doesn\'t match union (at "' + path_targetObject + '")';
            message += '\n' + obj_targetObject_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_targetObject_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_targetUrl = obj.targetUrl;
        const path_targetUrl = path + '.targetUrl';
        let obj_targetUrl_union0 = null;
        const obj_targetUrl_union0_error = (() => {
            if (typeof obj_targetUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_targetUrl + '" (at "' + path_targetUrl + '")');
            }
        })();
        if (obj_targetUrl_union0_error != null) {
            obj_targetUrl_union0 = obj_targetUrl_union0_error.message;
        }
        let obj_targetUrl_union1 = null;
        const obj_targetUrl_union1_error = (() => {
            if (obj_targetUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_targetUrl + '" (at "' + path_targetUrl + '")');
            }
        })();
        if (obj_targetUrl_union1_error != null) {
            obj_targetUrl_union1 = obj_targetUrl_union1_error.message;
        }
        if (obj_targetUrl_union0 && obj_targetUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_targetUrl + '")';
            message += '\n' + obj_targetUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_targetUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$b = function PlatformActionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'actionListContext',
                kind: 'Scalar',
            },
            {
                name: 'actionTarget',
                kind: 'Scalar',
            },
            {
                name: 'actionTargetType',
                kind: 'Scalar',
            },
            {
                name: 'apiName',
                kind: 'Scalar',
            },
            {
                name: 'externalId',
                kind: 'Scalar',
            },
            {
                name: 'iconUrl',
                kind: 'Scalar',
            },
            {
                name: 'id',
                kind: 'Scalar',
            },
            {
                name: 'isMassAction',
                kind: 'Scalar',
            },
            {
                name: 'label',
                kind: 'Scalar',
            },
            {
                name: 'primaryColor',
                kind: 'Scalar',
            },
            {
                name: 'relatedListRecordId',
                kind: 'Scalar',
            },
            {
                name: 'relatedSourceObject',
                kind: 'Scalar',
            },
            {
                name: 'section',
                kind: 'Scalar',
            },
            {
                name: 'sourceObject',
                kind: 'Scalar',
            },
            {
                name: 'subtype',
                kind: 'Scalar',
            },
            {
                name: 'targetObject',
                kind: 'Scalar',
            },
            {
                name: 'targetUrl',
                kind: 'Scalar',
            },
            {
                name: 'type',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$e(existing, incoming) {
    const existing_actionListContext = existing.actionListContext;
    const incoming_actionListContext = incoming.actionListContext;
    if (!(existing_actionListContext === incoming_actionListContext)) {
        return false;
    }
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_externalId = existing.externalId;
    const incoming_externalId = incoming.externalId;
    if (!(existing_externalId === incoming_externalId)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_isMassAction = existing.isMassAction;
    const incoming_isMassAction = incoming.isMassAction;
    if (!(existing_isMassAction === incoming_isMassAction)) {
        return false;
    }
    const existing_label = existing.label;
    const incoming_label = incoming.label;
    if (!(existing_label === incoming_label)) {
        return false;
    }
    const existing_sourceObject = existing.sourceObject;
    const incoming_sourceObject = incoming.sourceObject;
    if (!(existing_sourceObject === incoming_sourceObject)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    const existing_actionTarget = existing.actionTarget;
    const incoming_actionTarget = incoming.actionTarget;
    if (!(existing_actionTarget === incoming_actionTarget)) {
        return false;
    }
    const existing_actionTargetType = existing.actionTargetType;
    const incoming_actionTargetType = incoming.actionTargetType;
    if (!(existing_actionTargetType === incoming_actionTargetType)) {
        return false;
    }
    const existing_iconUrl = existing.iconUrl;
    const incoming_iconUrl = incoming.iconUrl;
    if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
    }
    const existing_primaryColor = existing.primaryColor;
    const incoming_primaryColor = incoming.primaryColor;
    if (!(existing_primaryColor === incoming_primaryColor)) {
        return false;
    }
    const existing_relatedListRecordId = existing.relatedListRecordId;
    const incoming_relatedListRecordId = incoming.relatedListRecordId;
    if (!(existing_relatedListRecordId === incoming_relatedListRecordId)) {
        return false;
    }
    const existing_relatedSourceObject = existing.relatedSourceObject;
    const incoming_relatedSourceObject = incoming.relatedSourceObject;
    if (!(existing_relatedSourceObject === incoming_relatedSourceObject)) {
        return false;
    }
    const existing_section = existing.section;
    const incoming_section = incoming.section;
    if (!(existing_section === incoming_section)) {
        return false;
    }
    const existing_subtype = existing.subtype;
    const incoming_subtype = incoming.subtype;
    if (!(existing_subtype === incoming_subtype)) {
        return false;
    }
    const existing_targetObject = existing.targetObject;
    const incoming_targetObject = incoming.targetObject;
    if (!(existing_targetObject === incoming_targetObject)) {
        return false;
    }
    const existing_targetUrl = existing.targetUrl;
    const incoming_targetUrl = incoming.targetUrl;
    if (!(existing_targetUrl === incoming_targetUrl)) {
        return false;
    }
    return true;
}

function validate$t(obj, path = 'EntityActionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actions = obj.actions;
        const path_actions = path + '.actions';
        if (!ArrayIsArray$1(obj_actions)) {
            return new TypeError('Expected "array" but received "' + typeof obj_actions + '" (at "' + path_actions + '")');
        }
        for (let i = 0; i < obj_actions.length; i++) {
            const obj_actions_item = obj_actions[i];
            const path_actions_item = path_actions + '[' + i + ']';
            const referencePlatformActionRepresentationValidationError = validate$s(obj_actions_item, path_actions_item);
            if (referencePlatformActionRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match PlatformActionRepresentation (at "' + path_actions_item + '")\n';
                message += referencePlatformActionRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_links = obj.links;
        const path_links = path + '.links';
        if (!ArrayIsArray$1(obj_links)) {
            return new TypeError('Expected "array" but received "' + typeof obj_links + '" (at "' + path_links + '")');
        }
        for (let i = 0; i < obj_links.length; i++) {
            const obj_links_item = obj_links[i];
            const path_links_item = path_links + '[' + i + ']';
            if (typeof obj_links_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_links_item + '" (at "' + path_links_item + '")');
            }
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$e(config) {
    return keyPrefix + 'EntityActionRepresentation:' + config.url;
}
function keyBuilderFromType$a(object) {
    const keyParams = {
        url: object.url
    };
    return keyBuilder$e(keyParams);
}
function normalize$c(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$c = function EntityActionRepresentationSelect() {
    const { selections: PlatformActionRepresentation__selections, opaque: PlatformActionRepresentation__opaque, } = select$b();
    return {
        kind: 'Fragment',
        private: [
            'links',
            'url'
        ],
        selections: [
            {
                name: 'actions',
                kind: 'Object',
                plural: true,
                selections: PlatformActionRepresentation__selections
            }
        ]
    };
};
function equals$f(existing, incoming) {
    const existing_url = existing.url;
    const incoming_url = incoming.url;
    if (!(existing_url === incoming_url)) {
        return false;
    }
    const existing_actions = existing.actions;
    const incoming_actions = incoming.actions;
    const equals_actions_items = equalsArray(existing_actions, incoming_actions, (existing_actions_item, incoming_actions_item) => {
        if (!(equals$e(existing_actions_item, incoming_actions_item))) {
            return false;
        }
    });
    if (equals_actions_items === false) {
        return false;
    }
    const existing_links = existing.links;
    const incoming_links = incoming.links;
    const equals_links_items = equalsArray(existing_links, incoming_links, (existing_links_item, incoming_links_item) => {
        if (!(existing_links_item === incoming_links_item)) {
            return false;
        }
    });
    if (equals_links_items === false) {
        return false;
    }
    return true;
}
const ingest$c = function EntityActionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$t(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$a(input);
    let incomingRecord = normalize$c(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$f(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

const TTL$3 = 300000;
function validate$u(obj, path = 'ActionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actions = obj.actions;
        const path_actions = path + '.actions';
        if (typeof obj_actions !== 'object' || ArrayIsArray$1(obj_actions) || obj_actions === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_actions + '" (at "' + path_actions + '")');
        }
        const obj_actions_keys = ObjectKeys$1(obj_actions);
        for (let i = 0; i < obj_actions_keys.length; i++) {
            const key = obj_actions_keys[i];
            const obj_actions_prop = obj_actions[key];
            const path_actions_prop = path_actions + '["' + key + '"]';
            if (typeof obj_actions_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_actions_prop + '" (at "' + path_actions_prop + '")');
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$d(input, existing, path, lds, store, timestamp) {
    const input_actions = input.actions;
    const input_actions_id = path.fullPath + '__actions';
    const input_actions_keys = Object.keys(input_actions);
    const input_actions_length = input_actions_keys.length;
    for (let i = 0; i < input_actions_length; i++) {
        const key = input_actions_keys[i];
        const input_actions_prop = input_actions[key];
        const input_actions_prop_id = input_actions_id + '__' + key;
        input_actions[key] = ingest$c(input_actions_prop, {
            fullPath: input_actions_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store);
    }
    return input;
}
const select$d = function ActionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag',
            'url'
        ],
        selections: [
            {
                name: 'actions',
                kind: 'Link',
                map: true,
                fragment: select$c()
            }
        ]
    };
};
function equals$g(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_url = existing.url;
    const incoming_url = incoming.url;
    if (!(existing_url === incoming_url)) {
        return false;
    }
    const existing_actions = existing.actions;
    const incoming_actions = incoming.actions;
    const equals_actions_props = equalsObject(existing_actions, incoming_actions, (existing_actions_prop, incoming_actions_prop) => {
        if (!(existing_actions_prop.__ref === incoming_actions_prop.__ref)) {
            return false;
        }
    });
    if (equals_actions_props === false) {
        return false;
    }
    return true;
}
const ingest$d = function ActionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$u(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$d(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$g(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function select$e(lds, params) {
    return select$d();
}
function keyBuilder$f(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'objectApiNames:' + params.urlParams.objectApiNames + ')';
}
function ingestSuccess$1(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$f(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$e(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$1(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$f(params);
    lds.storeIngestFetchResponse(key, error, TTL$3);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$b(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/actions/lookup/' + config.urlParams.objectApiNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$d,
        headers,
    };
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getObjectApiNamesArray(value) {
    const valueArray = isArray(value) ? value : [value];
    const array = [];
    for (let i = 0, len = valueArray.length; i < len; i += 1) {
        const item = valueArray[i];
        const apiName = getObjectApiName(item);
        if (apiName === undefined) {
            return undefined;
        }
        push.call(array, apiName);
    }
    if (array.length === 0) {
        return undefined;
    }
    return dedupe(array);
}

/**
 * Returns the object API name.
 * @param value The value from which to get the object API name.
 * @returns The object API name.
 */
function getSortedObjectApiNamesArray(value) {
    const unsortedArray = getObjectApiNamesArray(value);
    return unsortedArray === undefined ? undefined : unsortedArray.sort();
}

var FormFactor;
(function (FormFactor) {
    FormFactor["Large"] = "Large";
    FormFactor["Medium"] = "Medium";
    FormFactor["Small"] = "Small";
})(FormFactor || (FormFactor = {}));

function coerceFormFactor(form) {
    if (form === FormFactor.Large || form === FormFactor.Medium || form === FormFactor.Small) {
        return form;
    }
    return undefined;
}

const adapterName$1 = 'getLookupActions';
const getLookupActions_ConfigPropertyNames = {
    displayName: 'getLookupActions',
    parameters: {
        required: ['objectApiNames'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$4(config) {
    return {
        urlParams: {
            objectApiNames: config.objectApiNames
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$7(config) {
    const coercedConfig = {};
    const objectApiNames = getSortedObjectApiNamesArray(config.objectApiNames);
    if (objectApiNames !== undefined) {
        coercedConfig.objectApiNames = objectApiNames;
    }
    const actionTypes = toSortedStringArray(config.actionTypes);
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function typeCheckConfig$7(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiNames = untrustedConfig.objectApiNames;
    if (ArrayIsArray(untrustedConfig_objectApiNames)) {
        const untrustedConfig_objectApiNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_objectApiNames.length; i < arrayLength; i++) {
            const untrustedConfig_objectApiNames_item = untrustedConfig_objectApiNames[i];
            if (typeof untrustedConfig_objectApiNames_item === 'string') {
                untrustedConfig_objectApiNames_array.push(untrustedConfig_objectApiNames_item);
            }
        }
        config.objectApiNames = untrustedConfig_objectApiNames_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$7(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$7(untrustedConfig);
    const config = typeCheckConfig$7(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$6(lds, config) {
    const resourceParams = createResourceParams$4(config);
    const selector = {
        recordId: keyBuilder$f(resourceParams),
        node: select$e(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$4(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$1(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$1(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$4(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$1(lds, config, resourceParams, response) {
    const snapshot = ingestError$1(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$4(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$4(lds, config, override) {
    const resourceParams = createResourceParams$4(config);
    const request = createResourceRequest$b(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$1(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$1(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$3(lds, config, snapshot) {
    const resourceParams = createResourceParams$4(config);
    const request = createResourceRequest$b(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$1(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$1(lds, config, resourceParams, response);
    });
}
const getLookupActionsAdapterFactory = (lds) => function getLookupActions(untrustedConfig) {
    const config = validateAdapterConfig$7(untrustedConfig, getLookupActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$6(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$3(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$4(lds, config);
};

function select$f(lds, params) {
    return select$d();
}
function keyBuilder$g(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'apiNames:' + params.queryParams.apiNames + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'retrievalMode:' + params.queryParams.retrievalMode + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
}
function ingestSuccess$2(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$g(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$f(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$2(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$g(params);
    lds.storeIngestFetchResponse(key, error, TTL$3);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$c(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$d,
        headers,
    };
}

function toSortedStringArrayAllowEmpty(value) {
    const valueArray = isArray(value) ? value : [value];
    if (valueArray.length === 0) {
        return valueArray;
    }
    return toSortedStringArray(valueArray);
}

const adapterName$2 = 'getRecordActions';
const oneOfConfigPropertiesIdentifier$1 = [
    'sections',
    'apiNames'
];
const getRecordActions_ConfigPropertyNames = {
    displayName: 'getRecordActions',
    parameters: {
        required: ['recordIds'],
        optional: ['actionTypes', 'apiNames', 'formFactor', 'retrievalMode', 'sections']
    }
};
function createResourceParams$5(config) {
    return {
        urlParams: {
            recordIds: config.recordIds
        },
        queryParams: {
            actionTypes: config.actionTypes, apiNames: config.apiNames, formFactor: config.formFactor, retrievalMode: config.retrievalMode, sections: config.sections
        }
    };
}
function coerceConfig$8(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const apiNames = toSortedStringArrayAllowEmpty(config.apiNames);
    if (apiNames !== undefined) {
        coercedConfig.apiNames = apiNames;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const retrievalMode = config.retrievalMode;
    if (retrievalMode !== undefined) {
        coercedConfig.retrievalMode = retrievalMode;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function typeCheckConfig$8(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_apiNames = untrustedConfig.apiNames;
    if (ArrayIsArray(untrustedConfig_apiNames)) {
        const untrustedConfig_apiNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_apiNames.length; i < arrayLength; i++) {
            const untrustedConfig_apiNames_item = untrustedConfig_apiNames[i];
            if (typeof untrustedConfig_apiNames_item === 'string') {
                untrustedConfig_apiNames_array.push(untrustedConfig_apiNames_item);
            }
        }
        config.apiNames = untrustedConfig_apiNames_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_retrievalMode = untrustedConfig.retrievalMode;
    if (typeof untrustedConfig_retrievalMode === 'string') {
        config.retrievalMode = untrustedConfig_retrievalMode;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$8(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames, oneOfConfigPropertiesIdentifier$1);
    }
    const coercedConfig = coerceConfig$8(untrustedConfig);
    const config = typeCheckConfig$8(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    if (config.sections === undefined &&
        config.apiNames === undefined) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$7(lds, config) {
    const resourceParams = createResourceParams$5(config);
    const selector = {
        recordId: keyBuilder$g(resourceParams),
        node: select$f(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$5(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$2(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$2(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$5(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$2(lds, config, resourceParams, response) {
    const snapshot = ingestError$2(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$5(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$5(lds, config, override) {
    const resourceParams = createResourceParams$5(config);
    const request = createResourceRequest$c(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$2(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$2(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$4(lds, config, snapshot) {
    const resourceParams = createResourceParams$5(config);
    const request = createResourceRequest$c(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$2(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$2(lds, config, resourceParams, response);
    });
}
const getRecordActionsAdapterFactory = (lds) => function getRecordActions(untrustedConfig) {
    const config = validateAdapterConfig$8(untrustedConfig, getRecordActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$7(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$4(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$5(lds, config);
};

function select$g(lds, params) {
    return select$d();
}
function keyBuilder$h(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ')';
}
function ingestSuccess$3(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$h(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$g(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$3(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$h(params);
    lds.storeIngestFetchResponse(key, error, TTL$3);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$d(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/record-edit',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$d,
        headers,
    };
}

const adapterName$3 = 'getRecordEditActions';
const getRecordEditActions_ConfigPropertyNames = {
    displayName: 'getRecordEditActions',
    parameters: {
        required: ['recordIds'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$6(config) {
    return {
        urlParams: {
            recordIds: config.recordIds
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$9(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function typeCheckConfig$9(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$9(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$9(untrustedConfig);
    const config = typeCheckConfig$9(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$8(lds, config) {
    const resourceParams = createResourceParams$6(config);
    const selector = {
        recordId: keyBuilder$h(resourceParams),
        node: select$g(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$6(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$3(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$3(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$6(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$3(lds, config, resourceParams, response) {
    const snapshot = ingestError$3(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$6(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$6(lds, config, override) {
    const resourceParams = createResourceParams$6(config);
    const request = createResourceRequest$d(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$3(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$3(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$5(lds, config, snapshot) {
    const resourceParams = createResourceParams$6(config);
    const request = createResourceRequest$d(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$3(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$3(lds, config, resourceParams, response);
    });
}
const getRecordEditActionsAdapterFactory = (lds) => function getRecordEditActions(untrustedConfig) {
    const config = validateAdapterConfig$9(untrustedConfig, getRecordEditActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$8(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$5(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$6(lds, config);
};

function select$h(lds, params) {
    return select$d();
}
function keyBuilder$i(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListId:' + params.urlParams.relatedListId + ')';
}
function ingestSuccess$4(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$i(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$h(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$4(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$i(params);
    lds.storeIngestFetchResponse(key, error, TTL$3);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$e(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$d,
        headers,
    };
}

function validate$v(obj, path = 'ActionBatchResultRepresentation') {
    const v_error = (() => {
        const path_statusCode = path + '.statusCode';
        const obj_statusCode = obj.statusCode;
        const path_result = path + '.result';
        const obj_result = obj.result;
        if (typeof obj_statusCode !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
        switch (obj_statusCode) {
            case 200: {
                if (typeof obj_result !== 'object') {
                    return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
                }
            }
            default: {
                if (obj_result === undefined) {
                    return new TypeError('Expected "' + path_result + '" to be present but received "undefined" (at "' + path_result + '")');
                }
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$e(input, existing, path, lds, store, timestamp) {
    const input_result = input.result;
    const input_result_id = path.fullPath + '__result';
    input.result = ingest$d(input_result, {
        fullPath: input_result_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$h(existing, incoming) {
    const existing_statusCode = existing.statusCode;
    const incoming_statusCode = incoming.statusCode;
    if (!(existing_statusCode === incoming_statusCode)) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
    }
    return true;
}
const ingest$e = function ActionBatchResultRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$v(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$e(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$h(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$w(obj, path = 'ActionBatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_results = obj.results;
        const path_results = path + '.results';
        if (!ArrayIsArray$1(obj_results)) {
            return new TypeError('Expected "array" but received "' + typeof obj_results + '" (at "' + path_results + '")');
        }
        for (let i = 0; i < obj_results.length; i++) {
            const obj_results_item = obj_results[i];
            const path_results_item = path_results + '[' + i + ']';
            if (typeof obj_results_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_results_item + '" (at "' + path_results_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$f(input, existing, path, lds, store, timestamp) {
    const input_results = input.results;
    const input_results_id = path.fullPath + '__results';
    for (let i = 0; i < input_results.length; i++) {
        const input_results_item = input_results[i];
        let input_results_item_id = input_results_id + '__' + i;
        input_results[i] = ingest$e(input_results_item, {
            fullPath: input_results_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$i(existing, incoming) {
    const existing_results = existing.results;
    const incoming_results = incoming.results;
    const equals_results_items = equalsArray(existing_results, incoming_results, (existing_results_item, incoming_results_item) => {
        if (!(existing_results_item.__ref === incoming_results_item.__ref)) {
            return false;
        }
    });
    if (equals_results_items === false) {
        return false;
    }
    return true;
}
const ingest$f = function ActionBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$w(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$f(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$i(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function createChildResourceParams(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListIds.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListIds[index];
        childConfigs.push({
            urlParams: {
                recordIds: resourceParams.urlParams.recordIds,
                relatedListId: item
            },
            queryParams: {
                actionTypes: resourceParams.queryParams.actionTypes,
                formFactor: resourceParams.queryParams.formFactor,
                sections: resourceParams.queryParams.sections
            }
        });
    }
    return childConfigs;
}
function select$i(lds, resourceParams) {
    const childResources = createChildResourceParams(resourceParams);
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$i(childResource);
                const childFragment = select$h();
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                switch (childSnapshot.state) {
                    case 'Fulfilled':
                        reader.seenIds[childKey] = true;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        reader.markMissing();
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                    case 'Stale':
                        reader.markStale();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function keyBuilder$j(params) {
    return keyPrefix + 'ActionBatchRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListIds:' + params.urlParams.relatedListIds + ')';
}
function ingestSuccess$5(lds, resourceParams, request, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const snapshotStateFulfilled = 'Fulfilled';
    const key = keyBuilder$j(resourceParams);
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const result = childEnvelopes[index];
        const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
        if (result.statusCode === 200) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: true,
                statusText: childStatusCodeText,
                headers: {},
            };
            const childSnapshot = ingestSuccess$4(lds, childResourceParams, createResourceRequest$e(childResourceParams), childResponse);
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
        else {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$4(lds, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [keyBuilder$i(childResourceParams)]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    ObjectFreeze(childSnapshotData);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$i(lds, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$5(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$j(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$f(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list/batch/' + config.urlParams.relatedListIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$f,
        headers,
    };
}

const adapterName$4 = 'getRelatedListsActions';
const getRelatedListsActions_ConfigPropertyNames = {
    displayName: 'getRelatedListsActions',
    parameters: {
        required: ['recordIds', 'relatedListIds'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$7(config) {
    return {
        urlParams: {
            recordIds: config.recordIds, relatedListIds: config.relatedListIds
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$a(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const relatedListIds = toSortedStringArray(config.relatedListIds);
    if (relatedListIds !== undefined) {
        coercedConfig.relatedListIds = relatedListIds;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function typeCheckConfig$a(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_relatedListIds = untrustedConfig.relatedListIds;
    if (ArrayIsArray(untrustedConfig_relatedListIds)) {
        const untrustedConfig_relatedListIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListIds.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListIds_item = untrustedConfig_relatedListIds[i];
            if (typeof untrustedConfig_relatedListIds_item === 'string') {
                untrustedConfig_relatedListIds_array.push(untrustedConfig_relatedListIds_item);
            }
        }
        config.relatedListIds = untrustedConfig_relatedListIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$a(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$a(untrustedConfig);
    const config = typeCheckConfig$a(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$9(lds, config) {
    const resourceParams = createResourceParams$7(config);
    const selector = {
        recordId: keyBuilder$j(resourceParams),
        node: select$i(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$7(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$4(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$5(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$7(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$4(lds, config, resourceParams, response) {
    const snapshot = ingestError$5(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$7(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$7(lds, config, override) {
    const resourceParams = createResourceParams$7(config);
    const request = createResourceRequest$f(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$4(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$4(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$6(lds, config, snapshot) {
    const resourceParams = createResourceParams$7(config);
    const request = createResourceRequest$f(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$4(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$4(lds, config, resourceParams, response);
    });
}
const getRelatedListsActionsAdapterFactory = (lds) => function getRelatedListsActions(untrustedConfig) {
    const config = validateAdapterConfig$a(untrustedConfig, getRelatedListsActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$9(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$6(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$7(lds, config);
};

const adapterName$5 = 'getRelatedListActions';
const getRelatedListActions_ConfigPropertyNames = {
    displayName: 'getRelatedListActions',
    parameters: {
        required: ['recordIds', 'relatedListId'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$8(config) {
    return {
        urlParams: {
            recordIds: config.recordIds, relatedListId: config.relatedListId
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$b(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const relatedListId = config.relatedListId;
    if (relatedListId !== undefined) {
        coercedConfig.relatedListId = relatedListId;
    }
    const actionTypes = config.actionTypes;
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function typeCheckConfig$b(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_relatedListId = untrustedConfig.relatedListId;
    if (typeof untrustedConfig_relatedListId === 'string') {
        config.relatedListId = untrustedConfig_relatedListId;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$b(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$b(untrustedConfig);
    const config = typeCheckConfig$b(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$a(lds, config) {
    const resourceParams = createResourceParams$8(config);
    const selector = {
        recordId: keyBuilder$i(resourceParams),
        node: select$h(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$8(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$5(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$4(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$8(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$5(lds, config, resourceParams, response) {
    const snapshot = ingestError$4(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$8(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$8(lds, config, override) {
    const resourceParams = createResourceParams$8(config);
    const request = createResourceRequest$e(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$5(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$5(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$7(lds, config, snapshot) {
    const resourceParams = createResourceParams$8(config);
    const request = createResourceRequest$e(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$5(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$5(lds, config, resourceParams, response);
    });
}
const getRelatedListActionsAdapterFactory = (lds) => function getRelatedListActions(untrustedConfig) {
    const config = validateAdapterConfig$b(untrustedConfig, getRelatedListActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$a(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$7(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$8(lds, config);
};

function select$j(lds, params) {
    return select$d();
}
function keyBuilder$k(params) {
    return keyPrefix + 'ActionRepresentation(' + 'actionTypes:' + params.queryParams.actionTypes + ',' + 'formFactor:' + params.queryParams.formFactor + ',' + 'sections:' + params.queryParams.sections + ',' + 'recordIds:' + params.urlParams.recordIds + ',' + 'relatedListRecordIds:' + params.urlParams.relatedListRecordIds + ')';
}
function ingestSuccess$6(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$k(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$j(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$6(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$k(params);
    lds.storeIngestFetchResponse(key, error, TTL$3);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$g(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/actions/record/' + config.urlParams.recordIds + '/related-list-record/' + config.urlParams.relatedListRecordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$d,
        headers,
    };
}

const adapterName$6 = 'getRelatedListRecordActions';
const getRelatedListRecordActions_ConfigPropertyNames = {
    displayName: 'getRelatedListRecordActions',
    parameters: {
        required: ['recordIds', 'relatedListRecordIds'],
        optional: ['actionTypes', 'formFactor', 'sections']
    }
};
function createResourceParams$9(config) {
    return {
        urlParams: {
            recordIds: config.recordIds, relatedListRecordIds: config.relatedListRecordIds
        },
        queryParams: {
            actionTypes: config.actionTypes, formFactor: config.formFactor, sections: config.sections
        }
    };
}
function coerceConfig$c(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const relatedListRecordIds = getRecordId18Array(config.relatedListRecordIds);
    if (relatedListRecordIds !== undefined) {
        coercedConfig.relatedListRecordIds = relatedListRecordIds;
    }
    const actionTypes = toSortedStringArray(config.actionTypes);
    if (actionTypes !== undefined) {
        coercedConfig.actionTypes = actionTypes;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const sections = toSortedStringArray(config.sections);
    if (sections !== undefined) {
        coercedConfig.sections = sections;
    }
    return coercedConfig;
}
function typeCheckConfig$c(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_relatedListRecordIds = untrustedConfig.relatedListRecordIds;
    if (ArrayIsArray(untrustedConfig_relatedListRecordIds)) {
        const untrustedConfig_relatedListRecordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListRecordIds.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListRecordIds_item = untrustedConfig_relatedListRecordIds[i];
            if (typeof untrustedConfig_relatedListRecordIds_item === 'string') {
                untrustedConfig_relatedListRecordIds_array.push(untrustedConfig_relatedListRecordIds_item);
            }
        }
        config.relatedListRecordIds = untrustedConfig_relatedListRecordIds_array;
    }
    const untrustedConfig_actionTypes = untrustedConfig.actionTypes;
    if (ArrayIsArray(untrustedConfig_actionTypes)) {
        const untrustedConfig_actionTypes_array = [];
        for (let i = 0, arrayLength = untrustedConfig_actionTypes.length; i < arrayLength; i++) {
            const untrustedConfig_actionTypes_item = untrustedConfig_actionTypes[i];
            if (typeof untrustedConfig_actionTypes_item === 'string') {
                untrustedConfig_actionTypes_array.push(untrustedConfig_actionTypes_item);
            }
        }
        config.actionTypes = untrustedConfig_actionTypes_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_sections = untrustedConfig.sections;
    if (ArrayIsArray(untrustedConfig_sections)) {
        const untrustedConfig_sections_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sections.length; i < arrayLength; i++) {
            const untrustedConfig_sections_item = untrustedConfig_sections[i];
            if (typeof untrustedConfig_sections_item === 'string') {
                untrustedConfig_sections_array.push(untrustedConfig_sections_item);
            }
        }
        config.sections = untrustedConfig_sections_array;
    }
    return config;
}
function validateAdapterConfig$c(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$c(untrustedConfig);
    const config = typeCheckConfig$c(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$b(lds, config) {
    const resourceParams = createResourceParams$9(config);
    const selector = {
        recordId: keyBuilder$k(resourceParams),
        node: select$j(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$9(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$6(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$6(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$9(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$6(lds, config, resourceParams, response) {
    const snapshot = ingestError$6(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$9(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$9(lds, config, override) {
    const resourceParams = createResourceParams$9(config);
    const request = createResourceRequest$g(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$6(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$6(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$8(lds, config, snapshot) {
    const resourceParams = createResourceParams$9(config);
    const request = createResourceRequest$g(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$6(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$6(lds, config, resourceParams, response);
    });
}
const getRelatedListRecordActionsAdapterFactory = (lds) => function getRelatedListRecordActions(untrustedConfig) {
    const config = validateAdapterConfig$c(untrustedConfig, getRelatedListRecordActions_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$b(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$8(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$9(lds, config);
};

function validate$x(obj, path = 'PageReferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_attributes = obj.attributes;
        const path_attributes = path + '.attributes';
        if (typeof obj_attributes !== 'object' || ArrayIsArray$1(obj_attributes) || obj_attributes === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_attributes + '" (at "' + path_attributes + '")');
        }
        const obj_attributes_keys = ObjectKeys$1(obj_attributes);
        for (let i = 0; i < obj_attributes_keys.length; i++) {
            const key = obj_attributes_keys[i];
            const obj_attributes_prop = obj_attributes[key];
        }
        const obj_state = obj.state;
        const path_state = path + '.state';
        if (typeof obj_state !== 'object' || ArrayIsArray$1(obj_state) || obj_state === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_state + '" (at "' + path_state + '")');
        }
        const obj_state_keys = ObjectKeys$1(obj_state);
        for (let i = 0; i < obj_state_keys.length; i++) {
            const key = obj_state_keys[i];
            const obj_state_prop = obj_state[key];
            const path_state_prop = path_state + '["' + key + '"]';
            if (typeof obj_state_prop !== 'object' || ArrayIsArray$1(obj_state_prop) || obj_state_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_state_prop + '" (at "' + path_state_prop + '")');
            }
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$g(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$k = function PageReferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        opaque: true
    };
};
function equals$j(existing, incoming) {
    if (JSONStrinify(incoming) !== JSONStrinify(existing)) {
        return false;
    }
    return true;
}
function deepFreeze$i(input) {
    const input_attributes = input.attributes;
    const input_attributes_keys = Object.keys(input_attributes);
    const input_attributes_length = input_attributes_keys.length;
    for (let i = 0; i < input_attributes_length; i++) {
        const key = input_attributes_keys[i];
        const input_attributes_prop = input_attributes[key];
        deepFreeze(input_attributes_prop);
    }
    ObjectFreeze$1(input_attributes);
    const input_state = input.state;
    const input_state_keys = Object.keys(input_state);
    const input_state_length = input_state_keys.length;
    for (let i = 0; i < input_state_length; i++) {
        const key = input_state_keys[i];
        const input_state_prop = input_state[key];
        ObjectFreeze$1(input_state_prop);
    }
    ObjectFreeze$1(input_state);
    ObjectFreeze$1(input);
}
const ingest$g = function PageReferenceRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$x(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$g(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    deepFreeze$i(input);
    if (existingRecord === undefined || equals$j(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$y(obj, path = 'NavItemRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_availableInClassic = obj.availableInClassic;
        const path_availableInClassic = path + '.availableInClassic';
        if (typeof obj_availableInClassic !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_availableInClassic + '" (at "' + path_availableInClassic + '")');
        }
        const obj_availableInLightning = obj.availableInLightning;
        const path_availableInLightning = path + '.availableInLightning';
        if (typeof obj_availableInLightning !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_availableInLightning + '" (at "' + path_availableInLightning + '")');
        }
        const obj_color = obj.color;
        const path_color = path + '.color';
        if (typeof obj_color !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_color + '" (at "' + path_color + '")');
        }
        const obj_content = obj.content;
        const path_content = path + '.content';
        let obj_content_union0 = null;
        const obj_content_union0_error = (() => {
            if (typeof obj_content !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_content + '" (at "' + path_content + '")');
            }
        })();
        if (obj_content_union0_error != null) {
            obj_content_union0 = obj_content_union0_error.message;
        }
        let obj_content_union1 = null;
        const obj_content_union1_error = (() => {
            if (obj_content !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_content + '" (at "' + path_content + '")');
            }
        })();
        if (obj_content_union1_error != null) {
            obj_content_union1 = obj_content_union1_error.message;
        }
        if (obj_content_union0 && obj_content_union1) {
            let message = 'Object doesn\'t match union (at "' + path_content + '")';
            message += '\n' + obj_content_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_content_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_custom = obj.custom;
        const path_custom = path + '.custom';
        if (typeof obj_custom !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_custom + '" (at "' + path_custom + '")');
        }
        const obj_developerName = obj.developerName;
        const path_developerName = path + '.developerName';
        if (typeof obj_developerName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_developerName + '" (at "' + path_developerName + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        if (typeof obj_iconUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_itemType = obj.itemType;
        const path_itemType = path + '.itemType';
        if (typeof obj_itemType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_itemType + '" (at "' + path_itemType + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_objectLabel = obj.objectLabel;
        const path_objectLabel = path + '.objectLabel';
        let obj_objectLabel_union0 = null;
        const obj_objectLabel_union0_error = (() => {
            if (typeof obj_objectLabel !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_objectLabel + '" (at "' + path_objectLabel + '")');
            }
        })();
        if (obj_objectLabel_union0_error != null) {
            obj_objectLabel_union0 = obj_objectLabel_union0_error.message;
        }
        let obj_objectLabel_union1 = null;
        const obj_objectLabel_union1_error = (() => {
            if (obj_objectLabel !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_objectLabel + '" (at "' + path_objectLabel + '")');
            }
        })();
        if (obj_objectLabel_union1_error != null) {
            obj_objectLabel_union1 = obj_objectLabel_union1_error.message;
        }
        if (obj_objectLabel_union0 && obj_objectLabel_union1) {
            let message = 'Object doesn\'t match union (at "' + path_objectLabel + '")';
            message += '\n' + obj_objectLabel_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_objectLabel_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectLabelPlural = obj.objectLabelPlural;
        const path_objectLabelPlural = path + '.objectLabelPlural';
        let obj_objectLabelPlural_union0 = null;
        const obj_objectLabelPlural_union0_error = (() => {
            if (typeof obj_objectLabelPlural !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_objectLabelPlural + '" (at "' + path_objectLabelPlural + '")');
            }
        })();
        if (obj_objectLabelPlural_union0_error != null) {
            obj_objectLabelPlural_union0 = obj_objectLabelPlural_union0_error.message;
        }
        let obj_objectLabelPlural_union1 = null;
        const obj_objectLabelPlural_union1_error = (() => {
            if (obj_objectLabelPlural !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_objectLabelPlural + '" (at "' + path_objectLabelPlural + '")');
            }
        })();
        if (obj_objectLabelPlural_union1_error != null) {
            obj_objectLabelPlural_union1 = obj_objectLabelPlural_union1_error.message;
        }
        if (obj_objectLabelPlural_union0 && obj_objectLabelPlural_union1) {
            let message = 'Object doesn\'t match union (at "' + path_objectLabelPlural + '")';
            message += '\n' + obj_objectLabelPlural_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_objectLabelPlural_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_pageReference = obj.pageReference;
        const path_pageReference = path + '.pageReference';
        let obj_pageReference_union0 = null;
        const obj_pageReference_union0_error = (() => {
            if (typeof obj_pageReference !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_pageReference + '" (at "' + path_pageReference + '")');
            }
        })();
        if (obj_pageReference_union0_error != null) {
            obj_pageReference_union0 = obj_pageReference_union0_error.message;
        }
        let obj_pageReference_union1 = null;
        const obj_pageReference_union1_error = (() => {
            if (obj_pageReference !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_pageReference + '" (at "' + path_pageReference + '")');
            }
        })();
        if (obj_pageReference_union1_error != null) {
            obj_pageReference_union1 = obj_pageReference_union1_error.message;
        }
        if (obj_pageReference_union0 && obj_pageReference_union1) {
            let message = 'Object doesn\'t match union (at "' + path_pageReference + '")';
            message += '\n' + obj_pageReference_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_pageReference_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_standardType = obj.standardType;
        const path_standardType = path + '.standardType';
        let obj_standardType_union0 = null;
        const obj_standardType_union0_error = (() => {
            if (typeof obj_standardType !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_standardType + '" (at "' + path_standardType + '")');
            }
        })();
        if (obj_standardType_union0_error != null) {
            obj_standardType_union0 = obj_standardType_union0_error.message;
        }
        let obj_standardType_union1 = null;
        const obj_standardType_union1_error = (() => {
            if (obj_standardType !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_standardType + '" (at "' + path_standardType + '")');
            }
        })();
        if (obj_standardType_union1_error != null) {
            obj_standardType_union1 = obj_standardType_union1_error.message;
        }
        if (obj_standardType_union0 && obj_standardType_union1) {
            let message = 'Object doesn\'t match union (at "' + path_standardType + '")';
            message += '\n' + obj_standardType_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_standardType_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$l(config) {
    return keyPrefix + 'NavItemRepresentation:' + config.developerName;
}
function keyBuilderFromType$b(object) {
    const keyParams = {
        developerName: object.developerName
    };
    return keyBuilder$l(keyParams);
}
function normalize$h(input, existing, path, lds, store, timestamp) {
    const input_pageReference = input.pageReference;
    const input_pageReference_id = path.fullPath + '__pageReference';
    if (input_pageReference !== null && typeof input_pageReference === 'object') {
        input.pageReference = ingest$g(input_pageReference, {
            fullPath: input_pageReference_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store);
    }
    return input;
}
const select$l = function NavItemRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'availableInClassic',
                kind: 'Scalar',
            },
            {
                name: 'availableInLightning',
                kind: 'Scalar',
            },
            {
                name: 'color',
                kind: 'Scalar',
            },
            {
                name: 'content',
                kind: 'Scalar',
            },
            {
                name: 'custom',
                kind: 'Scalar',
            },
            {
                name: 'developerName',
                kind: 'Scalar',
            },
            {
                name: 'iconUrl',
                kind: 'Scalar',
            },
            {
                name: 'id',
                kind: 'Scalar',
            },
            {
                name: 'itemType',
                kind: 'Scalar',
            },
            {
                name: 'label',
                kind: 'Scalar',
            },
            {
                name: 'objectApiName',
                kind: 'Scalar',
            },
            {
                name: 'objectLabel',
                kind: 'Scalar',
            },
            {
                name: 'objectLabelPlural',
                kind: 'Scalar',
            },
            {
                name: 'pageReference',
                kind: 'Link',
                nullable: true,
                fragment: select$k()
            },
            {
                name: 'standardType',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$k(existing, incoming) {
    const existing_availableInClassic = existing.availableInClassic;
    const incoming_availableInClassic = incoming.availableInClassic;
    if (!(existing_availableInClassic === incoming_availableInClassic)) {
        return false;
    }
    const existing_availableInLightning = existing.availableInLightning;
    const incoming_availableInLightning = incoming.availableInLightning;
    if (!(existing_availableInLightning === incoming_availableInLightning)) {
        return false;
    }
    const existing_custom = existing.custom;
    const incoming_custom = incoming.custom;
    if (!(existing_custom === incoming_custom)) {
        return false;
    }
    const existing_color = existing.color;
    const incoming_color = incoming.color;
    if (!(existing_color === incoming_color)) {
        return false;
    }
    const existing_developerName = existing.developerName;
    const incoming_developerName = incoming.developerName;
    if (!(existing_developerName === incoming_developerName)) {
        return false;
    }
    const existing_iconUrl = existing.iconUrl;
    const incoming_iconUrl = incoming.iconUrl;
    if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
    }
    const existing_itemType = existing.itemType;
    const incoming_itemType = incoming.itemType;
    if (!(existing_itemType === incoming_itemType)) {
        return false;
    }
    const existing_label = existing.label;
    const incoming_label = incoming.label;
    if (!(existing_label === incoming_label)) {
        return false;
    }
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_content = existing.content;
    const incoming_content = incoming.content;
    if (!(existing_content === incoming_content)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_objectLabel = existing.objectLabel;
    const incoming_objectLabel = incoming.objectLabel;
    if (!(existing_objectLabel === incoming_objectLabel)) {
        return false;
    }
    const existing_objectLabelPlural = existing.objectLabelPlural;
    const incoming_objectLabelPlural = incoming.objectLabelPlural;
    if (!(existing_objectLabelPlural === incoming_objectLabelPlural)) {
        return false;
    }
    const existing_pageReference = existing.pageReference;
    const incoming_pageReference = incoming.pageReference;
    if (!(existing_pageReference === incoming_pageReference
        || (existing_pageReference != null &&
            incoming_pageReference != null &&
            existing_pageReference.__ref != null &&
            incoming_pageReference.__ref != null &&
            existing_pageReference.__ref === incoming_pageReference.__ref))) {
        return false;
    }
    const existing_standardType = existing.standardType;
    const incoming_standardType = incoming.standardType;
    if (!(existing_standardType === incoming_standardType)) {
        return false;
    }
    return true;
}
const ingest$h = function NavItemRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$y(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$b(input);
    let incomingRecord = normalize$h(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$k(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 120000);
    return createLink(key);
};

function validate$z(obj, path = 'DuplicateRuleFilterItemRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_field = obj.field;
        const path_field = path + '.field';
        if (typeof obj_field !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_field + '" (at "' + path_field + '")');
        }
        const obj_operation = obj.operation;
        const path_operation = path + '.operation';
        if (typeof obj_operation !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_operation + '" (at "' + path_operation + '")');
        }
        const obj_sortOrder = obj.sortOrder;
        const path_sortOrder = path + '.sortOrder';
        if (typeof obj_sortOrder !== 'number' || (typeof obj_sortOrder === 'number' && Math.floor(obj_sortOrder) !== obj_sortOrder)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_sortOrder + '" (at "' + path_sortOrder + '")');
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        if (typeof obj_value !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$m = function DuplicateRuleFilterItemRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'field',
                kind: 'Scalar',
            },
            {
                name: 'operation',
                kind: 'Scalar',
            },
            {
                name: 'sortOrder',
                kind: 'Scalar',
            },
            {
                name: 'value',
                kind: 'Scalar',
            }
        ]
    };
};

function validate$A(obj, path = 'DuplicateRuleFilterRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_booleanFilter = obj.booleanFilter;
        const path_booleanFilter = path + '.booleanFilter';
        if (typeof obj_booleanFilter !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_booleanFilter + '" (at "' + path_booleanFilter + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_filterItems = obj.filterItems;
        const path_filterItems = path + '.filterItems';
        if (!ArrayIsArray$1(obj_filterItems)) {
            return new TypeError('Expected "array" but received "' + typeof obj_filterItems + '" (at "' + path_filterItems + '")');
        }
        for (let i = 0; i < obj_filterItems.length; i++) {
            const obj_filterItems_item = obj_filterItems[i];
            const path_filterItems_item = path_filterItems + '[' + i + ']';
            const referenceDuplicateRuleFilterItemRepresentationValidationError = validate$z(obj_filterItems_item, path_filterItems_item);
            if (referenceDuplicateRuleFilterItemRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateRuleFilterItemRepresentation (at "' + path_filterItems_item + '")\n';
                message += referenceDuplicateRuleFilterItemRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_ruleCritera = obj.ruleCritera;
        const path_ruleCritera = path + '.ruleCritera';
        if (typeof obj_ruleCritera !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_ruleCritera + '" (at "' + path_ruleCritera + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$n = function DuplicateRuleFilterRepresentationSelect() {
    const { selections: DuplicateRuleFilterItemRepresentation__selections, opaque: DuplicateRuleFilterItemRepresentation__opaque, } = select$m();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'booleanFilter',
                kind: 'Scalar',
            },
            {
                name: 'filterItems',
                kind: 'Object',
                plural: true,
                selections: DuplicateRuleFilterItemRepresentation__selections
            },
            {
                name: 'ruleCritera',
                kind: 'Scalar',
            }
        ]
    };
};

function validate$B(obj, path = 'MatchRuleRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_matchEngine = obj.matchEngine;
        const path_matchEngine = path + '.matchEngine';
        if (typeof obj_matchEngine !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_matchEngine + '" (at "' + path_matchEngine + '")');
        }
        const obj_matchFields = obj.matchFields;
        const path_matchFields = path + '.matchFields';
        if (!ArrayIsArray$1(obj_matchFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_matchFields + '" (at "' + path_matchFields + '")');
        }
        for (let i = 0; i < obj_matchFields.length; i++) {
            const obj_matchFields_item = obj_matchFields[i];
            const path_matchFields_item = path_matchFields + '[' + i + ']';
            if (typeof obj_matchFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_matchFields_item + '" (at "' + path_matchFields_item + '")');
            }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$o = function MatchRuleRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'matchEngine',
                kind: 'Scalar',
            },
            {
                name: 'matchFields',
                kind: 'Scalar',
                plural: true,
            },
            {
                name: 'name',
                kind: 'Scalar',
            },
            {
                name: 'objectApiName',
                kind: 'Scalar',
            }
        ]
    };
};

function validate$C(obj, path = 'DuplicateRuleRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_actionOnInsert = obj.actionOnInsert;
        const path_actionOnInsert = path + '.actionOnInsert';
        if (typeof obj_actionOnInsert !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionOnInsert + '" (at "' + path_actionOnInsert + '")');
        }
        const obj_actionOnUpdate = obj.actionOnUpdate;
        const path_actionOnUpdate = path + '.actionOnUpdate';
        if (typeof obj_actionOnUpdate !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_actionOnUpdate + '" (at "' + path_actionOnUpdate + '")');
        }
        const obj_active = obj.active;
        const path_active = path + '.active';
        if (typeof obj_active !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_active + '" (at "' + path_active + '")');
        }
        const obj_duplicateRuleFilters = obj.duplicateRuleFilters;
        const path_duplicateRuleFilters = path + '.duplicateRuleFilters';
        if (!ArrayIsArray$1(obj_duplicateRuleFilters)) {
            return new TypeError('Expected "array" but received "' + typeof obj_duplicateRuleFilters + '" (at "' + path_duplicateRuleFilters + '")');
        }
        for (let i = 0; i < obj_duplicateRuleFilters.length; i++) {
            const obj_duplicateRuleFilters_item = obj_duplicateRuleFilters[i];
            const path_duplicateRuleFilters_item = path_duplicateRuleFilters + '[' + i + ']';
            const referenceDuplicateRuleFilterRepresentationValidationError = validate$A(obj_duplicateRuleFilters_item, path_duplicateRuleFilters_item);
            if (referenceDuplicateRuleFilterRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateRuleFilterRepresentation (at "' + path_duplicateRuleFilters_item + '")\n';
                message += referenceDuplicateRuleFilterRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_matchRules = obj.matchRules;
        const path_matchRules = path + '.matchRules';
        if (!ArrayIsArray$1(obj_matchRules)) {
            return new TypeError('Expected "array" but received "' + typeof obj_matchRules + '" (at "' + path_matchRules + '")');
        }
        for (let i = 0; i < obj_matchRules.length; i++) {
            const obj_matchRules_item = obj_matchRules[i];
            const path_matchRules_item = path_matchRules + '[' + i + ']';
            const referenceMatchRuleRepresentationValidationError = validate$B(obj_matchRules_item, path_matchRules_item);
            if (referenceMatchRuleRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match MatchRuleRepresentation (at "' + path_matchRules_item + '")\n';
                message += referenceMatchRuleRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_name = obj.name;
        const path_name = path + '.name';
        if (typeof obj_name !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_name + '" (at "' + path_name + '")');
        }
        const obj_operationsOnInsert = obj.operationsOnInsert;
        const path_operationsOnInsert = path + '.operationsOnInsert';
        if (!ArrayIsArray$1(obj_operationsOnInsert)) {
            return new TypeError('Expected "array" but received "' + typeof obj_operationsOnInsert + '" (at "' + path_operationsOnInsert + '")');
        }
        for (let i = 0; i < obj_operationsOnInsert.length; i++) {
            const obj_operationsOnInsert_item = obj_operationsOnInsert[i];
            const path_operationsOnInsert_item = path_operationsOnInsert + '[' + i + ']';
            if (typeof obj_operationsOnInsert_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_operationsOnInsert_item + '" (at "' + path_operationsOnInsert_item + '")');
            }
        }
        const obj_operationsOnUpdate = obj.operationsOnUpdate;
        const path_operationsOnUpdate = path + '.operationsOnUpdate';
        if (!ArrayIsArray$1(obj_operationsOnUpdate)) {
            return new TypeError('Expected "array" but received "' + typeof obj_operationsOnUpdate + '" (at "' + path_operationsOnUpdate + '")');
        }
        for (let i = 0; i < obj_operationsOnUpdate.length; i++) {
            const obj_operationsOnUpdate_item = obj_operationsOnUpdate[i];
            const path_operationsOnUpdate_item = path_operationsOnUpdate + '[' + i + ']';
            if (typeof obj_operationsOnUpdate_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_operationsOnUpdate_item + '" (at "' + path_operationsOnUpdate_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$p = function DuplicateRuleRepresentationSelect() {
    const { selections: DuplicateRuleFilterRepresentation__selections, opaque: DuplicateRuleFilterRepresentation__opaque, } = select$n();
    const { selections: MatchRuleRepresentation__selections, opaque: MatchRuleRepresentation__opaque, } = select$o();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'actionOnInsert',
                kind: 'Scalar',
            },
            {
                name: 'actionOnUpdate',
                kind: 'Scalar',
            },
            {
                name: 'active',
                kind: 'Scalar',
            },
            {
                name: 'duplicateRuleFilters',
                kind: 'Object',
                plural: true,
                selections: DuplicateRuleFilterRepresentation__selections
            },
            {
                name: 'matchRules',
                kind: 'Object',
                plural: true,
                selections: MatchRuleRepresentation__selections
            },
            {
                name: 'name',
                kind: 'Scalar',
            },
            {
                name: 'operationsOnInsert',
                kind: 'Scalar',
                plural: true,
            },
            {
                name: 'operationsOnUpdate',
                kind: 'Scalar',
                plural: true,
            }
        ]
    };
};

const TTL$4 = 900000;
function validate$D(obj, path = 'DuplicatesConfigurationRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_dedupeEnabled = obj.dedupeEnabled;
        const path_dedupeEnabled = path + '.dedupeEnabled';
        if (typeof obj_dedupeEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_dedupeEnabled + '" (at "' + path_dedupeEnabled + '")');
        }
        const obj_dedupeFields = obj.dedupeFields;
        const path_dedupeFields = path + '.dedupeFields';
        if (!ArrayIsArray$1(obj_dedupeFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_dedupeFields + '" (at "' + path_dedupeFields + '")');
        }
        for (let i = 0; i < obj_dedupeFields.length; i++) {
            const obj_dedupeFields_item = obj_dedupeFields[i];
            const path_dedupeFields_item = path_dedupeFields + '[' + i + ']';
            if (typeof obj_dedupeFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_dedupeFields_item + '" (at "' + path_dedupeFields_item + '")');
            }
        }
        const obj_duplicateRules = obj.duplicateRules;
        const path_duplicateRules = path + '.duplicateRules';
        if (!ArrayIsArray$1(obj_duplicateRules)) {
            return new TypeError('Expected "array" but received "' + typeof obj_duplicateRules + '" (at "' + path_duplicateRules + '")');
        }
        for (let i = 0; i < obj_duplicateRules.length; i++) {
            const obj_duplicateRules_item = obj_duplicateRules[i];
            const path_duplicateRules_item = path_duplicateRules + '[' + i + ']';
            const referenceDuplicateRuleRepresentationValidationError = validate$C(obj_duplicateRules_item, path_duplicateRules_item);
            if (referenceDuplicateRuleRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateRuleRepresentation (at "' + path_duplicateRules_item + '")\n';
                message += referenceDuplicateRuleRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_predupeEnabled = obj.predupeEnabled;
        const path_predupeEnabled = path + '.predupeEnabled';
        if (typeof obj_predupeEnabled !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_predupeEnabled + '" (at "' + path_predupeEnabled + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$m(config) {
    return keyPrefix + 'DuplicatesConfigurationRepresentation:' + config.apiName;
}
function keyBuilderFromType$c(object) {
    const keyParams = {
        apiName: object.apiName
    };
    return keyBuilder$m(keyParams);
}
function normalize$i(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$q = function DuplicatesConfigurationRepresentationSelect() {
    const { selections: DuplicateRuleRepresentation__selections, opaque: DuplicateRuleRepresentation__opaque, } = select$p();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'apiName',
                kind: 'Scalar',
            },
            {
                name: 'dedupeEnabled',
                kind: 'Scalar',
            },
            {
                name: 'dedupeFields',
                kind: 'Scalar',
                plural: true,
            },
            {
                name: 'duplicateRules',
                kind: 'Object',
                plural: true,
                selections: DuplicateRuleRepresentation__selections
            },
            {
                name: 'predupeEnabled',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$l(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
const ingest$i = function DuplicatesConfigurationRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$D(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$c(input);
    let incomingRecord = normalize$i(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$l(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function select$r(lds, params) {
    return select$q();
}
function keyBuilder$n(params) {
    return keyBuilder$m({
        apiName: params.urlParams.objectApiName
    });
}
function ingestSuccess$7(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$n(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$r(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$7(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$n(params);
    lds.storeIngestFetchResponse(key, error, TTL$4);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$h(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/duplicates/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: ingest$i,
        headers,
    };
}

const adapterName$7 = 'getDuplicateConfiguration';
const getDuplicateConfiguration_ConfigPropertyNames = {
    displayName: 'getDuplicateConfiguration',
    parameters: {
        required: ['objectApiName'],
        optional: []
    }
};
function createResourceParams$a(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        }
    };
}
function typeCheckConfig$d(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    return config;
}
function validateAdapterConfig$d(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$d(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$c(lds, config) {
    const resourceParams = createResourceParams$a(config);
    const selector = {
        recordId: keyBuilder$n(resourceParams),
        node: select$r(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$a(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$7(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$7(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$a(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$7(lds, config, resourceParams, response) {
    const snapshot = ingestError$7(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$a(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$a(lds, config, override) {
    const resourceParams = createResourceParams$a(config);
    const request = createResourceRequest$h(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$7(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$7(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$9(lds, config, snapshot) {
    const resourceParams = createResourceParams$a(config);
    const request = createResourceRequest$h(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$7(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$7(lds, config, resourceParams, response);
    });
}
const getDuplicateConfigurationAdapterFactory = (lds) => function getDuplicateConfiguration(untrustedConfig) {
    const config = validateAdapterConfig$d(untrustedConfig, getDuplicateConfiguration_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$c(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$9(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$a(lds, config);
};

const TTL$5 = 120000;
function validate$E(obj, path = 'NavItemsRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        if (typeof obj_currentPageUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_navItems = obj.navItems;
        const path_navItems = path + '.navItems';
        if (!ArrayIsArray$1(obj_navItems)) {
            return new TypeError('Expected "array" but received "' + typeof obj_navItems + '" (at "' + path_navItems + '")');
        }
        for (let i = 0; i < obj_navItems.length; i++) {
            const obj_navItems_item = obj_navItems[i];
            const path_navItems_item = path_navItems + '[' + i + ']';
            if (typeof obj_navItems_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_navItems_item + '" (at "' + path_navItems_item + '")');
            }
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$j(input, existing, path, lds, store, timestamp) {
    const input_navItems = input.navItems;
    const input_navItems_id = path.fullPath + '__navItems';
    for (let i = 0; i < input_navItems.length; i++) {
        const input_navItems_item = input_navItems[i];
        let input_navItems_item_id = input_navItems_id + '__' + i;
        input_navItems[i] = ingest$h(input_navItems_item, {
            fullPath: input_navItems_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
const select$s = function NavItemsRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag',
            'currentPageUrl'
        ],
        selections: [
            {
                name: 'navItems',
                kind: 'Link',
                plural: true,
                fragment: select$l()
            },
            {
                name: 'nextPageUrl',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$m(existing, incoming) {
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_navItems = existing.navItems;
    const incoming_navItems = incoming.navItems;
    const equals_navItems_items = equalsArray(existing_navItems, incoming_navItems, (existing_navItems_item, incoming_navItems_item) => {
        if (!(existing_navItems_item.__ref === incoming_navItems_item.__ref)) {
            return false;
        }
    });
    if (equals_navItems_items === false) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    return true;
}
const ingest$j = function NavItemsRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$E(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$j(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$m(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 120000);
    return createLink(key);
};

function select$t(lds, params) {
    return select$s();
}
function keyBuilder$o(params) {
    return keyPrefix + 'NavItemsRepresentation(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'navItemNames:' + params.queryParams.navItemNames + ',' + 'page:' + params.queryParams.page + ',' + 'pageSize:' + params.queryParams.pageSize + ')';
}
function ingestSuccess$8(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$o(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$t(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$8(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$o(params);
    lds.storeIngestFetchResponse(key, error, TTL$5);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$i(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/nav-items',
        method: 'get',
        body: null,
        urlParams: {},
        queryParams: config.queryParams,
        ingest: ingest$j,
        headers,
    };
}

const adapterName$8 = 'getNavItems';
const getNavItems_ConfigPropertyNames = {
    displayName: 'getNavItems',
    parameters: {
        required: [],
        optional: ['formFactor', 'navItemNames', 'page', 'pageSize']
    }
};
function createResourceParams$b(config) {
    return {
        queryParams: {
            formFactor: config.formFactor, navItemNames: config.navItemNames, page: config.page, pageSize: config.pageSize
        }
    };
}
function coerceConfig$d(config) {
    const coercedConfig = {};
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const navItemNames = config.navItemNames;
    if (navItemNames !== undefined) {
        coercedConfig.navItemNames = navItemNames;
    }
    const page = config.page;
    if (page !== undefined) {
        coercedConfig.page = page;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    return coercedConfig;
}
function typeCheckConfig$e(untrustedConfig) {
    const config = {};
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_navItemNames = untrustedConfig.navItemNames;
    if (ArrayIsArray(untrustedConfig_navItemNames)) {
        const untrustedConfig_navItemNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_navItemNames.length; i < arrayLength; i++) {
            const untrustedConfig_navItemNames_item = untrustedConfig_navItemNames[i];
            if (typeof untrustedConfig_navItemNames_item === 'string') {
                untrustedConfig_navItemNames_array.push(untrustedConfig_navItemNames_item);
            }
        }
        config.navItemNames = untrustedConfig_navItemNames_array;
    }
    const untrustedConfig_page = untrustedConfig.page;
    if (typeof untrustedConfig_page === 'number' && Math.floor(untrustedConfig_page) === untrustedConfig_page) {
        config.page = untrustedConfig_page;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    return config;
}
function validateAdapterConfig$e(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$d(untrustedConfig);
    const config = typeCheckConfig$e(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$d(lds, config) {
    const resourceParams = createResourceParams$b(config);
    const selector = {
        recordId: keyBuilder$o(resourceParams),
        node: select$t(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$b(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$8(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$8(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$b(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$8(lds, config, resourceParams, response) {
    const snapshot = ingestError$8(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$b(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$b(lds, config, override) {
    const resourceParams = createResourceParams$b(config);
    const request = createResourceRequest$i(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$8(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$8(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$a(lds, config, snapshot) {
    const resourceParams = createResourceParams$b(config);
    const request = createResourceRequest$i(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$8(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$8(lds, config, resourceParams, response);
    });
}
const getNavItemsAdapterFactory = (lds) => function getNavItems(untrustedConfig) {
    const config = validateAdapterConfig$e(untrustedConfig, getNavItems_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$d(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$a(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$b(lds, config);
};

function validate$F(obj, path = 'SimplifiedBatchResultRepresentation') {
    const v_error = (() => {
        const path_statusCode = path + '.statusCode';
        const obj_statusCode = obj.statusCode;
        const path_result = path + '.result';
        const obj_result = obj.result;
        if (typeof obj_statusCode !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
        switch (obj_statusCode) {
            case 200: {
                if (typeof obj_result !== 'object') {
                    return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
                }
            }
            default: {
                if (obj_result === undefined) {
                    return new TypeError('Expected "' + path_result + '" to be present but received "undefined" (at "' + path_result + '")');
                }
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$k(input, existing, path, lds, store, timestamp) {
    const input_result = input.result;
    const input_result_id = path.fullPath + '__result';
    input.result = ingest$8(input_result, {
        fullPath: input_result_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$n(existing, incoming) {
    const existing_statusCode = existing.statusCode;
    const incoming_statusCode = incoming.statusCode;
    if (!(existing_statusCode === incoming_statusCode)) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
    }
    return true;
}
const ingest$k = function SimplifiedBatchResultRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$F(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$k(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$n(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$G(obj, path = 'SimplifiedBatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_results = obj.results;
        const path_results = path + '.results';
        if (!ArrayIsArray$1(obj_results)) {
            return new TypeError('Expected "array" but received "' + typeof obj_results + '" (at "' + path_results + '")');
        }
        for (let i = 0; i < obj_results.length; i++) {
            const obj_results_item = obj_results[i];
            const path_results_item = path_results + '[' + i + ']';
            if (typeof obj_results_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_results_item + '" (at "' + path_results_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$l(input, existing, path, lds, store, timestamp) {
    const input_results = input.results;
    const input_results_id = path.fullPath + '__results';
    for (let i = 0; i < input_results.length; i++) {
        const input_results_item = input_results[i];
        let input_results_item_id = input_results_id + '__' + i;
        input_results[i] = ingest$k(input_results_item, {
            fullPath: input_results_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$o(existing, incoming) {
    const existing_results = existing.results;
    const incoming_results = incoming.results;
    const equals_results_items = equalsArray(existing_results, incoming_results, (existing_results_item, incoming_results_item) => {
        if (!(existing_results_item.__ref === incoming_results_item.__ref)) {
            return false;
        }
    });
    if (equals_results_items === false) {
        return false;
    }
    return true;
}
const ingest$l = function SimplifiedBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$G(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$l(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$o(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function createChildResourceParams$1(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.objectApiNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.objectApiNames[index];
        childConfigs.push({
            urlParams: {
                objectApiName: item
            }
        });
    }
    return childConfigs;
}
function select$u(lds, resourceParams) {
    const childResources = createChildResourceParams$1(resourceParams);
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$a(childResource);
                const childFragment = select$8();
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                switch (childSnapshot.state) {
                    case 'Fulfilled':
                        reader.seenIds[childKey] = true;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        reader.markMissing();
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                    case 'Stale':
                        reader.markStale();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function keyBuilder$p(params) {
    return keyPrefix + 'SimplifiedBatchRepresentation(' + 'objectApiNames:' + params.urlParams.objectApiNames + ')';
}
function ingestSuccess$9(lds, resourceParams, request, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$1(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const snapshotStateFulfilled = 'Fulfilled';
    const key = keyBuilder$p(resourceParams);
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const result = childEnvelopes[index];
        const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
        if (result.statusCode === 200) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: true,
                statusText: childStatusCodeText,
                headers: {},
            };
            const childSnapshot = ingestSuccess(lds, childResourceParams, createResourceRequest$9(childResourceParams), childResponse);
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
        else {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError(lds, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [keyBuilder$a(childResourceParams)]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    ObjectFreeze(childSnapshotData);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$u(lds, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$9(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$p(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$j(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/object-info/batch/' + config.urlParams.objectApiNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: ingest$l,
        headers,
    };
}

const adapterName$9 = 'getObjectInfos';
const getObjectInfos_ConfigPropertyNames = {
    displayName: 'getObjectInfos',
    parameters: {
        required: ['objectApiNames'],
        optional: []
    }
};
function createResourceParams$c(config) {
    return {
        urlParams: {
            objectApiNames: config.objectApiNames
        }
    };
}
function coerceConfig$e(config) {
    const coercedConfig = {};
    const objectApiNames = getObjectApiNamesArray(config.objectApiNames);
    if (objectApiNames !== undefined) {
        coercedConfig.objectApiNames = objectApiNames;
    }
    return coercedConfig;
}
function typeCheckConfig$f(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiNames = untrustedConfig.objectApiNames;
    if (ArrayIsArray(untrustedConfig_objectApiNames)) {
        const untrustedConfig_objectApiNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_objectApiNames.length; i < arrayLength; i++) {
            const untrustedConfig_objectApiNames_item = untrustedConfig_objectApiNames[i];
            if (typeof untrustedConfig_objectApiNames_item === 'string') {
                untrustedConfig_objectApiNames_array.push(untrustedConfig_objectApiNames_item);
            }
        }
        config.objectApiNames = untrustedConfig_objectApiNames_array;
    }
    return config;
}
function validateAdapterConfig$f(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$e(untrustedConfig);
    const config = typeCheckConfig$f(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$e(lds, config) {
    const resourceParams = createResourceParams$c(config);
    const selector = {
        recordId: keyBuilder$p(resourceParams),
        node: select$u(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$c(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$9(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$9(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$c(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$9(lds, config, resourceParams, response) {
    const snapshot = ingestError$9(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$c(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$c(lds, config, override) {
    const resourceParams = createResourceParams$c(config);
    const request = createResourceRequest$j(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$9(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$9(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$b(lds, config, snapshot) {
    const resourceParams = createResourceParams$c(config);
    const request = createResourceRequest$j(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$9(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$9(lds, config, resourceParams, response);
    });
}
const getObjectInfosAdapterFactory = (lds) => function getObjectInfos(untrustedConfig) {
    const config = validateAdapterConfig$f(untrustedConfig, getObjectInfos_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$e(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$b(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$c(lds, config);
};

const select$v = function LeadStatusPicklistValueAttributesRepresentationSelect() {
    const { selections: AbstractPicklistValueAttributesRepresentationSelections } = select$y();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractPicklistValueAttributesRepresentationSelections,
            {
                name: 'converted',
                kind: 'Scalar',
            }
        ]
    };
};

const select$w = function CaseStatusPicklistValueAttributesRepresentationSelect() {
    const { selections: AbstractPicklistValueAttributesRepresentationSelections } = select$y();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractPicklistValueAttributesRepresentationSelections,
            {
                name: 'closed',
                kind: 'Scalar',
            }
        ]
    };
};

const select$x = function OpportunityStagePicklistValueAttributesRepresentationSelect() {
    const { selections: AbstractPicklistValueAttributesRepresentationSelections } = select$y();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractPicklistValueAttributesRepresentationSelections,
            {
                name: 'closed',
                kind: 'Scalar',
            },
            {
                name: 'defaultProbability',
                kind: 'Scalar',
            },
            {
                name: 'forecastCategoryName',
                kind: 'Scalar',
            },
            {
                name: 'won',
                kind: 'Scalar',
            }
        ]
    };
};

var DiscriminatorValues$1;
(function (DiscriminatorValues) {
    DiscriminatorValues["LeadStatus"] = "LeadStatus";
    DiscriminatorValues["CaseStatus"] = "CaseStatus";
    DiscriminatorValues["OpportunityStage"] = "OpportunityStage";
})(DiscriminatorValues$1 || (DiscriminatorValues$1 = {}));
function validate$H(obj, path = 'AbstractPicklistValueAttributesRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_picklistAtrributesValueType = obj.picklistAtrributesValueType;
        const path_picklistAtrributesValueType = path + '.picklistAtrributesValueType';
        if (typeof obj_picklistAtrributesValueType !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_picklistAtrributesValueType + '" (at "' + path_picklistAtrributesValueType + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const selectChildren = function AbstractPicklistValueAttributesRepresentationSelectChildren() {
    const LeadStatusPicklistValueAttributesRepresentationSelections = select$v();
    const CaseStatusPicklistValueAttributesRepresentationSelections = select$w();
    const OpportunityStagePicklistValueAttributesRepresentationSelections = select$x();
    return {
        kind: 'Fragment',
        union: true,
        discriminator: 'picklistAtrributesValueType',
        unionSelections: {
            [DiscriminatorValues$1.LeadStatus]: LeadStatusPicklistValueAttributesRepresentationSelections,
            [DiscriminatorValues$1.CaseStatus]: CaseStatusPicklistValueAttributesRepresentationSelections,
            [DiscriminatorValues$1.OpportunityStage]: OpportunityStagePicklistValueAttributesRepresentationSelections
        }
    };
};
const select$y = function AbstractPicklistValueAttributesRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'picklistAtrributesValueType',
                kind: 'Scalar',
            }
        ]
    };
};

function validate$I(obj, path = 'PicklistValueRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_attributes = obj.attributes;
        const path_attributes = path + '.attributes';
        let obj_attributes_union0 = null;
        const obj_attributes_union0_error = (() => {
            const referenceAbstractPicklistValueAttributesRepresentationValidationError = validate$H(obj_attributes, path_attributes);
            if (referenceAbstractPicklistValueAttributesRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match AbstractPicklistValueAttributesRepresentation (at "' + path_attributes + '")\n';
                message += referenceAbstractPicklistValueAttributesRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_attributes_union0_error != null) {
            obj_attributes_union0 = obj_attributes_union0_error.message;
        }
        let obj_attributes_union1 = null;
        const obj_attributes_union1_error = (() => {
            if (obj_attributes !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_attributes + '" (at "' + path_attributes + '")');
            }
        })();
        if (obj_attributes_union1_error != null) {
            obj_attributes_union1 = obj_attributes_union1_error.message;
        }
        if (obj_attributes_union0 && obj_attributes_union1) {
            let message = 'Object doesn\'t match union (at "' + path_attributes + '")';
            message += '\n' + obj_attributes_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_attributes_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_validFor = obj.validFor;
        const path_validFor = path + '.validFor';
        if (!ArrayIsArray$1(obj_validFor)) {
            return new TypeError('Expected "array" but received "' + typeof obj_validFor + '" (at "' + path_validFor + '")');
        }
        for (let i = 0; i < obj_validFor.length; i++) {
            const obj_validFor_item = obj_validFor[i];
            const path_validFor_item = path_validFor + '[' + i + ']';
            if (typeof obj_validFor_item !== 'number' || (typeof obj_validFor_item === 'number' && Math.floor(obj_validFor_item) !== obj_validFor_item)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_validFor_item + '" (at "' + path_validFor_item + '")');
            }
        }
        const obj_value = obj.value;
        const path_value = path + '.value';
        if (typeof obj_value !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_value + '" (at "' + path_value + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$z = function PicklistValueRepresentationSelect() {
    const AbstractPicklistValueAttributesRepresentation__unionSelections = selectChildren();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                kind: 'Object',
                name: 'attributes',
                discriminator: AbstractPicklistValueAttributesRepresentation__unionSelections.discriminator,
                union: true,
                nullable: true,
                unionSelections: AbstractPicklistValueAttributesRepresentation__unionSelections.unionSelections
            },
            {
                name: 'label',
                kind: 'Scalar',
            },
            {
                name: 'validFor',
                kind: 'Scalar',
                plural: true,
            },
            {
                name: 'value',
                kind: 'Scalar',
            }
        ]
    };
};

function validate$J(obj, path = 'PicklistValuesRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_controllerValues = obj.controllerValues;
        const path_controllerValues = path + '.controllerValues';
        if (typeof obj_controllerValues !== 'object' || ArrayIsArray$1(obj_controllerValues) || obj_controllerValues === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_controllerValues + '" (at "' + path_controllerValues + '")');
        }
        const obj_controllerValues_keys = ObjectKeys$1(obj_controllerValues);
        for (let i = 0; i < obj_controllerValues_keys.length; i++) {
            const key = obj_controllerValues_keys[i];
            const obj_controllerValues_prop = obj_controllerValues[key];
            const path_controllerValues_prop = path_controllerValues + '["' + key + '"]';
            if (typeof obj_controllerValues_prop !== 'number' || (typeof obj_controllerValues_prop === 'number' && Math.floor(obj_controllerValues_prop) !== obj_controllerValues_prop)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_controllerValues_prop + '" (at "' + path_controllerValues_prop + '")');
            }
        }
        const obj_defaultValue = obj.defaultValue;
        const path_defaultValue = path + '.defaultValue';
        let obj_defaultValue_union0 = null;
        const obj_defaultValue_union0_error = (() => {
            const referencePicklistValueRepresentationValidationError = validate$I(obj_defaultValue, path_defaultValue);
            if (referencePicklistValueRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match PicklistValueRepresentation (at "' + path_defaultValue + '")\n';
                message += referencePicklistValueRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_defaultValue_union0_error != null) {
            obj_defaultValue_union0 = obj_defaultValue_union0_error.message;
        }
        let obj_defaultValue_union1 = null;
        const obj_defaultValue_union1_error = (() => {
            if (obj_defaultValue !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_defaultValue + '" (at "' + path_defaultValue + '")');
            }
        })();
        if (obj_defaultValue_union1_error != null) {
            obj_defaultValue_union1 = obj_defaultValue_union1_error.message;
        }
        if (obj_defaultValue_union0 && obj_defaultValue_union1) {
            let message = 'Object doesn\'t match union (at "' + path_defaultValue + '")';
            message += '\n' + obj_defaultValue_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_defaultValue_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_url = obj.url;
        const path_url = path + '.url';
        if (typeof obj_url !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_url + '" (at "' + path_url + '")');
        }
        const obj_values = obj.values;
        const path_values = path + '.values';
        if (!ArrayIsArray$1(obj_values)) {
            return new TypeError('Expected "array" but received "' + typeof obj_values + '" (at "' + path_values + '")');
        }
        for (let i = 0; i < obj_values.length; i++) {
            const obj_values_item = obj_values[i];
            const path_values_item = path_values + '[' + i + ']';
            const referencePicklistValueRepresentationValidationError = validate$I(obj_values_item, path_values_item);
            if (referencePicklistValueRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match PicklistValueRepresentation (at "' + path_values_item + '")\n';
                message += referencePicklistValueRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$q(config) {
    return keyPrefix + 'PicklistValuesRepresentation:' + config.id;
}
function keyBuilderFromType$d(object) {
    const keyParams = {
        id: object.url
    };
    return keyBuilder$q(keyParams);
}
function normalize$m(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$A = function PicklistValuesRepresentationSelect() {
    const { selections: PicklistValueRepresentation__selections, opaque: PicklistValueRepresentation__opaque, } = select$z();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'controllerValues',
                kind: 'Scalar',
                map: true,
            },
            {
                name: 'defaultValue',
                kind: 'Object',
                nullable: true,
                selections: PicklistValueRepresentation__selections
            },
            {
                name: 'url',
                kind: 'Scalar',
            },
            {
                name: 'values',
                kind: 'Object',
                plural: true,
                selections: PicklistValueRepresentation__selections
            }
        ]
    };
};
function equals$p(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
const ingest$m = function PicklistValuesRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$J(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$d(input);
    let incomingRecord = normalize$m(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$p(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

const TTL$6 = 300000;
function validate$K(obj, path = 'PicklistValuesCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_picklistFieldValues = obj.picklistFieldValues;
        const path_picklistFieldValues = path + '.picklistFieldValues';
        if (typeof obj_picklistFieldValues !== 'object' || ArrayIsArray$1(obj_picklistFieldValues) || obj_picklistFieldValues === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_picklistFieldValues + '" (at "' + path_picklistFieldValues + '")');
        }
        const obj_picklistFieldValues_keys = ObjectKeys$1(obj_picklistFieldValues);
        for (let i = 0; i < obj_picklistFieldValues_keys.length; i++) {
            const key = obj_picklistFieldValues_keys[i];
            const obj_picklistFieldValues_prop = obj_picklistFieldValues[key];
            const path_picklistFieldValues_prop = path_picklistFieldValues + '["' + key + '"]';
            if (typeof obj_picklistFieldValues_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_picklistFieldValues_prop + '" (at "' + path_picklistFieldValues_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$n(input, existing, path, lds, store, timestamp) {
    const input_picklistFieldValues = input.picklistFieldValues;
    const input_picklistFieldValues_id = path.fullPath + '__picklistFieldValues';
    const input_picklistFieldValues_keys = Object.keys(input_picklistFieldValues);
    const input_picklistFieldValues_length = input_picklistFieldValues_keys.length;
    for (let i = 0; i < input_picklistFieldValues_length; i++) {
        const key = input_picklistFieldValues_keys[i];
        const input_picklistFieldValues_prop = input_picklistFieldValues[key];
        const input_picklistFieldValues_prop_id = input_picklistFieldValues_id + '__' + key;
        input_picklistFieldValues[key] = ingest$m(input_picklistFieldValues_prop, {
            fullPath: input_picklistFieldValues_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
const select$B = function PicklistValuesCollectionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'picklistFieldValues',
                kind: 'Link',
                map: true,
                fragment: select$A()
            }
        ]
    };
};
function equals$q(existing, incoming) {
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_picklistFieldValues = existing.picklistFieldValues;
    const incoming_picklistFieldValues = incoming.picklistFieldValues;
    const equals_picklistFieldValues_props = equalsObject(existing_picklistFieldValues, incoming_picklistFieldValues, (existing_picklistFieldValues_prop, incoming_picklistFieldValues_prop) => {
        if (!(existing_picklistFieldValues_prop.__ref === incoming_picklistFieldValues_prop.__ref)) {
            return false;
        }
    });
    if (equals_picklistFieldValues_props === false) {
        return false;
    }
    return true;
}
const ingest$n = function PicklistValuesCollectionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$K(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$n(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$q(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function select$C(lds, params) {
    return select$B();
}
function keyBuilder$r(params) {
    return keyPrefix + 'PicklistValuesCollectionRepresentation(' + 'objectApiName:' + params.urlParams.objectApiName + ',' + 'recordTypeId:' + params.urlParams.recordTypeId + ')';
}
function ingestSuccess$a(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$r(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$C(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$a(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$r(params);
    lds.storeIngestFetchResponse(key, error, TTL$6);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$k(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '/picklist-values/' + config.urlParams.recordTypeId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: ingest$n,
        headers,
    };
}

const adapterName$a = 'getPicklistValuesByRecordType';
const getPicklistValuesByRecordType_ConfigPropertyNames = {
    displayName: 'getPicklistValuesByRecordType',
    parameters: {
        required: ['objectApiName', 'recordTypeId'],
        optional: []
    }
};
function createResourceParams$d(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$f(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$g(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$g(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$f(untrustedConfig);
    const config = typeCheckConfig$g(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$f(lds, config) {
    const resourceParams = createResourceParams$d(config);
    const selector = {
        recordId: keyBuilder$r(resourceParams),
        node: select$C(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$d(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$a(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$a(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$a(lds, config, resourceParams, response) {
    const snapshot = ingestError$a(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$d(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$d(lds, config, override) {
    const resourceParams = createResourceParams$d(config);
    const request = createResourceRequest$k(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$a(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$a(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$c(lds, config, snapshot) {
    const resourceParams = createResourceParams$d(config);
    const request = createResourceRequest$k(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$a(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$a(lds, config, resourceParams, response);
    });
}
const getPicklistValuesByRecordTypeAdapterFactory = (lds) => function getPicklistValuesByRecordType(untrustedConfig) {
    const config = validateAdapterConfig$g(untrustedConfig, getPicklistValuesByRecordType_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$f(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$c(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$d(lds, config);
};

function validate$L(obj, path = 'MatchResultInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_recordIds = obj.recordIds;
        const path_recordIds = path + '.recordIds';
        if (!ArrayIsArray$1(obj_recordIds)) {
            return new TypeError('Expected "array" but received "' + typeof obj_recordIds + '" (at "' + path_recordIds + '")');
        }
        for (let i = 0; i < obj_recordIds.length; i++) {
            const obj_recordIds_item = obj_recordIds[i];
            const path_recordIds_item = path_recordIds + '[' + i + ']';
            if (typeof obj_recordIds_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordIds_item + '" (at "' + path_recordIds_item + '")');
            }
        }
        const obj_rule = obj.rule;
        const path_rule = path + '.rule';
        if (typeof obj_rule !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_rule + '" (at "' + path_rule + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$j(input) {
    const input_recordIds = input.recordIds;
    ObjectFreeze$1(input_recordIds);
    ObjectFreeze$1(input);
}

function validate$M(obj, path = 'DuplicateResultInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_allowSave = obj.allowSave;
        const path_allowSave = path + '.allowSave';
        if (typeof obj_allowSave !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_allowSave + '" (at "' + path_allowSave + '")');
        }
        const obj_matchResultInfo = obj.matchResultInfo;
        const path_matchResultInfo = path + '.matchResultInfo';
        const referenceMatchResultInfoRepresentationValidationError = validate$L(obj_matchResultInfo, path_matchResultInfo);
        if (referenceMatchResultInfoRepresentationValidationError !== null) {
            let message = 'Object doesn\'t match MatchResultInfoRepresentation (at "' + path_matchResultInfo + '")\n';
            message += referenceMatchResultInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_rule = obj.rule;
        const path_rule = path + '.rule';
        if (typeof obj_rule !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_rule + '" (at "' + path_rule + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$k(input) {
    const input_matchResultInfo = input.matchResultInfo;
    deepFreeze$j(input_matchResultInfo);
    ObjectFreeze$1(input);
}

function validate$N(obj, path = 'MatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_duplicateResultInfos = obj.duplicateResultInfos;
        const path_duplicateResultInfos = path + '.duplicateResultInfos';
        if (typeof obj_duplicateResultInfos !== 'object' || ArrayIsArray$1(obj_duplicateResultInfos) || obj_duplicateResultInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_duplicateResultInfos + '" (at "' + path_duplicateResultInfos + '")');
        }
        const obj_duplicateResultInfos_keys = ObjectKeys$1(obj_duplicateResultInfos);
        for (let i = 0; i < obj_duplicateResultInfos_keys.length; i++) {
            const key = obj_duplicateResultInfos_keys[i];
            const obj_duplicateResultInfos_prop = obj_duplicateResultInfos[key];
            const path_duplicateResultInfos_prop = path_duplicateResultInfos + '["' + key + '"]';
            const referenceDuplicateResultInfoRepresentationValidationError = validate$M(obj_duplicateResultInfos_prop, path_duplicateResultInfos_prop);
            if (referenceDuplicateResultInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match DuplicateResultInfoRepresentation (at "' + path_duplicateResultInfos_prop + '")\n';
                message += referenceDuplicateResultInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_recordIds = obj.recordIds;
        const path_recordIds = path + '.recordIds';
        if (!ArrayIsArray$1(obj_recordIds)) {
            return new TypeError('Expected "array" but received "' + typeof obj_recordIds + '" (at "' + path_recordIds + '")');
        }
        for (let i = 0; i < obj_recordIds.length; i++) {
            const obj_recordIds_item = obj_recordIds[i];
            const path_recordIds_item = path_recordIds + '[' + i + ']';
            if (typeof obj_recordIds_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordIds_item + '" (at "' + path_recordIds_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$l(input) {
    const input_duplicateResultInfos = input.duplicateResultInfos;
    const input_duplicateResultInfos_keys = Object.keys(input_duplicateResultInfos);
    const input_duplicateResultInfos_length = input_duplicateResultInfos_keys.length;
    for (let i = 0; i < input_duplicateResultInfos_length; i++) {
        const key = input_duplicateResultInfos_keys[i];
        const input_duplicateResultInfos_prop = input_duplicateResultInfos[key];
        deepFreeze$k(input_duplicateResultInfos_prop);
    }
    ObjectFreeze$1(input_duplicateResultInfos);
    const input_recordIds = input.recordIds;
    ObjectFreeze$1(input_recordIds);
    ObjectFreeze$1(input);
}

const TTL$7 = 30000;
function validate$O(obj, path = 'DuplicatesRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_allowSave = obj.allowSave;
        const path_allowSave = path + '.allowSave';
        if (typeof obj_allowSave !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_allowSave + '" (at "' + path_allowSave + '")');
        }
        const obj_duplicateError = obj.duplicateError;
        const path_duplicateError = path + '.duplicateError';
        if (typeof obj_duplicateError !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_duplicateError + '" (at "' + path_duplicateError + '")');
        }
        const obj_duplicateRules = obj.duplicateRules;
        const path_duplicateRules = path + '.duplicateRules';
        if (!ArrayIsArray$1(obj_duplicateRules)) {
            return new TypeError('Expected "array" but received "' + typeof obj_duplicateRules + '" (at "' + path_duplicateRules + '")');
        }
        for (let i = 0; i < obj_duplicateRules.length; i++) {
            const obj_duplicateRules_item = obj_duplicateRules[i];
            const path_duplicateRules_item = path_duplicateRules + '[' + i + ']';
            if (typeof obj_duplicateRules_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_duplicateRules_item + '" (at "' + path_duplicateRules_item + '")');
            }
        }
        const obj_matches = obj.matches;
        const path_matches = path + '.matches';
        if (!ArrayIsArray$1(obj_matches)) {
            return new TypeError('Expected "array" but received "' + typeof obj_matches + '" (at "' + path_matches + '")');
        }
        for (let i = 0; i < obj_matches.length; i++) {
            const obj_matches_item = obj_matches[i];
            const path_matches_item = path_matches + '[' + i + ']';
            const referenceMatchRepresentationValidationError = validate$N(obj_matches_item, path_matches_item);
            if (referenceMatchRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match MatchRepresentation (at "' + path_matches_item + '")\n';
                message += referenceMatchRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$o(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$D = function DuplicatesRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        opaque: true
    };
};
function equals$r(existing, incoming) {
    if (JSONStrinify(incoming) !== JSONStrinify(existing)) {
        return false;
    }
    return true;
}
function deepFreeze$m(input) {
    const input_duplicateRules = input.duplicateRules;
    ObjectFreeze$1(input_duplicateRules);
    const input_matches = input.matches;
    for (let i = 0; i < input_matches.length; i++) {
        const input_matches_item = input_matches[i];
        deepFreeze$l(input_matches_item);
    }
    ObjectFreeze$1(input_matches);
    ObjectFreeze$1(input);
}
const ingest$o = function DuplicatesRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$O(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$o(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    deepFreeze$m(input);
    if (existingRecord === undefined || equals$r(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 30000);
    return createLink(key);
};

function select$E(lds, params) {
    return select$D();
}
function keyBuilder$s(params) {
    return keyPrefix + 'DuplicatesRepresentation(' + (params.body.allowSaveOnDuplicate === undefined ? 'allowSaveOnDuplicate' : 'allowSaveOnDuplicate:' + params.body.allowSaveOnDuplicate) + '::' + (params.body.apiName === undefined ? 'apiName' : 'apiName:' + params.body.apiName) + '::' + stableJSONStringify(params.body.fields) + ')';
}
function ingestSuccess$b(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$s(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$E(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$b(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$s(params);
    lds.storeIngestFetchResponse(key, error, TTL$7);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$l(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/predupe',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        ingest: ingest$o,
        headers,
    };
}

const adapterName$b = 'getDuplicates';
const getDuplicates_ConfigPropertyNames = {
    displayName: 'getDuplicates',
    parameters: {
        required: ['fields'],
        optional: ['allowSaveOnDuplicate', 'apiName']
    }
};
function createResourceParams$e(config) {
    return {
        body: {
            allowSaveOnDuplicate: config.allowSaveOnDuplicate, apiName: config.apiName, fields: config.fields
        }
    };
}
function typeCheckConfig$h(untrustedConfig) {
    const config = {};
    const untrustedConfig_allowSaveOnDuplicate = untrustedConfig.allowSaveOnDuplicate;
    if (typeof untrustedConfig_allowSaveOnDuplicate === 'boolean') {
        config.allowSaveOnDuplicate = untrustedConfig_allowSaveOnDuplicate;
    }
    const untrustedConfig_apiName = untrustedConfig.apiName;
    if (typeof untrustedConfig_apiName === 'string') {
        config.apiName = untrustedConfig_apiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
            const key = untrustedConfig_fields_keys[i];
            const untrustedConfig_fields_prop = untrustedConfig_fields[key];
            if (typeof untrustedConfig_fields_prop === 'string') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'number') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (untrustedConfig_fields_prop === null) {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'boolean') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
        }
        if (Object.keys(untrustedConfig_fields_object).length >= 0) {
            config.fields = untrustedConfig_fields_object;
        }
    }
    return config;
}
function validateAdapterConfig$h(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$h(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$g(lds, config) {
    const resourceParams = createResourceParams$e(config);
    const selector = {
        recordId: keyBuilder$s(resourceParams),
        node: select$E(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$e(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$b(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$b(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$b(lds, config, resourceParams, response) {
    const snapshot = ingestError$b(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$e(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$e(lds, config, override) {
    const resourceParams = createResourceParams$e(config);
    const request = createResourceRequest$l(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$b(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$b(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$d(lds, config, snapshot) {
    const resourceParams = createResourceParams$e(config);
    const request = createResourceRequest$l(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$b(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$b(lds, config, resourceParams, response);
    });
}
const getDuplicatesAdapterFactory = (lds) => function getDuplicates(untrustedConfig) {
    const config = validateAdapterConfig$h(untrustedConfig, getDuplicates_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$g(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$d(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$e(lds, config);
};

function validate$P(obj, path = 'RelatedListReferenceRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        let obj_id_union0 = null;
        const obj_id_union0_error = (() => {
            if (typeof obj_id !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union0_error != null) {
            obj_id_union0 = obj_id_union0_error.message;
        }
        let obj_id_union1 = null;
        const obj_id_union1_error = (() => {
            if (obj_id !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
            }
        })();
        if (obj_id_union1_error != null) {
            obj_id_union1 = obj_id_union1_error.message;
        }
        if (obj_id_union0 && obj_id_union1) {
            let message = 'Object doesn\'t match union (at "' + path_id + '")';
            message += '\n' + obj_id_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_id_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_inContextOfRecordId = obj.inContextOfRecordId;
        const path_inContextOfRecordId = path + '.inContextOfRecordId';
        let obj_inContextOfRecordId_union0 = null;
        const obj_inContextOfRecordId_union0_error = (() => {
            if (typeof obj_inContextOfRecordId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_inContextOfRecordId + '" (at "' + path_inContextOfRecordId + '")');
            }
        })();
        if (obj_inContextOfRecordId_union0_error != null) {
            obj_inContextOfRecordId_union0 = obj_inContextOfRecordId_union0_error.message;
        }
        let obj_inContextOfRecordId_union1 = null;
        const obj_inContextOfRecordId_union1_error = (() => {
            if (obj_inContextOfRecordId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_inContextOfRecordId + '" (at "' + path_inContextOfRecordId + '")');
            }
        })();
        if (obj_inContextOfRecordId_union1_error != null) {
            obj_inContextOfRecordId_union1 = obj_inContextOfRecordId_union1_error.message;
        }
        if (obj_inContextOfRecordId_union0 && obj_inContextOfRecordId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_inContextOfRecordId + '")';
            message += '\n' + obj_inContextOfRecordId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_inContextOfRecordId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_listViewApiName = obj.listViewApiName;
        const path_listViewApiName = path + '.listViewApiName';
        let obj_listViewApiName_union0 = null;
        const obj_listViewApiName_union0_error = (() => {
            if (typeof obj_listViewApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union0_error != null) {
            obj_listViewApiName_union0 = obj_listViewApiName_union0_error.message;
        }
        let obj_listViewApiName_union1 = null;
        const obj_listViewApiName_union1_error = (() => {
            if (obj_listViewApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_listViewApiName + '" (at "' + path_listViewApiName + '")');
            }
        })();
        if (obj_listViewApiName_union1_error != null) {
            obj_listViewApiName_union1 = obj_listViewApiName_union1_error.message;
        }
        if (obj_listViewApiName_union0 && obj_listViewApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_listViewApiName + '")';
            message += '\n' + obj_listViewApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_listViewApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        let obj_objectApiName_union0 = null;
        const obj_objectApiName_union0_error = (() => {
            if (typeof obj_objectApiName !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
            }
        })();
        if (obj_objectApiName_union0_error != null) {
            obj_objectApiName_union0 = obj_objectApiName_union0_error.message;
        }
        let obj_objectApiName_union1 = null;
        const obj_objectApiName_union1_error = (() => {
            if (obj_objectApiName !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
            }
        })();
        if (obj_objectApiName_union1_error != null) {
            obj_objectApiName_union1 = obj_objectApiName_union1_error.message;
        }
        if (obj_objectApiName_union0 && obj_objectApiName_union1) {
            let message = 'Object doesn\'t match union (at "' + path_objectApiName + '")';
            message += '\n' + obj_objectApiName_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_objectApiName_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_parentObjectApiName = obj.parentObjectApiName;
        const path_parentObjectApiName = path + '.parentObjectApiName';
        if (typeof obj_parentObjectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentObjectApiName + '" (at "' + path_parentObjectApiName + '")');
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$F = function RelatedListReferenceRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'id',
                kind: 'Scalar',
            },
            {
                name: 'inContextOfRecordId',
                kind: 'Scalar',
            },
            {
                name: 'listViewApiName',
                kind: 'Scalar',
            },
            {
                name: 'objectApiName',
                kind: 'Scalar',
            },
            {
                name: 'parentObjectApiName',
                kind: 'Scalar',
            },
            {
                name: 'recordTypeId',
                kind: 'Scalar',
            },
            {
                name: 'relatedListId',
                kind: 'Scalar',
            },
            {
                name: 'type',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$s(existing, incoming) {
    const existing_parentObjectApiName = existing.parentObjectApiName;
    const incoming_parentObjectApiName = incoming.parentObjectApiName;
    if (!(existing_parentObjectApiName === incoming_parentObjectApiName)) {
        return false;
    }
    const existing_relatedListId = existing.relatedListId;
    const incoming_relatedListId = incoming.relatedListId;
    if (!(existing_relatedListId === incoming_relatedListId)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_inContextOfRecordId = existing.inContextOfRecordId;
    const incoming_inContextOfRecordId = incoming.inContextOfRecordId;
    if (!(existing_inContextOfRecordId === incoming_inContextOfRecordId)) {
        return false;
    }
    const existing_listViewApiName = existing.listViewApiName;
    const incoming_listViewApiName = incoming.listViewApiName;
    if (!(existing_listViewApiName === incoming_listViewApiName)) {
        return false;
    }
    const existing_objectApiName = existing.objectApiName;
    const incoming_objectApiName = incoming.objectApiName;
    if (!(existing_objectApiName === incoming_objectApiName)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
function deepFreeze$n(input) {
    ObjectFreeze$1(input);
}

function validate$Q(obj, path = 'RelatedListRecordCountRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        let obj_count_union0 = null;
        const obj_count_union0_error = (() => {
            if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
            }
        })();
        if (obj_count_union0_error != null) {
            obj_count_union0 = obj_count_union0_error.message;
        }
        let obj_count_union1 = null;
        const obj_count_union1_error = (() => {
            if (obj_count !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_count + '" (at "' + path_count + '")');
            }
        })();
        if (obj_count_union1_error != null) {
            obj_count_union1 = obj_count_union1_error.message;
        }
        if (obj_count_union0 && obj_count_union1) {
            let message = 'Object doesn\'t match union (at "' + path_count + '")';
            message += '\n' + obj_count_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_count_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_hasMore = obj.hasMore;
        const path_hasMore = path + '.hasMore';
        if (typeof obj_hasMore !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_hasMore + '" (at "' + path_hasMore + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referenceRelatedListReferenceRepresentationValidationError = validate$P(obj_listReference, path_listReference);
        if (referenceRelatedListReferenceRepresentationValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
            message += referenceRelatedListReferenceRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$t(config) {
    return keyPrefix + 'RelatedListRecordCountRepresentation:' + (config.parentRecordId === null ? '' : config.parentRecordId) + ':' + config.relatedListName;
}
function keyBuilderFromType$e(object) {
    const keyParams = {
        parentRecordId: object.listReference.inContextOfRecordId,
        relatedListName: object.listReference.relatedListId
    };
    return keyBuilder$t(keyParams);
}
function normalize$p(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$G = function RelatedListRecordCountRepresentationSelect() {
    const { selections: RelatedListReferenceRepresentation__selections, opaque: RelatedListReferenceRepresentation__opaque, } = select$F();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'count',
                kind: 'Scalar',
            },
            {
                name: 'hasMore',
                kind: 'Scalar',
            },
            {
                name: 'listReference',
                kind: 'Object',
                selections: RelatedListReferenceRepresentation__selections
            }
        ]
    };
};
function equals$t(existing, incoming) {
    const existing_hasMore = existing.hasMore;
    const incoming_hasMore = incoming.hasMore;
    if (!(existing_hasMore === incoming_hasMore)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_listReference = existing.listReference;
    const incoming_listReference = incoming.listReference;
    if (!(equals$s(existing_listReference, incoming_listReference))) {
        return false;
    }
    return true;
}
const ingest$p = function RelatedListRecordCountRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$Q(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$e(input);
    let incomingRecord = normalize$p(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$t(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function select$H(lds, params) {
    return select$G();
}
function keyBuilder$u(params) {
    return keyBuilder$t({
        parentRecordId: params.urlParams.parentRecordId,
        relatedListName: params.urlParams.relatedListName
    });
}
function ingestSuccess$c(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$u(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$H(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$c(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$u(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$m(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-count/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$p,
        headers,
    };
}

function validate$R(obj, path = 'SimpleRelatedListCountBatchRepresentation') {
    const v_error = (() => {
        const path_statusCode = path + '.statusCode';
        const obj_statusCode = obj.statusCode;
        const path_result = path + '.result';
        const obj_result = obj.result;
        if (typeof obj_statusCode !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
        switch (obj_statusCode) {
            case 200: {
                if (typeof obj_result !== 'object') {
                    return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
                }
            }
            default: {
                if (obj_result === undefined) {
                    return new TypeError('Expected "' + path_result + '" to be present but received "undefined" (at "' + path_result + '")');
                }
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$q(input, existing, path, lds, store, timestamp) {
    const input_result = input.result;
    const input_result_id = path.fullPath + '__result';
    input.result = ingest$p(input_result, {
        fullPath: input_result_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store);
    return input;
}
function equals$u(existing, incoming) {
    const existing_statusCode = existing.statusCode;
    const incoming_statusCode = incoming.statusCode;
    if (!(existing_statusCode === incoming_statusCode)) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
    }
    return true;
}
const ingest$q = function SimpleRelatedListCountBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$R(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$q(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$u(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$S(obj, path = 'BatchRelatedListCountRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_results = obj.results;
        const path_results = path + '.results';
        if (!ArrayIsArray$1(obj_results)) {
            return new TypeError('Expected "array" but received "' + typeof obj_results + '" (at "' + path_results + '")');
        }
        for (let i = 0; i < obj_results.length; i++) {
            const obj_results_item = obj_results[i];
            const path_results_item = path_results + '[' + i + ']';
            if (typeof obj_results_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_results_item + '" (at "' + path_results_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$r(input, existing, path, lds, store, timestamp) {
    const input_results = input.results;
    const input_results_id = path.fullPath + '__results';
    for (let i = 0; i < input_results.length; i++) {
        const input_results_item = input_results[i];
        let input_results_item_id = input_results_id + '__' + i;
        input_results[i] = ingest$q(input_results_item, {
            fullPath: input_results_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store);
    }
    return input;
}
function equals$v(existing, incoming) {
    const existing_results = existing.results;
    const incoming_results = incoming.results;
    const equals_results_items = equalsArray(existing_results, incoming_results, (existing_results_item, incoming_results_item) => {
        if (!(existing_results_item.__ref === incoming_results_item.__ref)) {
            return false;
        }
    });
    if (equals_results_items === false) {
        return false;
    }
    return true;
}
const ingest$r = function BatchRelatedListCountRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$S(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$r(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$v(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function createChildResourceParams$2(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListNames[index];
        childConfigs.push({
            urlParams: {
                parentRecordId: resourceParams.urlParams.parentRecordId,
                relatedListName: item
            },
            queryParams: {
                maxCount: resourceParams.queryParams.maxCount
            }
        });
    }
    return childConfigs;
}
function select$I(lds, resourceParams) {
    const childResources = createChildResourceParams$2(resourceParams);
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$u(childResource);
                const childFragment = select$H();
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                switch (childSnapshot.state) {
                    case 'Fulfilled':
                        reader.seenIds[childKey] = true;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        reader.markMissing();
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                    case 'Stale':
                        reader.markStale();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function keyBuilder$v(params) {
    return keyPrefix + 'BatchRelatedListCountRepresentation(' + 'maxCount:' + params.queryParams.maxCount + ',' + 'parentRecordId:' + params.urlParams.parentRecordId + ',' + 'relatedListNames:' + params.urlParams.relatedListNames + ')';
}
function ingestSuccess$d(lds, resourceParams, request, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$2(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const snapshotStateFulfilled = 'Fulfilled';
    const key = keyBuilder$v(resourceParams);
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const result = childEnvelopes[index];
        const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
        if (result.statusCode === 200) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: true,
                statusText: childStatusCodeText,
                headers: {},
            };
            const childSnapshot = ingestSuccess$c(lds, childResourceParams, createResourceRequest$m(childResourceParams), childResponse);
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
        else {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$c(lds, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [keyBuilder$u(childResourceParams)]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    ObjectFreeze(childSnapshotData);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$I(lds, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$d(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$v(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$n(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-count/batch/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$r,
        headers,
    };
}

const adapterName$c = 'getRelatedListsCount';
const getRelatedListsCount_ConfigPropertyNames = {
    displayName: 'getRelatedListsCount',
    parameters: {
        required: ['parentRecordId', 'relatedListNames'],
        optional: ['maxCount']
    }
};
function createResourceParams$f(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListNames: config.relatedListNames
        },
        queryParams: {
            maxCount: config.maxCount
        }
    };
}
function coerceConfig$g(config) {
    const coercedConfig = {};
    const parentRecordId = config.parentRecordId;
    if (parentRecordId !== undefined) {
        coercedConfig.parentRecordId = parentRecordId;
    }
    const relatedListNames = getFieldApiNamesArray(config.relatedListNames);
    if (relatedListNames !== undefined) {
        coercedConfig.relatedListNames = relatedListNames;
    }
    const maxCount = config.maxCount;
    if (maxCount !== undefined) {
        coercedConfig.maxCount = maxCount;
    }
    return coercedConfig;
}
function typeCheckConfig$i(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedListNames = untrustedConfig.relatedListNames;
    if (ArrayIsArray(untrustedConfig_relatedListNames)) {
        const untrustedConfig_relatedListNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListNames.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListNames_item = untrustedConfig_relatedListNames[i];
            if (typeof untrustedConfig_relatedListNames_item === 'string') {
                untrustedConfig_relatedListNames_array.push(untrustedConfig_relatedListNames_item);
            }
        }
        config.relatedListNames = untrustedConfig_relatedListNames_array;
    }
    const untrustedConfig_maxCount = untrustedConfig.maxCount;
    if (typeof untrustedConfig_maxCount === 'number' && Math.floor(untrustedConfig_maxCount) === untrustedConfig_maxCount) {
        config.maxCount = untrustedConfig_maxCount;
    }
    return config;
}
function validateAdapterConfig$i(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$g(untrustedConfig);
    const config = typeCheckConfig$i(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$h(lds, config) {
    const resourceParams = createResourceParams$f(config);
    const selector = {
        recordId: keyBuilder$v(resourceParams),
        node: select$I(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$f(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$c(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$d(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$c(lds, config, resourceParams, response) {
    const snapshot = ingestError$d(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$f(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$f(lds, config, override) {
    const resourceParams = createResourceParams$f(config);
    const request = createResourceRequest$n(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$c(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$c(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$e(lds, config, snapshot) {
    const resourceParams = createResourceParams$f(config);
    const request = createResourceRequest$n(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$c(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$c(lds, config, resourceParams, response);
    });
}
const getRelatedListsCountAdapterFactory = (lds) => function getRelatedListsCount(untrustedConfig) {
    const config = validateAdapterConfig$i(untrustedConfig, getRelatedListsCount_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$h(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$e(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$f(lds, config);
};

const adapterName$d = 'getRelatedListCount';
const getRelatedListCount_ConfigPropertyNames = {
    displayName: 'getRelatedListCount',
    parameters: {
        required: ['parentRecordId', 'relatedListName'],
        optional: ['maxCount']
    }
};
function createResourceParams$g(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListName: config.relatedListName
        },
        queryParams: {
            maxCount: config.maxCount
        }
    };
}
function typeCheckConfig$j(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedListName = untrustedConfig.relatedListName;
    if (typeof untrustedConfig_relatedListName === 'string') {
        config.relatedListName = untrustedConfig_relatedListName;
    }
    const untrustedConfig_maxCount = untrustedConfig.maxCount;
    if (typeof untrustedConfig_maxCount === 'number' && Math.floor(untrustedConfig_maxCount) === untrustedConfig_maxCount) {
        config.maxCount = untrustedConfig_maxCount;
    }
    return config;
}
function validateAdapterConfig$j(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$j(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$i(lds, config) {
    const resourceParams = createResourceParams$g(config);
    const selector = {
        recordId: keyBuilder$u(resourceParams),
        node: select$H(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$g(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$d(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$c(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$g(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$d(lds, config, resourceParams, response) {
    const snapshot = ingestError$c(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$g(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$g(lds, config, override) {
    const resourceParams = createResourceParams$g(config);
    const request = createResourceRequest$m(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$d(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$d(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$f(lds, config, snapshot) {
    const resourceParams = createResourceParams$g(config);
    const request = createResourceRequest$m(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$d(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$d(lds, config, resourceParams, response);
    });
}
const getRelatedListCountAdapterFactory = (lds) => function getRelatedListCount(untrustedConfig) {
    const config = validateAdapterConfig$j(untrustedConfig, getRelatedListCount_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$i(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$f(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$g(lds, config);
};

function validate$T(obj, path = 'RelatedListColumnRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_lookupId = obj.lookupId;
        const path_lookupId = path + '.lookupId';
        let obj_lookupId_union0 = null;
        const obj_lookupId_union0_error = (() => {
            if (typeof obj_lookupId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
            }
        })();
        if (obj_lookupId_union0_error != null) {
            obj_lookupId_union0 = obj_lookupId_union0_error.message;
        }
        let obj_lookupId_union1 = null;
        const obj_lookupId_union1_error = (() => {
            if (obj_lookupId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lookupId + '" (at "' + path_lookupId + '")');
            }
        })();
        if (obj_lookupId_union1_error != null) {
            obj_lookupId_union1 = obj_lookupId_union1_error.message;
        }
        if (obj_lookupId_union0 && obj_lookupId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lookupId + '")';
            message += '\n' + obj_lookupId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lookupId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_sortable = obj.sortable;
        const path_sortable = path + '.sortable';
        if (typeof obj_sortable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_sortable + '" (at "' + path_sortable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$o(input) {
    ObjectFreeze$1(input);
}

const TTL$8 = 900000;
function validate$U(obj, path = 'RelatedListInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_cloneable = obj.cloneable;
        const path_cloneable = path + '.cloneable';
        if (typeof obj_cloneable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_cloneable + '" (at "' + path_cloneable + '")');
        }
        const obj_createable = obj.createable;
        const path_createable = path + '.createable';
        if (typeof obj_createable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_createable + '" (at "' + path_createable + '")');
        }
        const obj_deletable = obj.deletable;
        const path_deletable = path + '.deletable';
        if (typeof obj_deletable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_deletable + '" (at "' + path_deletable + '")');
        }
        const obj_displayColumns = obj.displayColumns;
        const path_displayColumns = path + '.displayColumns';
        if (!ArrayIsArray$1(obj_displayColumns)) {
            return new TypeError('Expected "array" but received "' + typeof obj_displayColumns + '" (at "' + path_displayColumns + '")');
        }
        for (let i = 0; i < obj_displayColumns.length; i++) {
            const obj_displayColumns_item = obj_displayColumns[i];
            const path_displayColumns_item = path_displayColumns + '[' + i + ']';
            const referenceRelatedListColumnRepresentationValidationError = validate$T(obj_displayColumns_item, path_displayColumns_item);
            if (referenceRelatedListColumnRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RelatedListColumnRepresentation (at "' + path_displayColumns_item + '")\n';
                message += referenceRelatedListColumnRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_filterLogicString = obj.filterLogicString;
        const path_filterLogicString = path + '.filterLogicString';
        if (typeof obj_filterLogicString !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_filterLogicString + '" (at "' + path_filterLogicString + '")');
        }
        const obj_filteredByInfo = obj.filteredByInfo;
        const path_filteredByInfo = path + '.filteredByInfo';
        if (!ArrayIsArray$1(obj_filteredByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_filteredByInfo + '" (at "' + path_filteredByInfo + '")');
        }
        for (let i = 0; i < obj_filteredByInfo.length; i++) {
            const obj_filteredByInfo_item = obj_filteredByInfo[i];
            const path_filteredByInfo_item = path_filteredByInfo + '[' + i + ']';
            const referenceListFilterByInfoRepresentationValidationError = validate$1(obj_filteredByInfo_item, path_filteredByInfo_item);
            if (referenceListFilterByInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ListFilterByInfoRepresentation (at "' + path_filteredByInfo_item + '")\n';
                message += referenceListFilterByInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referenceRelatedListReferenceRepresentationValidationError = validate$P(obj_listReference, path_listReference);
        if (referenceRelatedListReferenceRepresentationValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
            message += referenceRelatedListReferenceRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_orderedByInfo = obj.orderedByInfo;
        const path_orderedByInfo = path + '.orderedByInfo';
        if (!ArrayIsArray$1(obj_orderedByInfo)) {
            return new TypeError('Expected "array" but received "' + typeof obj_orderedByInfo + '" (at "' + path_orderedByInfo + '")');
        }
        for (let i = 0; i < obj_orderedByInfo.length; i++) {
            const obj_orderedByInfo_item = obj_orderedByInfo[i];
            const path_orderedByInfo_item = path_orderedByInfo + '[' + i + ']';
            const referenceListOrderByInfoRepresentationValidationError = validate$2(obj_orderedByInfo_item, path_orderedByInfo_item);
            if (referenceListOrderByInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ListOrderByInfoRepresentation (at "' + path_orderedByInfo_item + '")\n';
                message += referenceListOrderByInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
        const obj_updateable = obj.updateable;
        const path_updateable = path + '.updateable';
        if (typeof obj_updateable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_updateable + '" (at "' + path_updateable + '")');
        }
        const obj_userPreferences = obj.userPreferences;
        const path_userPreferences = path + '.userPreferences';
        const referenceListUserPreferenceRepresentationValidationError = validate$3(obj_userPreferences, path_userPreferences);
        if (referenceListUserPreferenceRepresentationValidationError !== null) {
            let message = 'Object doesn\'t match ListUserPreferenceRepresentation (at "' + path_userPreferences + '")\n';
            message += referenceListUserPreferenceRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_visibility = obj.visibility;
        const path_visibility = path + '.visibility';
        if (typeof obj_visibility !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_visibility + '" (at "' + path_visibility + '")');
        }
        const obj_visibilityEditable = obj.visibilityEditable;
        const path_visibilityEditable = path + '.visibilityEditable';
        if (typeof obj_visibilityEditable !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_visibilityEditable + '" (at "' + path_visibilityEditable + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$w(config) {
    return keyPrefix + 'RelatedListInfoRepresentation:' + config.parentObjectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId) + ':' + config.relatedListId;
}
function keyBuilderFromType$f(object) {
    const keyParams = {
        parentObjectApiName: object.listReference.parentObjectApiName,
        recordTypeId: object.listReference.recordTypeId,
        relatedListId: object.listReference.relatedListId
    };
    return keyBuilder$w(keyParams);
}
function normalize$s(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$J = function RelatedListInfoRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'cloneable',
                kind: 'Scalar'
            },
            {
                name: 'createable',
                kind: 'Scalar'
            },
            {
                name: 'deletable',
                kind: 'Scalar'
            },
            {
                name: 'displayColumns',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'filterLogicString',
                kind: 'Scalar'
            },
            {
                name: 'filteredByInfo',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'label',
                kind: 'Scalar'
            },
            {
                name: 'listReference',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'orderedByInfo',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'updateable',
                kind: 'Scalar'
            },
            {
                name: 'userPreferences',
                kind: 'Object',
                opaque: true
            },
            {
                name: 'visibility',
                kind: 'Scalar'
            },
            {
                name: 'visibilityEditable',
                kind: 'Scalar'
            }
        ]
    };
};
function equals$w(existing, incoming) {
    if (JSONStrinify(incoming) !== JSONStrinify(existing)) {
        return false;
    }
    return true;
}
function deepFreeze$p(input) {
    const input_displayColumns = input.displayColumns;
    for (let i = 0; i < input_displayColumns.length; i++) {
        const input_displayColumns_item = input_displayColumns[i];
        deepFreeze$o(input_displayColumns_item);
    }
    ObjectFreeze$1(input_displayColumns);
    const input_filteredByInfo = input.filteredByInfo;
    for (let i = 0; i < input_filteredByInfo.length; i++) {
        const input_filteredByInfo_item = input_filteredByInfo[i];
        deepFreeze$1(input_filteredByInfo_item);
    }
    ObjectFreeze$1(input_filteredByInfo);
    const input_listReference = input.listReference;
    deepFreeze$n(input_listReference);
    const input_orderedByInfo = input.orderedByInfo;
    for (let i = 0; i < input_orderedByInfo.length; i++) {
        const input_orderedByInfo_item = input_orderedByInfo[i];
        deepFreeze$2(input_orderedByInfo_item);
    }
    ObjectFreeze$1(input_orderedByInfo);
    const input_userPreferences = input.userPreferences;
    deepFreeze$3(input_userPreferences);
    ObjectFreeze$1(input);
}
const ingest$s = function RelatedListInfoRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$U(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$f(input);
    let incomingRecord = normalize$s(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    deepFreeze$p(input);
    if (existingRecord === undefined || equals$w(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function select$K(lds, params) {
    return select$J();
}
function keyBuilder$x(params) {
    return keyBuilder$w({
        parentObjectApiName: params.urlParams.parentObjectApiName,
        relatedListId: params.urlParams.relatedListId,
        recordTypeId: params.queryParams.recordTypeId || null
    });
}
function ingestSuccess$e(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$x(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$K(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$e(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$x(params);
    lds.storeIngestFetchResponse(key, error, TTL$8);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$o(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$s,
        headers,
    };
}

function validate$V(obj, path = 'SimpleRelatedListInfoResultRepresentation') {
    const v_error = (() => {
        const path_statusCode = path + '.statusCode';
        const obj_statusCode = obj.statusCode;
        const path_result = path + '.result';
        const obj_result = obj.result;
        if (typeof obj_statusCode !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
        switch (obj_statusCode) {
            case 200: {
                if (typeof obj_result !== 'object') {
                    return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
                }
            }
            default: {
                if (obj_result === undefined) {
                    return new TypeError('Expected "' + path_result + '" to be present but received "undefined" (at "' + path_result + '")');
                }
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$t(input, existing, path, lds, store, timestamp) {
    const input_result = input.result;
    const input_result_id = path.fullPath + '__result';
    input.result = ingest$s(input_result, {
        fullPath: input_result_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$x(existing, incoming) {
    const existing_statusCode = existing.statusCode;
    const incoming_statusCode = incoming.statusCode;
    if (!(existing_statusCode === incoming_statusCode)) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
    }
    return true;
}
const ingest$t = function SimpleRelatedListInfoResultRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$V(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$t(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$x(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$W(obj, path = 'RelatedListInfoBatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_results = obj.results;
        const path_results = path + '.results';
        if (!ArrayIsArray$1(obj_results)) {
            return new TypeError('Expected "array" but received "' + typeof obj_results + '" (at "' + path_results + '")');
        }
        for (let i = 0; i < obj_results.length; i++) {
            const obj_results_item = obj_results[i];
            const path_results_item = path_results + '[' + i + ']';
            if (typeof obj_results_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_results_item + '" (at "' + path_results_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$u(input, existing, path, lds, store, timestamp) {
    const input_results = input.results;
    const input_results_id = path.fullPath + '__results';
    for (let i = 0; i < input_results.length; i++) {
        const input_results_item = input_results[i];
        let input_results_item_id = input_results_id + '__' + i;
        input_results[i] = ingest$t(input_results_item, {
            fullPath: input_results_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$y(existing, incoming) {
    const existing_results = existing.results;
    const incoming_results = incoming.results;
    const equals_results_items = equalsArray(existing_results, incoming_results, (existing_results_item, incoming_results_item) => {
        if (!(existing_results_item.__ref === incoming_results_item.__ref)) {
            return false;
        }
    });
    if (equals_results_items === false) {
        return false;
    }
    return true;
}
const ingest$u = function RelatedListInfoBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$W(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$u(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$y(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function createChildResourceParams$3(resourceParams) {
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListNames.length; index < len; index += 1) {
        const item = resourceParams.urlParams.relatedListNames[index];
        childConfigs.push({
            urlParams: {
                parentObjectApiName: resourceParams.urlParams.parentObjectApiName,
                relatedListId: item
            },
            queryParams: {
                recordTypeId: resourceParams.queryParams.recordTypeId
            }
        });
    }
    return childConfigs;
}
function select$L(lds, resourceParams) {
    const childResources = createChildResourceParams$3(resourceParams);
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$x(childResource);
                const childFragment = select$K();
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                switch (childSnapshot.state) {
                    case 'Fulfilled':
                        reader.seenIds[childKey] = true;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        reader.markMissing();
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                    case 'Stale':
                        reader.markStale();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        }
    };
}
function keyBuilder$y(params) {
    return keyPrefix + 'RelatedListInfoBatchRepresentation(' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'parentObjectApiName:' + params.urlParams.parentObjectApiName + ',' + 'relatedListNames:' + params.urlParams.relatedListNames + ')';
}
function ingestSuccess$f(lds, resourceParams, request, response, snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$3(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' + childResourceParamsArray.length + ' items, received ' + childEnvelopes.length);
        }
    }
    const snapshotStateFulfilled = 'Fulfilled';
    const key = keyBuilder$y(resourceParams);
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const result = childEnvelopes[index];
        const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
        if (result.statusCode === 200) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: true,
                statusText: childStatusCodeText,
                headers: {},
            };
            const childSnapshot = ingestSuccess$e(lds, childResourceParams, createResourceRequest$o(childResourceParams), childResponse);
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
        else {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$e(lds, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [keyBuilder$x(childResourceParams)]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses
    };
    ObjectFreeze(childSnapshotData);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$L(lds, resourceParams),
            variables: {},
        },
        refresh: snapshotRefresh,
        variables: {},
    };
}
function ingestError$f(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$y(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$p(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-info/batch/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListNames + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$u,
        headers,
    };
}

const adapterName$e = 'getRelatedListInfoBatch';
const getRelatedListInfoBatch_ConfigPropertyNames = {
    displayName: 'getRelatedListInfoBatch',
    parameters: {
        required: ['parentObjectApiName', 'relatedListNames'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$h(config) {
    return {
        urlParams: {
            parentObjectApiName: config.parentObjectApiName, relatedListNames: config.relatedListNames
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        }
    };
}
function typeCheckConfig$k(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentObjectApiName = untrustedConfig.parentObjectApiName;
    if (typeof untrustedConfig_parentObjectApiName === 'string') {
        config.parentObjectApiName = untrustedConfig_parentObjectApiName;
    }
    const untrustedConfig_relatedListNames = untrustedConfig.relatedListNames;
    if (ArrayIsArray(untrustedConfig_relatedListNames)) {
        const untrustedConfig_relatedListNames_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedListNames.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListNames_item = untrustedConfig_relatedListNames[i];
            if (typeof untrustedConfig_relatedListNames_item === 'string') {
                untrustedConfig_relatedListNames_array.push(untrustedConfig_relatedListNames_item);
            }
        }
        config.relatedListNames = untrustedConfig_relatedListNames_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$k(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$k(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$j(lds, config) {
    const resourceParams = createResourceParams$h(config);
    const selector = {
        recordId: keyBuilder$y(resourceParams),
        node: select$L(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$h(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$e(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$f(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$h(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$e(lds, config, resourceParams, response) {
    const snapshot = ingestError$f(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$h(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$h(lds, config, override) {
    const resourceParams = createResourceParams$h(config);
    const request = createResourceRequest$p(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$e(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$e(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$g(lds, config, snapshot) {
    const resourceParams = createResourceParams$h(config);
    const request = createResourceRequest$p(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$e(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$e(lds, config, resourceParams, response);
    });
}
const getRelatedListInfoBatchAdapterFactory = (lds) => function getRelatedListInfoBatch(untrustedConfig) {
    const config = validateAdapterConfig$k(untrustedConfig, getRelatedListInfoBatch_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$j(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$g(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$h(lds, config);
};

function validate$X(obj, path = 'RelatedListSummaryInfoRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_entityLabel = obj.entityLabel;
        const path_entityLabel = path + '.entityLabel';
        if (typeof obj_entityLabel !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_entityLabel + '" (at "' + path_entityLabel + '")');
        }
        const obj_entityPluralLabel = obj.entityPluralLabel;
        const path_entityPluralLabel = path + '.entityPluralLabel';
        if (typeof obj_entityPluralLabel !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_entityPluralLabel + '" (at "' + path_entityPluralLabel + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_keyPrefix = obj.keyPrefix;
        const path_keyPrefix = path + '.keyPrefix';
        let obj_keyPrefix_union0 = null;
        const obj_keyPrefix_union0_error = (() => {
            if (typeof obj_keyPrefix !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union0_error != null) {
            obj_keyPrefix_union0 = obj_keyPrefix_union0_error.message;
        }
        let obj_keyPrefix_union1 = null;
        const obj_keyPrefix_union1_error = (() => {
            if (obj_keyPrefix !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_keyPrefix + '" (at "' + path_keyPrefix + '")');
            }
        })();
        if (obj_keyPrefix_union1_error != null) {
            obj_keyPrefix_union1 = obj_keyPrefix_union1_error.message;
        }
        if (obj_keyPrefix_union0 && obj_keyPrefix_union1) {
            let message = 'Object doesn\'t match union (at "' + path_keyPrefix + '")';
            message += '\n' + obj_keyPrefix_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_keyPrefix_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_label = obj.label;
        const path_label = path + '.label';
        if (typeof obj_label !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_label + '" (at "' + path_label + '")');
        }
        const obj_objectApiName = obj.objectApiName;
        const path_objectApiName = path + '.objectApiName';
        if (typeof obj_objectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_objectApiName + '" (at "' + path_objectApiName + '")');
        }
        const obj_parentFieldApiName = obj.parentFieldApiName;
        const path_parentFieldApiName = path + '.parentFieldApiName';
        if (typeof obj_parentFieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentFieldApiName + '" (at "' + path_parentFieldApiName + '")');
        }
        const obj_relatedListId = obj.relatedListId;
        const path_relatedListId = path + '.relatedListId';
        if (typeof obj_relatedListId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_relatedListId + '" (at "' + path_relatedListId + '")');
        }
        const obj_relatedListInfoUrl = obj.relatedListInfoUrl;
        const path_relatedListInfoUrl = path + '.relatedListInfoUrl';
        let obj_relatedListInfoUrl_union0 = null;
        const obj_relatedListInfoUrl_union0_error = (() => {
            if (typeof obj_relatedListInfoUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_relatedListInfoUrl + '" (at "' + path_relatedListInfoUrl + '")');
            }
        })();
        if (obj_relatedListInfoUrl_union0_error != null) {
            obj_relatedListInfoUrl_union0 = obj_relatedListInfoUrl_union0_error.message;
        }
        let obj_relatedListInfoUrl_union1 = null;
        const obj_relatedListInfoUrl_union1_error = (() => {
            if (obj_relatedListInfoUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_relatedListInfoUrl + '" (at "' + path_relatedListInfoUrl + '")');
            }
        })();
        if (obj_relatedListInfoUrl_union1_error != null) {
            obj_relatedListInfoUrl_union1 = obj_relatedListInfoUrl_union1_error.message;
        }
        if (obj_relatedListInfoUrl_union0 && obj_relatedListInfoUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_relatedListInfoUrl + '")';
            message += '\n' + obj_relatedListInfoUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_relatedListInfoUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_themeInfo = obj.themeInfo;
        const path_themeInfo = path + '.themeInfo';
        let obj_themeInfo_union0 = null;
        const obj_themeInfo_union0_error = (() => {
            const referenceThemeInfoRepresentationValidationError = validate$i(obj_themeInfo, path_themeInfo);
            if (referenceThemeInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ThemeInfoRepresentation (at "' + path_themeInfo + '")\n';
                message += referenceThemeInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_themeInfo_union0_error != null) {
            obj_themeInfo_union0 = obj_themeInfo_union0_error.message;
        }
        let obj_themeInfo_union1 = null;
        const obj_themeInfo_union1_error = (() => {
            if (obj_themeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_themeInfo + '" (at "' + path_themeInfo + '")');
            }
        })();
        if (obj_themeInfo_union1_error != null) {
            obj_themeInfo_union1 = obj_themeInfo_union1_error.message;
        }
        if (obj_themeInfo_union0 && obj_themeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_themeInfo + '")';
            message += '\n' + obj_themeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_themeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function deepFreeze$q(input) {
    const input_themeInfo = input.themeInfo;
    if (input_themeInfo !== null && typeof input_themeInfo === 'object') {
        deepFreeze$9(input_themeInfo);
    }
    ObjectFreeze$1(input);
}

function validate$Y(obj, path = 'RelatedListSummaryInfoCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_parentObjectApiName = obj.parentObjectApiName;
        const path_parentObjectApiName = path + '.parentObjectApiName';
        if (typeof obj_parentObjectApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_parentObjectApiName + '" (at "' + path_parentObjectApiName + '")');
        }
        const obj_parentRecordTypeId = obj.parentRecordTypeId;
        const path_parentRecordTypeId = path + '.parentRecordTypeId';
        let obj_parentRecordTypeId_union0 = null;
        const obj_parentRecordTypeId_union0_error = (() => {
            if (typeof obj_parentRecordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_parentRecordTypeId + '" (at "' + path_parentRecordTypeId + '")');
            }
        })();
        if (obj_parentRecordTypeId_union0_error != null) {
            obj_parentRecordTypeId_union0 = obj_parentRecordTypeId_union0_error.message;
        }
        let obj_parentRecordTypeId_union1 = null;
        const obj_parentRecordTypeId_union1_error = (() => {
            if (obj_parentRecordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_parentRecordTypeId + '" (at "' + path_parentRecordTypeId + '")');
            }
        })();
        if (obj_parentRecordTypeId_union1_error != null) {
            obj_parentRecordTypeId_union1 = obj_parentRecordTypeId_union1_error.message;
        }
        if (obj_parentRecordTypeId_union0 && obj_parentRecordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_parentRecordTypeId + '")';
            message += '\n' + obj_parentRecordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_parentRecordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_relatedLists = obj.relatedLists;
        const path_relatedLists = path + '.relatedLists';
        if (!ArrayIsArray$1(obj_relatedLists)) {
            return new TypeError('Expected "array" but received "' + typeof obj_relatedLists + '" (at "' + path_relatedLists + '")');
        }
        for (let i = 0; i < obj_relatedLists.length; i++) {
            const obj_relatedLists_item = obj_relatedLists[i];
            const path_relatedLists_item = path_relatedLists + '[' + i + ']';
            const referenceRelatedListSummaryInfoRepresentationValidationError = validate$X(obj_relatedLists_item, path_relatedLists_item);
            if (referenceRelatedListSummaryInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RelatedListSummaryInfoRepresentation (at "' + path_relatedLists_item + '")\n';
                message += referenceRelatedListSummaryInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$z(config) {
    return keyPrefix + 'RelatedListSummaryInfoCollectionRepresentation:' + config.parentObjectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$g(object) {
    const keyParams = {
        parentObjectApiName: object.parentObjectApiName,
        recordTypeId: object.parentRecordTypeId
    };
    return keyBuilder$z(keyParams);
}
function normalize$v(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$M = function RelatedListSummaryInfoCollectionRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            {
                name: 'parentObjectApiName',
                kind: 'Scalar'
            },
            {
                name: 'parentRecordTypeId',
                kind: 'Scalar'
            },
            {
                name: 'relatedLists',
                kind: 'Object',
                opaque: true
            }
        ]
    };
};
function equals$z(existing, incoming) {
    if (existing.eTag !== incoming.eTag) {
        return false;
    }
    return true;
}
function deepFreeze$r(input) {
    const input_relatedLists = input.relatedLists;
    for (let i = 0; i < input_relatedLists.length; i++) {
        const input_relatedLists_item = input_relatedLists[i];
        deepFreeze$q(input_relatedLists_item);
    }
    ObjectFreeze$1(input_relatedLists);
    ObjectFreeze$1(input);
}
const ingest$v = function RelatedListSummaryInfoCollectionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$Y(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$g(input);
    let incomingRecord = normalize$v(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    deepFreeze$r(input);
    if (existingRecord === undefined || equals$z(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function select$N(lds, params) {
    return select$M();
}
function keyBuilder$A(params) {
    return keyBuilder$z({
        parentObjectApiName: params.urlParams.parentObjectApiName,
        recordTypeId: params.queryParams.recordTypeId || null
    });
}
function ingestSuccess$g(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$A(resourceParams);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$N(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function ingestError$g(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$A(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$q(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$v,
        headers,
    };
}

const adapterName$f = 'getRelatedListsInfo';
const getRelatedListsInfo_ConfigPropertyNames = {
    displayName: 'getRelatedListsInfo',
    parameters: {
        required: ['parentObjectApiName'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$i(config) {
    return {
        urlParams: {
            parentObjectApiName: config.parentObjectApiName
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        }
    };
}
function typeCheckConfig$l(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentObjectApiName = untrustedConfig.parentObjectApiName;
    if (typeof untrustedConfig_parentObjectApiName === 'string') {
        config.parentObjectApiName = untrustedConfig_parentObjectApiName;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$l(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$l(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$k(lds, config) {
    const resourceParams = createResourceParams$i(config);
    const selector = {
        recordId: keyBuilder$A(resourceParams),
        node: select$N(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$i(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$f(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$g(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$f(lds, config, resourceParams, response) {
    const snapshot = ingestError$g(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$i(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$i(lds, config, override) {
    const resourceParams = createResourceParams$i(config);
    const request = createResourceRequest$q(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$f(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$f(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$h(lds, config, snapshot) {
    const resourceParams = createResourceParams$i(config);
    const request = createResourceRequest$q(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$f(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$f(lds, config, resourceParams, response);
    });
}
const getRelatedListsInfoAdapterFactory = (lds) => function getRelatedListsInfo(untrustedConfig) {
    const config = validateAdapterConfig$l(untrustedConfig, getRelatedListsInfo_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$k(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$h(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$i(lds, config);
};

const adapterName$g = 'getRelatedListInfo';
const getRelatedListInfo_ConfigPropertyNames = {
    displayName: 'getRelatedListInfo',
    parameters: {
        required: ['parentObjectApiName', 'relatedListId'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$j(config) {
    return {
        urlParams: {
            parentObjectApiName: config.parentObjectApiName, relatedListId: config.relatedListId
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        }
    };
}
function typeCheckConfig$m(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentObjectApiName = untrustedConfig.parentObjectApiName;
    if (typeof untrustedConfig_parentObjectApiName === 'string') {
        config.parentObjectApiName = untrustedConfig_parentObjectApiName;
    }
    const untrustedConfig_relatedListId = untrustedConfig.relatedListId;
    if (typeof untrustedConfig_relatedListId === 'string') {
        config.relatedListId = untrustedConfig_relatedListId;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$m(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$m(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$l(lds, config) {
    const resourceParams = createResourceParams$j(config);
    const selector = {
        recordId: keyBuilder$x(resourceParams),
        node: select$K(),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$j(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$g(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$e(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$g(lds, config, resourceParams, response) {
    const snapshot = ingestError$e(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$j(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$j(lds, config, override) {
    const resourceParams = createResourceParams$j(config);
    const request = createResourceRequest$o(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$g(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$g(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$i(lds, config, snapshot) {
    const resourceParams = createResourceParams$j(config);
    const request = createResourceRequest$o(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$g(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$g(lds, config, resourceParams, response);
    });
}
const getRelatedListInfoAdapterFactory = (lds) => function getRelatedListInfo(untrustedConfig) {
    const config = validateAdapterConfig$m(untrustedConfig, getRelatedListInfo_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$l(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$i(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$j(lds, config);
};

function validate$Z(obj, path = 'ListOrderedByInfoInputRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_fieldApiName = obj.fieldApiName;
        const path_fieldApiName = path + '.fieldApiName';
        if (typeof obj_fieldApiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_fieldApiName + '" (at "' + path_fieldApiName + '")');
        }
        const obj_isAscending = obj.isAscending;
        const path_isAscending = path + '.isAscending';
        if (typeof obj_isAscending !== 'boolean') {
            return new TypeError('Expected "boolean" but received "' + typeof obj_isAscending + '" (at "' + path_isAscending + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}

function select$O(lds, params) {
    return select$J();
}
function ingestSuccess$h(lds, resourceParams, request, response, snapshotRefresh) {
    const { body } = response;
    const key = keyBuilder$w({
        parentObjectApiName: body.listReference.parentObjectApiName,
        recordTypeId: body.listReference.recordTypeId,
        relatedListId: body.listReference.relatedListId,
    });
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$O(),
        variables: {},
    }, snapshotRefresh);
    if (process.env.NODE_ENV !== 'production') {
        if (response.headers !== undefined && snapshot.state !== 'Fulfilled') {
            throw new Error('Invalid network response. Expected resource response to result in Fulfilled snapshot');
        }
        if (!(snapshot.state === 'Fulfilled' || snapshot.state === 'Stale')) {
            throw new Error('Invalid resource response. Expected resource response to result in Fulfilled or Stale snapshot');
        }
    }
    return snapshot;
}
function createResourceRequest$r(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-info/' + config.urlParams.parentObjectApiName + '/' + config.urlParams.relatedListId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$s,
        headers,
    };
}

const adapterName$h = 'updateRelatedListInfo';
const updateRelatedListInfo_ConfigPropertyNames = {
    displayName: 'updateRelatedListInfo',
    parameters: {
        required: ['parentObjectApiName', 'relatedListId', 'orderedByInfo', 'userPreferences'],
        optional: ['recordTypeId']
    }
};
function createResourceParams$k(config) {
    return {
        urlParams: {
            parentObjectApiName: config.parentObjectApiName, relatedListId: config.relatedListId
        },
        queryParams: {
            recordTypeId: config.recordTypeId
        },
        body: {
            orderedByInfo: config.orderedByInfo, userPreferences: config.userPreferences
        }
    };
}
function typeCheckConfig$n(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentObjectApiName = untrustedConfig.parentObjectApiName;
    if (typeof untrustedConfig_parentObjectApiName === 'string') {
        config.parentObjectApiName = untrustedConfig_parentObjectApiName;
    }
    const untrustedConfig_relatedListId = untrustedConfig.relatedListId;
    if (typeof untrustedConfig_relatedListId === 'string') {
        config.relatedListId = untrustedConfig_relatedListId;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    const untrustedConfig_orderedByInfo = untrustedConfig.orderedByInfo;
    if (ArrayIsArray(untrustedConfig_orderedByInfo)) {
        const untrustedConfig_orderedByInfo_array = [];
        for (let i = 0, arrayLength = untrustedConfig_orderedByInfo.length; i < arrayLength; i++) {
            const untrustedConfig_orderedByInfo_item = untrustedConfig_orderedByInfo[i];
            const referenceListOrderedByInfoInputRepresentationValidationError = validate$Z(untrustedConfig_orderedByInfo_item);
            if (referenceListOrderedByInfoInputRepresentationValidationError === null) {
                untrustedConfig_orderedByInfo_array.push(untrustedConfig_orderedByInfo_item);
            }
        }
        config.orderedByInfo = untrustedConfig_orderedByInfo_array;
    }
    const untrustedConfig_userPreferences = untrustedConfig.userPreferences;
    const referenceListUserPreferenceRepresentationValidationError = validate$3(untrustedConfig_userPreferences);
    if (referenceListUserPreferenceRepresentationValidationError === null) {
        config.userPreferences = untrustedConfig_userPreferences;
    }
    return config;
}
function validateAdapterConfig$n(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$n(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildNetworkSnapshot$k(lds, config, override) {
    const resourceParams = createResourceParams$k(config);
    const request = createResourceRequest$r(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        const snapshot = ingestSuccess$h(lds, resourceParams, request, response);
        lds.storeBroadcast();
        return snapshot;
    }, (response) => {
        return lds.errorSnapshot(response);
    });
}
const updateRelatedListInfoAdapterFactory = (lds) => {
    return function updateRelatedListInfo(untrustedConfig) {
        const config = validateAdapterConfig$n(untrustedConfig, updateRelatedListInfo_ConfigPropertyNames);
        // Invalid or incomplete config
        if (config === null) {
            throw new Error(`Invalid config for "${adapterName$h}"`);
        }
        return buildNetworkSnapshot$k(lds, config);
    };
};

function validate$_(obj, path = 'RelatedListRecordCollectionRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_count = obj.count;
        const path_count = path + '.count';
        if (typeof obj_count !== 'number' || (typeof obj_count === 'number' && Math.floor(obj_count) !== obj_count)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_count + '" (at "' + path_count + '")');
        }
        const obj_currentPageToken = obj.currentPageToken;
        const path_currentPageToken = path + '.currentPageToken';
        if (typeof obj_currentPageToken !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_currentPageToken + '" (at "' + path_currentPageToken + '")');
        }
        const obj_currentPageUrl = obj.currentPageUrl;
        const path_currentPageUrl = path + '.currentPageUrl';
        let obj_currentPageUrl_union0 = null;
        const obj_currentPageUrl_union0_error = (() => {
            if (typeof obj_currentPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
            }
        })();
        if (obj_currentPageUrl_union0_error != null) {
            obj_currentPageUrl_union0 = obj_currentPageUrl_union0_error.message;
        }
        let obj_currentPageUrl_union1 = null;
        const obj_currentPageUrl_union1_error = (() => {
            if (obj_currentPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_currentPageUrl + '" (at "' + path_currentPageUrl + '")');
            }
        })();
        if (obj_currentPageUrl_union1_error != null) {
            obj_currentPageUrl_union1 = obj_currentPageUrl_union1_error.message;
        }
        if (obj_currentPageUrl_union0 && obj_currentPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_currentPageUrl + '")';
            message += '\n' + obj_currentPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_currentPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (!ArrayIsArray$1(obj_fields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        for (let i = 0; i < obj_fields.length; i++) {
            const obj_fields_item = obj_fields[i];
            const path_fields_item = path_fields + '[' + i + ']';
            if (typeof obj_fields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_fields_item + '" (at "' + path_fields_item + '")');
            }
        }
        const obj_listInfoETag = obj.listInfoETag;
        const path_listInfoETag = path + '.listInfoETag';
        let obj_listInfoETag_union0 = null;
        const obj_listInfoETag_union0_error = (() => {
            if (typeof obj_listInfoETag !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
            }
        })();
        if (obj_listInfoETag_union0_error != null) {
            obj_listInfoETag_union0 = obj_listInfoETag_union0_error.message;
        }
        let obj_listInfoETag_union1 = null;
        const obj_listInfoETag_union1_error = (() => {
            if (obj_listInfoETag !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_listInfoETag + '" (at "' + path_listInfoETag + '")');
            }
        })();
        if (obj_listInfoETag_union1_error != null) {
            obj_listInfoETag_union1 = obj_listInfoETag_union1_error.message;
        }
        if (obj_listInfoETag_union0 && obj_listInfoETag_union1) {
            let message = 'Object doesn\'t match union (at "' + path_listInfoETag + '")';
            message += '\n' + obj_listInfoETag_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_listInfoETag_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_listReference = obj.listReference;
        const path_listReference = path + '.listReference';
        const referenceRelatedListReferenceRepresentationValidationError = validate$P(obj_listReference, path_listReference);
        if (referenceRelatedListReferenceRepresentationValidationError !== null) {
            let message = 'Object doesn\'t match RelatedListReferenceRepresentation (at "' + path_listReference + '")\n';
            message += referenceRelatedListReferenceRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageToken = obj.nextPageToken;
        const path_nextPageToken = path + '.nextPageToken';
        let obj_nextPageToken_union0 = null;
        const obj_nextPageToken_union0_error = (() => {
            if (typeof obj_nextPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union0_error != null) {
            obj_nextPageToken_union0 = obj_nextPageToken_union0_error.message;
        }
        let obj_nextPageToken_union1 = null;
        const obj_nextPageToken_union1_error = (() => {
            if (obj_nextPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageToken + '" (at "' + path_nextPageToken + '")');
            }
        })();
        if (obj_nextPageToken_union1_error != null) {
            obj_nextPageToken_union1 = obj_nextPageToken_union1_error.message;
        }
        if (obj_nextPageToken_union0 && obj_nextPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageToken + '")';
            message += '\n' + obj_nextPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_nextPageUrl = obj.nextPageUrl;
        const path_nextPageUrl = path + '.nextPageUrl';
        let obj_nextPageUrl_union0 = null;
        const obj_nextPageUrl_union0_error = (() => {
            if (typeof obj_nextPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union0_error != null) {
            obj_nextPageUrl_union0 = obj_nextPageUrl_union0_error.message;
        }
        let obj_nextPageUrl_union1 = null;
        const obj_nextPageUrl_union1_error = (() => {
            if (obj_nextPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_nextPageUrl + '" (at "' + path_nextPageUrl + '")');
            }
        })();
        if (obj_nextPageUrl_union1_error != null) {
            obj_nextPageUrl_union1 = obj_nextPageUrl_union1_error.message;
        }
        if (obj_nextPageUrl_union0 && obj_nextPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_nextPageUrl + '")';
            message += '\n' + obj_nextPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_nextPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_optionalFields = obj.optionalFields;
        const path_optionalFields = path + '.optionalFields';
        if (!ArrayIsArray$1(obj_optionalFields)) {
            return new TypeError('Expected "array" but received "' + typeof obj_optionalFields + '" (at "' + path_optionalFields + '")');
        }
        for (let i = 0; i < obj_optionalFields.length; i++) {
            const obj_optionalFields_item = obj_optionalFields[i];
            const path_optionalFields_item = path_optionalFields + '[' + i + ']';
            if (typeof obj_optionalFields_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_optionalFields_item + '" (at "' + path_optionalFields_item + '")');
            }
        }
        const obj_pageSize = obj.pageSize;
        const path_pageSize = path + '.pageSize';
        let obj_pageSize_union0 = null;
        const obj_pageSize_union0_error = (() => {
            if (typeof obj_pageSize !== 'number' || (typeof obj_pageSize === 'number' && Math.floor(obj_pageSize) !== obj_pageSize)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
            }
        })();
        if (obj_pageSize_union0_error != null) {
            obj_pageSize_union0 = obj_pageSize_union0_error.message;
        }
        let obj_pageSize_union1 = null;
        const obj_pageSize_union1_error = (() => {
            if (obj_pageSize !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_pageSize + '" (at "' + path_pageSize + '")');
            }
        })();
        if (obj_pageSize_union1_error != null) {
            obj_pageSize_union1 = obj_pageSize_union1_error.message;
        }
        if (obj_pageSize_union0 && obj_pageSize_union1) {
            let message = 'Object doesn\'t match union (at "' + path_pageSize + '")';
            message += '\n' + obj_pageSize_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_pageSize_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageToken = obj.previousPageToken;
        const path_previousPageToken = path + '.previousPageToken';
        let obj_previousPageToken_union0 = null;
        const obj_previousPageToken_union0_error = (() => {
            if (typeof obj_previousPageToken !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union0_error != null) {
            obj_previousPageToken_union0 = obj_previousPageToken_union0_error.message;
        }
        let obj_previousPageToken_union1 = null;
        const obj_previousPageToken_union1_error = (() => {
            if (obj_previousPageToken !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageToken + '" (at "' + path_previousPageToken + '")');
            }
        })();
        if (obj_previousPageToken_union1_error != null) {
            obj_previousPageToken_union1 = obj_previousPageToken_union1_error.message;
        }
        if (obj_previousPageToken_union0 && obj_previousPageToken_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageToken + '")';
            message += '\n' + obj_previousPageToken_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageToken_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_previousPageUrl = obj.previousPageUrl;
        const path_previousPageUrl = path + '.previousPageUrl';
        let obj_previousPageUrl_union0 = null;
        const obj_previousPageUrl_union0_error = (() => {
            if (typeof obj_previousPageUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union0_error != null) {
            obj_previousPageUrl_union0 = obj_previousPageUrl_union0_error.message;
        }
        let obj_previousPageUrl_union1 = null;
        const obj_previousPageUrl_union1_error = (() => {
            if (obj_previousPageUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_previousPageUrl + '" (at "' + path_previousPageUrl + '")');
            }
        })();
        if (obj_previousPageUrl_union1_error != null) {
            obj_previousPageUrl_union1 = obj_previousPageUrl_union1_error.message;
        }
        if (obj_previousPageUrl_union0 && obj_previousPageUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_previousPageUrl + '")';
            message += '\n' + obj_previousPageUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_previousPageUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_records = obj.records;
        const path_records = path + '.records';
        if (!ArrayIsArray$1(obj_records)) {
            return new TypeError('Expected "array" but received "' + typeof obj_records + '" (at "' + path_records + '")');
        }
        for (let i = 0; i < obj_records.length; i++) {
            const obj_records_item = obj_records[i];
            const path_records_item = path_records + '[' + i + ']';
            if (typeof obj_records_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_records_item + '" (at "' + path_records_item + '")');
            }
        }
        const obj_sortBy = obj.sortBy;
        const path_sortBy = path + '.sortBy';
        if (!ArrayIsArray$1(obj_sortBy)) {
            return new TypeError('Expected "array" but received "' + typeof obj_sortBy + '" (at "' + path_sortBy + '")');
        }
        for (let i = 0; i < obj_sortBy.length; i++) {
            const obj_sortBy_item = obj_sortBy[i];
            const path_sortBy_item = path_sortBy + '[' + i + ']';
            if (typeof obj_sortBy_item !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_sortBy_item + '" (at "' + path_sortBy_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$B(config) {
    return keyPrefix + 'RelatedListRecordCollectionRepresentation:' + '[' + config.sortBy.join(',') + ']' + ':' + (config.parentRecordId === null ? '' : config.parentRecordId) + ':' + config.relatedListId;
}
function keyBuilderFromType$h(object) {
    const keyParams = {
        sortBy: object.sortBy,
        parentRecordId: object.listReference.inContextOfRecordId,
        relatedListId: object.listReference.relatedListId
    };
    return keyBuilder$B(keyParams);
}
function paginationKeyBuilder$2(config) {
    return keyBuilder$B(config) + '__pagination';
}
function normalize$w(input, existing, path, lds, store, timestamp) {
    const input_records = input.records;
    const input_records_id = path.fullPath + '__records';
    for (let i = 0; i < input_records.length; i++) {
        const input_records_item = input_records[i];
        let input_records_item_id = input_records_id + '__' + i;
        input_records[i] = ingest$4(input_records_item, {
            fullPath: input_records_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$A(existing, incoming) {
    const existing_count = existing.count;
    const incoming_count = incoming.count;
    if (!(existing_count === incoming_count)) {
        return false;
    }
    const existing_currentPageToken = existing.currentPageToken;
    const incoming_currentPageToken = incoming.currentPageToken;
    if (!(existing_currentPageToken === incoming_currentPageToken)) {
        return false;
    }
    const existing_currentPageUrl = existing.currentPageUrl;
    const incoming_currentPageUrl = incoming.currentPageUrl;
    if (!(existing_currentPageUrl === incoming_currentPageUrl)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_items = equalsArray(existing_fields, incoming_fields, (existing_fields_item, incoming_fields_item) => {
        if (!(existing_fields_item === incoming_fields_item)) {
            return false;
        }
    });
    if (equals_fields_items === false) {
        return false;
    }
    const existing_listInfoETag = existing.listInfoETag;
    const incoming_listInfoETag = incoming.listInfoETag;
    if (!(existing_listInfoETag === incoming_listInfoETag)) {
        return false;
    }
    const existing_listReference = existing.listReference;
    const incoming_listReference = incoming.listReference;
    if (!(equals$s(existing_listReference, incoming_listReference))) {
        return false;
    }
    const existing_nextPageToken = existing.nextPageToken;
    const incoming_nextPageToken = incoming.nextPageToken;
    if (!(existing_nextPageToken === incoming_nextPageToken)) {
        return false;
    }
    const existing_nextPageUrl = existing.nextPageUrl;
    const incoming_nextPageUrl = incoming.nextPageUrl;
    if (!(existing_nextPageUrl === incoming_nextPageUrl)) {
        return false;
    }
    const existing_optionalFields = existing.optionalFields;
    const incoming_optionalFields = incoming.optionalFields;
    const equals_optionalFields_items = equalsArray(existing_optionalFields, incoming_optionalFields, (existing_optionalFields_item, incoming_optionalFields_item) => {
        if (!(existing_optionalFields_item === incoming_optionalFields_item)) {
            return false;
        }
    });
    if (equals_optionalFields_items === false) {
        return false;
    }
    const existing_pageSize = existing.pageSize;
    const incoming_pageSize = incoming.pageSize;
    if (!(existing_pageSize === incoming_pageSize)) {
        return false;
    }
    const existing_previousPageToken = existing.previousPageToken;
    const incoming_previousPageToken = incoming.previousPageToken;
    if (!(existing_previousPageToken === incoming_previousPageToken)) {
        return false;
    }
    const existing_previousPageUrl = existing.previousPageUrl;
    const incoming_previousPageUrl = incoming.previousPageUrl;
    if (!(existing_previousPageUrl === incoming_previousPageUrl)) {
        return false;
    }
    const existing_records = existing.records;
    const incoming_records = incoming.records;
    const equals_records_items = equalsArray(existing_records, incoming_records, (existing_records_item, incoming_records_item) => {
        if (!(existing_records_item.__ref === incoming_records_item.__ref)) {
            return false;
        }
    });
    if (equals_records_items === false) {
        return false;
    }
    const existing_sortBy = existing.sortBy;
    const incoming_sortBy = incoming.sortBy;
    const equals_sortBy_items = equalsArray(existing_sortBy, incoming_sortBy, (existing_sortBy_item, incoming_sortBy_item) => {
        if (!(existing_sortBy_item === incoming_sortBy_item)) {
            return false;
        }
    });
    if (equals_sortBy_items === false) {
        return false;
    }
    return true;
}
const ingest$w = function RelatedListRecordCollectionRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$_(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$h(input);
    let incomingRecord = normalize$w(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    const paginationKey = paginationKeyBuilder$2({
        sortBy: input.sortBy,
        parentRecordId: input.listReference.inContextOfRecordId,
        relatedListId: input.listReference.relatedListId,
    });
    const { isPastEnd, offsetFor, save, setEnd, setToken } = lds.pagination(paginationKey);
    const currentOffset = offsetFor(input.currentPageToken);
    if (process.env.NODE_ENV !== 'production') {
        if (currentOffset === undefined ||
            (existingRecord &&
                existingRecord.records.length < currentOffset)) {
            throw new RangeError("currentPageToken value " + input.currentPageToken + " not recognized");
        }
    }
    const nextOffset = currentOffset + input.count;
    if (input.nextPageToken) {
        setToken(input.nextPageToken, nextOffset);
        if (isPastEnd(nextOffset)) {
            setEnd(undefined);
        }
    }
    else {
        setEnd(nextOffset);
    }
    if (input.previousPageToken) {
        // TODO - need request's pageSize to ingest previousPageToken at end of list
        if (input.nextPageToken) {
            setToken(input.previousPageToken, currentOffset - input.count);
        }
    }
    save();
    if (existingRecord) {
        incomingRecord.currentPageUrl = existingRecord.currentPageUrl;
        // TODO: needs optimization
        incomingRecord.records = [
            ...existingRecord.records.slice(0, currentOffset),
            ...incomingRecord.records,
            ...(input.nextPageToken ?
                existingRecord.records.slice(nextOffset) :
                []),
        ];
    }
    if (existingRecord === undefined || equals$A(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function keyBuilder$C(params) {
    return keyBuilder$B({
        sortBy: params.queryParams.sortBy || [],
        parentRecordId: params.urlParams.parentRecordId,
        relatedListId: params.urlParams.relatedListId
    });
}
function ingestError$h(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$C(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$s(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-records/' + config.urlParams.parentRecordId + '/' + config.urlParams.relatedListId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$w,
        headers,
    };
}

function records(key, selection, record, data, variables, reader) {
    reader.readPluralLink(key, {
        kind: 'Link',
        name: selection.name,
        plural: true,
        fragment: {
            kind: 'Fragment',
            private: [],
            selections: selection.selections,
        },
        pageToken: selection.pageToken,
        pageSize: selection.pageSize,
        tokenDataKey: selection.tokenDataKey,
    }, record, data);
    const pagination = reader.pagination(selection.tokenDataKey);
    variables.__pageSize = selection.pageSize;
    const currentOffset = pagination.offsetFor(selection.pageToken);
    const nextOffset = currentOffset + selection.pageSize;
    const previousOffset = currentOffset - selection.pageSize;
    // count
    variables.count = data.records.length;
    // current/next/previousPageToken
    variables.currentPageToken = selection.pageToken || pagination.defaultToken();
    const nextPageToken = pagination.isPastEnd(nextOffset) ? null : pagination.tokenFor(nextOffset);
    if (nextPageToken !== undefined) {
        variables.nextPageToken = nextPageToken;
    }
    const previousPageToken = previousOffset < 0 ? null : pagination.tokenFor(previousOffset);
    if (previousPageToken !== undefined) {
        variables.previousPageToken = previousPageToken;
    }
    // current/next/previousPageUrls cannot be generated until we have a template url
}
function variables(key, selection, record, data, variables, reader) {
    reader.readScalar(selection.name, variables, data);
}
function url(key, selection, record, data, variables, reader) {
    let urlProp = selection.name;
    let tokenProp = `${urlProp.substring(0, urlProp.indexOf('Url'))}Token`;
    // TODO W-6741077 Remove this change when craig sets the currentPageUrl
    if (variables[tokenProp] && record.currentPageUrl) {
        // currentPageUrl should never be empty so use that as the template
        variables[urlProp] = record.currentPageUrl
            .replace(/pageToken=[^&]+/, `pageToken=${variables[tokenProp]}`)
            .replace(/pageSize=\d+/, `pageSize=${variables.__pageSize}`);
    }
    else if (variables[tokenProp] === null) {
        variables[urlProp] = null;
    }
    reader.readScalar(selection.name, variables, data);
}

const DEFAULT_PAGE_SIZE$3 = 50;
const RELATED_LIST_REFERENCE_SELECTIONS = select$F().selections;
const select$P = (lds, params) => {
    const { queryParams, urlParams } = params;
    const { relatedListId, parentRecordId } = urlParams;
    let { fields = [], optionalFields = [], sortBy = [], pageToken, pageSize = DEFAULT_PAGE_SIZE$3, } = queryParams;
    // TODO - records code needs to be updated to support optional & required fields, this should be changed before ga
    fields = fields.concat(optionalFields).map(field => {
        return `${relatedListId}.${field}`;
    });
    return {
        kind: 'Fragment',
        private: ['eTag'],
        selections: [
            {
                kind: 'Custom',
                name: 'records',
                plural: true,
                selections: buildSelectionFromFields(fields, optionalFields),
                tokenDataKey: paginationKeyBuilder$2({
                    sortBy,
                    parentRecordId,
                    relatedListId,
                }),
                pageToken,
                pageSize,
                reader: records,
            },
            {
                kind: 'Object',
                name: 'listReference',
                selections: RELATED_LIST_REFERENCE_SELECTIONS,
            },
            {
                kind: 'Custom',
                name: 'count',
                reader: variables,
            },
            {
                kind: 'Custom',
                name: 'currentPageToken',
                reader: variables,
            },
            {
                kind: 'Scalar',
                name: 'currentPageUrl',
            },
            {
                kind: 'Scalar',
                name: 'fields',
                plural: true,
            },
            {
                kind: 'Scalar',
                name: 'optionalFields',
                plural: true,
            },
            {
                kind: 'Scalar',
                name: 'listInfoETag',
            },
            {
                kind: 'Custom',
                name: 'nextPageToken',
                reader: variables,
            },
            {
                kind: 'Custom',
                name: 'nextPageUrl',
                reader: url,
            },
            {
                kind: 'Custom',
                name: 'previousPageToken',
                reader: variables,
            },
            {
                kind: 'Custom',
                name: 'previousPageUrl',
                reader: url,
            },
            staticValuePathSelection({
                name: 'pageSize',
                value: pageSize === undefined ? DEFAULT_PAGE_SIZE$3 : pageSize,
            }),
            {
                kind: 'Scalar',
                name: 'sortBy',
                plural: true,
            },
        ],
    };
};
const ingestSuccess$i = (lds, resourceRequestConfig, request, resp, snapshotRefresh) => {
    const { body } = resp;
    const key = keyBuilder$C(resourceRequestConfig);
    lds.storeIngest(key, request, body);
    const snapshot = lds.storeLookup({
        recordId: key,
        node: select$P(lds, resourceRequestConfig),
        variables: {},
    }, snapshotRefresh);
    if (isUnfulfilledSnapshot(snapshot)) {
        throw new Error(`${Object.keys(snapshot.missingPaths).join(', ')} missing immediately after get-related-list-records request`);
    }
    return snapshot;
};

function validate$$(obj, path = 'CompositeRelatedListRecordCollectionResultRepresentation') {
    const v_error = (() => {
        const path_statusCode = path + '.statusCode';
        const obj_statusCode = obj.statusCode;
        const path_result = path + '.result';
        const obj_result = obj.result;
        if (typeof obj_statusCode !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
        switch (obj_statusCode) {
            case 200: {
                if (typeof obj_result !== 'object') {
                    return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
                }
            }
            default: {
                if (obj_result === undefined) {
                    return new TypeError('Expected "' + path_result + '" to be present but received "undefined" (at "' + path_result + '")');
                }
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$x(input, existing, path, lds, store, timestamp) {
    const input_result = input.result;
    const input_result_id = path.fullPath + '__result';
    input.result = ingest$w(input_result, {
        fullPath: input_result_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$B(existing, incoming) {
    const existing_statusCode = existing.statusCode;
    const incoming_statusCode = incoming.statusCode;
    if (!(existing_statusCode === incoming_statusCode)) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
    }
    return true;
}
const ingest$x = function CompositeRelatedListRecordCollectionResultRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$$(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$x(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$B(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$10(obj, path = 'RelatedListRecordCollectionBatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_results = obj.results;
        const path_results = path + '.results';
        if (!ArrayIsArray$1(obj_results)) {
            return new TypeError('Expected "array" but received "' + typeof obj_results + '" (at "' + path_results + '")');
        }
        for (let i = 0; i < obj_results.length; i++) {
            const obj_results_item = obj_results[i];
            const path_results_item = path_results + '[' + i + ']';
            if (typeof obj_results_item !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_results_item + '" (at "' + path_results_item + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$y(input, existing, path, lds, store, timestamp) {
    const input_results = input.results;
    const input_results_id = path.fullPath + '__results';
    for (let i = 0; i < input_results.length; i++) {
        const input_results_item = input_results[i];
        let input_results_item_id = input_results_id + '__' + i;
        input_results[i] = ingest$x(input_results_item, {
            fullPath: input_results_item_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$C(existing, incoming) {
    const existing_results = existing.results;
    const incoming_results = incoming.results;
    const equals_results_items = equalsArray(existing_results, incoming_results, (existing_results_item, incoming_results_item) => {
        if (!(existing_results_item.__ref === incoming_results_item.__ref)) {
            return false;
        }
    });
    if (equals_results_items === false) {
        return false;
    }
    return true;
}
const ingest$y = function RelatedListRecordCollectionBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$10(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$y(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$C(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

// Single Wire Imports
const createChildResourceParams$4 = (resourceParams) => {
    var _a, _b, _c;
    const childConfigs = [];
    for (let index = 0, len = resourceParams.urlParams.relatedListIds.length; index < len; index += 1) {
        const relatedListId = resourceParams.urlParams.relatedListIds[index];
        const fields = (_a = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.fields)) === null || _a === void 0 ? void 0 : _a.split(',');
        const optionalFields = (_b = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.optionalFields)) === null || _b === void 0 ? void 0 : _b.split(',');
        const sortBy = (_c = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.sortBy)) === null || _c === void 0 ? void 0 : _c.split(',');
        const pageSize = extractSingleResourceParamsFromBatchParamString(relatedListId, resourceParams.queryParams.pageSize);
        childConfigs.push({
            urlParams: {
                parentRecordId: resourceParams.urlParams.parentRecordId,
                relatedListId: relatedListId,
            },
            queryParams: {
                fields: fields,
                optionalFields: optionalFields,
                sortBy: sortBy,
                pageSize: pageSize ? Number(pageSize) : undefined,
            },
        });
    }
    return childConfigs;
};
function extractSingleResourceParamsFromBatchParamString(relatedListId, batchParamString) {
    var _a;
    return (_a = batchParamString === null || batchParamString === void 0 ? void 0 : batchParamString.split(';').find(field => field.startsWith(relatedListId))) === null || _a === void 0 ? void 0 : _a.slice(relatedListId.length + 1);
}
// HUGE BLOCK OF COPY PASTED CODE:
// WE NEED TO DO THIS SO THAT THE ADAPTER CAN USE ONLY OUR OVERRIDE FILE
// PLEASE DO NOT CHANGE ANYTHING HERE...
function select$Q(lds, resourceParams) {
    const childResources = createChildResourceParams$4(resourceParams);
    const envelopeBodyPath = 'result';
    const envelopeStatusCodePath = 'statusCode';
    const envelopePath = 'results';
    return {
        kind: 'Fragment',
        reader: true,
        synthetic: true,
        read: (reader) => {
            const sink = {};
            reader.enterPath(envelopePath);
            const results = [];
            for (let i = 0, len = childResources.length; i < len; i += 1) {
                reader.enterPath(i);
                const childResource = childResources[i];
                const childKey = keyBuilder$C(childResource);
                const childFragment = select$P(lds, childResource);
                const childSnapshot = reader.read({
                    recordId: childKey,
                    node: childFragment,
                    variables: {},
                });
                const childSink = {};
                switch (childSnapshot.state) {
                    case 'Fulfilled':
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, 200);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshot.data);
                        reader.exitPath();
                        break;
                    case 'Error':
                        // eslint-disable-next-line no-case-declarations
                        const { error: childSnapshotError } = childSnapshot;
                        reader.enterPath(envelopeStatusCodePath);
                        reader.assignScalar(envelopeStatusCodePath, childSink, childSnapshotError.status);
                        reader.exitPath();
                        reader.enterPath(envelopeBodyPath);
                        reader.assignNonScalar(childSink, envelopeBodyPath, childSnapshotError.body);
                        reader.exitPath();
                        break;
                    case 'Unfulfilled':
                        reader.markMissing();
                        break;
                    case 'Pending':
                        reader.markPending();
                        break;
                    case 'Stale':
                        reader.markStale();
                        break;
                }
                ObjectFreeze(childSink);
                ArrayPrototypePush.call(results, childSink);
                reader.exitPath();
            }
            reader.assignNonScalar(sink, envelopePath, results);
            ObjectFreeze(sink);
            reader.exitPath();
            return sink;
        },
    };
}
function keyBuilder$D(params) {
    return (keyPrefix +
        'RelatedListRecordCollectionBatchRepresentation(' +
        'fields:' +
        params.queryParams.fields +
        ',' +
        'optionalFields:' +
        params.queryParams.optionalFields +
        ',' +
        'pageSize:' +
        params.queryParams.pageSize +
        ',' +
        'sortBy:' +
        params.queryParams.sortBy +
        ',' +
        'parentRecordId:' +
        params.urlParams.parentRecordId +
        ',' +
        'relatedListIds:' +
        params.urlParams.relatedListIds +
        ')');
}
function ingestSuccess$j(lds, resourceParams, _request, response, _snapshotRefresh) {
    const childEnvelopes = response.body.results;
    const childResourceParamsArray = createChildResourceParams$4(resourceParams);
    if (process.env.NODE_ENV !== 'production') {
        if (childResourceParamsArray.length !== childEnvelopes.length) {
            throw new Error('Invalid composite resource response. Expected ' +
                childResourceParamsArray.length +
                ' items, received ' +
                childEnvelopes.length);
        }
    }
    const snapshotStateFulfilled = 'Fulfilled';
    const key = keyBuilder$D(resourceParams);
    const childSnapshotDataResponses = [];
    let seenRecords = {};
    for (let index = 0, len = childResourceParamsArray.length; index < len; index += 1) {
        const childResourceParams = childResourceParamsArray[index];
        const result = childEnvelopes[index];
        const childStatusCodeText = getFetchResponseStatusText(result.statusCode);
        if (result.statusCode === 200) {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: true,
                statusText: childStatusCodeText,
                headers: {},
            };
            const childSnapshot = ingestSuccess$i(lds, childResourceParams, createResourceRequest$s(childResourceParams), childResponse);
            seenRecords = {
                ...seenRecords,
                ...childSnapshot.seenRecords,
                [childSnapshot.recordId]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childSnapshot.data,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
        else {
            const { statusCode: childStatusCode, result: childBody } = result;
            const childResponse = {
                status: childStatusCode,
                body: childBody,
                ok: false,
                statusText: childStatusCodeText,
                headers: {},
            };
            ingestError$h(lds, childResourceParams, childResponse);
            seenRecords = {
                ...seenRecords,
                [keyBuilder$C(childResourceParams)]: true,
            };
            const childValue = {
                statusCode: childStatusCode,
                result: childBody,
            };
            ObjectFreeze(childValue);
            childSnapshotDataResponses.push(childValue);
        }
    }
    ObjectFreeze(childSnapshotDataResponses);
    const childSnapshotData = {
        results: childSnapshotDataResponses,
    };
    ObjectFreeze(childSnapshotData);
    return {
        recordId: key,
        data: childSnapshotData,
        state: snapshotStateFulfilled,
        seenRecords: seenRecords,
        select: {
            recordId: key,
            node: select$Q(lds, resourceParams),
            variables: {},
        },
        variables: {},
    };
}
function ingestError$i(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$D(params);
    lds.storeIngestFetchResponse(key, error);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$t(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/related-list-records/batch/' +
            config.urlParams.parentRecordId +
            '/' +
            config.urlParams.relatedListIds +
            '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$y,
        headers,
    };
}

const adapterName$i = 'getRelatedListRecordsBatch';
function createResourceParams$l(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListIds: config.relatedListIds
        },
        queryParams: {
            fields: config.fields, optionalFields: config.optionalFields, pageSize: config.pageSize, sortBy: config.sortBy
        }
    };
}
function buildInMemorySnapshot$m(lds, config) {
    const resourceParams = createResourceParams$l(config);
    const selector = {
        recordId: keyBuilder$D(resourceParams),
        node: select$Q(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$l(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$h(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$j(lds, resourceParams, request, response);
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$h(lds, config, resourceParams, response) {
    const snapshot = ingestError$i(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$l(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$l(lds, config, override) {
    const resourceParams = createResourceParams$l(config);
    const request = createResourceRequest$t(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$h(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$h(lds, config, resourceParams, response);
    });
}

const getRelatedListRecordsBatch_ConfigPropertyNames = {
    displayName: 'getRelatedListRecordsBatch',
    parameters: {
        required: ['parentRecordId', 'relatedLists'],
        optional: [],
    },
};
function coerceActualAdapterConfigToGeneratedRepresentation(config) {
    var relatedListIds = [];
    var fields = [];
    var optionalFields = [];
    var pageSize = [];
    var sortBy = [];
    config.relatedLists.forEach(relatedList => {
        var _a, _b, _c;
        relatedListIds.push(relatedList.relatedListId);
        if (!!relatedList.fields && relatedList.fields.length) {
            fields.push(relatedList.relatedListId + ':' + ((_a = relatedList.fields) === null || _a === void 0 ? void 0 : _a.join()));
        }
        if (!!relatedList.optionalFields && relatedList.optionalFields.length) {
            optionalFields.push(relatedList.relatedListId + ':' + ((_b = relatedList.optionalFields) === null || _b === void 0 ? void 0 : _b.join()));
        }
        if (relatedList.pageSize) {
            pageSize.push(relatedList.relatedListId + ':' + relatedList.pageSize);
        }
        if (!!relatedList.sortBy && relatedList.sortBy.length) {
            sortBy.push(relatedList.relatedListId + ':' + ((_c = relatedList.sortBy) === null || _c === void 0 ? void 0 : _c.join()));
        }
    });
    const fieldsParam = fields.join(';');
    const optionalFieldsParam = optionalFields.join(';');
    const pageSizeParam = pageSize.join(';');
    const sortByParam = sortBy.join(';');
    return {
        parentRecordId: config.parentRecordId,
        relatedListIds: relatedListIds,
        fields: fieldsParam,
        optionalFields: optionalFieldsParam,
        pageSize: pageSizeParam,
        sortBy: sortByParam,
    };
}
function typeCheckConfig$o(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedLists = untrustedConfig.relatedLists;
    if (ArrayIsArray(untrustedConfig_relatedLists)) {
        const untrustedConfig_relatedLists_array = [];
        for (let i = 0, arrayLength = untrustedConfig_relatedLists.length; i < arrayLength; i++) {
            const untrustedConfig_relatedListIds_item = untrustedConfig_relatedLists[i];
            if (typeof untrustedConfig_relatedListIds_item === 'object') {
                // Not sure if this inner type checking is necessary?
                const untrustedConfig_fields = untrustedConfig_relatedListIds_item.fields;
                if (ArrayIsArray(untrustedConfig_fields)) {
                    const untrustedConfig_fields_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
                        const untrustedConfig_fields_item = untrustedConfig_fields[i];
                        if (typeof untrustedConfig_fields_item === 'string') {
                            untrustedConfig_fields_array.push(untrustedConfig_fields_item);
                        }
                    }
                    untrustedConfig_relatedListIds_item.fields = untrustedConfig_fields_array;
                }
                const untrustedConfig_optionalFields = untrustedConfig_relatedListIds_item.optionalFields;
                if (ArrayIsArray(untrustedConfig_optionalFields)) {
                    const untrustedConfig_optionalFields_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
                        const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
                        if (typeof untrustedConfig_optionalFields_item === 'string') {
                            untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
                        }
                    }
                    untrustedConfig_relatedListIds_item.optionalFields = untrustedConfig_optionalFields_array;
                }
                const untrustedConfig_pageSize = untrustedConfig_relatedListIds_item.pageSize;
                if (untrustedConfig_pageSize) {
                    if (typeof untrustedConfig_pageSize === 'number') {
                        untrustedConfig_relatedListIds_item.pageSize = untrustedConfig_pageSize;
                    }
                    else {
                        //Not a number here, set pagesize to undefined
                        untrustedConfig_relatedListIds_item.pageSize = undefined;
                    }
                }
                const untrustedConfig_sortBy = untrustedConfig_relatedListIds_item.sortBy;
                if (ArrayIsArray(untrustedConfig_sortBy)) {
                    const untrustedConfig_sortBy_array = [];
                    for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
                        const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
                        if (typeof untrustedConfig_sortBy_item === 'string') {
                            untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
                        }
                    }
                    untrustedConfig_relatedListIds_item.sortBy = untrustedConfig_sortBy_array;
                }
                untrustedConfig_relatedLists_array.push(untrustedConfig_relatedListIds_item);
            }
        }
        config.relatedLists = untrustedConfig_relatedLists_array;
    }
    return config;
}
const getRelatedListRecordsBatchAdapterFactory = (lds) => function getRelatedListRecordsBatch(untrustedConfig) {
    const config = validateAdapterConfig$o(untrustedConfig, getRelatedListRecordsBatch_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const coercedConfig = coerceActualAdapterConfigToGeneratedRepresentation(config);
    const cacheSnapshot = buildInMemorySnapshot$m(lds, coercedConfig);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    return buildNetworkSnapshot$l(lds, coercedConfig);
};
// HUGE BLOCK OF COPY PASTED CODE:
// WE NEED TO DO THIS SO THAT THE ADAPTER CAN USE OUR OVERWRITTEN FUNCTIONS
// PLEASE DO NOT CHANGE ANYTHING HERE...
function validateAdapterConfig$o(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$o(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const adapterName$j = 'getRelatedListRecords';
const getRelatedListRecords_ConfigPropertyNames = {
    displayName: 'getRelatedListRecords',
    parameters: {
        required: ['parentRecordId', 'relatedListId'],
        optional: ['fields', 'optionalFields', 'pageSize', 'pageToken', 'sortBy']
    }
};
function createResourceParams$m(config) {
    return {
        urlParams: {
            parentRecordId: config.parentRecordId, relatedListId: config.relatedListId
        },
        queryParams: {
            fields: config.fields, optionalFields: config.optionalFields, pageSize: config.pageSize, pageToken: config.pageToken, sortBy: config.sortBy
        }
    };
}
function typeCheckConfig$p(untrustedConfig) {
    const config = {};
    const untrustedConfig_parentRecordId = untrustedConfig.parentRecordId;
    if (typeof untrustedConfig_parentRecordId === 'string') {
        config.parentRecordId = untrustedConfig_parentRecordId;
    }
    const untrustedConfig_relatedListId = untrustedConfig.relatedListId;
    if (typeof untrustedConfig_relatedListId === 'string') {
        config.relatedListId = untrustedConfig_relatedListId;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (ArrayIsArray(untrustedConfig_fields)) {
        const untrustedConfig_fields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_fields.length; i < arrayLength; i++) {
            const untrustedConfig_fields_item = untrustedConfig_fields[i];
            if (typeof untrustedConfig_fields_item === 'string') {
                untrustedConfig_fields_array.push(untrustedConfig_fields_item);
            }
        }
        config.fields = untrustedConfig_fields_array;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_pageToken = untrustedConfig.pageToken;
    if (typeof untrustedConfig_pageToken === 'string') {
        config.pageToken = untrustedConfig_pageToken;
    }
    const untrustedConfig_sortBy = untrustedConfig.sortBy;
    if (ArrayIsArray(untrustedConfig_sortBy)) {
        const untrustedConfig_sortBy_array = [];
        for (let i = 0, arrayLength = untrustedConfig_sortBy.length; i < arrayLength; i++) {
            const untrustedConfig_sortBy_item = untrustedConfig_sortBy[i];
            if (typeof untrustedConfig_sortBy_item === 'string') {
                untrustedConfig_sortBy_array.push(untrustedConfig_sortBy_item);
            }
        }
        config.sortBy = untrustedConfig_sortBy_array;
    }
    return config;
}
function validateAdapterConfig$p(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$p(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}
function buildInMemorySnapshot$n(lds, config) {
    const resourceParams = createResourceParams$m(config);
    const selector = {
        recordId: keyBuilder$C(resourceParams),
        node: select$P(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$m(lds, config, snapshotRefreshOptions)
    });
}
function onResourceResponseSuccess$i(lds, config, resourceParams, request, response) {
    const snapshot = ingestSuccess$i(lds, resourceParams, request, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function onResourceResponseError$i(lds, config, resourceParams, response) {
    const snapshot = ingestError$h(lds, resourceParams, response, {
        config,
        resolve: () => buildNetworkSnapshot$m(lds, config, snapshotRefreshOptions)
    });
    lds.storeBroadcast();
    return snapshot;
}
function buildNetworkSnapshot$m(lds, config, override) {
    const resourceParams = createResourceParams$m(config);
    const request = createResourceRequest$s(resourceParams);
    return lds.dispatchResourceRequest(request, override)
        .then((response) => {
        return onResourceResponseSuccess$i(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$i(lds, config, resourceParams, response);
    });
}
function resolveUnfulfilledSnapshot$j(lds, config, snapshot) {
    const resourceParams = createResourceParams$m(config);
    const request = createResourceRequest$s(resourceParams);
    return lds.resolveUnfulfilledSnapshot(request, snapshot)
        .then((response) => {
        return onResourceResponseSuccess$i(lds, config, resourceParams, request, response);
    }, (response) => {
        return onResourceResponseError$i(lds, config, resourceParams, response);
    });
}
const getRelatedListRecordsAdapterFactory = (lds) => function getRelatedListRecords(untrustedConfig) {
    const config = validateAdapterConfig$p(untrustedConfig, getRelatedListRecords_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$n(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    if (cacheSnapshot.state === SNAPSHOT_STATE_UNFULFILLED) {
        return resolveUnfulfilledSnapshot$j(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$m(lds, config);
};

function createResourceRequest$u(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'delete',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: null,
        headers,
    };
}

function deepFreeze$s(value) {
    // No need to freeze primitives
    if (typeof value !== 'object' || value === null) {
        return;
    }
    if (isArray(value)) {
        for (let i = 0, len = value.length; i < len; i += 1) {
            deepFreeze$s(value[i]);
        }
    }
    else {
        const keys$1 = keys(value);
        for (let i = 0, len = keys$1.length; i < len; i += 1) {
            deepFreeze$s(value[keys$1[i]]);
        }
    }
    freeze(value);
}

const factory$5 = (lds) => (recordId) => {
    const coercedRecordId = getRecordId18(recordId);
    if (coercedRecordId === undefined) {
        throw new TypeError('Unexpected parameter, expected a Salesforce Record id.');
    }
    const request = createResourceRequest$u({
        urlParams: {
            recordId: coercedRecordId,
        },
    });
    return lds.dispatchResourceRequest(request).then(() => {
        const storeRecordKey = keyBuilder$2({ recordId: coercedRecordId });
        lds.storeEvict(storeRecordKey);
        lds.storeBroadcast();
    }, (err) => {
        deepFreeze$s(err);
        throw err;
    });
};

function createResourceRequest$v(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$9,
        headers,
    };
}

var LayoutType;
(function (LayoutType) {
    LayoutType["Full"] = "Full";
    LayoutType["Compact"] = "Compact";
})(LayoutType || (LayoutType = {}));

function coerceLayoutType(value) {
    if (value === LayoutType.Full || value === LayoutType.Compact) {
        return value;
    }
    return undefined;
}

function coerceLayoutMode(value) {
    if (value === LayoutMode.Create || value === LayoutMode.Edit || value === LayoutMode.View) {
        return value;
    }
    return undefined;
}

function coerceConfig$h(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const formFactor = config.formFactor;
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const layoutType = coerceLayoutType(config.layoutType);
    if (layoutType !== undefined) {
        coercedConfig.layoutType = layoutType;
    }
    const mode = coerceLayoutMode(config.mode);
    if (mode !== undefined) {
        coercedConfig.mode = mode;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$q(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_layoutType = untrustedConfig.layoutType;
    if (typeof untrustedConfig_layoutType === 'string') {
        config.layoutType = untrustedConfig_layoutType;
    }
    const untrustedConfig_mode = untrustedConfig.mode;
    if (typeof untrustedConfig_mode === 'string') {
        config.mode = untrustedConfig_mode;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$q(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$h(untrustedConfig);
    const config = typeCheckConfig$q(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const layoutSelections$2 = select$9();
// FYI stricter required set than RAML, matches lds222 behavior
const getLayout_ConfigPropertyNames = {
    displayName: 'getLayout',
    parameters: {
        required: ['objectApiName', 'layoutType', 'mode'],
        optional: ['recordTypeId'],
    },
};
function buildSnapshotRefresh$5(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$n(lds, config, snapshotRefreshOptions),
    };
}
function buildRequestAndKey(config) {
    const recordTypeId = config.recordTypeId;
    const request = createResourceRequest$v({
        urlParams: {
            objectApiName: config.objectApiName,
        },
        queryParams: {
            layoutType: config.layoutType,
            mode: config.mode,
            recordTypeId,
        },
    });
    const key = keyBuilder$b({
        objectApiName: config.objectApiName,
        recordTypeId,
        layoutType: config.layoutType,
        mode: config.mode,
    });
    return { request, key };
}
function onResourceResponseSuccess$j(lds, config, key, request, response) {
    const { body } = response;
    lds.storeIngest(key, request, body);
    lds.storeBroadcast();
    return lds.storeLookup({
        recordId: key,
        node: layoutSelections$2,
        variables: {},
    }, buildSnapshotRefresh$5(lds, config));
}
function onResourceResponseError$j(lds, config, key, error) {
    lds.storeIngestFetchResponse(key, error);
    lds.storeBroadcast();
    return lds.errorSnapshot(error, buildSnapshotRefresh$5(lds, config));
}
function buildNetworkSnapshot$n(lds, config, requestOverride) {
    const { request, key } = buildRequestAndKey(config);
    return lds.dispatchResourceRequest(request, requestOverride).then(response => {
        return onResourceResponseSuccess$j(lds, config, key, request, response);
    }, (error) => {
        return onResourceResponseError$j(lds, config, key, error);
    });
}
function resolveUnfulfilledSnapshot$k(lds, config, snapshot) {
    const { request, key } = buildRequestAndKey(config);
    return lds.resolveUnfulfilledSnapshot(request, snapshot).then(response => {
        return onResourceResponseSuccess$j(lds, config, key, request, response);
    }, (error) => {
        return onResourceResponseError$j(lds, config, key, error);
    });
}
function buildInMemorySnapshot$o(lds, config) {
    const { recordTypeId, layoutType, mode } = config;
    const key = keyBuilder$b({
        objectApiName: config.objectApiName,
        recordTypeId,
        layoutType,
        mode,
    });
    return lds.storeLookup({
        recordId: key,
        node: layoutSelections$2,
        variables: {},
    }, buildSnapshotRefresh$5(lds, config));
}
function coerceConfigWithDefaults$1(untrusted) {
    const config = validateAdapterConfig$q(untrusted, getLayout_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    // recordTypeId coercion is nuts: if `null` (but not undefined) then use MASTER record type id
    let recordTypeId = config.recordTypeId;
    if (recordTypeId === undefined) {
        // must check untrusted bc config has been coerced
        if (untrusted.recordTypeId !== null) {
            return null;
        }
        recordTypeId = MASTER_RECORD_TYPE_ID;
    }
    // layoutType and mode are required during validation.
    // They will always be valid at this point.
    return {
        ...config,
        recordTypeId,
        layoutType: config.layoutType,
        mode: config.mode,
    };
}
const factory$6 = (lds) => function getLayout(untrusted) {
    const config = coerceConfigWithDefaults$1(untrusted);
    if (config === null) {
        return null;
    }
    const snapshot = buildInMemorySnapshot$o(lds, config);
    // Cache hit
    if (lds.snapshotDataAvailable(snapshot)) {
        return snapshot;
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot$k(lds, config, snapshot);
    }
    return buildNetworkSnapshot$n(lds, config);
};

function createResourceRequest$w(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '/user-state',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$a,
        headers,
    };
}

function coerceConfig$i(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const formFactor = config.formFactor;
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const layoutType = coerceLayoutType(config.layoutType);
    if (layoutType !== undefined) {
        coercedConfig.layoutType = layoutType;
    }
    const mode = coerceLayoutMode(config.mode);
    if (mode !== undefined) {
        coercedConfig.mode = mode;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$r(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_layoutType = untrustedConfig.layoutType;
    if (typeof untrustedConfig_layoutType === 'string') {
        config.layoutType = untrustedConfig_layoutType;
    }
    const untrustedConfig_mode = untrustedConfig.mode;
    if (typeof untrustedConfig_mode === 'string') {
        config.mode = untrustedConfig_mode;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$r(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$i(untrustedConfig);
    const config = typeCheckConfig$r(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const recordLayoutSelect = select$a();
// FYI stricter required set than RAML defines, matches lds222 behavior
const getLayoutUserState_ConfigPropertyNames = {
    displayName: 'getLayoutUserState',
    parameters: {
        required: ['objectApiName', 'recordTypeId'],
        optional: ['formFactor', 'layoutType', 'mode'],
    },
};
function coerceConfigWithDefaults$2(untrustedConfig) {
    const config = validateAdapterConfig$r(untrustedConfig, getLayoutUserState_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    // recordTypeId is overridden to be required
    const recordTypeId = config.recordTypeId;
    const untrusted = untrustedConfig;
    let layoutType = config.layoutType;
    if (layoutType === undefined) {
        if (untrusted.layoutType === undefined) {
            layoutType = LayoutType.Full;
        }
        else {
            return null;
        }
    }
    let mode = config.mode;
    if (mode === undefined) {
        if (untrusted.mode === undefined) {
            mode = LayoutMode.View;
        }
        else {
            return null;
        }
    }
    return {
        ...config,
        recordTypeId,
        layoutType,
        mode,
    };
}
function buildSnapshotRefresh$6(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$o(lds, config),
    };
}
function buildInMemorySnapshot$p(lds, config) {
    const { objectApiName, recordTypeId, layoutType, mode } = config;
    const key = keyBuilder$c({
        apiName: objectApiName,
        recordTypeId,
        layoutType,
        mode,
    });
    return lds.storeLookup({
        recordId: key,
        node: recordLayoutSelect,
        variables: {},
    }, buildSnapshotRefresh$6(lds, config));
}
function buildNetworkSnapshot$o(lds, config) {
    const { request, key } = prepareRequest$2(config);
    return lds.dispatchResourceRequest(request).then(response => {
        return onResourceResponseSuccess$k(lds, config, key, request, response);
    }, (error) => {
        return onResourceResponseError$k(lds, config, key, error);
    });
}
function resolveUnfulfilledSnapshot$l(lds, config, snapshot) {
    const { request, key } = prepareRequest$2(config);
    return lds
        .resolveUnfulfilledSnapshot(request, snapshot)
        .then(response => {
        return onResourceResponseSuccess$k(lds, config, key, request, response);
    }, (error) => {
        return onResourceResponseError$k(lds, config, key, error);
    });
}
function onResourceResponseSuccess$k(lds, config, key, request, response) {
    const { body } = response;
    const { recordTypeId, layoutType, mode } = config;
    // Hack- adding in this params so record-ui will be able to use normed values.
    body.apiName = config.objectApiName;
    body.recordTypeId = recordTypeId;
    body.layoutType = layoutType;
    body.mode = mode;
    lds.storeIngest(key, request, body);
    lds.storeBroadcast();
    return buildInMemorySnapshot$p(lds, config);
}
function onResourceResponseError$k(lds, config, key, error) {
    lds.storeIngestFetchResponse(key, error);
    lds.storeBroadcast();
    return lds.errorSnapshot(error, buildSnapshotRefresh$6(lds, config));
}
function prepareRequest$2(config) {
    const { recordTypeId, layoutType, mode, objectApiName } = config;
    const key = keyBuilder$c({
        apiName: objectApiName,
        recordTypeId,
        layoutType,
        mode,
    });
    const request = createResourceRequest$w({
        urlParams: { objectApiName: config.objectApiName },
        queryParams: {
            layoutType: config.layoutType,
            mode: config.mode,
            recordTypeId: config.recordTypeId,
        },
    });
    return { request, key };
}
const factory$7 = (lds) => function getLayoutUserState(untrustedConfig) {
    const config = coerceConfigWithDefaults$2(untrustedConfig);
    if (config === null) {
        return null;
    }
    const cacheSnapshot = buildInMemorySnapshot$p(lds, config);
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot)) {
        return cacheSnapshot;
    }
    if (isUnfulfilledSnapshot(cacheSnapshot)) {
        return resolveUnfulfilledSnapshot$l(lds, config, cacheSnapshot);
    }
    return buildNetworkSnapshot$o(lds, config);
};

function createResourceRequest$x(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/layout/' + config.urlParams.objectApiName + '/user-state',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$a,
        headers,
    };
}

function validate$11(obj, path = 'RecordLayoutUserStateInputRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_sectionUserStates = obj.sectionUserStates;
        const path_sectionUserStates = path + '.sectionUserStates';
        if (typeof obj_sectionUserStates !== 'object' || ArrayIsArray$1(obj_sectionUserStates) || obj_sectionUserStates === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_sectionUserStates + '" (at "' + path_sectionUserStates + '")');
        }
        const obj_sectionUserStates_keys = ObjectKeys$1(obj_sectionUserStates);
        for (let i = 0; i < obj_sectionUserStates_keys.length; i++) {
            const key = obj_sectionUserStates_keys[i];
            const obj_sectionUserStates_prop = obj_sectionUserStates[key];
            const path_sectionUserStates_prop = path_sectionUserStates + '["' + key + '"]';
            if (typeof obj_sectionUserStates_prop !== 'object' || ArrayIsArray$1(obj_sectionUserStates_prop) || obj_sectionUserStates_prop === null) {
                return new TypeError('Expected "object" but received "' + typeof obj_sectionUserStates_prop + '" (at "' + path_sectionUserStates_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}

// Hack method- this should be removed eventually when layoutUserState raml is fixed.
function addAdditionalFieldsForNorming(layoutUserState, apiName, recordTypeId, layoutType, mode) {
    // Hack- adding in this params so record-ui will be able to use normed values.
    layoutUserState.apiName = apiName;
    layoutUserState.recordTypeId = recordTypeId;
    layoutUserState.layoutType = layoutType;
    layoutUserState.mode = mode;
}
function updateLayoutUserState(lds, config, key, updateRequest) {
    return lds.dispatchResourceRequest(updateRequest).then(response => {
        return ingestAndBroadcast(lds, key, updateRequest, config, response.body);
    }, (err) => {
        deepFreeze$s(err);
        throw err;
    });
}
function ingestAndBroadcast(lds, key, request, config, body) {
    addAdditionalFieldsForNorming(body, config.objectApiName, config.recordTypeId, config.layoutType, config.mode);
    lds.storeIngest(key, request, body);
    lds.storeBroadcast();
    return buildInMemorySnapshot$p(lds, config);
}
function clone(userLayoutState) {
    return parse(stringify(userLayoutState));
}
// Applies optimisticUpdate to layoutUserState
// If the optimistic update can be applied, returns RecordLayoutUserStateRepresentation
// If the optimistic update cannot be applied, returns null
// The optimistic update can be applied only IF the cached layoutUserState has all the sections
// enumerated on the layout user state input
function optimisticUpdate(cachedLayoutUserState, layoutUserStateInput) {
    let clonedLayoutUserState;
    let clonedLayoutUserStateSections;
    const { sectionUserStates } = layoutUserStateInput;
    const { sectionUserStates: cachedSectionUserStates } = cachedLayoutUserState;
    const sectionUserStateKeys = keys(sectionUserStates);
    for (let i = 0, len = sectionUserStateKeys.length; i < len; i += 1) {
        const sectionId = sectionUserStateKeys[i];
        if (cachedSectionUserStates[sectionId] === undefined) {
            // Cannot update a section that isn't in the cache. Cancel the optimistic update.
            return null;
        }
        if (clonedLayoutUserState === undefined) {
            // We have to clone cachedLayoutUserState because this object is coming from
            // a snapshot, where it is frozen
            clonedLayoutUserState = clone(cachedLayoutUserState);
            // hold onto sectionUserStates from clonedLayoutUserState
            clonedLayoutUserStateSections = clonedLayoutUserState.sectionUserStates;
        }
        // DEV MODE sanity check
        if (process.env.NODE_ENV !== 'production') {
            if (clonedLayoutUserStateSections === undefined) {
                throw new Error('clonedLayoutUserStateSections is undefined in updateLayoutUserState optimisticUpdate');
            }
        }
        const userState = sectionUserStates[sectionId];
        clonedLayoutUserStateSections[sectionId].collapsed = userState.collapsed;
    }
    // DEV MODE sanity check
    if (process.env.NODE_ENV !== 'production') {
        if (clonedLayoutUserState === undefined) {
            throw new Error('clonedLayoutUserState is undefined in updateLayoutUserState optimisticUpdate');
        }
    }
    return clonedLayoutUserState;
}
function coerceConfigWithDefaults$3(untrusted, layoutUserStateInput) {
    const config = coerceConfigWithDefaults$2(untrusted);
    if (config === null) {
        throw new Error(`@wire(updateLayoutUserState) invalid configuration ${stringify(untrusted)}`);
    }
    // This will throw if layoutUserStateInput is not a valid input
    validate$11(layoutUserStateInput, 'layoutUserStateInput');
    return {
        ...config,
        layoutUserStateInput: layoutUserStateInput,
    };
}
const factory$8 = (lds) => {
    return (untrustedObjectApiName, untrustedRecordTypeId, untrustedLayoutType, untrustedMode, untrustedLayoutUserStateInput) => {
        const untrusted = {
            objectApiName: untrustedObjectApiName,
            recordTypeId: untrustedRecordTypeId,
            layoutType: untrustedLayoutType,
            mode: untrustedMode,
        };
        const config = coerceConfigWithDefaults$3(untrusted, untrustedLayoutUserStateInput);
        if (config === null) {
            throw new Error(`@wire(updateLayoutUserState) invalid configuration ${stringify(untrusted)}`);
        }
        const { objectApiName, layoutType, mode, recordTypeId, layoutUserStateInput } = config;
        const updateRequest = createResourceRequest$x({
            urlParams: {
                objectApiName,
            },
            body: layoutUserStateInput,
            queryParams: {
                layoutType,
                mode,
                recordTypeId,
            },
        });
        const key = keyBuilder$c({
            apiName: objectApiName,
            recordTypeId,
            layoutType,
            mode,
        });
        const cacheSnapshot = buildInMemorySnapshot$p(lds, config);
        if (isFulfilledSnapshot(cacheSnapshot)) {
            // Create an optimistic update if we can
            const updatedLayoutUserState = optimisticUpdate(cacheSnapshot.data, layoutUserStateInput);
            if (updatedLayoutUserState !== null) {
                // Ingest optimistic update done client side
                ingestAndBroadcast(lds, key, updateRequest, config, updatedLayoutUserState);
            }
        }
        return updateLayoutUserState(lds, config, key, updateRequest);
    };
};

function keyBuilder$E(params) {
    return keyPrefix + 'RecordCollectionRepresentation(' + 'dependentFieldBindings:' + params.queryParams.dependentFieldBindings + ',' + 'pageParam:' + params.queryParams.pageParam + ',' + 'pageSize:' + params.queryParams.pageSize + ',' + 'q:' + params.queryParams.q + ',' + 'searchType:' + params.queryParams.searchType + ',' + 'sourceRecordId:' + params.queryParams.sourceRecordId + ',' + 'fieldApiName:' + params.urlParams.fieldApiName + ',' + 'objectApiName:' + params.urlParams.objectApiName + ',' + 'targetApiName:' + params.urlParams.targetApiName + ')';
}
function createResourceRequest$y(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/lookups/' + config.urlParams.objectApiName + '/' + config.urlParams.fieldApiName + '/' + config.urlParams.targetApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$2,
        headers,
    };
}

function coerceConfig$j(config) {
    const coercedConfig = {};
    const fieldApiName = getFieldApiName(config.fieldApiName);
    if (fieldApiName !== undefined) {
        coercedConfig.fieldApiName = fieldApiName;
    }
    const objectApiName = config.objectApiName;
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const targetApiName = getObjectApiName(config.targetApiName);
    if (targetApiName !== undefined) {
        coercedConfig.targetApiName = targetApiName;
    }
    const dependentFieldBindings = config.dependentFieldBindings;
    if (dependentFieldBindings !== undefined) {
        coercedConfig.dependentFieldBindings = dependentFieldBindings;
    }
    const pageParam = config.pageParam;
    if (pageParam !== undefined) {
        coercedConfig.pageParam = pageParam;
    }
    const pageSize = config.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const q = config.q;
    if (q !== undefined) {
        coercedConfig.q = q;
    }
    const searchType = config.searchType;
    if (searchType !== undefined) {
        coercedConfig.searchType = searchType;
    }
    const sourceRecordId = config.sourceRecordId;
    if (sourceRecordId !== undefined) {
        coercedConfig.sourceRecordId = sourceRecordId;
    }
    return coercedConfig;
}
function typeCheckConfig$s(untrustedConfig) {
    const config = {};
    const untrustedConfig_fieldApiName = untrustedConfig.fieldApiName;
    if (typeof untrustedConfig_fieldApiName === 'string') {
        config.fieldApiName = untrustedConfig_fieldApiName;
    }
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_targetApiName = untrustedConfig.targetApiName;
    if (typeof untrustedConfig_targetApiName === 'string') {
        config.targetApiName = untrustedConfig_targetApiName;
    }
    const untrustedConfig_dependentFieldBindings = untrustedConfig.dependentFieldBindings;
    if (ArrayIsArray(untrustedConfig_dependentFieldBindings)) {
        const untrustedConfig_dependentFieldBindings_array = [];
        for (let i = 0, arrayLength = untrustedConfig_dependentFieldBindings.length; i < arrayLength; i++) {
            const untrustedConfig_dependentFieldBindings_item = untrustedConfig_dependentFieldBindings[i];
            if (typeof untrustedConfig_dependentFieldBindings_item === 'string') {
                untrustedConfig_dependentFieldBindings_array.push(untrustedConfig_dependentFieldBindings_item);
            }
        }
        config.dependentFieldBindings = untrustedConfig_dependentFieldBindings_array;
    }
    const untrustedConfig_pageParam = untrustedConfig.pageParam;
    if (typeof untrustedConfig_pageParam === 'number' && Math.floor(untrustedConfig_pageParam) === untrustedConfig_pageParam) {
        config.pageParam = untrustedConfig_pageParam;
    }
    const untrustedConfig_pageSize = untrustedConfig.pageSize;
    if (typeof untrustedConfig_pageSize === 'number' && Math.floor(untrustedConfig_pageSize) === untrustedConfig_pageSize) {
        config.pageSize = untrustedConfig_pageSize;
    }
    const untrustedConfig_q = untrustedConfig.q;
    if (typeof untrustedConfig_q === 'string') {
        config.q = untrustedConfig_q;
    }
    const untrustedConfig_searchType = untrustedConfig.searchType;
    if (typeof untrustedConfig_searchType === 'string') {
        config.searchType = untrustedConfig_searchType;
    }
    const untrustedConfig_sourceRecordId = untrustedConfig.sourceRecordId;
    if (typeof untrustedConfig_sourceRecordId === 'string') {
        config.sourceRecordId = untrustedConfig_sourceRecordId;
    }
    return config;
}
function validateAdapterConfig$s(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$j(untrustedConfig);
    const config = typeCheckConfig$s(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const paramNames = {
    displayName: 'getLookupRecords',
    parameters: {
        required: ['fieldApiName', 'targetApiName'],
        optional: ['requestParams'],
    },
};
function coerceRequestParams(untrusted) {
    if (!untrustedIsObject(untrusted)) {
        return {};
    }
    const coercedConfig = {};
    const requestParams = untrusted.requestParams || {};
    const dependentFieldBindings = requestParams.dependentFieldBindings;
    if (dependentFieldBindings !== undefined) {
        coercedConfig.dependentFieldBindings = dependentFieldBindings;
    }
    const pageParam = requestParams.pageParam;
    if (pageParam !== undefined) {
        coercedConfig.pageParam = pageParam;
    }
    const pageSize = requestParams.pageSize;
    if (pageSize !== undefined) {
        coercedConfig.pageSize = pageSize;
    }
    const q = requestParams.q;
    if (q !== undefined) {
        coercedConfig.q = q;
    }
    const searchType = requestParams.searchType;
    if (searchType !== undefined) {
        coercedConfig.searchType = searchType;
    }
    const sourceRecordId = requestParams.sourceRecordId;
    if (sourceRecordId !== undefined) {
        coercedConfig.sourceRecordId = sourceRecordId;
    }
    return coercedConfig;
}
function coerceConfigWithDefaults$4(untrusted) {
    const config = validateAdapterConfig$s(untrusted, paramNames);
    if (config === null) {
        return config;
    }
    const coercedRequestParams = coerceRequestParams(untrusted);
    const { objectApiName, fieldApiName } = getFieldId(config.fieldApiName);
    return {
        ...config,
        objectApiName,
        fieldApiName,
        ...coercedRequestParams,
    };
}
function removeEtags(recordRep) {
    const { fields } = recordRep;
    delete recordRep.eTag;
    delete recordRep.weakEtag;
    Object.keys(fields).forEach(fieldName => {
        const { value: nestedValue } = fields[fieldName];
        if (isSpanningRecord(nestedValue)) {
            removeEtags(nestedValue);
        }
    });
}
function buildNetworkSnapshot$p(lds, config) {
    const { objectApiName, fieldApiName, targetApiName } = config;
    const resourceParams = {
        urlParams: {
            objectApiName,
            fieldApiName,
            targetApiName,
        },
        queryParams: {
            pageParam: config.pageParam,
            pageSize: config.pageSize,
            q: config.q,
            searchType: config.searchType,
            dependentFieldBindings: config.dependentFieldBindings,
            sourceRecordId: config.sourceRecordId,
        },
    };
    const request = createResourceRequest$y(resourceParams);
    return lds.dispatchResourceRequest(request).then(response => {
        // TODO W-7235112 - remove this hack to never ingest lookup responses that
        // avoids issues caused by them not being real RecordRepresentations
        const key = keyBuilder$E(resourceParams);
        const { body } = response;
        const { records } = body;
        for (let i = 0, len = records.length; i < len; i += 1) {
            removeEtags(records[i]);
        }
        deepFreeze$s(body);
        return {
            state: 'Fulfilled',
            recordId: key,
            variables: {},
            seenRecords: {},
            select: {
                recordId: key,
                node: {
                    kind: 'Fragment',
                },
                variables: {},
            },
            data: body,
        };
    }, (err) => {
        return lds.errorSnapshot(err);
    });
}
const factory$9 = (lds) => {
    return refreshable(function (untrusted) {
        const config = coerceConfigWithDefaults$4(untrusted);
        if (config === null) {
            return null;
        }
        return buildNetworkSnapshot$p(lds, config);
    }, (untrusted) => {
        const config = coerceConfigWithDefaults$4(untrusted);
        if (config === null) {
            throw new Error('Refresh should not be called with partial configuration');
        }
        return buildNetworkSnapshot$p(lds, config);
    });
};

function createResourceRequest$z(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/object-info/' + config.urlParams.objectApiName + '/picklist-values/' + config.urlParams.recordTypeId + '/' + config.urlParams.fieldApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: ingest$m,
        headers,
    };
}

const adapterName$k = 'getPicklistValues';
function coerceConfig$k(config) {
    const coercedConfig = {};
    const fieldApiName = getFieldApiName(config.fieldApiName);
    if (fieldApiName !== undefined) {
        coercedConfig.fieldApiName = fieldApiName;
    }
    const objectApiName = config.objectApiName;
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$t(untrustedConfig) {
    const config = {};
    const untrustedConfig_fieldApiName = untrustedConfig.fieldApiName;
    if (typeof untrustedConfig_fieldApiName === 'string') {
        config.fieldApiName = untrustedConfig_fieldApiName;
    }
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$t(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$k(untrustedConfig);
    const config = typeCheckConfig$t(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const path = select$A().selections;
function buildSnapshotRefresh$7(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$q(lds, config),
    };
}
function buildRequestAndKey$1(config) {
    const { recordTypeId, fieldApiName } = config;
    const fieldNames = getFieldId(fieldApiName);
    const request = createResourceRequest$z({
        urlParams: {
            objectApiName: fieldNames.objectApiName,
            fieldApiName: fieldNames.fieldApiName,
            recordTypeId,
        },
    });
    const key = keyBuilder$q({ id: `${request.baseUri}${request.basePath}` });
    return { request, key };
}
function onResponseSuccess(lds, config, key, request, response) {
    const { body } = response;
    lds.storeIngest(key, request, body);
    lds.storeBroadcast();
    return buildInMemorySnapshot$q(lds, config);
}
function onResponseError(lds, config, key, err) {
    lds.storeIngestFetchResponse(key, err);
    lds.storeBroadcast();
    return lds.errorSnapshot(err, buildSnapshotRefresh$7(lds, config));
}
function buildNetworkSnapshot$q(lds, config) {
    const { request, key } = buildRequestAndKey$1(config);
    return lds.dispatchResourceRequest(request).then(response => {
        return onResponseSuccess(lds, config, key, request, response);
    }, (err) => {
        return onResponseError(lds, config, key, err);
    });
}
function resolveUnfulfilledSnapshot$m(lds, config, snapshot) {
    const { request, key } = buildRequestAndKey$1(config);
    return lds.resolveUnfulfilledSnapshot(request, snapshot).then(response => {
        return onResponseSuccess(lds, config, key, request, response);
    }, (err) => {
        return onResponseError(lds, config, key, err);
    });
}
function buildInMemorySnapshot$q(lds, config) {
    const fieldNames = getFieldId(config.fieldApiName);
    const request = createResourceRequest$z({
        urlParams: {
            objectApiName: fieldNames.objectApiName,
            fieldApiName: fieldNames.fieldApiName,
            recordTypeId: config.recordTypeId,
        },
    });
    const key = keyBuilder$q({ id: `${request.baseUri}${request.basePath}` });
    return lds.storeLookup({
        recordId: key,
        node: {
            kind: 'Fragment',
            private: ['eTag'],
            selections: path,
        },
        variables: {},
    }, buildSnapshotRefresh$7(lds, config));
}
const picklistValuesConfigPropertyNames = {
    displayName: adapterName$k,
    parameters: {
        required: ['recordTypeId', 'fieldApiName'],
        optional: [],
    },
};
const factory$a = (lds) => function getPicklistValues(untrusted) {
    const config = validateAdapterConfig$t(untrusted, picklistValuesConfigPropertyNames);
    if (config === null) {
        return null;
    }
    const snapshot = buildInMemorySnapshot$q(lds, config);
    if (lds.snapshotDataAvailable(snapshot)) {
        return snapshot;
    }
    if (isUnfulfilledSnapshot(snapshot)) {
        return resolveUnfulfilledSnapshot$m(lds, config, snapshot);
    }
    return buildNetworkSnapshot$q(lds, config);
};

function validate$12(obj, path = 'PhotoMetadataRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_companyBluemasterId = obj.companyBluemasterId;
        const path_companyBluemasterId = path + '.companyBluemasterId';
        let obj_companyBluemasterId_union0 = null;
        const obj_companyBluemasterId_union0_error = (() => {
            if (typeof obj_companyBluemasterId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_companyBluemasterId + '" (at "' + path_companyBluemasterId + '")');
            }
        })();
        if (obj_companyBluemasterId_union0_error != null) {
            obj_companyBluemasterId_union0 = obj_companyBluemasterId_union0_error.message;
        }
        let obj_companyBluemasterId_union1 = null;
        const obj_companyBluemasterId_union1_error = (() => {
            if (obj_companyBluemasterId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_companyBluemasterId + '" (at "' + path_companyBluemasterId + '")');
            }
        })();
        if (obj_companyBluemasterId_union1_error != null) {
            obj_companyBluemasterId_union1 = obj_companyBluemasterId_union1_error.message;
        }
        if (obj_companyBluemasterId_union0 && obj_companyBluemasterId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_companyBluemasterId + '")';
            message += '\n' + obj_companyBluemasterId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_companyBluemasterId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_responseId = obj.responseId;
        const path_responseId = path + '.responseId';
        let obj_responseId_union0 = null;
        const obj_responseId_union0_error = (() => {
            if (typeof obj_responseId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_responseId + '" (at "' + path_responseId + '")');
            }
        })();
        if (obj_responseId_union0_error != null) {
            obj_responseId_union0 = obj_responseId_union0_error.message;
        }
        let obj_responseId_union1 = null;
        const obj_responseId_union1_error = (() => {
            if (obj_responseId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_responseId + '" (at "' + path_responseId + '")');
            }
        })();
        if (obj_responseId_union1_error != null) {
            obj_responseId_union1 = obj_responseId_union1_error.message;
        }
        if (obj_responseId_union0 && obj_responseId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_responseId + '")';
            message += '\n' + obj_responseId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_responseId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$R = function PhotoMetadataRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'companyBluemasterId',
                kind: 'Scalar',
            },
            {
                name: 'responseId',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$D(existing, incoming) {
    const existing_companyBluemasterId = existing.companyBluemasterId;
    const incoming_companyBluemasterId = incoming.companyBluemasterId;
    if (!(existing_companyBluemasterId === incoming_companyBluemasterId)) {
        return false;
    }
    const existing_responseId = existing.responseId;
    const incoming_responseId = incoming.responseId;
    if (!(existing_responseId === incoming_responseId)) {
        return false;
    }
    return true;
}

function validate$13(obj, path = 'PhotoRecordAvatarRepresentation') {
    const validateAbstractRecordAvatarRepresentation_validateError = validate$15(obj, path);
    if (validateAbstractRecordAvatarRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_backgroundColor = obj.backgroundColor;
        const path_backgroundColor = path + '.backgroundColor';
        let obj_backgroundColor_union0 = null;
        const obj_backgroundColor_union0_error = (() => {
            if (typeof obj_backgroundColor !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union0_error != null) {
            obj_backgroundColor_union0 = obj_backgroundColor_union0_error.message;
        }
        let obj_backgroundColor_union1 = null;
        const obj_backgroundColor_union1_error = (() => {
            if (obj_backgroundColor !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union1_error != null) {
            obj_backgroundColor_union1 = obj_backgroundColor_union1_error.message;
        }
        if (obj_backgroundColor_union0 && obj_backgroundColor_union1) {
            let message = 'Object doesn\'t match union (at "' + path_backgroundColor + '")';
            message += '\n' + obj_backgroundColor_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_backgroundColor_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_height = obj.height;
        const path_height = path + '.height';
        let obj_height_union0 = null;
        const obj_height_union0_error = (() => {
            if (typeof obj_height !== 'number' || (typeof obj_height === 'number' && Math.floor(obj_height) !== obj_height)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_height + '" (at "' + path_height + '")');
            }
        })();
        if (obj_height_union0_error != null) {
            obj_height_union0 = obj_height_union0_error.message;
        }
        let obj_height_union1 = null;
        const obj_height_union1_error = (() => {
            if (obj_height !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_height + '" (at "' + path_height + '")');
            }
        })();
        if (obj_height_union1_error != null) {
            obj_height_union1 = obj_height_union1_error.message;
        }
        if (obj_height_union0 && obj_height_union1) {
            let message = 'Object doesn\'t match union (at "' + path_height + '")';
            message += '\n' + obj_height_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_height_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_photoMetadata = obj.photoMetadata;
        const path_photoMetadata = path + '.photoMetadata';
        const referencePhotoMetadataRepresentationValidationError = validate$12(obj_photoMetadata, path_photoMetadata);
        if (referencePhotoMetadataRepresentationValidationError !== null) {
            let message = 'Object doesn\'t match PhotoMetadataRepresentation (at "' + path_photoMetadata + '")\n';
            message += referencePhotoMetadataRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_photoUrl = obj.photoUrl;
        const path_photoUrl = path + '.photoUrl';
        if (typeof obj_photoUrl !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_photoUrl + '" (at "' + path_photoUrl + '")');
        }
        const obj_provider = obj.provider;
        const path_provider = path + '.provider';
        let obj_provider_union0 = null;
        const obj_provider_union0_error = (() => {
            if (typeof obj_provider !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_provider + '" (at "' + path_provider + '")');
            }
        })();
        if (obj_provider_union0_error != null) {
            obj_provider_union0 = obj_provider_union0_error.message;
        }
        let obj_provider_union1 = null;
        const obj_provider_union1_error = (() => {
            if (obj_provider !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_provider + '" (at "' + path_provider + '")');
            }
        })();
        if (obj_provider_union1_error != null) {
            obj_provider_union1 = obj_provider_union1_error.message;
        }
        if (obj_provider_union0 && obj_provider_union1) {
            let message = 'Object doesn\'t match union (at "' + path_provider + '")';
            message += '\n' + obj_provider_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_provider_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_width = obj.width;
        const path_width = path + '.width';
        let obj_width_union0 = null;
        const obj_width_union0_error = (() => {
            if (typeof obj_width !== 'number' || (typeof obj_width === 'number' && Math.floor(obj_width) !== obj_width)) {
                return new TypeError('Expected "integer" but received "' + typeof obj_width + '" (at "' + path_width + '")');
            }
        })();
        if (obj_width_union0_error != null) {
            obj_width_union0 = obj_width_union0_error.message;
        }
        let obj_width_union1 = null;
        const obj_width_union1_error = (() => {
            if (obj_width !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_width + '" (at "' + path_width + '")');
            }
        })();
        if (obj_width_union1_error != null) {
            obj_width_union1 = obj_width_union1_error.message;
        }
        if (obj_width_union0 && obj_width_union1) {
            let message = 'Object doesn\'t match union (at "' + path_width + '")';
            message += '\n' + obj_width_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_width_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilderFromType$i(object) {
    return keyBuilderFromType$k(object);
}
function normalize$z(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$S = function PhotoRecordAvatarRepresentationSelect() {
    const { selections: AbstractRecordAvatarRepresentationSelections } = select$U();
    const { selections: PhotoMetadataRepresentation__selections, opaque: PhotoMetadataRepresentation__opaque, } = select$R();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            ...AbstractRecordAvatarRepresentationSelections,
            {
                name: 'backgroundColor',
                kind: 'Scalar',
            },
            {
                name: 'height',
                kind: 'Scalar',
            },
            {
                name: 'photoMetadata',
                kind: 'Object',
                selections: PhotoMetadataRepresentation__selections
            },
            {
                name: 'photoUrl',
                kind: 'Scalar',
            },
            {
                name: 'provider',
                kind: 'Scalar',
            },
            {
                name: 'width',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$E(existing, incoming) {
    if (equals$G(existing, incoming) === false) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_photoUrl = existing.photoUrl;
    const incoming_photoUrl = incoming.photoUrl;
    if (!(existing_photoUrl === incoming_photoUrl)) {
        return false;
    }
    const existing_backgroundColor = existing.backgroundColor;
    const incoming_backgroundColor = incoming.backgroundColor;
    if (!(existing_backgroundColor === incoming_backgroundColor)) {
        return false;
    }
    const existing_height = existing.height;
    const incoming_height = incoming.height;
    if (!(existing_height === incoming_height)) {
        return false;
    }
    const existing_photoMetadata = existing.photoMetadata;
    const incoming_photoMetadata = incoming.photoMetadata;
    if (!(equals$D(existing_photoMetadata, incoming_photoMetadata))) {
        return false;
    }
    const existing_provider = existing.provider;
    const incoming_provider = incoming.provider;
    if (!(existing_provider === incoming_provider)) {
        return false;
    }
    const existing_width = existing.width;
    const incoming_width = incoming.width;
    if (!(existing_width === incoming_width)) {
        return false;
    }
    return true;
}
const ingest$z = function PhotoRecordAvatarRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$13(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$i(input);
    let incomingRecord = normalize$z(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$E(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$14(obj, path = 'ThemeRecordAvatarRepresentation') {
    const validateAbstractRecordAvatarRepresentation_validateError = validate$15(obj, path);
    if (validateAbstractRecordAvatarRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_backgroundColor = obj.backgroundColor;
        const path_backgroundColor = path + '.backgroundColor';
        let obj_backgroundColor_union0 = null;
        const obj_backgroundColor_union0_error = (() => {
            if (typeof obj_backgroundColor !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union0_error != null) {
            obj_backgroundColor_union0 = obj_backgroundColor_union0_error.message;
        }
        let obj_backgroundColor_union1 = null;
        const obj_backgroundColor_union1_error = (() => {
            if (obj_backgroundColor !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_backgroundColor + '" (at "' + path_backgroundColor + '")');
            }
        })();
        if (obj_backgroundColor_union1_error != null) {
            obj_backgroundColor_union1 = obj_backgroundColor_union1_error.message;
        }
        if (obj_backgroundColor_union0 && obj_backgroundColor_union1) {
            let message = 'Object doesn\'t match union (at "' + path_backgroundColor + '")';
            message += '\n' + obj_backgroundColor_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_backgroundColor_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_iconUrl = obj.iconUrl;
        const path_iconUrl = path + '.iconUrl';
        let obj_iconUrl_union0 = null;
        const obj_iconUrl_union0_error = (() => {
            if (typeof obj_iconUrl !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union0_error != null) {
            obj_iconUrl_union0 = obj_iconUrl_union0_error.message;
        }
        let obj_iconUrl_union1 = null;
        const obj_iconUrl_union1_error = (() => {
            if (obj_iconUrl !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_iconUrl + '" (at "' + path_iconUrl + '")');
            }
        })();
        if (obj_iconUrl_union1_error != null) {
            obj_iconUrl_union1 = obj_iconUrl_union1_error.message;
        }
        if (obj_iconUrl_union0 && obj_iconUrl_union1) {
            let message = 'Object doesn\'t match union (at "' + path_iconUrl + '")';
            message += '\n' + obj_iconUrl_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_iconUrl_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilderFromType$j(object) {
    return keyBuilderFromType$k(object);
}
function normalize$A(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$T = function ThemeRecordAvatarRepresentationSelect() {
    const { selections: AbstractRecordAvatarRepresentationSelections } = select$U();
    return {
        kind: 'Fragment',
        private: [
            'eTag'
        ],
        selections: [
            ...AbstractRecordAvatarRepresentationSelections,
            {
                name: 'backgroundColor',
                kind: 'Scalar',
            },
            {
                name: 'iconUrl',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$F(existing, incoming) {
    if (equals$G(existing, incoming) === false) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_backgroundColor = existing.backgroundColor;
    const incoming_backgroundColor = incoming.backgroundColor;
    if (!(existing_backgroundColor === incoming_backgroundColor)) {
        return false;
    }
    const existing_iconUrl = existing.iconUrl;
    const incoming_iconUrl = incoming.iconUrl;
    if (!(existing_iconUrl === incoming_iconUrl)) {
        return false;
    }
    return true;
}
const ingest$A = function ThemeRecordAvatarRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$14(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$j(input);
    let incomingRecord = normalize$A(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$F(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

var DiscriminatorValues$2;
(function (DiscriminatorValues) {
    DiscriminatorValues["Photo"] = "Photo";
    DiscriminatorValues["Theme"] = "Theme";
})(DiscriminatorValues$2 || (DiscriminatorValues$2 = {}));
function validate$15(obj, path = 'AbstractRecordAvatarRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_recordId = obj.recordId;
        const path_recordId = path + '.recordId';
        if (typeof obj_recordId !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_recordId + '" (at "' + path_recordId + '")');
        }
        const obj_type = obj.type;
        const path_type = path + '.type';
        if (typeof obj_type !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_type + '" (at "' + path_type + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$F(config) {
    return keyPrefix + 'AbstractRecordAvatarRepresentation:' + config.recordId;
}
function keyBuilderFromType$k(object) {
    const keyParams = {
        recordId: object.recordId
    };
    return keyBuilder$F(keyParams);
}
function normalize$B(input, existing, path, lds, store, timestamp) {
    return input;
}
const selectChildren$1 = function AbstractRecordAvatarRepresentationSelectChildren() {
    const PhotoRecordAvatarRepresentationSelections = select$S();
    const ThemeRecordAvatarRepresentationSelections = select$T();
    return {
        kind: 'Fragment',
        union: true,
        discriminator: 'type',
        unionSelections: {
            [DiscriminatorValues$2.Photo]: PhotoRecordAvatarRepresentationSelections,
            [DiscriminatorValues$2.Theme]: ThemeRecordAvatarRepresentationSelections
        }
    };
};
const select$U = function AbstractRecordAvatarRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'recordId',
                kind: 'Scalar',
            },
            {
                name: 'type',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$G(existing, incoming) {
    const existing_recordId = existing.recordId;
    const incoming_recordId = incoming.recordId;
    if (!(existing_recordId === incoming_recordId)) {
        return false;
    }
    const existing_type = existing.type;
    const incoming_type = incoming.type;
    if (!(existing_type === incoming_type)) {
        return false;
    }
    return true;
}
const ingest$B = function AbstractRecordAvatarRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$15(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$k(input);
    let incomingRecord = normalize$B(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$G(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};
const discriminatorIngest = function AbstractRecordAvatarRepresentationDiscriminatorIngest(input, path, lds, store, timestamp) {
    const discriminatorValue = input.type;
    if (discriminatorValue === 'Photo') {
        return ingest$z(input, path, lds, store);
    }
    if (discriminatorValue === 'Theme') {
        return ingest$A(input, path, lds, store);
    }
    throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "Photo","Theme"`);
};

function validate$16(obj, path = 'RecordAvatarBatchRepresentation') {
    const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$1a(obj, path);
    if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (typeof obj_result !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$C(input, existing, path, lds, store, timestamp) {
    const input_result = input.result;
    const input_result_id = path.fullPath + '__result';
    input.result = discriminatorIngest(input_result, {
        fullPath: input_result_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store);
    return input;
}
const select$V = function RecordAvatarBatchRepresentationSelect() {
    const { selections: AbstractRecordAvatarBatchRepresentationSelections } = select$Z();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractRecordAvatarBatchRepresentationSelections,
            {
                kind: 'Link',
                name: 'result',
                fragment: selectChildren$1()
            }
        ]
    };
};
function equals$H(existing, incoming) {
    if (equals$L(existing, incoming) === false) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    if (!(existing_result.__ref === incoming_result.__ref)) {
        return false;
    }
    return true;
}
const ingest$C = function RecordAvatarBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$16(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$C(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$H(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function validate$17(obj, path = 'ErrorSingleRecordAvatarRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_errorCode = obj.errorCode;
        const path_errorCode = path + '.errorCode';
        if (typeof obj_errorCode !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_errorCode + '" (at "' + path_errorCode + '")');
        }
        const obj_message = obj.message;
        const path_message = path + '.message';
        if (typeof obj_message !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_message + '" (at "' + path_message + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const select$W = function ErrorSingleRecordAvatarRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'errorCode',
                kind: 'Scalar',
            },
            {
                name: 'message',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$I(existing, incoming) {
    const existing_errorCode = existing.errorCode;
    const incoming_errorCode = incoming.errorCode;
    if (!(existing_errorCode === incoming_errorCode)) {
        return false;
    }
    const existing_message = existing.message;
    const incoming_message = incoming.message;
    if (!(existing_message === incoming_message)) {
        return false;
    }
    return true;
}

function validate$18(obj, path = 'ErrorBadRequestRecordAvatarBatchRepresentation') {
    const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$1a(obj, path);
    if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (!ArrayIsArray$1(obj_result)) {
            return new TypeError('Expected "array" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
        for (let i = 0; i < obj_result.length; i++) {
            const obj_result_item = obj_result[i];
            const path_result_item = path_result + '[' + i + ']';
            const referenceErrorSingleRecordAvatarRepresentationValidationError = validate$17(obj_result_item, path_result_item);
            if (referenceErrorSingleRecordAvatarRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "' + path_result_item + '")\n';
                message += referenceErrorSingleRecordAvatarRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$D(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$X = function ErrorBadRequestRecordAvatarBatchRepresentationSelect() {
    const { selections: AbstractRecordAvatarBatchRepresentationSelections } = select$Z();
    const { selections: ErrorSingleRecordAvatarRepresentation__selections, opaque: ErrorSingleRecordAvatarRepresentation__opaque, } = select$W();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractRecordAvatarBatchRepresentationSelections,
            {
                name: 'result',
                kind: 'Object',
                plural: true,
                selections: ErrorSingleRecordAvatarRepresentation__selections
            }
        ]
    };
};
function equals$J(existing, incoming) {
    if (equals$L(existing, incoming) === false) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    const equals_result_items = equalsArray(existing_result, incoming_result, (existing_result_item, incoming_result_item) => {
        if (!(equals$I(existing_result_item, incoming_result_item))) {
            return false;
        }
    });
    if (equals_result_items === false) {
        return false;
    }
    return true;
}
const ingest$D = function ErrorBadRequestRecordAvatarBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$18(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$D(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$J(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

function validate$19(obj, path = 'ErrorRecordAvatarBatchRepresentation') {
    const validateAbstractRecordAvatarBatchRepresentation_validateError = validate$1a(obj, path);
    if (validateAbstractRecordAvatarBatchRepresentation_validateError !== null) {
        return validateAbstractRecordAvatarBatchRepresentation_validateError;
    }
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_result = obj.result;
        const path_result = path + '.result';
        if (!ArrayIsArray$1(obj_result)) {
            return new TypeError('Expected "array" but received "' + typeof obj_result + '" (at "' + path_result + '")');
        }
        for (let i = 0; i < obj_result.length; i++) {
            const obj_result_item = obj_result[i];
            const path_result_item = path_result + '[' + i + ']';
            const referenceErrorSingleRecordAvatarRepresentationValidationError = validate$17(obj_result_item, path_result_item);
            if (referenceErrorSingleRecordAvatarRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match ErrorSingleRecordAvatarRepresentation (at "' + path_result_item + '")\n';
                message += referenceErrorSingleRecordAvatarRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$E(input, existing, path, lds, store, timestamp) {
    return input;
}
const select$Y = function ErrorRecordAvatarBatchRepresentationSelect() {
    const { selections: AbstractRecordAvatarBatchRepresentationSelections } = select$Z();
    const { selections: ErrorSingleRecordAvatarRepresentation__selections, opaque: ErrorSingleRecordAvatarRepresentation__opaque, } = select$W();
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            ...AbstractRecordAvatarBatchRepresentationSelections,
            {
                name: 'result',
                kind: 'Object',
                plural: true,
                selections: ErrorSingleRecordAvatarRepresentation__selections
            }
        ]
    };
};
function equals$K(existing, incoming) {
    if (equals$L(existing, incoming) === false) {
        return false;
    }
    const existing_result = existing.result;
    const incoming_result = incoming.result;
    const equals_result_items = equalsArray(existing_result, incoming_result, (existing_result_item, incoming_result_item) => {
        if (!(equals$I(existing_result_item, incoming_result_item))) {
            return false;
        }
    });
    if (equals_result_items === false) {
        return false;
    }
    return true;
}
const ingest$E = function ErrorRecordAvatarBatchRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$19(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$E(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    });
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$K(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 300000);
    return createLink(key);
};

const DiscriminatorValues$3 = {
    '200': 200,
    '400': 400,
    '404': 404
};
function validate$1a(obj, path = 'AbstractRecordAvatarBatchRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_statusCode = obj.statusCode;
        const path_statusCode = path + '.statusCode';
        if (typeof obj_statusCode !== 'number') {
            return new TypeError('Expected "number" but received "' + typeof obj_statusCode + '" (at "' + path_statusCode + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
const selectChildren$2 = function AbstractRecordAvatarBatchRepresentationSelectChildren() {
    const RecordAvatarBatchRepresentationSelections = select$V();
    const ErrorBadRequestRecordAvatarBatchRepresentationSelections = select$X();
    const ErrorRecordAvatarBatchRepresentationSelections = select$Y();
    return {
        kind: 'Fragment',
        union: true,
        discriminator: 'statusCode',
        unionSelections: {
            [DiscriminatorValues$3['200']]: RecordAvatarBatchRepresentationSelections,
            [DiscriminatorValues$3['400']]: ErrorBadRequestRecordAvatarBatchRepresentationSelections,
            [DiscriminatorValues$3['404']]: ErrorRecordAvatarBatchRepresentationSelections
        }
    };
};
const select$Z = function AbstractRecordAvatarBatchRepresentationSelect() {
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                name: 'statusCode',
                kind: 'Scalar',
            }
        ]
    };
};
function equals$L(existing, incoming) {
    const existing_statusCode = existing.statusCode;
    const incoming_statusCode = incoming.statusCode;
    if (!(existing_statusCode === incoming_statusCode)) {
        return false;
    }
    return true;
}
const discriminatorIngest$1 = function AbstractRecordAvatarBatchRepresentationDiscriminatorIngest(input, path, lds, store, timestamp) {
    const discriminatorValue = input.statusCode;
    if (discriminatorValue === 200) {
        return ingest$C(input, path, lds, store, timestamp);
    }
    if (discriminatorValue === 400) {
        return ingest$D(input, path, lds, store, timestamp);
    }
    if (discriminatorValue === 404) {
        return ingest$E(input, path, lds, store, timestamp);
    }
    throw new Error(`Invalid discriminatorValue "${discriminatorValue}". Expected one of "200","400","404"`);
};

function validate$1b(obj, path = 'RecordAvatarBulkMapRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_keys = ObjectKeys$1(obj);
        for (let i = 0; i < obj_keys.length; i++) {
            const key = obj_keys[i];
            const obj_prop = obj[key];
            const path_prop = path + '["' + key + '"]';
            if (typeof obj_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_prop + '" (at "' + path_prop + '")');
            }
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$F(input, existing, path, lds, store, timestamp) {
    const input_keys = Object.keys(input);
    const input_length = input_keys.length;
    for (let i = 0; i < input_length; i++) {
        const key = input_keys[i];
        const input_prop = input[key];
        const input_prop_id = path.fullPath + '__' + key;
        input[key] = discriminatorIngest$1(input_prop, {
            fullPath: input_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$M(existing, incoming) {
    const equals_props = equalsObject(existing, incoming, (existing_prop, incoming_prop) => {
        if (!(existing_prop.__ref === incoming_prop.__ref)) {
            return false;
        }
    });
    if (equals_props === false) {
        return false;
    }
    return true;
}

function merge$2(existing, incoming, _lds, _path) {
    if (existing === undefined) {
        return incoming;
    }
    // Merge RecordRepresentation field values together
    return {
        ...existing,
        ...incoming,
    };
}

const ingest$F = function RecordAvatarBulkMapRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$1b(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$F(input, store.records[key], {
        fullPath: key,
        parent: path.parent,
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    incomingRecord = merge$2(existingRecord, incomingRecord);
    if (existingRecord === undefined || equals$M(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function createResourceRequest$A(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/record-avatars/batch/' + config.urlParams.recordIds + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$F,
        headers,
    };
}

const getRecordAvatars_ConfigPropertyNames = {
    displayName: 'getRecordAvatars',
    parameters: {
        required: ['recordIds'],
        optional: ['formFactor']
    }
};
function coerceConfig$l(config) {
    const coercedConfig = {};
    const recordIds = getRecordId18Array(config.recordIds);
    if (recordIds !== undefined) {
        coercedConfig.recordIds = recordIds;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    return coercedConfig;
}
function typeCheckConfig$u(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordIds = untrustedConfig.recordIds;
    if (ArrayIsArray(untrustedConfig_recordIds)) {
        const untrustedConfig_recordIds_array = [];
        for (let i = 0, arrayLength = untrustedConfig_recordIds.length; i < arrayLength; i++) {
            const untrustedConfig_recordIds_item = untrustedConfig_recordIds[i];
            if (typeof untrustedConfig_recordIds_item === 'string') {
                untrustedConfig_recordIds_array.push(untrustedConfig_recordIds_item);
            }
        }
        config.recordIds = untrustedConfig_recordIds_array;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    return config;
}
function validateAdapterConfig$u(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$l(untrustedConfig);
    const config = typeCheckConfig$u(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function selectAvatars(recordIds) {
    return recordIds.map((recordId) => {
        return {
            kind: 'Link',
            name: recordId,
            fragment: selectChildren$2(),
        };
    });
}
// All of the avatars are ingested into
// the same top level object
const KEY = `${keyPrefix}RecordAvatarsBulk`;
function buildInMemorySnapshot$r(lds, config) {
    const { recordIds } = config;
    const sel = selectAvatars(recordIds);
    return lds.storeLookup({
        recordId: KEY,
        node: {
            kind: 'Fragment',
            private: [],
            selections: sel,
        },
        variables: {},
    }, buildSnapshotRefresh$8(lds, config, recordIds));
}
function buildSnapshotRefresh$8(lds, config, recordIds) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$r(lds, config, recordIds),
    };
}
function buildRequest(recordIds) {
    const resourceRequest = createResourceRequest$A({
        urlParams: {
            recordIds,
        },
        queryParams: {},
    });
    return resourceRequest;
}
function isRecordAvatarBulkMapRepresentation(response) {
    return response.body.hasErrors === undefined;
}
function onResponseSuccess$1(lds, config, recordIds, request, response) {
    let formatted;
    // the selector passed to resolveUnfulfilledSnapshot requests the data already formatted so the response
    // can either be a RecordAvatarBulkRepresentation or a RecordAvatarBulkMapRepresentation
    if (isRecordAvatarBulkMapRepresentation(response)) {
        formatted = response.body;
    }
    else {
        formatted = response.body.results.reduce((seed, avatar, index) => {
            const recordId = recordIds[index];
            seed[recordId] = avatar;
            return seed;
        }, {});
    }
    lds.storeIngest(KEY, request, formatted);
    lds.storeBroadcast();
    return buildInMemorySnapshot$r(lds, config);
}
function onResponseError$1(lds, config, recordIds, err) {
    lds.storeIngestFetchResponse(KEY, err);
    lds.storeBroadcast();
    return lds.errorSnapshot(err, buildSnapshotRefresh$8(lds, config, recordIds));
}
function resolveUnfulfilledSnapshot$n(lds, config, recordIds, snapshot) {
    const resourceRequest = buildRequest(recordIds);
    return lds.resolveUnfulfilledSnapshot(resourceRequest, snapshot).then(response => {
        return onResponseSuccess$1(lds, config, recordIds, resourceRequest, response);
    }, (err) => {
        return onResponseError$1(lds, config, recordIds, err);
    });
}
/**
 *
 * The third argument, "recordIds", is here because
 * We only want to fetch avatars that are actually missing
 * This list will be a subset of the recordIds that are on the adapter config.
 *
 */
function buildNetworkSnapshot$r(lds, config, recordIds) {
    const resourceRequest = buildRequest(recordIds);
    return lds.dispatchResourceRequest(resourceRequest).then(response => {
        return onResponseSuccess$1(lds, config, recordIds, resourceRequest, response);
    }, (err) => {
        return onResponseError$1(lds, config, recordIds, err);
    });
}
// We have to type guard against pending snapshots
// We should only ever get UnfulfilledSnapshot here
function getRecordIds(config, snapshot) {
    if (process.env.NODE_ENV !== 'production') {
        if (isUnfulfilledSnapshot(snapshot) === false) {
            throw new Error('Unexpected snapshot state in "getRecordIds" in "getRecordAvatars"');
        }
    }
    // Missing all avatars
    if (snapshot.data === undefined) {
        return config.recordIds;
    }
    return keys(snapshot.missingPaths).sort();
}
const factory$b = (lds) => function getRecordAvatars(unknown) {
    const config = validateAdapterConfig$u(unknown, getRecordAvatars_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    const cacheLookup = buildInMemorySnapshot$r(lds, config);
    // CACHE HIT
    if (lds.snapshotDataAvailable(cacheLookup)) {
        return cacheLookup;
    }
    // CACHE MISS
    // Only fetch avatars that are missing
    const recordIds = getRecordIds(config, cacheLookup);
    if (isUnfulfilledSnapshot(cacheLookup)) {
        return resolveUnfulfilledSnapshot$n(lds, config, recordIds, cacheLookup);
    }
    return buildNetworkSnapshot$r(lds, config, recordIds);
};

function keyBuilder$G(params) {
    return keyBuilder$F({
        recordId: params.urlParams.recordId
    });
}
function createResourceRequest$B(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/record-avatars/' + config.urlParams.recordId + '/association',
        method: 'post',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: ingest$B,
        headers,
    };
}

const updateRecordAvatar_ConfigPropertyNames = {
    displayName: 'updateRecordAvatar',
    parameters: {
        required: ['recordId', 'actionType'],
        optional: ['blueMasterId', 'externalId', 'photoUrl', 'profileName']
    }
};
function typeCheckConfig$v(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_actionType = untrustedConfig.actionType;
    if (typeof untrustedConfig_actionType === 'string') {
        config.actionType = untrustedConfig_actionType;
    }
    const untrustedConfig_blueMasterId = untrustedConfig.blueMasterId;
    if (typeof untrustedConfig_blueMasterId === 'string') {
        config.blueMasterId = untrustedConfig_blueMasterId;
    }
    const untrustedConfig_externalId = untrustedConfig.externalId;
    if (typeof untrustedConfig_externalId === 'string') {
        config.externalId = untrustedConfig_externalId;
    }
    const untrustedConfig_photoUrl = untrustedConfig.photoUrl;
    if (typeof untrustedConfig_photoUrl === 'string') {
        config.photoUrl = untrustedConfig_photoUrl;
    }
    const untrustedConfig_profileName = untrustedConfig.profileName;
    if (typeof untrustedConfig_profileName === 'string') {
        config.profileName = untrustedConfig_profileName;
    }
    return config;
}
function validateAdapterConfig$v(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const config = typeCheckConfig$v(untrustedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const factory$c = (lds) => {
    return (untrustedConfig) => {
        const config = validateAdapterConfig$v(untrustedConfig, updateRecordAvatar_ConfigPropertyNames);
        if (config === null) {
            throw new Error('updateRecordAvatar invalid configuration');
        }
        const resourceParams = {
            urlParams: {
                recordId: config.recordId,
            },
            body: {
                externalId: config.externalId,
                blueMasterId: config.blueMasterId,
                profileName: config.profileName,
                photoUrl: config.photoUrl,
                actionType: config.actionType,
            },
        };
        const request = createResourceRequest$B(resourceParams);
        const key = keyBuilder$G(resourceParams);
        return lds.dispatchResourceRequest(request).then(response => {
            let selectors;
            if (response.body.type === 'Theme') {
                selectors = select$T;
                lds.storeIngest(key, { ...request, ingest: ingest$A }, response.body);
            }
            else if (response.body.type === 'Photo') {
                selectors = select$S;
                lds.storeIngest(key, { ...request, ingest: ingest$z }, response.body);
            }
            else {
                throw new Error('Unsupported avatar type');
            }
            lds.storeBroadcast();
            // TODO W-6804405 - support unions on fragments (only supported on links today)
            return lds.storeLookup({
                recordId: key,
                node: selectors(),
                variables: {},
            });
        }, (err) => {
            deepFreeze$s(err);
            throw err;
        });
    };
};

function validate$1c(obj, path = 'RecordCreateDefaultRecordRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_childRelationships = obj.childRelationships;
        const path_childRelationships = path + '.childRelationships';
        if (typeof obj_childRelationships !== 'object' || ArrayIsArray$1(obj_childRelationships) || obj_childRelationships === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_childRelationships + '" (at "' + path_childRelationships + '")');
        }
        const obj_childRelationships_keys = ObjectKeys$1(obj_childRelationships);
        for (let i = 0; i < obj_childRelationships_keys.length; i++) {
            const key = obj_childRelationships_keys[i];
            const obj_childRelationships_prop = obj_childRelationships[key];
            const path_childRelationships_prop = path_childRelationships + '["' + key + '"]';
            if (typeof obj_childRelationships_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_childRelationships_prop + '" (at "' + path_childRelationships_prop + '")');
            }
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_id = obj.id;
        const path_id = path + '.id';
        if (obj_id !== null) {
            return new TypeError('Expected "null" but received "' + typeof obj_id + '" (at "' + path_id + '")');
        }
        const obj_lastModifiedById = obj.lastModifiedById;
        const path_lastModifiedById = path + '.lastModifiedById';
        let obj_lastModifiedById_union0 = null;
        const obj_lastModifiedById_union0_error = (() => {
            if (typeof obj_lastModifiedById !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union0_error != null) {
            obj_lastModifiedById_union0 = obj_lastModifiedById_union0_error.message;
        }
        let obj_lastModifiedById_union1 = null;
        const obj_lastModifiedById_union1_error = (() => {
            if (obj_lastModifiedById !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedById + '" (at "' + path_lastModifiedById + '")');
            }
        })();
        if (obj_lastModifiedById_union1_error != null) {
            obj_lastModifiedById_union1 = obj_lastModifiedById_union1_error.message;
        }
        if (obj_lastModifiedById_union0 && obj_lastModifiedById_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedById + '")';
            message += '\n' + obj_lastModifiedById_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedById_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_lastModifiedDate = obj.lastModifiedDate;
        const path_lastModifiedDate = path + '.lastModifiedDate';
        let obj_lastModifiedDate_union0 = null;
        const obj_lastModifiedDate_union0_error = (() => {
            if (typeof obj_lastModifiedDate !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union0_error != null) {
            obj_lastModifiedDate_union0 = obj_lastModifiedDate_union0_error.message;
        }
        let obj_lastModifiedDate_union1 = null;
        const obj_lastModifiedDate_union1_error = (() => {
            if (obj_lastModifiedDate !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_lastModifiedDate + '" (at "' + path_lastModifiedDate + '")');
            }
        })();
        if (obj_lastModifiedDate_union1_error != null) {
            obj_lastModifiedDate_union1 = obj_lastModifiedDate_union1_error.message;
        }
        if (obj_lastModifiedDate_union0 && obj_lastModifiedDate_union1) {
            let message = 'Object doesn\'t match union (at "' + path_lastModifiedDate + '")';
            message += '\n' + obj_lastModifiedDate_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_lastModifiedDate_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_recordTypeInfo = obj.recordTypeInfo;
        const path_recordTypeInfo = path + '.recordTypeInfo';
        let obj_recordTypeInfo_union0 = null;
        const obj_recordTypeInfo_union0_error = (() => {
            const referenceRecordTypeInfoRepresentationValidationError = validate$6(obj_recordTypeInfo, path_recordTypeInfo);
            if (referenceRecordTypeInfoRepresentationValidationError !== null) {
                let message = 'Object doesn\'t match RecordTypeInfoRepresentation (at "' + path_recordTypeInfo + '")\n';
                message += referenceRecordTypeInfoRepresentationValidationError.message.split('\n').map((line) => '\t' + line).join('\n');
                return new TypeError(message);
            }
        })();
        if (obj_recordTypeInfo_union0_error != null) {
            obj_recordTypeInfo_union0 = obj_recordTypeInfo_union0_error.message;
        }
        let obj_recordTypeInfo_union1 = null;
        const obj_recordTypeInfo_union1_error = (() => {
            if (obj_recordTypeInfo !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeInfo + '" (at "' + path_recordTypeInfo + '")');
            }
        })();
        if (obj_recordTypeInfo_union1_error != null) {
            obj_recordTypeInfo_union1 = obj_recordTypeInfo_union1_error.message;
        }
        if (obj_recordTypeInfo_union0 && obj_recordTypeInfo_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeInfo + '")';
            message += '\n' + obj_recordTypeInfo_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeInfo_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_systemModstamp = obj.systemModstamp;
        const path_systemModstamp = path + '.systemModstamp';
        let obj_systemModstamp_union0 = null;
        const obj_systemModstamp_union0_error = (() => {
            if (typeof obj_systemModstamp !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union0_error != null) {
            obj_systemModstamp_union0 = obj_systemModstamp_union0_error.message;
        }
        let obj_systemModstamp_union1 = null;
        const obj_systemModstamp_union1_error = (() => {
            if (obj_systemModstamp !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_systemModstamp + '" (at "' + path_systemModstamp + '")');
            }
        })();
        if (obj_systemModstamp_union1_error != null) {
            obj_systemModstamp_union1 = obj_systemModstamp_union1_error.message;
        }
        if (obj_systemModstamp_union0 && obj_systemModstamp_union1) {
            let message = 'Object doesn\'t match union (at "' + path_systemModstamp + '")';
            message += '\n' + obj_systemModstamp_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_systemModstamp_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_eTag = obj.eTag;
        const path_eTag = path + '.eTag';
        if (typeof obj_eTag !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_eTag + '" (at "' + path_eTag + '")');
        }
        const obj_weakEtag = obj.weakEtag;
        const path_weakEtag = path + '.weakEtag';
        if (typeof obj_weakEtag !== 'number' || (typeof obj_weakEtag === 'number' && Math.floor(obj_weakEtag) !== obj_weakEtag)) {
            return new TypeError('Expected "integer" but received "' + typeof obj_weakEtag + '" (at "' + path_weakEtag + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$G(input, existing, path, lds, store, timestamp) {
    const input_childRelationships = input.childRelationships;
    const input_childRelationships_id = path.fullPath + '__childRelationships';
    const input_childRelationships_keys = Object.keys(input_childRelationships);
    const input_childRelationships_length = input_childRelationships_keys.length;
    for (let i = 0; i < input_childRelationships_length; i++) {
        const key = input_childRelationships_keys[i];
        const input_childRelationships_prop = input_childRelationships[key];
        const input_childRelationships_prop_id = input_childRelationships_id + '__' + key;
        input_childRelationships[key] = ingest$2(input_childRelationships_prop, {
            fullPath: input_childRelationships_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_fields = input.fields;
    const input_fields_id = path.fullPath + '__fields';
    const input_fields_keys = Object.keys(input_fields);
    const input_fields_length = input_fields_keys.length;
    for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        const input_fields_prop_id = input_fields_id + '__' + key;
        input_fields[key] = ingest$3(input_fields_prop, {
            fullPath: input_fields_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$N(existing, incoming) {
    const existing_weakEtag = existing.weakEtag;
    const incoming_weakEtag = incoming.weakEtag;
    if (!(existing_weakEtag === incoming_weakEtag)) {
        return false;
    }
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_eTag = existing.eTag;
    const incoming_eTag = incoming.eTag;
    if (!(existing_eTag === incoming_eTag)) {
        return false;
    }
    const existing_childRelationships = existing.childRelationships;
    const incoming_childRelationships = incoming.childRelationships;
    const equals_childRelationships_props = equalsObject(existing_childRelationships, incoming_childRelationships, (existing_childRelationships_prop, incoming_childRelationships_prop) => {
        if (!(existing_childRelationships_prop.__ref === incoming_childRelationships_prop.__ref)) {
            return false;
        }
    });
    if (equals_childRelationships_props === false) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_id = existing.id;
    const incoming_id = incoming.id;
    if (!(existing_id === incoming_id)) {
        return false;
    }
    const existing_lastModifiedById = existing.lastModifiedById;
    const incoming_lastModifiedById = incoming.lastModifiedById;
    if (!(existing_lastModifiedById === incoming_lastModifiedById)) {
        return false;
    }
    const existing_lastModifiedDate = existing.lastModifiedDate;
    const incoming_lastModifiedDate = incoming.lastModifiedDate;
    if (!(existing_lastModifiedDate === incoming_lastModifiedDate)) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    const existing_recordTypeInfo = existing.recordTypeInfo;
    const incoming_recordTypeInfo = incoming.recordTypeInfo;
    if (!(existing_recordTypeInfo === incoming_recordTypeInfo
        || (existing_recordTypeInfo != null &&
            incoming_recordTypeInfo != null &&
            equals$2(existing_recordTypeInfo, incoming_recordTypeInfo)))) {
        return false;
    }
    const existing_systemModstamp = existing.systemModstamp;
    const incoming_systemModstamp = incoming.systemModstamp;
    if (!(existing_systemModstamp === incoming_systemModstamp)) {
        return false;
    }
    return true;
}
const ingest$G = function RecordCreateDefaultRecordRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$1c(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$G(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$N(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

function validate$1d(obj, path = 'RecordDefaultsRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_layout = obj.layout;
        const path_layout = path + '.layout';
        let obj_layout_union0 = null;
        const obj_layout_union0_error = (() => {
            if (typeof obj_layout !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_layout + '" (at "' + path_layout + '")');
            }
        })();
        if (obj_layout_union0_error != null) {
            obj_layout_union0 = obj_layout_union0_error.message;
        }
        let obj_layout_union1 = null;
        const obj_layout_union1_error = (() => {
            if (obj_layout !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_layout + '" (at "' + path_layout + '")');
            }
        })();
        if (obj_layout_union1_error != null) {
            obj_layout_union1 = obj_layout_union1_error.message;
        }
        if (obj_layout_union0 && obj_layout_union1) {
            let message = 'Object doesn\'t match union (at "' + path_layout + '")';
            message += '\n' + obj_layout_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_layout_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$H(input, existing, path, lds, store, timestamp) {
    const input_layout = input.layout;
    const input_layout_id = path.fullPath + '__layout';
    if (input_layout !== null && typeof input_layout === 'object') {
        input.layout = ingest$9(input_layout, {
            fullPath: input_layout_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_objectInfos = input.objectInfos;
    const input_objectInfos_id = path.fullPath + '__objectInfos';
    const input_objectInfos_keys = Object.keys(input_objectInfos);
    const input_objectInfos_length = input_objectInfos_keys.length;
    for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$8(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_record = input.record;
    const input_record_id = path.fullPath + '__record';
    input.record = ingest$G(input_record, {
        fullPath: input_record_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$O(existing, incoming) {
    const existing_layout = existing.layout;
    const incoming_layout = incoming.layout;
    if (!(existing_layout === incoming_layout
        || (existing_layout != null &&
            incoming_layout != null &&
            existing_layout.__ref != null &&
            incoming_layout.__ref != null &&
            existing_layout.__ref === incoming_layout.__ref))) {
        return false;
    }
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_record = existing.record;
    const incoming_record = incoming.record;
    if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
    }
    return true;
}
const ingest$H = function RecordDefaultsRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$1d(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$H(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$O(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function keyBuilder$H(params) {
    return keyPrefix + 'RecordDefaultsRepresentation(' + 'formFactor:' + params.queryParams.formFactor + ',' + 'optionalFields:' + params.queryParams.optionalFields + ',' + 'recordTypeId:' + params.queryParams.recordTypeId + ',' + 'objectApiName:' + params.urlParams.objectApiName + ')';
}
function createResourceRequest$C(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/record-defaults/create/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$H,
        headers,
    };
}

const getRecordCreateDefaults_ConfigPropertyNames = {
    displayName: 'getRecordCreateDefaults',
    parameters: {
        required: ['objectApiName'],
        optional: ['formFactor', 'optionalFields', 'recordTypeId']
    }
};
function createResourceParams$n(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            formFactor: config.formFactor, optionalFields: config.optionalFields, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$m(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const formFactor = coerceFormFactor(config.formFactor);
    if (formFactor !== undefined) {
        coercedConfig.formFactor = formFactor;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const recordTypeId = getRecordId18(config.recordTypeId);
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$w(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_formFactor = untrustedConfig.formFactor;
    if (typeof untrustedConfig_formFactor === 'string') {
        config.formFactor = untrustedConfig_formFactor;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$w(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$m(untrustedConfig);
    const config = typeCheckConfig$w(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const layoutSelections$3 = select$9();
const objectInfoSelections = select$7();
function buildSelector(resp) {
    const recordSelections = buildSelectionFromRecord(resp.record);
    return [
        {
            kind: 'Link',
            name: 'layout',
            nullable: true,
            fragment: layoutSelections$3,
        },
        {
            kind: 'Link',
            name: 'objectInfos',
            map: true,
            fragment: objectInfoSelections,
        },
        {
            kind: 'Link',
            name: 'record',
            fragment: {
                kind: 'Fragment',
                private: [],
                selections: recordSelections,
            },
        },
    ];
}
function buildSnapshotRefresh$9(lds, config) {
    return {
        config,
        resolve: () => buildNetworkSnapshot$s(lds, config),
    };
}
function buildNetworkSnapshot$s(lds, config) {
    const params = createResourceParams$n(config);
    const request = createResourceRequest$C(params);
    const key = keyBuilder$H(params);
    const selectorKey = `${key}__selector`;
    return lds.dispatchResourceRequest(request).then(response => {
        const { body } = response;
        const cacheSelector = {
            recordId: key,
            node: {
                kind: 'Fragment',
                private: [],
                selections: buildSelector(body),
            },
            variables: {},
        };
        lds.storePublish(selectorKey, cacheSelector);
        lds.storeIngest(key, request, body);
        lds.storeBroadcast();
        return lds.storeLookup(cacheSelector, buildSnapshotRefresh$9(lds, config));
    }, (err) => {
        lds.storeIngestFetchResponse(key, err);
        lds.storeBroadcast();
        return lds.errorSnapshot(err, buildSnapshotRefresh$9(lds, config));
    });
}
function coerceConfigWithDefaults$5(untrusted) {
    const config = validateAdapterConfig$w(untrusted, getRecordCreateDefaults_ConfigPropertyNames);
    if (config === null) {
        return null;
    }
    let formFactor = config.formFactor;
    if (formFactor === undefined) {
        if (untrusted.formFactor === undefined) {
            formFactor = FormFactor.Large;
        }
        else {
            return null;
        }
    }
    const recordTypeId = config.recordTypeId === undefined ? MASTER_RECORD_TYPE_ID : config.recordTypeId;
    const optionalFields = config.optionalFields === undefined ? [] : config.optionalFields;
    return {
        ...config,
        formFactor,
        recordTypeId,
        optionalFields,
    };
}
function buildInMemorySnapshot$s(lds, config) {
    const params = createResourceParams$n(config);
    const key = keyBuilder$H(params);
    const selectorKey = `${key}__selector`;
    /**
     * getRecordCreateDefaults returns a value that includes a map of ObjectInfos,
     * a layout and a record. The returned record includes fields that are not
     * known to the client. Because we don't know what the return shape will be,
     * we have to store a selector from a previous response and see if we can
     * extract those values back out.
     *
     * cacheSnapshot is the cached selector from a previous request. It is just
     * a stashed selector
     */
    const cacheSnapshot = lds.storeLookup({
        recordId: selectorKey,
        node: {
            kind: 'Fragment',
            private: [],
            opaque: true,
        },
        variables: {},
    });
    // We've seen this request before
    if (isFulfilledSnapshot(cacheSnapshot)) {
        const snapshot = lds.storeLookup(cacheSnapshot.data, buildSnapshotRefresh$9(lds, config));
        // Cache hit
        if (lds.snapshotDataAvailable(snapshot)) {
            return snapshot;
        }
    }
    return null;
}
const factory$d = (lds) => function getRecordCreateDefaults(untrusted) {
    const config = coerceConfigWithDefaults$5(untrusted);
    if (config === null) {
        return null;
    }
    const snapshot = buildInMemorySnapshot$s(lds, config);
    if (snapshot !== null) {
        return snapshot;
    }
    return buildNetworkSnapshot$s(lds, config);
};

function validate$1e(obj, path = 'CloneRecordTemplateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$I(input, existing, path, lds, store, timestamp) {
    const input_fields = input.fields;
    const input_fields_id = path.fullPath + '__fields';
    const input_fields_keys = Object.keys(input_fields);
    const input_fields_length = input_fields_keys.length;
    for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        const input_fields_prop_id = input_fields_id + '__' + key;
        input_fields[key] = ingest$3(input_fields_prop, {
            fullPath: input_fields_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$P(existing, incoming) {
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
const ingest$I = function CloneRecordTemplateRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$1e(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$I(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$P(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    return createLink(key);
};

const TTL$9 = 1000;
function validate$1f(obj, path = 'CloneTemplateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function normalize$J(input, existing, path, lds, store, timestamp) {
    const input_objectInfos = input.objectInfos;
    const input_objectInfos_id = path.fullPath + '__objectInfos';
    const input_objectInfos_keys = Object.keys(input_objectInfos);
    const input_objectInfos_length = input_objectInfos_keys.length;
    for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$8(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_record = input.record;
    const input_record_id = path.fullPath + '__record';
    input.record = ingest$I(input_record, {
        fullPath: input_record_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$Q(existing, incoming) {
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_record = existing.record;
    const incoming_record = incoming.record;
    if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
    }
    return true;
}
const ingest$J = function CloneTemplateRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$1f(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = path.fullPath;
    let incomingRecord = normalize$J(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$Q(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 1000);
    return createLink(key);
};

function createResourceRequest$D(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/record-defaults/template/clone/' + config.urlParams.recordId + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$J,
        headers,
    };
}

const topLevelTemplateRecordProperties = {
    [API_NAME_SELECTION.name]: true,
    [RECORD_TYPE_ID_SELECTION.name]: true,
    [FIELDS_SELECTION.name]: true,
};
/**
 * Convert a RecordCreateDefaultTemplateRecordRepresentation into its equivalent selection.
 */
function buildSelectionFromFields$1(optionalFields) {
    return filter.call(buildSelectionFromFields([], optionalFields), function (pathSelection) {
        return topLevelTemplateRecordProperties[pathSelection.name] === true;
    });
}

const select$_ = (lds, params) => {
    const objectInfoSelections = select$7();
    let { optionalFields } = params.queryParams;
    optionalFields =
        optionalFields === undefined ? ['.CloneSourceId'] : [...optionalFields, '.CloneSourceId'];
    const recordSelections = buildSelectionFromFields$1(optionalFields);
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                kind: 'Link',
                name: 'objectInfos',
                map: true,
                fragment: objectInfoSelections,
            },
            {
                kind: 'Link',
                name: 'record',
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: recordSelections,
                },
            },
        ],
    };
};

const getRecordTemplateClone_ConfigPropertyNames = {
    displayName: 'getRecordTemplateClone',
    parameters: {
        required: ['recordId'],
        optional: ['optionalFields', 'recordTypeId']
    }
};
function createResourceParams$o(config) {
    return {
        urlParams: {
            recordId: config.recordId
        },
        queryParams: {
            optionalFields: config.optionalFields, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$n(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const recordTypeId = config.recordTypeId;
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$x(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$x(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$n(untrustedConfig);
    const config = typeCheckConfig$x(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function extractTrackedFields$1(node, parentFieldName, fieldsList = []) {
    // Filter Error and null nodes
    if (!isGraphNode(node)) {
        return [];
    }
    const fields = node.object('fields');
    const keys = fields.keys();
    for (let i = 0, len = keys.length; i < len; i += 1) {
        const key = keys[i];
        const fieldValueRep = fields.link(key);
        const fieldName = `${parentFieldName}.${key}`;
        if (fieldValueRep.isMissing()) {
            push.call(fieldsList, fieldName);
            continue;
        }
        const field = fieldValueRep.follow();
        // Filter Error and null nodes
        if (!isGraphNode(field)) {
            continue;
        }
        if (field.isScalar('value') === false) {
            const spanning = field
                .link('value')
                .follow();
            extractTrackedFields(spanning, fieldName, fieldsList, {}, MAX_RECORD_DEPTH // Only get tracked fields 1 level deep
            );
        }
        else {
            const state = fieldValueRep.linkData();
            if (state !== undefined) {
                const { fields } = state;
                for (let s = 0, len = fields.length; s < len; s += 1) {
                    const childFieldName = fields[s];
                    push.call(fieldsList, `${fieldName}.${childFieldName}`);
                }
            }
            else {
                push.call(fieldsList, fieldName);
            }
        }
    }
    return fieldsList;
}
function getTrackedFields$1(lds, key, fieldsFromConfig) {
    const fieldsList = fieldsFromConfig === undefined ? [] : [...fieldsFromConfig];
    const graphNode = lds.getNode(key);
    if (!isGraphNode(graphNode)) {
        return fieldsList;
    }
    const fileName = graphNode.scalar('apiName');
    const fields = extractTrackedFields$1(graphNode, fileName, fieldsList);
    return dedupe(fields).sort();
}

function keyBuilder$I(config) {
    return (keyPrefix +
        'CloneTemplateRepresentation:' +
        config.cloneSourceId +
        ':' +
        (config.recordTypeId === null ? '' : config.recordTypeId));
}
function keyBuilderFromType$l(object) {
    let value = object.record &&
        object.record.fields &&
        object.record.fields.CloneSourceId &&
        object.record.fields.CloneSourceId.value;
    if (typeof value !== 'string') {
        if (process.env.NODE_ENV !== 'production') {
            throw new Error('Invalid type. Expected "CloneSourceId" to be type "string" but got : ' + value);
        }
        else {
            value = '';
        }
    }
    const keyParams = {
        cloneSourceId: value,
        recordTypeId: object.record.recordTypeId,
    };
    return keyBuilder$I(keyParams);
}

function keyBuilder$J(config) {
    return (keyPrefix +
        'CloneTemplateRepresentation:' +
        config.cloneSourceId +
        ':' +
        (config.recordTypeId === null ? '' : config.recordTypeId) +
        '__record');
}

const METADATA_PREFIX = 'METADATA::';
function buildMetadataKey(recordId) {
    return `${METADATA_PREFIX}${keyPrefix}CloneTemplateRepresentation::${recordId}`;
}
function getMetadata(lds, recordId) {
    const metadataKey = buildMetadataKey(recordId);
    return lds.storeLookup({
        recordId: metadataKey,
        node: {
            kind: 'Fragment',
            private: [],
            selections: [
                {
                    name: 'recordTypeId',
                    kind: 'Scalar',
                },
            ],
        },
        variables: {},
    });
}
function saveDefaultRecordTypeId(lds, recordId, objectInfo) {
    const metadataKey = buildMetadataKey(recordId);
    lds.storePublish(metadataKey, {
        recordTypeId: objectInfo.defaultRecordTypeId,
    });
}
function getRecordTypeId$1(lds, adapterConfig) {
    const config = createResourceParams$o(adapterConfig);
    const { recordTypeId } = config.queryParams;
    if (recordTypeId !== undefined && recordTypeId !== null) {
        return recordTypeId;
    }
    const metadataSnapshot = getMetadata(lds, config.urlParams.recordId);
    if (isFulfilledSnapshot(metadataSnapshot)) {
        const { recordTypeId } = metadataSnapshot.data;
        if (recordTypeId === null) {
            return undefined;
        }
        return recordTypeId;
    }
    return undefined;
}
const buildNetworkSnapshot$t = (lds, config, override) => {
    const resourceParams = createResourceParams$o(config);
    const recordTypeId = getRecordTypeId$1(lds, config);
    const { recordId } = config;
    const resourceRequest = createResourceRequest$D(resourceParams);
    const request = recordTypeId === undefined
        ? resourceRequest
        : createResourceRequest$D({
            ...resourceParams,
            queryParams: {
                ...resourceRequest.queryParams,
                optionalFields: getTrackedFields$1(lds, keyBuilder$J({
                    cloneSourceId: recordId,
                    recordTypeId: recordTypeId,
                }), config.optionalFields),
            },
        });
    return lds.dispatchResourceRequest(request, override).then(response => {
        const { body } = response;
        const key = keyBuilderFromType$l(body);
        const responseRecordTypeId = body.record.recordTypeId;
        const objectApiName = body.record.apiName;
        // publish metadata for recordTypeId
        saveDefaultRecordTypeId(lds, recordId, body.objectInfos[objectApiName]);
        lds.storeIngest(key, request, body);
        // mark missing optionalFields
        const templateRecordKey = keyBuilder$J({
            cloneSourceId: resourceParams.urlParams.recordId,
            recordTypeId: responseRecordTypeId,
        });
        const recordNode = lds.getNode(templateRecordKey);
        const allTrackedFields = getTrackedFields$1(lds, templateRecordKey, resourceParams.queryParams.optionalFields);
        markMissingOptionalFields(recordNode, allTrackedFields);
        lds.storeBroadcast();
        const snapshot = buildInMemorySnapshot$t(lds, {
            ...config,
            recordTypeId: responseRecordTypeId,
        });
        if (process.env.NODE_ENV !== 'production') {
            if (snapshot.state !== 'Fulfilled') {
                throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
            }
        }
        return snapshot;
    }, (response) => {
        const key = keyBuilder$I({
            cloneSourceId: config.recordId,
            recordTypeId: config.recordTypeId || null,
        });
        lds.storeIngestFetchResponse(key, response, TTL$9);
        return lds.errorSnapshot(response, {
            config,
            resolve: () => buildNetworkSnapshot$t(lds, config, snapshotRefreshOptions),
        });
    });
};
const buildInMemorySnapshot$t = (lds, config) => {
    const resourceParams = createResourceParams$o(config);
    const key = keyBuilder$I({
        cloneSourceId: config.recordId,
        recordTypeId: config.recordTypeId || null,
    });
    const selector = {
        recordId: key,
        node: select$_(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$t(lds, config, snapshotRefreshOptions),
    });
};
const factory$e = (lds) => function getRecordDefaultsTemplateForCreate(untrustedConfig) {
    const config = validateAdapterConfig$x(untrustedConfig, getRecordTemplateClone_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const recordTypeId = getRecordTypeId$1(lds, config);
    const cacheSnapshot = buildInMemorySnapshot$t(lds, {
        ...config,
        recordTypeId,
    });
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    return buildNetworkSnapshot$t(lds, config);
};

function validate$1g(obj, path = 'CreateRecordTemplateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_apiName = obj.apiName;
        const path_apiName = path + '.apiName';
        if (typeof obj_apiName !== 'string') {
            return new TypeError('Expected "string" but received "' + typeof obj_apiName + '" (at "' + path_apiName + '")');
        }
        const obj_fields = obj.fields;
        const path_fields = path + '.fields';
        if (typeof obj_fields !== 'object' || ArrayIsArray$1(obj_fields) || obj_fields === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_fields + '" (at "' + path_fields + '")');
        }
        const obj_fields_keys = ObjectKeys$1(obj_fields);
        for (let i = 0; i < obj_fields_keys.length; i++) {
            const key = obj_fields_keys[i];
            const obj_fields_prop = obj_fields[key];
            const path_fields_prop = path_fields + '["' + key + '"]';
            if (typeof obj_fields_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_fields_prop + '" (at "' + path_fields_prop + '")');
            }
        }
        const obj_recordTypeId = obj.recordTypeId;
        const path_recordTypeId = path + '.recordTypeId';
        let obj_recordTypeId_union0 = null;
        const obj_recordTypeId_union0_error = (() => {
            if (typeof obj_recordTypeId !== 'string') {
                return new TypeError('Expected "string" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union0_error != null) {
            obj_recordTypeId_union0 = obj_recordTypeId_union0_error.message;
        }
        let obj_recordTypeId_union1 = null;
        const obj_recordTypeId_union1_error = (() => {
            if (obj_recordTypeId !== null) {
                return new TypeError('Expected "null" but received "' + typeof obj_recordTypeId + '" (at "' + path_recordTypeId + '")');
            }
        })();
        if (obj_recordTypeId_union1_error != null) {
            obj_recordTypeId_union1 = obj_recordTypeId_union1_error.message;
        }
        if (obj_recordTypeId_union0 && obj_recordTypeId_union1) {
            let message = 'Object doesn\'t match union (at "' + path_recordTypeId + '")';
            message += '\n' + obj_recordTypeId_union0.split('\n').map((line) => '\t' + line).join('\n');
            message += '\n' + obj_recordTypeId_union1.split('\n').map((line) => '\t' + line).join('\n');
            return new TypeError(message);
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$K(config) {
    return keyPrefix + 'CreateRecordTemplateRepresentation:' + config.apiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$m(object) {
    const keyParams = {
        apiName: object.apiName,
        recordTypeId: object.recordTypeId
    };
    return keyBuilder$K(keyParams);
}
function normalize$K(input, existing, path, lds, store, timestamp) {
    const input_fields = input.fields;
    const input_fields_id = path.fullPath + '__fields';
    const input_fields_keys = Object.keys(input_fields);
    const input_fields_length = input_fields_keys.length;
    for (let i = 0; i < input_fields_length; i++) {
        const key = input_fields_keys[i];
        const input_fields_prop = input_fields[key];
        const input_fields_prop_id = input_fields_id + '__' + key;
        input_fields[key] = ingest$3(input_fields_prop, {
            fullPath: input_fields_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    return input;
}
function equals$R(existing, incoming) {
    const existing_apiName = existing.apiName;
    const incoming_apiName = incoming.apiName;
    if (!(existing_apiName === incoming_apiName)) {
        return false;
    }
    const existing_fields = existing.fields;
    const incoming_fields = incoming.fields;
    const equals_fields_props = equalsObject(existing_fields, incoming_fields, (existing_fields_prop, incoming_fields_prop) => {
        if (!(existing_fields_prop.__ref === incoming_fields_prop.__ref)) {
            return false;
        }
    });
    if (equals_fields_props === false) {
        return false;
    }
    const existing_recordTypeId = existing.recordTypeId;
    const incoming_recordTypeId = incoming.recordTypeId;
    if (!(existing_recordTypeId === incoming_recordTypeId)) {
        return false;
    }
    return true;
}
const ingest$K = function CreateRecordTemplateRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$1g(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$m(input);
    let incomingRecord = normalize$K(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$R(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 30000);
    return createLink(key);
};

const TTL$a = 900000;
function validate$1h(obj, path = 'CreateTemplateRepresentation') {
    const v_error = (() => {
        if (typeof obj !== 'object' || ArrayIsArray$1(obj) || obj === null) {
            return new TypeError('Expected "object" but received "' + typeof obj + '" (at "' + path + '")');
        }
        const obj_objectInfos = obj.objectInfos;
        const path_objectInfos = path + '.objectInfos';
        if (typeof obj_objectInfos !== 'object' || ArrayIsArray$1(obj_objectInfos) || obj_objectInfos === null) {
            return new TypeError('Expected "object" but received "' + typeof obj_objectInfos + '" (at "' + path_objectInfos + '")');
        }
        const obj_objectInfos_keys = ObjectKeys$1(obj_objectInfos);
        for (let i = 0; i < obj_objectInfos_keys.length; i++) {
            const key = obj_objectInfos_keys[i];
            const obj_objectInfos_prop = obj_objectInfos[key];
            const path_objectInfos_prop = path_objectInfos + '["' + key + '"]';
            if (typeof obj_objectInfos_prop !== 'object') {
                return new TypeError('Expected "object" but received "' + typeof obj_objectInfos_prop + '" (at "' + path_objectInfos_prop + '")');
            }
        }
        const obj_record = obj.record;
        const path_record = path + '.record';
        if (typeof obj_record !== 'object') {
            return new TypeError('Expected "object" but received "' + typeof obj_record + '" (at "' + path_record + '")');
        }
    })();
    return v_error === undefined ? null : v_error;
}
function keyBuilder$L(config) {
    return keyPrefix + 'CreateTemplateRepresentation:' + config.objectApiName + ':' + (config.recordTypeId === null ? '' : config.recordTypeId);
}
function keyBuilderFromType$n(object) {
    const keyParams = {
        objectApiName: object.record.apiName,
        recordTypeId: object.record.recordTypeId
    };
    return keyBuilder$L(keyParams);
}
function normalize$L(input, existing, path, lds, store, timestamp) {
    const input_objectInfos = input.objectInfos;
    const input_objectInfos_id = path.fullPath + '__objectInfos';
    const input_objectInfos_keys = Object.keys(input_objectInfos);
    const input_objectInfos_length = input_objectInfos_keys.length;
    for (let i = 0; i < input_objectInfos_length; i++) {
        const key = input_objectInfos_keys[i];
        const input_objectInfos_prop = input_objectInfos[key];
        const input_objectInfos_prop_id = input_objectInfos_id + '__' + key;
        input_objectInfos[key] = ingest$8(input_objectInfos_prop, {
            fullPath: input_objectInfos_prop_id,
            parent: {
                data: input,
                key: path.fullPath,
                existing: existing,
            }
        }, lds, store, timestamp);
    }
    const input_record = input.record;
    const input_record_id = path.fullPath + '__record';
    input.record = ingest$K(input_record, {
        fullPath: input_record_id,
        parent: {
            data: input,
            key: path.fullPath,
            existing: existing,
        }
    }, lds, store, timestamp);
    return input;
}
function equals$S(existing, incoming) {
    const existing_objectInfos = existing.objectInfos;
    const incoming_objectInfos = incoming.objectInfos;
    const equals_objectInfos_props = equalsObject(existing_objectInfos, incoming_objectInfos, (existing_objectInfos_prop, incoming_objectInfos_prop) => {
        if (!(existing_objectInfos_prop.__ref === incoming_objectInfos_prop.__ref)) {
            return false;
        }
    });
    if (equals_objectInfos_props === false) {
        return false;
    }
    const existing_record = existing.record;
    const incoming_record = incoming.record;
    if (!(existing_record.__ref === incoming_record.__ref)) {
        return false;
    }
    return true;
}
const ingest$L = function CreateTemplateRepresentationIngest(input, path, lds, store, timestamp) {
    if (process.env.NODE_ENV !== 'production') {
        const validateError = validate$1h(input);
        if (validateError !== null) {
            throw validateError;
        }
    }
    const key = keyBuilderFromType$n(input);
    let incomingRecord = normalize$L(input, store.records[key], {
        fullPath: key,
        parent: path.parent
    }, lds, store, timestamp);
    const existingRecord = store.records[key];
    if (existingRecord === undefined || equals$S(existingRecord, incomingRecord) === false) {
        lds.storePublish(key, incomingRecord);
    }
    lds.storeSetExpiration(key, timestamp + 900000);
    return createLink(key);
};

function keyBuilder$M(params) {
    return keyBuilder$L({
        objectApiName: params.urlParams.objectApiName,
        recordTypeId: params.queryParams.recordTypeId || null
    });
}
function ingestError$j(lds, params, error, snapshotRefresh) {
    const key = keyBuilder$M(params);
    lds.storeIngestFetchResponse(key, error, TTL$a);
    return lds.errorSnapshot(error, snapshotRefresh);
}
function createResourceRequest$E(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/record-defaults/template/create/' + config.urlParams.objectApiName + '',
        method: 'get',
        body: null,
        urlParams: config.urlParams,
        queryParams: config.queryParams,
        ingest: ingest$L,
        headers,
    };
}

const select$$ = (lds, params) => {
    const objectInfoSelections = select$7();
    let { optionalFields } = params.queryParams;
    optionalFields = optionalFields === undefined ? [] : optionalFields;
    const recordSelections = buildSelectionFromFields$1(optionalFields);
    return {
        kind: 'Fragment',
        private: [],
        selections: [
            {
                kind: 'Link',
                name: 'objectInfos',
                map: true,
                fragment: objectInfoSelections,
            },
            {
                kind: 'Link',
                name: 'record',
                fragment: {
                    kind: 'Fragment',
                    private: [],
                    selections: recordSelections,
                },
            },
        ],
    };
};

const getRecordTemplateCreate_ConfigPropertyNames = {
    displayName: 'getRecordTemplateCreate',
    parameters: {
        required: ['objectApiName'],
        optional: ['optionalFields', 'recordTypeId']
    }
};
function createResourceParams$p(config) {
    return {
        urlParams: {
            objectApiName: config.objectApiName
        },
        queryParams: {
            optionalFields: config.optionalFields, recordTypeId: config.recordTypeId
        }
    };
}
function coerceConfig$o(config) {
    const coercedConfig = {};
    const objectApiName = getObjectApiName(config.objectApiName);
    if (objectApiName !== undefined) {
        coercedConfig.objectApiName = objectApiName;
    }
    const optionalFields = getFieldApiNamesArray(config.optionalFields);
    if (optionalFields !== undefined) {
        coercedConfig.optionalFields = optionalFields;
    }
    const recordTypeId = config.recordTypeId;
    if (recordTypeId !== undefined) {
        coercedConfig.recordTypeId = recordTypeId;
    }
    return coercedConfig;
}
function typeCheckConfig$y(untrustedConfig) {
    const config = {};
    const untrustedConfig_objectApiName = untrustedConfig.objectApiName;
    if (typeof untrustedConfig_objectApiName === 'string') {
        config.objectApiName = untrustedConfig_objectApiName;
    }
    const untrustedConfig_optionalFields = untrustedConfig.optionalFields;
    if (ArrayIsArray(untrustedConfig_optionalFields)) {
        const untrustedConfig_optionalFields_array = [];
        for (let i = 0, arrayLength = untrustedConfig_optionalFields.length; i < arrayLength; i++) {
            const untrustedConfig_optionalFields_item = untrustedConfig_optionalFields[i];
            if (typeof untrustedConfig_optionalFields_item === 'string') {
                untrustedConfig_optionalFields_array.push(untrustedConfig_optionalFields_item);
            }
        }
        config.optionalFields = untrustedConfig_optionalFields_array;
    }
    const untrustedConfig_recordTypeId = untrustedConfig.recordTypeId;
    if (typeof untrustedConfig_recordTypeId === 'string') {
        config.recordTypeId = untrustedConfig_recordTypeId;
    }
    return config;
}
function validateAdapterConfig$y(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$o(untrustedConfig);
    const config = typeCheckConfig$y(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

const METADATA_PREFIX$1 = 'METADATA::';
function buildMetadataKey$1(objectApiName) {
    return `${METADATA_PREFIX$1}${keyPrefix}CreateTemplateRepresentation::${objectApiName}`;
}
function getMetadata$1(lds, objectApiName) {
    const metadataKey = buildMetadataKey$1(objectApiName);
    return lds.storeLookup({
        recordId: metadataKey,
        node: {
            kind: 'Fragment',
            private: [],
            selections: [
                {
                    name: 'recordTypeId',
                    kind: 'Scalar',
                },
            ],
        },
        variables: {},
    });
}
function saveDefaultRecordTypeId$1(lds, objectApiName, objectInfo) {
    const metadataKey = buildMetadataKey$1(objectApiName);
    lds.storePublish(metadataKey, {
        recordTypeId: objectInfo.defaultRecordTypeId,
    });
}
function getRecordTypeId$2(lds, adapterConfig) {
    const config = createResourceParams$p(adapterConfig);
    const { recordTypeId } = config.queryParams;
    if (recordTypeId !== undefined && recordTypeId !== null) {
        return recordTypeId;
    }
    const metadataSnapshot = getMetadata$1(lds, config.urlParams.objectApiName);
    if (isFulfilledSnapshot(metadataSnapshot)) {
        const { recordTypeId } = metadataSnapshot.data;
        if (recordTypeId === null) {
            return undefined;
        }
        return recordTypeId;
    }
    return undefined;
}
const buildNetworkSnapshot$u = (lds, config, override) => {
    const resourceParams = createResourceParams$p(config);
    const recordTypeId = getRecordTypeId$2(lds, config);
    const { objectApiName } = config;
    const resourceRequest = createResourceRequest$E(resourceParams);
    const request = recordTypeId === undefined
        ? resourceRequest
        : createResourceRequest$E({
            ...resourceParams,
            queryParams: {
                ...resourceRequest.queryParams,
                optionalFields: getTrackedFields$1(lds, keyBuilder$K({
                    apiName: objectApiName,
                    recordTypeId: recordTypeId,
                }), config.optionalFields),
            },
        });
    return lds.dispatchResourceRequest(request, override).then(response => {
        const { body } = response;
        const key = keyBuilderFromType$n(body);
        const responseRecordTypeId = body.record.recordTypeId;
        // publish metadata for recordTypeId
        saveDefaultRecordTypeId$1(lds, objectApiName, body.objectInfos[objectApiName]);
        lds.storeIngest(key, request, body);
        // mark missing optionalFields
        const templateRecordKey = keyBuilder$K({
            apiName: resourceParams.urlParams.objectApiName,
            recordTypeId: responseRecordTypeId,
        });
        const recordNode = lds.getNode(templateRecordKey);
        const allTrackedFields = getTrackedFields$1(lds, templateRecordKey, resourceParams.queryParams.optionalFields);
        markMissingOptionalFields(recordNode, allTrackedFields);
        lds.storeBroadcast();
        const snapshot = buildInMemorySnapshot$u(lds, {
            ...config,
            recordTypeId: responseRecordTypeId,
        });
        if (process.env.NODE_ENV !== 'production') {
            if (snapshot.state !== 'Fulfilled') {
                throw new Error('Invalid network response. Expected network response to result in Fulfilled snapshot');
            }
        }
        return snapshot;
    }, (response) => {
        const snapshot = ingestError$j(lds, resourceParams, response, {
            config,
            resolve: () => buildNetworkSnapshot$u(lds, config, snapshotRefreshOptions),
        });
        lds.storeBroadcast();
        return snapshot;
    });
};
const buildInMemorySnapshot$u = (lds, config) => {
    const resourceParams = createResourceParams$p(config);
    const selector = {
        recordId: keyBuilder$M(resourceParams),
        node: select$$(lds, resourceParams),
        variables: {},
    };
    return lds.storeLookup(selector, {
        config,
        resolve: () => buildNetworkSnapshot$u(lds, config, snapshotRefreshOptions),
    });
};
const factory$f = (lds) => function getRecordDefaultsTemplateForCreate(untrustedConfig) {
    const config = validateAdapterConfig$y(untrustedConfig, getRecordTemplateCreate_ConfigPropertyNames);
    // Invalid or incomplete config
    if (config === null) {
        return null;
    }
    const recordTypeId = getRecordTypeId$2(lds, config);
    const cacheSnapshot = buildInMemorySnapshot$u(lds, {
        ...config,
        recordTypeId,
    });
    // Cache Hit
    if (lds.snapshotDataAvailable(cacheSnapshot) === true) {
        return cacheSnapshot;
    }
    return buildNetworkSnapshot$u(lds, config);
};

function createResourceRequest$F(config) {
    const headers = {};
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/records',
        method: 'post',
        body: config.body,
        urlParams: {},
        queryParams: {},
        ingest: ingest$4,
        headers,
    };
}

const factory$g = (lds) => {
    return function (config) {
        const request = createResourceRequest$F({
            body: config,
        });
        return lds.dispatchResourceRequest(request).then(response => {
            const { body } = response;
            const selections = buildSelectionFromRecord(body);
            const key = keyBuilder$2({
                recordId: body.id,
            });
            lds.storeIngest(key, request, body);
            lds.storeBroadcast();
            return lds.storeLookup({
                recordId: key,
                node: {
                    kind: 'Fragment',
                    private: [],
                    selections,
                },
                variables: {},
            });
        }, (err) => {
            deepFreeze$s(err);
            throw err;
        });
    };
};

function createResourceRequest$G(config) {
    const headers = {};
    const header_ifUnmodifiedSince = config.headers.ifUnmodifiedSince;
    if (header_ifUnmodifiedSince !== undefined) {
        headers['If-Unmodified-Since'] = header_ifUnmodifiedSince;
    }
    return {
        baseUri: '/services/data/v50.0',
        basePath: '/ui-api/records/' + config.urlParams.recordId + '',
        method: 'patch',
        body: config.body,
        urlParams: config.urlParams,
        queryParams: {},
        ingest: ingest$4,
        headers,
    };
}

const updateRecord_ConfigPropertyNames = {
    displayName: 'updateRecord',
    parameters: {
        required: ['recordId', 'fields'],
        optional: ['allowSaveOnDuplicate', 'apiName', 'ifUnmodifiedSince']
    }
};
function coerceConfig$p(config) {
    const coercedConfig = {};
    const recordId = getRecordId18(config.recordId);
    if (recordId !== undefined) {
        coercedConfig.recordId = recordId;
    }
    const allowSaveOnDuplicate = config.allowSaveOnDuplicate;
    if (allowSaveOnDuplicate !== undefined) {
        coercedConfig.allowSaveOnDuplicate = allowSaveOnDuplicate;
    }
    const apiName = config.apiName;
    if (apiName !== undefined) {
        coercedConfig.apiName = apiName;
    }
    const fields = config.fields;
    if (fields !== undefined) {
        coercedConfig.fields = fields;
    }
    const ifUnmodifiedSince = config.ifUnmodifiedSince;
    if (ifUnmodifiedSince !== undefined) {
        coercedConfig.ifUnmodifiedSince = ifUnmodifiedSince;
    }
    return coercedConfig;
}
function typeCheckConfig$z(untrustedConfig) {
    const config = {};
    const untrustedConfig_recordId = untrustedConfig.recordId;
    if (typeof untrustedConfig_recordId === 'string') {
        config.recordId = untrustedConfig_recordId;
    }
    const untrustedConfig_allowSaveOnDuplicate = untrustedConfig.allowSaveOnDuplicate;
    if (typeof untrustedConfig_allowSaveOnDuplicate === 'boolean') {
        config.allowSaveOnDuplicate = untrustedConfig_allowSaveOnDuplicate;
    }
    const untrustedConfig_apiName = untrustedConfig.apiName;
    if (typeof untrustedConfig_apiName === 'string') {
        config.apiName = untrustedConfig_apiName;
    }
    const untrustedConfig_fields = untrustedConfig.fields;
    if (untrustedIsObject(untrustedConfig_fields)) {
        const untrustedConfig_fields_object = {};
        const untrustedConfig_fields_keys = Object.keys(untrustedConfig_fields);
        for (let i = 0, arrayLength = untrustedConfig_fields_keys.length; i < arrayLength; i++) {
            const key = untrustedConfig_fields_keys[i];
            const untrustedConfig_fields_prop = untrustedConfig_fields[key];
            if (typeof untrustedConfig_fields_prop === 'string') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'number') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (untrustedConfig_fields_prop === null) {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
            if (typeof untrustedConfig_fields_prop === 'boolean') {
                untrustedConfig_fields_object[key] = untrustedConfig_fields_prop;
            }
        }
        if (Object.keys(untrustedConfig_fields_object).length >= 0) {
            config.fields = untrustedConfig_fields_object;
        }
    }
    const untrustedConfig_ifUnmodifiedSince = untrustedConfig.ifUnmodifiedSince;
    if (typeof untrustedConfig_ifUnmodifiedSince === 'string') {
        config.ifUnmodifiedSince = untrustedConfig_ifUnmodifiedSince;
    }
    return config;
}
function validateAdapterConfig$z(untrustedConfig, configPropertyNames) {
    if (!untrustedIsObject(untrustedConfig)) {
        return null;
    }
    if (process.env.NODE_ENV !== 'production') {
        validateConfig(untrustedConfig, configPropertyNames);
    }
    const coercedConfig = coerceConfig$p(untrustedConfig);
    const config = typeCheckConfig$z(coercedConfig);
    if (!areRequiredParametersPresent(config, configPropertyNames)) {
        return null;
    }
    return config;
}

function getHeaders(clientOptions) {
    const headers = {};
    if (untrustedIsObject(clientOptions)) {
        if (typeof clientOptions.ifUnmodifiedSince === 'string') {
            headers.ifUnmodifiedSince = clientOptions.ifUnmodifiedSince;
        }
    }
    return headers;
}
const factory$h = (lds) => {
    return (untrusted, clientOptions) => {
        let config = null;
        if (untrustedIsObject(untrusted) &&
            untrustedIsObject(untrusted.fields)) {
            config = validateAdapterConfig$z({ recordId: untrusted.fields.Id, ...untrusted }, updateRecord_ConfigPropertyNames);
        }
        // Invalid or incomplete config
        if (config === null) {
            throw new Error('Invalid recordInput');
        }
        const { recordId } = config;
        const headers = getHeaders(clientOptions);
        const request = createResourceRequest$G({
            urlParams: {
                recordId,
            },
            body: {
                apiName: config.apiName,
                fields: config.fields,
                allowSaveOnDuplicate: config.allowSaveOnDuplicate,
            },
            headers,
        });
        return lds.dispatchResourceRequest(request).then(response => {
            const { body } = response;
            const sel = buildSelectionFromRecord(body);
            const key = keyBuilder$2({
                recordId,
            });
            lds.storeIngest(key, request, body);
            lds.storeBroadcast();
            return lds.storeLookup({
                recordId: key,
                node: {
                    kind: 'Fragment',
                    private: [],
                    selections: sel,
                },
                variables: {},
            });
        }, (err) => {
            deepFreeze$s(err);
            throw err;
        });
    };
};

const getLookupActions = createWireAdapterConstructor(adapterName$1, getLookupActionsAdapterFactory);
const getRecordActions = createWireAdapterConstructor(adapterName$2, getRecordActionsAdapterFactory);
const getRecordEditActions = createWireAdapterConstructor(adapterName$3, getRecordEditActionsAdapterFactory);
const getRelatedListsActions = createWireAdapterConstructor(adapterName$4, getRelatedListsActionsAdapterFactory);
const getRelatedListActions = createWireAdapterConstructor(adapterName$5, getRelatedListActionsAdapterFactory);
const getRelatedListRecordActions = createWireAdapterConstructor(adapterName$6, getRelatedListRecordActionsAdapterFactory);
const getDuplicateConfiguration = createWireAdapterConstructor(adapterName$7, getDuplicateConfigurationAdapterFactory);
const getNavItems = createWireAdapterConstructor(adapterName$8, getNavItemsAdapterFactory);
const getObjectInfos = createWireAdapterConstructor(adapterName$9, getObjectInfosAdapterFactory);
const getObjectInfo = createWireAdapterConstructor(adapterName, getObjectInfoAdapterFactory);
const getPicklistValuesByRecordType = createWireAdapterConstructor(adapterName$a, getPicklistValuesByRecordTypeAdapterFactory);
const getDuplicates = createWireAdapterConstructor(adapterName$b, getDuplicatesAdapterFactory);
const getRelatedListsCount = createWireAdapterConstructor(adapterName$c, getRelatedListsCountAdapterFactory);
const getRelatedListCount = createWireAdapterConstructor(adapterName$d, getRelatedListCountAdapterFactory);
const getRelatedListInfoBatch = createWireAdapterConstructor(adapterName$e, getRelatedListInfoBatchAdapterFactory);
const getRelatedListsInfo = createWireAdapterConstructor(adapterName$f, getRelatedListsInfoAdapterFactory);
const getRelatedListInfo = createWireAdapterConstructor(adapterName$g, getRelatedListInfoAdapterFactory);
const getRelatedListRecordsBatch = createWireAdapterConstructor(adapterName$i, getRelatedListRecordsBatchAdapterFactory);
const getRelatedListRecords = createWireAdapterConstructor(adapterName$j, getRelatedListRecordsAdapterFactory);
const deleteRecord = createLDSAdapter('deleteRecord', factory$5);
const getListUi = createWireAdapterConstructor('getListUi', factory$2);
const getLayout = createWireAdapterConstructor('getLayout', factory$6);
const getLayoutUserState = createWireAdapterConstructor('getLayoutUserState', factory$7);
const getLookupRecords = createWireAdapterConstructor('getLookupRecords', factory$9);
const getPicklistValues = createWireAdapterConstructor('getPicklistValues', factory$a);
const getRecordAvatars = createWireAdapterConstructor('getRecordAvatars', factory$b);
const _updateRecordAvatar = createLDSAdapter('updateRecordAvatar', factory$c);
const updateRecordAvatar = (...config) => {
    return _updateRecordAvatar(...config).then(snapshot => snapshot.data);
};
const getRecordCreateDefaults = createWireAdapterConstructor('getRecordCreateDefaults', factory$d);
const getRecordTemplateClone = createWireAdapterConstructor('getRecordTemplateClone', factory$e);
const getRecordTemplateCreate = createWireAdapterConstructor('getRecordTemplateCreate', factory$f);
const getRecordUi = createWireAdapterConstructor('getRecordUi', factory$3);
const _createRecord = createLDSAdapter('createRecord', factory$g);
const createRecord = (...config) => {
    return _createRecord(...config).then(snapshot => snapshot.data);
};
const getRecord$1 = createWireAdapterConstructor('getRecord', factory$4);
const _updateRecord = createLDSAdapter('updateRecord', factory$h);
const updateRecord = (...config) => {
    return _updateRecord(...config).then(snapshot => snapshot.data);
};

/** Custom adapters */
// updateLayoutUserState adapter should always return undefined
const baseUpdateLayoutUserState = createLDSAdapter('updateLayoutUserState', factory$8);
const updateLayoutUserState$1 = (apiName, recordTypeId, layoutType, mode, layoutUserStateInput) => {
    return baseUpdateLayoutUserState(apiName, recordTypeId, layoutType, mode, layoutUserStateInput).then(() => undefined);
};
const baseUpdateRelatedListInfo = createLDSAdapter('baseUpdateRelatedListInfo', updateRelatedListInfoAdapterFactory);
// In order to export the imperative wire correctly, we need to add some safety checks
// to ensure the config passed is correct
const updateRelatedListInfo = (config) => {
    const value = baseUpdateRelatedListInfo(config);
    if (value === null) {
        throw new Error('Invalid config for updateRelatedListInfo');
    }
    if ('then' in value) {
        return value.then(snapshot => snapshot.data);
    }
    if (value.state === 'Error') {
        return Promise.reject(value.error);
    }
    return Promise.resolve(value.data);
};
/** SFDC utils */
const getRecordNotifyChange = throttle(60, 60000, createLDSAdapter('getRecordNotifyChange', notifyChangeFactory), {
    allowFunction: incrementGetRecordNotifyChangeAllowCount,
    dropFunction: incrementGetRecordNotifyChangeDropCount,
});

export { MRU, createRecord, deleteRecord, getDuplicateConfiguration, getDuplicates, getLayout, getLayoutUserState, getListUi, getLookupActions, getLookupRecords, getNavItems, getObjectInfo, getObjectInfos, getPicklistValues, getPicklistValuesByRecordType, getRecord$1 as getRecord, getRecordActions, getRecordAvatars, getRecordCreateDefaults, getRecordEditActions, getRecordNotifyChange, getRecordTemplateClone, getRecordTemplateCreate, getRecordUi, getRelatedListActions, getRelatedListCount, getRelatedListInfo, getRelatedListInfoBatch, getRelatedListRecordActions, getRelatedListRecords, getRelatedListRecordsBatch, getRelatedListsActions, getRelatedListsCount, getRelatedListsInfo, ingest$8 as ingestObjectInfo, ingest$4 as ingestRecord, keyBuilder$9 as keyBuilderObjectInfo, keyBuilder$2 as keyBuilderRecord, updateLayoutUserState$1 as updateLayoutUserState, updateRecord, updateRecordAvatar, updateRelatedListInfo };
