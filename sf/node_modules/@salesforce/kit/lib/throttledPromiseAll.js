"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ThrottledPromiseAll_results;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThrottledPromiseAll = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const collections_1 = require("./collections");
const duration_1 = require("./duration");
/**
 * A promise that throttles the number of promises running at a time.
 *
 * The constructor takes {@link PromiseOptions} to initialize the constraints of the promise.
 *
 * ```typescript
 * // Create a ThrottledPromiseAll that will take numbers and return numbers
 * const throttledPromise = new ThrottledPromiseAll<number, number>({ concurrency: 1, timeout: Duration.milliseconds(100) });
 *
 * // Define a producer function that will take a number and return a promise that resolves to a number
 * const numberProducer = (source: number, throttledPromiseAll: ThrottledPromiseAll<number, number | undefined>): Promise<number> => Promise.resolve(source + 1);
 * throttledPromiseAll.add([1, 2, 3, 4, 5], numberProducer);
 *
 * const numberResults = await throttledPromiseAll.all();
 * ```
 */
class ThrottledPromiseAll {
    /**
     * Construct a new ThrottledPromiseAll.
     *
     * @param options {@link PromiseOptions}
     */
    constructor(options = { concurrency: 1 }) {
        _ThrottledPromiseAll_results.set(this, []);
        this.queue = [];
        this.concurrency = options.concurrency;
        this.wait = options.timeout ?? duration_1.Duration.milliseconds(0);
    }
    /**
     * Returns the results of the promises that have been resolved.
     */
    get results() {
        return __classPrivateFieldGet(this, _ThrottledPromiseAll_results, "f");
    }
    /**
     * Add source items to the queue of promises to be resolved.
     * Adding an item to the queue requires a producer function that will take the source item and return a promise.
     * Each item in the can have a different producer function, as long as the producer function conforms the
     * types of the ThrottledPromiseAll when constructed.
     *
     * @param source
     * @param producer the producer function that will take the source item and return a promise. The producer function signature
     * must conform to the types of the ThrottledPromiseAll when constructed.
     */
    add(source, producer) {
        (0, collections_1.ensureArray)(source).forEach((s) => this.queue.push({ source: s, producer }));
    }
    /**
     * Returns a promise that resolves the items present in the queue using the associated producer.
     *
     * This function will throw an error if the timeout is reached before all items in the queue are resolved (see {@link PromiseOptions.timeout}).
     *
     * @returns A promise that resolves to an array of results.
     */
    async all() {
        let timeoutPromise;
        if (this.wait.milliseconds > 0) {
            if (!this.timeout) {
                timeoutPromise = new Promise((resolve, reject) => {
                    this.timeout = setTimeout(() => {
                        try {
                            if (this.timeout) {
                                clearTimeout(this.timeout);
                            }
                            this.stop();
                            reject(new Error(`PromiseQueue timed out after ${this.wait.milliseconds} milliseconds`));
                        }
                        catch (e) {
                            reject(e);
                        }
                    }, this.wait.milliseconds);
                });
            }
        }
        try {
            if (timeoutPromise) {
                await Promise.race([this.dequeue(), timeoutPromise]);
            }
            else {
                await this.dequeue();
            }
            this.stop();
            return __classPrivateFieldGet(this, _ThrottledPromiseAll_results, "f");
        }
        catch (e) {
            this.stop();
            throw e;
        }
    }
    stop() {
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        this.queue.splice(0, this.queue.length);
    }
    async dequeue() {
        while (this.queue.length > 0) {
            const next = this.queue.slice(0, this.concurrency);
            this.queue.splice(0, this.concurrency);
            // eslint-disable-next-line no-await-in-loop
            const results = await Promise.all(next.map((item) => item.producer(item.source, this).catch((e) => Promise.reject(e))));
            __classPrivateFieldGet(this, _ThrottledPromiseAll_results, "f").push(...results);
        }
    }
}
exports.ThrottledPromiseAll = ThrottledPromiseAll;
_ThrottledPromiseAll_results = new WeakMap();
//# sourceMappingURL=throttledPromiseAll.js.map