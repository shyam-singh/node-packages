"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.retrieveKeychain = void 0;
const kit_1 = require("@salesforce/kit");
const logger_1 = require("../logger");
const messages_1 = require("../messages");
const keyChainImpl_1 = require("./keyChainImpl");
const messages = new messages_1.Messages('@salesforce/core', 'encryption', new Map([["invalidEncryptedFormatError", "The encrypted data is not properly formatted."], ["invalidEncryptedFormatError.actions", ["If attempting to create a scratch org then re-authorize. Otherwise create a new scratch org."]], ["authDecryptError", "Failed to decipher auth data. reason: %s."], ["unsupportedOperatingSystemError", "Unsupported Operating System: %s"], ["missingCredentialProgramError", "Unable to find required security software: %s"], ["credentialProgramAccessError", "Unable to execute security software: %s"], ["passwordRetryError", "Failed to get the password after %i retries."], ["passwordRequiredError", "A password is required."], ["keyChainServiceRequiredError", "Unable to get or set a keychain value without a service name."], ["keyChainAccountRequiredError", "Unable to get or set a keychain value without an account name."], ["keyChainUserCanceledError", "User canceled authentication."], ["keychainPasswordCreationError", "Failed to create a password in the keychain."], ["genericKeychainServiceError", "The service and account specified in %s do not match the version of the toolbelt."], ["genericKeychainServiceError.actions", ["Check your toolbelt version and re-auth."]], ["genericKeychainInvalidPermsError", "Invalid file permissions for secret file"], ["genericKeychainInvalidPermsError.actions", ["Ensure the file %s has the file permission octal value of %s."]], ["passwordNotFoundError", "Could not find password.\n%s"], ["passwordNotFoundError.actions", ["Ensure a valid password is returned with the following command: [%s]"]], ["setCredentialError", "Command failed with response:\n%s"], ["setCredentialError.actions", ["Determine why this command failed to set an encryption key for user %s: [%s]."]], ["macKeychainOutOfSync", "We\u2019ve encountered an error with the Mac keychain being out of sync with your `sfdx` credentials. To fix the problem, sync your credentials by authenticating into your org again using the auth commands."]]));
/**
 * Gets the os level keychain impl.
 *
 * @param platform The os platform.
 * @ignore
 */
const retrieveKeychain = async (platform) => {
    const logger = await logger_1.Logger.child('keyChain');
    logger.debug(`platform: ${platform}`);
    const useGenericUnixKeychainVar = kit_1.env.getBoolean('SF_USE_GENERIC_UNIX_KEYCHAIN');
    const shouldUseGenericUnixKeychain = useGenericUnixKeychainVar && useGenericUnixKeychainVar;
    if (platform.startsWith('win')) {
        return keyChainImpl_1.keyChainImpl.generic_windows;
    }
    else if (platform.includes('darwin')) {
        // OSX can use the generic keychain. This is useful when running under an
        // automation user.
        if (shouldUseGenericUnixKeychain) {
            return keyChainImpl_1.keyChainImpl.generic_unix;
        }
        else {
            return keyChainImpl_1.keyChainImpl.darwin;
        }
    }
    else if (platform.includes('linux')) {
        // Use the generic keychain if specified
        if (shouldUseGenericUnixKeychain) {
            return keyChainImpl_1.keyChainImpl.generic_unix;
        }
        else {
            // otherwise try and use the builtin keychain
            try {
                await keyChainImpl_1.keyChainImpl.linux.validateProgram();
                return keyChainImpl_1.keyChainImpl.linux;
            }
            catch (e) {
                // If the builtin keychain is not available use generic
                return keyChainImpl_1.keyChainImpl.generic_unix;
            }
        }
    }
    else {
        throw messages.createError('unsupportedOperatingSystemError', [platform]);
    }
};
exports.retrieveKeychain = retrieveKeychain;
//# sourceMappingURL=keyChain.js.map